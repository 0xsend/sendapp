/**
 * ! Executing this script will delete all data in your database and seed it with new users.
 * ! Make sure to adjust the script to your needs.
 * Use any TypeScript runner to run this script, for example: `npx tsx seed.ts`
 * Learn more about the Seed Client by following our guide: https://docs.snaplet.dev/seed/getting-started
 */
import { baseMainnetClient } from '@my/wagmi'
import { createSeedClient } from '@snaplet/seed'
import pg from 'pg'
import { hexToBytes } from 'viem'
import { models } from '../src'
import { leaderboardReferralsAllTimes, userOnboarded } from '../src/models'
import { select } from '../src/select'
import { pravatar } from '../src/utils'
const { Client } = pg

const dryRun = process.env.DRY !== '0'

// This is a basic example generated by Snaplet to start you off, check out the docs for where to go from here
// * For more on getting started with @snaplet/seed: https://docs.snaplet.dev/getting-started/quick-start/seed
// * For a more detailed reference: https://docs.snaplet.dev/core-concepts/seed
const seed = await createSeedClient({
  dryRun,
  models,
})

console.log('Snaplet resetting database.', `dryRun=${dryRun}`)

// Clears all existing data in the database, but keep the structure
await seed.$resetDatabase(select)

console.log('Snaplet seeding database.')

await seed.swap_routers([
  {
    router_addr: Buffer.from(hexToBytes('0xc7d3ab410d49b664d03fe5b1038852ac852b1b29')),
    chain_id: baseMainnetClient.chain.id,
  },
])

// Create users with tags and send accounts
const seededUsers = await seed.users([
  {
    phone: '17777777777',
    profiles: [
      {
        name: 'Alice',
        avatar_url: pravatar('Alice'),
        x_username: 'x_alice',
      },
    ],
    tags: [
      {
        name: 'alice',
        status: 'confirmed',
      },
      {
        name: '0xalice',
        status: 'confirmed',
      },
    ],
    send_accounts: [{}],
    chain_addresses: [{}],
    leaderboard_referrals_all_time: [leaderboardReferralsAllTimes],
  },
  {
    phone: '1234567890',
    profiles: [
      {
        name: 'Jane',
        avatar_url: pravatar('Jane'),
        x_username: 'x_jane',
      },
    ],
    tags: [
      {
        name: 'jane',
        status: 'confirmed',
      },
      {
        name: '0xjane',
        status: 'confirmed',
      },
    ],
    send_accounts: [{}],
    chain_addresses: [{}],
    leaderboard_referrals_all_time: [leaderboardReferralsAllTimes],
  },
  {
    phone: '15555555555',
    profiles: [
      {
        name: 'John',
        avatar_url: pravatar('John'),
        x_username: 'x_john',
      },
    ],
    tags: [
      {
        name: 'john',
        status: 'confirmed',
      },
      {
        name: '0xjohn',
        status: 'confirmed',
      },
    ],
    send_accounts: [{}],
    chain_addresses: [{}],
    leaderboard_referrals_all_time: [leaderboardReferralsAllTimes],
  },
  ...Array.from({ length: 100 }, () => ({
    ...userOnboarded,
    leaderboard_referrals_all_time: [leaderboardReferralsAllTimes],
  })),
])

// Post-process to set main_tag_id for each send account
// We need to run a direct SQL update since Snaplet doesn't handle
// cross-table references in seed data functions properly
if (!dryRun) {
  console.log('Setting up send_account_tags and main tag IDs...')

  // Create a new postgres client for the update
  const client = new Client({
    connectionString:
      process.env.SUPABASE_DB_URL || 'postgresql://postgres:postgres@127.0.0.1:54322/postgres',
  })

  try {
    await client.connect()

    // First, update tags with their user_id using the send_account_tags relationship
    // Since tags are created with send_account_tags relationships, we can use this to set the user_id
    const tagUpdateResult = await client.query(`
      UPDATE tags t
      SET user_id = sa.user_id
      FROM send_account_tags sat
      JOIN send_accounts sa ON sa.id = sat.send_account_id
      WHERE t.id = sat.tag_id
      AND t.user_id IS NULL
    `)

    console.log(`Updated ${tagUpdateResult.rowCount} tags with user_id`)

    // Now ensure any remaining send_account_tags are created for all user tags
    // This creates any missing relationships between send_accounts and tags
    const insertResult = await client.query(`
      INSERT INTO send_account_tags (send_account_id, tag_id)
      SELECT DISTINCT sa.id, t.id
      FROM send_accounts sa
      JOIN tags t ON t.user_id = sa.user_id
      WHERE t.status = 'confirmed'
      AND NOT EXISTS (
        SELECT 1
        FROM send_account_tags sat
        WHERE sat.send_account_id = sa.id
        AND sat.tag_id = t.id
      )
    `)

    console.log(`Created ${insertResult.rowCount} send_account_tags relationships`)

    // Now update all send_accounts to set main_tag_id
    // This sets the main_tag_id to the first (alphabetically) tag for each user
    const updateResult = await client.query(`
      UPDATE send_accounts sa
      SET main_tag_id = (
        SELECT t.id
        FROM tags t
        JOIN send_account_tags sat ON sat.tag_id = t.id
        WHERE sat.send_account_id = sa.id
        AND t.status = 'confirmed'
        ORDER BY t.name ASC
        LIMIT 1
      )
      WHERE sa.main_tag_id IS NULL
      AND EXISTS (
        SELECT 1
        FROM send_account_tags sat
        JOIN tags t ON t.id = sat.tag_id
        WHERE sat.send_account_id = sa.id
        AND t.status = 'confirmed'
      )
    `)

    console.log(`Updated ${updateResult.rowCount} send accounts with main tag IDs`)

    console.log('Seeding sendpot data...')

    // Get some send_account addresses to use for winners and ticket purchases
    const sendAccountsResult = await client.query(`
      SELECT address_bytes, user_id
      FROM send_accounts
      ORDER BY id
      LIMIT 10
    `)

    const sendAccounts = sendAccountsResult.rows

    if (sendAccounts.length > 0) {
      const aliceAddress = sendAccounts[0].address_bytes
      const nowSeconds = Math.floor(Date.now() / 1000)
      const zeroReferrer = Buffer.from('0000000000000000000000000000000000000000', 'hex')

      // Generate ticket purchases for all three runs
      const ticketPurchasesForRun1 = Array.from({ length: 5 }, (_, i) => ({
        block_num: 50 + i,
        block_time: nowSeconds - 200000 - (50 - i) * 1000,
        tx_hash: Buffer.from(
          hexToBytes(
            `0xdeadbeef${i}cafe1234567890abcdef1234567890abcdef1234567890abcdef`.padEnd(
              64,
              '0'
            ) as `0x${string}`
          )
        ),
        tx_idx: i,
        referrer: zeroReferrer,
        recipient: sendAccounts[Math.floor(Math.random() * sendAccounts.length)].address_bytes,
        buyer: sendAccounts[Math.floor(Math.random() * sendAccounts.length)].address_bytes,
        tickets_purchased_total_bps: 10000 * (i + 1),
      }))

      const ticketPurchasesForRun2 = Array.from({ length: 8 }, (_, i) => ({
        block_num: 150 + i,
        block_time: nowSeconds - 100000 - (50 - i) * 1000,
        tx_hash: Buffer.from(
          hexToBytes(
            `0xbaadcafe${i}1234567890abcdef1234567890abcdef1234567890abcdef`.padEnd(
              64,
              '0'
            ) as `0x${string}`
          )
        ),
        tx_idx: i,
        referrer: zeroReferrer,
        recipient: sendAccounts[Math.floor(Math.random() * sendAccounts.length)].address_bytes,
        buyer: sendAccounts[Math.floor(Math.random() * sendAccounts.length)].address_bytes,
        tickets_purchased_total_bps: 15000 * (i + 1),
      }))

      const ticketPurchasesForRun3 = sendAccounts.slice(0, 10).map((account, i) => ({
        block_num: 250 + i,
        block_time: nowSeconds - 50000 - i * 1000,
        tx_hash: Buffer.from(
          hexToBytes(
            `0xf00dcafe${i}1234567890abcdef1234567890abcdef1234567890abcdef`.padEnd(
              64,
              '0'
            ) as `0x${string}`
          )
        ),
        tx_idx: i,
        referrer: zeroReferrer,
        recipient: account.address_bytes,
        buyer: account.address_bytes,
        tickets_purchased_total_bps: 25000 * (i + 1),
      }))

      // Seed using Snaplet seed client
      await seed.sendpot_jackpot_runs([
        // First run: alice wins at block 100
        {
          block_num: 100,
          block_time: nowSeconds - 200000,
          time: nowSeconds - 200000,
          tx_hash: Buffer.from(
            hexToBytes('0xdeadbeefcafe1234567890abcdef1234567890abcdef1234567890abcdef12')
          ),
          winner: aliceAddress,
          winning_ticket: 5,
          win_amount: 1000000000000000000, // 1 ETH
          tickets_purchased_total_bps: 140000,
        },
        // Second run: pending (no winner) at block 200
        {
          block_num: 200,
          block_time: nowSeconds - 100000,
          time: nowSeconds - 100000,
          tx_hash: Buffer.from(
            hexToBytes('0xbaadcafef00d1234567890abcdef1234567890abcdef1234567890abcdef12')
          ),
          winner: Buffer.from(hexToBytes('0x0000000000000000000000000000000000000000')),
          winning_ticket: 4,
          win_amount: 0,
          tickets_purchased_total_bps: 0,
        },
        // Third run: pending (no winner) at block 300
        {
          block_num: 300,
          block_time: nowSeconds - 50000,
          time: nowSeconds - 50000,
          tx_hash: Buffer.from(hexToBytes('0xcafef00d1234567890abcdef1234567890abcdef123456')),
          winner: Buffer.from(hexToBytes('0x0000000000000000000000000000000000000000')),
          winning_ticket: 1,
          win_amount: 0,
          tickets_purchased_total_bps: 0,
        },
      ])

      // Seed ticket purchases
      await seed.sendpot_user_ticket_purchases([
        ...ticketPurchasesForRun1,
        ...ticketPurchasesForRun2,
        ...ticketPurchasesForRun3,
      ])

      console.log('Seeded sendpot data: 3 jackpot runs and ticket purchases')
    }
  } finally {
    await client.end()
  }
}

console.log(`Snaplet seed done! Seeded ${seededUsers.users.length} users.`)
process.exit()
