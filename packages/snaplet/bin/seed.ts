/**
 * ! Executing this script will delete all data in your database and seed it with new users.
 * ! Make sure to adjust the script to your needs.
 * Use any TypeScript runner to run this script, for example: `npx tsx seed.ts`
 * Learn more about the Seed Client by following our guide: https://docs.snaplet.dev/seed/getting-started
 */
import { baseMainnetClient } from '@my/wagmi'
import { copycat } from '@snaplet/copycat'
import { createSeedClient } from '@snaplet/seed'
import pg from 'pg'
import { hexToBytes } from 'viem'
import {
  createNewTokenDistribution,
  createOldTokenDistribution,
  createTransferInDistribution,
  leaderboardReferralsAllTimes,
  models,
  userOnboarded,
} from '../src'
import { select } from '../src/select'
import { pravatar } from '../src/utils'
const { Client } = pg

const dryRun = process.env.DRY !== '0'

// This is a basic example generated by Snaplet to start you off, check out the docs for where to go from here
// * For more on getting started with @snaplet/seed: https://docs.snaplet.dev/getting-started/quick-start/seed
// * For a more detailed reference: https://docs.snaplet.dev/core-concepts/seed
const seed = await createSeedClient({
  dryRun,
  models,
})

console.log('Snaplet resetting database.', `dryRun=${dryRun}`)

// Clears all existing data in the database, but keep the structure
await seed.$resetDatabase(select)

console.log('Snaplet seeding database.')

await seed.swap_routers([
  {
    router_addr: Buffer.from(hexToBytes('0xc7d3ab410d49b664d03fe5b1038852ac852b1b29')),
    chain_id: baseMainnetClient.chain.id,
  },
])
// Seed distributions
console.log('Seeding distributions...')
const now = new Date()
const currentMonthStart = new Date(now.getFullYear(), now.getMonth(), 1, 0, 0, 0, 0)
const currentMonthEnd = new Date(now.getFullYear(), now.getMonth() + 1, 1, 0, 0, 0, 0)
currentMonthEnd.setSeconds(currentMonthEnd.getSeconds() - 1)

const lastMonthStart = new Date(now.getFullYear(), now.getMonth() - 1, 1, 0, 0, 0, 0)
const lastMonthEnd = new Date(now.getFullYear(), now.getMonth(), 1, 0, 0, 0, 0)
lastMonthEnd.setSeconds(lastMonthEnd.getSeconds() - 1)

const nextMonthStart = new Date(now.getFullYear(), now.getMonth() + 1, 1, 0, 0, 0, 0)
const nextMonthEnd = new Date(now.getFullYear(), now.getMonth() + 2, 1, 0, 0, 0, 0)
nextMonthEnd.setSeconds(nextMonthEnd.getSeconds() - 1)

await seed.distributions([
  // Distribution #6 - Last of the early era (old token, no decimals, bonus pools)
  createOldTokenDistribution({
    number: 6,
    description: 'Sixth distributions of 200,000,000 SEND tokens to early hodlers',
    amount: 200000000,
    hodler_pool_bips: 9000,
    bonus_pool_bips: 1000,
    fixed_pool_bips: 500,
    qualification_start: new Date('2024-05-17T00:00:00Z'),
    qualification_end: new Date('2024-05-31T23:59:59Z'),
    claim_end: new Date('2024-07-31T23:59:59Z'),
    hodler_min_balance: 150000,
    tranche_id: 5,
  }),
  // Distribution #7 - First of simplified era (old token, no decimals, no bonus pool)
  createOldTokenDistribution({
    number: 7,
    description: 'Seventh distributions of 300,000,000 SEND tokens to early hodlers',
    amount: 300000000,
    qualification_start: new Date('2024-09-01T00:00:00Z'),
    qualification_end: new Date('2024-09-30T23:59:59Z'),
    hodler_min_balance: 300000,
    tranche_id: 6,
  }),
  // Distribution #10 - Last of old token era
  createOldTokenDistribution({
    number: 10,
    description: 'Tenth distribution of 500,000,000 SEND tokens to early hodlers',
    amount: 500000000,
    qualification_start: new Date('2024-12-01T00:00:00Z'),
    qualification_end: new Date('2024-12-31T23:59:59Z'),
    hodler_min_balance: 400000,
    tranche_id: 9,
  }),
  // Distribution #11 - MAJOR CHANGE: New token with 18 decimals, much higher amounts
  createNewTokenDistribution({
    number: 11,
    description: 'Eleventh distribution of 3,000,000 SEND tokens to early hodlers',
    amount: 3000000000000000000000000, // 3M with 18 decimals
    qualification_start: new Date('2025-01-01T00:00:00Z'),
    qualification_end: new Date('2025-01-31T23:59:59Z'),
    hodler_min_balance: 7500000000000000000000, // 7500 SEND
    tranche_id: 4,
  }),
  // Distribution #16 - First with earn_min_balance requirement
  createNewTokenDistribution({
    number: 16,
    description: 'Sixteenth distribution of 3,000,000 SEND tokens to early hodlers',
    amount: 3000000000000000000000000,
    qualification_start: new Date('2025-06-01T00:00:00Z'),
    qualification_end: new Date('2025-06-30T23:59:59Z'),
    hodler_min_balance: 1000000000000000000000, // 1000 SEND
    earn_min_balance: 5000000, // 5 USDC
    tranche_id: 9,
  }),
  // Last month's distribution (ended, using recent pattern)
  createNewTokenDistribution({
    number: 50,
    amount: 3000000000000000000000000,
    qualification_start: lastMonthStart,
    qualification_end: lastMonthEnd,
    hodler_min_balance: 1000000000000000000000,
    earn_min_balance: 5000000,
    tranche_id: 43,
  }),
  // Current month's distribution (active)
  createNewTokenDistribution({
    number: 51,
    amount: 3000000000000000000000000,
    qualification_start: currentMonthStart,
    qualification_end: currentMonthEnd,
    hodler_min_balance: 1000000000000000000000,
    earn_min_balance: 5000000,
    tranche_id: 44,
  }),
  // Next month's distribution (future)
  createNewTokenDistribution({
    number: 52,
    amount: 3000000000000000000000000,
    qualification_start: nextMonthStart,
    qualification_end: nextMonthEnd,
    hodler_min_balance: 1000000000000000000000,
    earn_min_balance: 5000000,
    tranche_id: 45,
  }),
])

console.log('Seeded 8 distributions representing different eras (6, 7, 10, 11, 16, 50, 51, 52)')

// Create users with tags and send accounts
const seededUsers = await seed.users([
  {
    phone: '17777777777',
    profiles: [
      {
        name: 'Alice',
        avatar_url: pravatar('Alice'),
        x_username: 'x_alice',
      },
    ],
    tags: [
      {
        name: 'alice',
        status: 'confirmed',
      },
      {
        name: '0xalice',
        status: 'confirmed',
      },
    ],
    send_accounts: [{}],
    chain_addresses: [{}],
    leaderboard_referrals_all_time: [leaderboardReferralsAllTimes],
  },
  {
    phone: '1234567890',
    profiles: [
      {
        name: 'Jane',
        avatar_url: pravatar('Jane'),
        x_username: 'x_jane',
      },
    ],
    tags: [
      {
        name: 'jane',
        status: 'confirmed',
      },
      {
        name: '0xjane',
        status: 'confirmed',
      },
    ],
    send_accounts: [{}],
    chain_addresses: [{}],
    leaderboard_referrals_all_time: [leaderboardReferralsAllTimes],
  },
  {
    phone: '15555555555',
    profiles: [
      {
        name: 'John',
        avatar_url: pravatar('John'),
        x_username: 'x_john',
      },
    ],
    tags: [
      {
        name: 'john',
        status: 'confirmed',
      },
      {
        name: '0xjohn',
        status: 'confirmed',
      },
    ],
    send_accounts: [{}],
    chain_addresses: [{}],
    leaderboard_referrals_all_time: [leaderboardReferralsAllTimes],
  },
  ...Array.from({ length: 100 }, () => ({
    ...userOnboarded,
    leaderboard_referrals_all_time: [leaderboardReferralsAllTimes],
  })),
])

// Post-process to set main_tag_id for each send account
// We need to run a direct SQL update since Snaplet doesn't handle
// cross-table references in seed data functions properly
if (!dryRun) {
  console.log('Setting up send_account_tags and main tag IDs...')

  // Create a new postgres client for the update
  const client = new Client({
    connectionString:
      process.env.SUPABASE_DB_URL || 'postgresql://postgres:postgres@127.0.0.1:54322/postgres',
  })

  try {
    await client.connect()

    // Insert distribution verification values and send_slash for each distribution
    console.log('Setting up distribution verification values and send_slash...')

    const verificationTypes = [
      'tag_registration',
      'create_passkey',
      'send_ten',
      'send_one_hundred',
      'total_tag_referrals',
      'tag_referral',
      'send_streak',
      'send_ceiling',
    ]

    for (const distNumber of [6, 7, 10, 11, 16, 50, 51, 52]) {
      // Insert verification values for each type
      for (const vType of verificationTypes) {
        // For distributions without an immediate predecessor (6, 10, 11, 16, 50),
        // we need to provide default multiplier values
        const needsDefaults = [6, 10, 11, 16, 50].includes(distNumber)
        if (needsDefaults) {
          await client.query(
            `SELECT insert_verification_value(
              distribution_number => $1,
              type => $2::public.verification_type,
              multiplier_min => 1.0,
              multiplier_max => 1.0,
              multiplier_step => 0.0
            )`,
            [distNumber, vType]
          )
        } else {
          await client.query(
            `SELECT insert_verification_value(
              distribution_number => $1,
              type => $2::public.verification_type
            )`,
            [distNumber, vType]
          )
        }
      }

      // Insert send_slash config
      await client.query('SELECT insert_send_slash(distribution_number => $1)', [distNumber])

      console.log(`  Configured distribution ${distNumber}`)
    }

    // Set up test data for distribution 51 (current month) to test SEND amount calculations
    console.log('Setting up test distribution verifications and shares for Alice...')

    // Find Alice from the seeded users (first user with phone '17777777777')
    const aliceUser = seededUsers.users.find((u) => u.phone === '17777777777')
    const aliceSendAccount = aliceUser
      ? seededUsers.send_accounts.find((sa) => sa.user_id === aliceUser.id)
      : null

    if (aliceUser && aliceSendAccount) {
      const aliceUserId = aliceUser.id
      const aliceAddress = aliceSendAccount.address

      // Get distribution 51 (current month) and distribution 50 (previous month)
      const dist51Result = await client.query(`
        SELECT id FROM distributions WHERE number = 51 LIMIT 1
      `)
      const dist50Result = await client.query(`
        SELECT id FROM distributions WHERE number = 50 LIMIT 1
      `)

      if (dist51Result.rows.length > 0) {
        const dist51Id = dist51Result.rows[0].id
        const dist50Id = dist50Result.rows.length > 0 ? dist50Result.rows[0].id : null

        // Insert distribution verifications for Alice in distribution 51
        // These weights will be used by the fixed pool calculations
        // First check if they already exist to avoid duplicates
        const existingVerifications = await client.query(
          `SELECT type FROM distribution_verifications WHERE distribution_id = $1 AND user_id = $2`,
          [dist51Id, aliceUserId]
        )

        if (existingVerifications.rows.length === 0) {
          await client.query(
            `
            INSERT INTO distribution_verifications (distribution_id, user_id, type, weight)
            VALUES 
              ($1, $2, 'send_ceiling', 50000000000000000000),  -- 50 SEND sent (for slash calculation)
              ($1, $2, 'send_ten', 3),                         -- sent $10 three times
              ($1, $2, 'send_streak', 7),                      -- 7 day streak
              ($1, $2, 'tag_registration', 1),                 -- has sendtag
              ($1, $2, 'tag_referral', 2)                      -- 2 referrals (creates multiplier)
          `,
            [dist51Id, aliceUserId]
          )
        }

        // Insert distribution shares for Alice in distribution 51
        // These show the calculated amounts after all verifications
        const existingShare = await client.query(
          `SELECT id FROM distribution_shares WHERE distribution_id = $1 AND user_id = $2`,
          [dist51Id, aliceUserId]
        )

        if (existingShare.rows.length === 0) {
          await client.query(
            `
            INSERT INTO distribution_shares (
              distribution_id, 
              user_id, 
              address, 
              amount, 
              hodler_pool_amount, 
              fixed_pool_amount, 
              bonus_pool_amount,
              balance_rank,
              "index"
            )
            VALUES ($1, $2, $3, 1500000000000000000000, 0, 1500000000000000000000, 0, 42, 0)
          `,
            [dist51Id, aliceUserId, aliceAddress]
          )
        }

        console.log('  Created distribution verifications for Alice in distribution 51')
        console.log('    - send_ceiling: 50 SEND (for slash calculation)')
        console.log('    - send_ten: weight 3')
        console.log('    - send_streak: weight 7')
        console.log('    - tag_registration: weight 1')
        console.log('    - tag_referral: weight 2 (will create multiplier)')

        // If distribution 50 exists, create a previous distribution share for slash calculation
        if (dist50Id) {
          const existingShare50 = await client.query(
            `SELECT id FROM distribution_shares WHERE distribution_id = $1 AND user_id = $2`,
            [dist50Id, aliceUserId]
          )

          if (existingShare50.rows.length === 0) {
            await client.query(
              `
              INSERT INTO distribution_shares (
                distribution_id, 
                user_id, 
                address, 
                amount, 
                hodler_pool_amount, 
                fixed_pool_amount, 
                bonus_pool_amount,
                balance_rank,
                "index"
              )
              VALUES ($1, $2, $3, 1000000000000000000000, 0, 1000000000000000000000, 0, 35, 0)
            `,
              [dist50Id, aliceUserId, aliceAddress]
            )
          }

          console.log(
            '  Created previous distribution share for Alice in distribution 50 (for slash calculation)'
          )
        }
      }
    }

    // First, update tags with their user_id using the send_account_tags relationship
    // Since tags are created with send_account_tags relationships, we can use this to set the user_id
    const tagUpdateResult = await client.query(`
      UPDATE tags t
      SET user_id = sa.user_id
      FROM send_account_tags sat
      JOIN send_accounts sa ON sa.id = sat.send_account_id
      WHERE t.id = sat.tag_id
      AND t.user_id IS NULL
    `)

    console.log(`Updated ${tagUpdateResult.rowCount} tags with user_id`)

    // Now ensure any remaining send_account_tags are created for all user tags
    // This creates any missing relationships between send_accounts and tags
    const insertResult = await client.query(`
      INSERT INTO send_account_tags (send_account_id, tag_id)
      SELECT DISTINCT sa.id, t.id
      FROM send_accounts sa
      JOIN tags t ON t.user_id = sa.user_id
      WHERE t.status = 'confirmed'
      AND NOT EXISTS (
        SELECT 1
        FROM send_account_tags sat
        WHERE sat.send_account_id = sa.id
        AND sat.tag_id = t.id
      )
    `)

    console.log(`Created ${insertResult.rowCount} send_account_tags relationships`)

    // Now update all send_accounts to set main_tag_id
    // This sets the main_tag_id to the first (alphabetically) tag for each user
    const updateResult = await client.query(`
      UPDATE send_accounts sa
      SET main_tag_id = (
        SELECT t.id
        FROM tags t
        JOIN send_account_tags sat ON sat.tag_id = t.id
        WHERE sat.send_account_id = sa.id
        AND t.status = 'confirmed'
        ORDER BY t.name ASC
        LIMIT 1
      )
      WHERE sa.main_tag_id IS NULL
      AND EXISTS (
        SELECT 1
        FROM send_account_tags sat
        JOIN tags t ON t.id = sat.tag_id
        WHERE sat.send_account_id = sa.id
        AND t.status = 'confirmed'
      )
    `)

    console.log(`Updated ${updateResult.rowCount} send accounts with main tag IDs`)

    console.log('Seeding sendpot data...')

    // Get some send_account addresses to use for winners and ticket purchases
    const sendAccountsResult = await client.query(`
      SELECT address_bytes, user_id
      FROM send_accounts
      ORDER BY id
      LIMIT 10
    `)

    const sendAccounts = sendAccountsResult.rows

    if (sendAccounts.length > 0) {
      // Seed transfers within distribution periods
      console.log('Seeding send_token_transfers within distribution periods...')

      // Get distribution date ranges
      const distributionsResult = await client.query(`
        SELECT number, 
               EXTRACT(EPOCH FROM qualification_start) AS start_epoch,
               EXTRACT(EPOCH FROM qualification_end) AS end_epoch
        FROM distributions
        WHERE number IN (6, 7, 10, 11, 16, 50, 51, 52)
        ORDER BY number
      `)

      const distributionPeriods = distributionsResult.rows
      const transfers: ReturnType<typeof createTransferInDistribution>[] = []

      // Create transfers for each distribution period
      for (const dist of distributionPeriods) {
        // Create 5-10 transfers per distribution for a subset of accounts
        const numTransfers = copycat.int(`dist-${dist.number}-count`, { min: 5, max: 10 })

        for (let i = 0; i < numTransfers; i++) {
          const fromIdx = copycat.int(`dist-${dist.number}-from-${i}`, {
            min: 0,
            max: Math.min(sendAccounts.length, 10) - 1,
          })
          const toIdx = copycat.int(`dist-${dist.number}-to-${i}`, {
            min: 0,
            max: Math.min(sendAccounts.length, 10) - 1,
          })

          const fromAccount = sendAccounts[fromIdx]
          const toAccount = sendAccounts[toIdx]

          // Skip if same account
          if (fromAccount.address_bytes.equals(toAccount.address_bytes)) continue

          // Amount: random between 10-1000 SEND (with 18 decimals for dist 11+, no decimals for earlier)
          const isNewToken = dist.number >= 11
          const baseAmount = copycat.int(`dist-${dist.number}-amount-${i}`, { min: 10, max: 1000 })
          const amount = isNewToken ? baseAmount * 1e18 : baseAmount

          const timespanSeconds = dist.end_epoch - dist.start_epoch
          const offsetSeconds = copycat.int(`dist-${dist.number}-offset-${i}`, {
            min: 0,
            max: Math.floor(timespanSeconds),
          })

          transfers.push(
            createTransferInDistribution({
              from_address_bytes: fromAccount.address_bytes,
              to_address_bytes: toAccount.address_bytes,
              amount,
              distribution_start_epoch: Math.floor(dist.start_epoch),
              distribution_end_epoch: Math.floor(dist.end_epoch),
              offset_from_start_seconds: offsetSeconds,
            })
          )
        }
      }

      // Seed all transfers
      if (transfers.length > 0) {
        await seed.send_token_transfers(transfers)
        console.log(
          `Seeded ${transfers.length} send_token_transfers across ${distributionPeriods.length} distributions`
        )
      }

      const aliceAddress = sendAccounts[0].address_bytes
      const nowSeconds = Math.floor(Date.now() / 1000)
      const zeroReferrer = Buffer.from('0000000000000000000000000000000000000000', 'hex')

      // Generate ticket purchases for all three runs
      const ticketPurchasesForRun1 = Array.from({ length: 5 }, (_, i) => ({
        block_num: 50 + i,
        block_time: nowSeconds - 200000 - (50 - i) * 1000,
        tx_hash: Buffer.from(
          hexToBytes(
            `0xdeadbeef${i}cafe1234567890abcdef1234567890abcdef1234567890abcdef`.padEnd(
              64,
              '0'
            ) as `0x${string}`
          )
        ),
        tx_idx: i,
        referrer: zeroReferrer,
        recipient: sendAccounts[Math.floor(Math.random() * sendAccounts.length)].address_bytes,
        buyer: sendAccounts[Math.floor(Math.random() * sendAccounts.length)].address_bytes,
        tickets_purchased_total_bps: 10000 * (i + 1),
      }))

      const ticketPurchasesForRun2 = Array.from({ length: 8 }, (_, i) => ({
        block_num: 150 + i,
        block_time: nowSeconds - 100000 - (50 - i) * 1000,
        tx_hash: Buffer.from(
          hexToBytes(
            `0xbaadcafe${i}1234567890abcdef1234567890abcdef1234567890abcdef`.padEnd(
              64,
              '0'
            ) as `0x${string}`
          )
        ),
        tx_idx: i,
        referrer: zeroReferrer,
        recipient: sendAccounts[Math.floor(Math.random() * sendAccounts.length)].address_bytes,
        buyer: sendAccounts[Math.floor(Math.random() * sendAccounts.length)].address_bytes,
        tickets_purchased_total_bps: 15000 * (i + 1),
      }))

      const ticketPurchasesForRun3 = sendAccounts.slice(0, 10).map((account, i) => ({
        block_num: 250 + i,
        block_time: nowSeconds - 50000 - i * 1000,
        tx_hash: Buffer.from(
          hexToBytes(
            `0xf00dcafe${i}1234567890abcdef1234567890abcdef1234567890abcdef`.padEnd(
              64,
              '0'
            ) as `0x${string}`
          )
        ),
        tx_idx: i,
        referrer: zeroReferrer,
        recipient: account.address_bytes,
        buyer: account.address_bytes,
        tickets_purchased_total_bps: 25000 * (i + 1),
      }))

      // Seed using Snaplet seed client
      await seed.sendpot_jackpot_runs([
        // First run: alice wins at block 100
        {
          block_num: 100,
          block_time: nowSeconds - 200000,
          time: nowSeconds - 200000,
          tx_hash: Buffer.from(
            hexToBytes('0xdeadbeefcafe1234567890abcdef1234567890abcdef1234567890abcdef12')
          ),
          winner: aliceAddress,
          winning_ticket: 5,
          win_amount: 1000000000000000000, // 1 ETH
          tickets_purchased_total_bps: 140000,
        },
        // Second run: pending (no winner) at block 200
        {
          block_num: 200,
          block_time: nowSeconds - 100000,
          time: nowSeconds - 100000,
          tx_hash: Buffer.from(
            hexToBytes('0xbaadcafef00d1234567890abcdef1234567890abcdef1234567890abcdef12')
          ),
          winner: Buffer.from(hexToBytes('0x0000000000000000000000000000000000000000')),
          winning_ticket: 4,
          win_amount: 0,
          tickets_purchased_total_bps: 0,
        },
        // Third run: pending (no winner) at block 300
        {
          block_num: 300,
          block_time: nowSeconds - 50000,
          time: nowSeconds - 50000,
          tx_hash: Buffer.from(hexToBytes('0xcafef00d1234567890abcdef1234567890abcdef123456')),
          winner: Buffer.from(hexToBytes('0x0000000000000000000000000000000000000000')),
          winning_ticket: 1,
          win_amount: 0,
          tickets_purchased_total_bps: 0,
        },
      ])

      // Seed ticket purchases
      await seed.sendpot_user_ticket_purchases([
        ...ticketPurchasesForRun1,
        ...ticketPurchasesForRun2,
        ...ticketPurchasesForRun3,
      ])

      console.log('Seeded sendpot data: 3 jackpot runs and ticket purchases')
    }

    // Refresh the send_scores_history materialized view
    console.log('Refreshing send_scores_history materialized view...')
    await client.query('SELECT public.refresh_send_scores_history()')
    console.log('send_scores_history materialized view refreshed successfully')
  } finally {
    await client.end()
  }
}

console.log(`Snaplet seed done! Seeded ${seededUsers.users.length} users.`)
process.exit()
