/**
 * ! Executing this script will delete all data in your database and seed it with new users.
 * ! Make sure to adjust the script to your needs.
 * Use any TypeScript runner to run this script, for example: `npx tsx seed.ts`
 * Learn more about the Seed Client by following our guide: https://docs.snaplet.dev/seed/getting-started
 */
import { baseMainnetClient } from '@my/wagmi'
import { createSeedClient } from '@snaplet/seed'
import pg from 'pg'
import { hexToBytes } from 'viem'
import { models } from '../src'
import { leaderboardReferralsAllTimes, userOnboarded } from '../src/models'
import { select } from '../src/select'
import { pravatar } from '../src/utils'
const { Client } = pg

const dryRun = process.env.DRY !== '0'

// This is a basic example generated by Snaplet to start you off, check out the docs for where to go from here
// * For more on getting started with @snaplet/seed: https://docs.snaplet.dev/getting-started/quick-start/seed
// * For a more detailed reference: https://docs.snaplet.dev/core-concepts/seed
const seed = await createSeedClient({
  dryRun,
  models,
})

console.log('Snaplet resetting database.', `dryRun=${dryRun}`)

// Clears all existing data in the database, but keep the structure
await seed.$resetDatabase(select)

console.log('Snaplet seeding database.')

await seed.swap_routers([
  {
    router_addr: Buffer.from(hexToBytes('0xc7d3ab410d49b664d03fe5b1038852ac852b1b29')),
    chain_id: baseMainnetClient.chain.id,
  },
])

// Create users with tags and send accounts
const seededUsers = await seed.users([
  {
    phone: '17777777777',
    profiles: [
      {
        name: 'Alice',
        avatar_url: pravatar('Alice'),
        x_username: 'x_alice',
      },
    ],
    tags: [
      {
        name: 'alice',
        status: 'confirmed',
      },
      {
        name: '0xalice',
        status: 'confirmed',
      },
    ],
    send_accounts: [{}],
    chain_addresses: [{}],
    leaderboard_referrals_all_time: [leaderboardReferralsAllTimes],
  },
  {
    phone: '1234567890',
    profiles: [
      {
        name: 'Jane',
        avatar_url: pravatar('Jane'),
        x_username: 'x_jane',
      },
    ],
    tags: [
      {
        name: 'jane',
        status: 'confirmed',
      },
      {
        name: '0xjane',
        status: 'confirmed',
      },
    ],
    send_accounts: [{}],
    chain_addresses: [{}],
    leaderboard_referrals_all_time: [leaderboardReferralsAllTimes],
  },
  {
    phone: '15555555555',
    profiles: [
      {
        name: 'John',
        avatar_url: pravatar('John'),
        x_username: 'x_john',
      },
    ],
    tags: [
      {
        name: 'john',
        status: 'confirmed',
      },
      {
        name: '0xjohn',
        status: 'confirmed',
      },
    ],
    send_accounts: [{}],
    chain_addresses: [{}],
    leaderboard_referrals_all_time: [leaderboardReferralsAllTimes],
  },
  ...Array.from({ length: 100 }, () => ({
    ...userOnboarded,
    leaderboard_referrals_all_time: [leaderboardReferralsAllTimes],
  })),
])

// Post-process to set main_tag_id for each send account
// We need to run a direct SQL update since Snaplet doesn't handle
// cross-table references in seed data functions properly
if (!dryRun) {
  console.log('Setting up send_account_tags and main tag IDs...')

  // Create a new postgres client for the update
  const client = new Client({
    connectionString:
      process.env.SUPABASE_DB_URL || 'postgresql://postgres:postgres@127.0.0.1:54322/postgres',
  })

  try {
    await client.connect()

    // First, update tags with their user_id using the send_account_tags relationship
    // Since tags are created with send_account_tags relationships, we can use this to set the user_id
    const tagUpdateResult = await client.query(`
      UPDATE tags t
      SET user_id = sa.user_id
      FROM send_account_tags sat
      JOIN send_accounts sa ON sa.id = sat.send_account_id
      WHERE t.id = sat.tag_id
      AND t.user_id IS NULL
    `)

    console.log(`Updated ${tagUpdateResult.rowCount} tags with user_id`)

    // Now ensure any remaining send_account_tags are created for all user tags
    // This creates any missing relationships between send_accounts and tags
    const insertResult = await client.query(`
      INSERT INTO send_account_tags (send_account_id, tag_id)
      SELECT DISTINCT sa.id, t.id
      FROM send_accounts sa
      JOIN tags t ON t.user_id = sa.user_id
      WHERE t.status = 'confirmed'
      AND NOT EXISTS (
        SELECT 1
        FROM send_account_tags sat
        WHERE sat.send_account_id = sa.id
        AND sat.tag_id = t.id
      )
    `)

    console.log(`Created ${insertResult.rowCount} send_account_tags relationships`)

    // Now update all send_accounts to set main_tag_id
    // This sets the main_tag_id to the first (alphabetically) tag for each user
    const updateResult = await client.query(`
      UPDATE send_accounts sa
      SET main_tag_id = (
        SELECT t.id
        FROM tags t
        JOIN send_account_tags sat ON sat.tag_id = t.id
        WHERE sat.send_account_id = sa.id
        AND t.status = 'confirmed'
        ORDER BY t.name ASC
        LIMIT 1
      )
      WHERE sa.main_tag_id IS NULL
      AND EXISTS (
        SELECT 1
        FROM send_account_tags sat
        JOIN tags t ON t.id = sat.tag_id
        WHERE sat.send_account_id = sa.id
        AND t.status = 'confirmed'
      )
    `)

    console.log(`Updated ${updateResult.rowCount} send accounts with main tag IDs`)

    // Seed sendpot data
    console.log('Seeding sendpot data...')

    // Get some send_account addresses to use for winners and ticket purchases
    const sendAccountsResult = await client.query(`
      SELECT address_bytes, user_id
      FROM send_accounts
      ORDER BY id
      LIMIT 10
    `)

    const sendAccounts = sendAccountsResult.rows

    if (sendAccounts.length > 0) {
      // Insert jackpot runs
      // First run: alice wins at block 100
      const aliceAddress = sendAccounts[0].address_bytes

      await client.query(
        `
        INSERT INTO sendpot_jackpot_runs (
          chain_id, log_addr, block_time, tx_hash, time, winner,
          winning_ticket, win_amount, tickets_purchased_total_bps,
          ig_name, src_name, block_num, tx_idx, log_idx, abi_idx
        ) VALUES (
          $1, $2, $3, $4, $5, $6,
          $7, $8, $9,
          $10, $11, $12, $13, $14, $15
        )
      `,
        [
          8453, // chain_id
          Buffer.from('cafebabe'.repeat(5)), // log_addr
          1000000000, // block_time
          Buffer.from('deadbeef'.repeat(8)), // tx_hash
          1000000000, // time
          aliceAddress, // winner
          5, // winning_ticket
          1000000000000000000n, // win_amount (1 ETH)
          100000n, // tickets_purchased_total_bps (1000 tickets = 1.0, so 100000 = 10.0)
          'ig_sendpot', // ig_name
          'src_base', // src_name
          100, // block_num
          0, // tx_idx
          0, // log_idx
          0, // abi_idx
        ]
      )

      // Insert ticket purchases for the first run (blocks 50-99)
      for (let i = 0; i < 5; i++) {
        const buyer = sendAccounts[Math.floor(Math.random() * sendAccounts.length)].address_bytes
        const recipient =
          sendAccounts[Math.floor(Math.random() * sendAccounts.length)].address_bytes
        const referrer = sendAccounts[Math.floor(Math.random() * sendAccounts.length)].address_bytes

        await client.query(
          `
          INSERT INTO sendpot_user_ticket_purchases (
            chain_id, log_addr, block_time, tx_hash, referrer, value,
            recipient, buyer, tickets_purchased_total_bps,
            ig_name, src_name, block_num, tx_idx, log_idx, abi_idx
          ) VALUES (
            $1, $2, $3, $4, $5, $6,
            $7, $8, $9,
            $10, $11, $12, $13, $14, $15
          )
        `,
          [
            8453, // chain_id
            Buffer.from('cafebabe'.repeat(5)), // log_addr
            1000000000 - (50 - i) * 1000, // block_time
            Buffer.from(`deadbeef${i}`.repeat(8)), // tx_hash
            referrer, // referrer
            1000000000000000n * BigInt(i + 1), // value
            recipient, // recipient
            buyer, // buyer
            10000n * BigInt(i + 1), // tickets_purchased_total_bps
            'ig_sendpot', // ig_name
            'src_base', // src_name
            50 + i, // block_num
            i, // tx_idx
            0, // log_idx
            0, // abi_idx
          ]
        )
      }

      // Second run: pending (no winner yet) at block 200
      await client.query(
        `
        INSERT INTO sendpot_jackpot_runs (
          chain_id, log_addr, block_time, tx_hash, time, winner,
          winning_ticket, win_amount, tickets_purchased_total_bps,
          ig_name, src_name, block_num, tx_idx, log_idx, abi_idx
        ) VALUES (
          $1, $2, $3, $4, $5, $6,
          $7, $8, $9,
          $10, $11, $12, $13, $14, $15
        )
      `,
        [
          8453, // chain_id
          Buffer.from('cafebabe'.repeat(5)), // log_addr
          2000000000, // block_time
          Buffer.from('deadbeef'.repeat(8)), // tx_hash
          2000000000, // time
          null, // winner (NULL for pending)
          null, // winning_ticket (NULL for pending)
          0n, // win_amount (0 for pending)
          200000n, // tickets_purchased_total_bps
          'ig_sendpot', // ig_name
          'src_base', // src_name
          200, // block_num
          0, // tx_idx
          0, // log_idx
          0, // abi_idx
        ]
      )

      // Insert ticket purchases for the second run (blocks 150-199)
      for (let i = 0; i < 8; i++) {
        const buyer = sendAccounts[Math.floor(Math.random() * sendAccounts.length)].address_bytes
        const recipient =
          sendAccounts[Math.floor(Math.random() * sendAccounts.length)].address_bytes
        const referrer = sendAccounts[Math.floor(Math.random() * sendAccounts.length)].address_bytes

        await client.query(
          `
          INSERT INTO sendpot_user_ticket_purchases (
            chain_id, log_addr, block_time, tx_hash, referrer, value,
            recipient, buyer, tickets_purchased_total_bps,
            ig_name, src_name, block_num, tx_idx, log_idx, abi_idx
          ) VALUES (
            $1, $2, $3, $4, $5, $6,
            $7, $8, $9,
            $10, $11, $12, $13, $14, $15
          )
        `,
          [
            8453, // chain_id
            Buffer.from('cafebabe'.repeat(5)), // log_addr
            2000000000 - (50 - i) * 1000, // block_time
            Buffer.from(`baadcafe${i}`.repeat(8)), // tx_hash
            referrer, // referrer
            2000000000000000n * BigInt(i + 1), // value
            recipient, // recipient
            buyer, // buyer
            15000n * BigInt(i + 1), // tickets_purchased_total_bps
            'ig_sendpot', // ig_name
            'src_base', // src_name
            150 + i, // block_num
            i, // tx_idx
            0, // log_idx
            0, // abi_idx
          ]
        )
      }

      console.log('Seeded sendpot data: 2 jackpot runs and ticket purchases')

      // Add additional sendpot data using direct SQL
      console.log('Adding additional sendpot data...')

      await client.query(
        `
        -- Insert a third jackpot run (pending, no winner)
        INSERT INTO sendpot_jackpot_runs (
          chain_id, log_addr, block_time, tx_hash, time, winner,
          winning_ticket, win_amount, tickets_purchased_total_bps,
          ig_name, src_name, block_num, tx_idx, log_idx, abi_idx
        )
        VALUES (
          8453,
          $1::bytea,
          3000000000,
          $2::bytea,
          3000000000,
          NULL,
          NULL,
          0,
          150000,
          'ig_sendpot',
          'src_base',
          300,
          0,
          0,
          0
        )
      `,
        [Buffer.from('11111111'.repeat(5)), Buffer.from('22222222'.repeat(8))]
      )

      // Insert ticket purchases for the third run
      await client.query(
        `
        INSERT INTO sendpot_user_ticket_purchases (
          chain_id, log_addr, block_time, tx_hash, referrer, value,
          recipient, buyer, tickets_purchased_total_bps,
          ig_name, src_name, block_num, tx_idx, log_idx, abi_idx
        )
        SELECT 
          8453,
          $1::bytea,
          3000000000 - (row_number() OVER (ORDER BY sa.id) * 1000),
          $2::bytea,
          sa2.address_bytes,
          (row_number() OVER (ORDER BY sa.id))::numeric * 500000000000000,
          sa.address_bytes,
          sa.address_bytes,
          (row_number() OVER (ORDER BY sa.id))::numeric * 25000,
          'ig_sendpot',
          'src_base',
          (row_number() OVER (ORDER BY sa.id)) + 250,
          0,
          0,
          0
        FROM send_accounts sa
        CROSS JOIN LATERAL (
          SELECT address_bytes FROM send_accounts 
          ORDER BY RANDOM() LIMIT 1
        ) sa2
        ORDER BY sa.id
        LIMIT 10
      `,
        [Buffer.from('33333333'.repeat(5)), Buffer.from('44444444'.repeat(8))]
      )

      console.log('Added additional sendpot data')
    }
  } finally {
    await client.end()
  }
}

console.log(`Snaplet seed done! Seeded ${seededUsers.users.length} users.`)
process.exit()
