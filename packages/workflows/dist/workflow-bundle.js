var __TEMPORAL__;
/******/ (() => { // webpackBootstrap
/******/ 	var __webpack_modules__ = ({

/***/ "../../node_modules/@temporalio/common/lib/activity-options.js":
/*!*********************************************************************!*\
  !*** ../../node_modules/@temporalio/common/lib/activity-options.js ***!
  \*********************************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";

var _a;
Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.decodeActivityCancellationType = exports.encodeActivityCancellationType = exports.ActivityCancellationType = void 0;
const internal_workflow_1 = __webpack_require__(/*! ./internal-workflow */ "../../node_modules/@temporalio/common/lib/internal-workflow/index.js");
exports.ActivityCancellationType = {
    TRY_CANCEL: 'TRY_CANCEL',
    WAIT_CANCELLATION_COMPLETED: 'WAIT_CANCELLATION_COMPLETED',
    ABANDON: 'ABANDON',
};
_a = (0, internal_workflow_1.makeProtoEnumConverters)({
    [exports.ActivityCancellationType.TRY_CANCEL]: 0,
    [exports.ActivityCancellationType.WAIT_CANCELLATION_COMPLETED]: 1,
    [exports.ActivityCancellationType.ABANDON]: 2,
}, ''), exports.encodeActivityCancellationType = _a[0], exports.decodeActivityCancellationType = _a[1];


/***/ }),

/***/ "../../node_modules/@temporalio/common/lib/converter/data-converter.js":
/*!*****************************************************************************!*\
  !*** ../../node_modules/@temporalio/common/lib/converter/data-converter.js ***!
  \*****************************************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.defaultDataConverter = exports.defaultFailureConverter = void 0;
const failure_converter_1 = __webpack_require__(/*! ./failure-converter */ "../../node_modules/@temporalio/common/lib/converter/failure-converter.js");
const payload_converter_1 = __webpack_require__(/*! ./payload-converter */ "../../node_modules/@temporalio/common/lib/converter/payload-converter.js");
/**
 * The default {@link FailureConverter} used by the SDK.
 *
 * Error messages and stack traces are serizalized as plain text.
 */
exports.defaultFailureConverter = new failure_converter_1.DefaultFailureConverter();
/**
 * A "loaded" data converter that uses the default set of failure and payload converters.
 */
exports.defaultDataConverter = {
    payloadConverter: payload_converter_1.defaultPayloadConverter,
    failureConverter: exports.defaultFailureConverter,
    payloadCodecs: [],
};


/***/ }),

/***/ "../../node_modules/@temporalio/common/lib/converter/failure-converter.js":
/*!********************************************************************************!*\
  !*** ../../node_modules/@temporalio/common/lib/converter/failure-converter.js ***!
  \********************************************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.DefaultFailureConverter = void 0;
exports.cutoffStackTrace = cutoffStackTrace;
const failure_1 = __webpack_require__(/*! ../failure */ "../../node_modules/@temporalio/common/lib/failure.js");
const type_helpers_1 = __webpack_require__(/*! ../type-helpers */ "../../node_modules/@temporalio/common/lib/type-helpers.js");
const time_1 = __webpack_require__(/*! ../time */ "../../node_modules/@temporalio/common/lib/time.js");
const payload_converter_1 = __webpack_require__(/*! ./payload-converter */ "../../node_modules/@temporalio/common/lib/converter/payload-converter.js");
function combineRegExp(...regexps) {
    return new RegExp(regexps.map((x) => `(?:${x.source})`).join('|'));
}
/**
 * Stack traces will be cutoff when on of these patterns is matched
 */
const CUTOFF_STACK_PATTERNS = combineRegExp(
/** Activity execution */
/\s+at Activity\.execute \(.*[\\/]worker[\\/](?:src|lib)[\\/]activity\.[jt]s:\d+:\d+\)/, 
/** Workflow activation */
/\s+at Activator\.\S+NextHandler \(.*[\\/]workflow[\\/](?:src|lib)[\\/]internals\.[jt]s:\d+:\d+\)/, 
/** Workflow run anything in context */
/\s+at Script\.runInContext \((?:node:vm|vm\.js):\d+:\d+\)/);
/**
 * Any stack trace frames that match any of those wil be dopped.
 * The "null." prefix on some cases is to avoid https://github.com/nodejs/node/issues/42417
 */
const DROPPED_STACK_FRAMES_PATTERNS = combineRegExp(
/** Internal functions used to recursively chain interceptors */
/\s+at (null\.)?next \(.*[\\/]common[\\/](?:src|lib)[\\/]interceptors\.[jt]s:\d+:\d+\)/, 
/** Internal functions used to recursively chain interceptors */
/\s+at (null\.)?executeNextHandler \(.*[\\/]worker[\\/](?:src|lib)[\\/]activity\.[jt]s:\d+:\d+\)/);
/**
 * Cuts out the framework part of a stack trace, leaving only user code entries
 */
function cutoffStackTrace(stack) {
    const lines = (stack ?? '').split(/\r?\n/);
    const acc = Array();
    for (const line of lines) {
        if (CUTOFF_STACK_PATTERNS.test(line))
            break;
        if (!DROPPED_STACK_FRAMES_PATTERNS.test(line))
            acc.push(line);
    }
    return acc.join('\n');
}
/**
 * Default, cross-language-compatible Failure converter.
 *
 * By default, it will leave error messages and stack traces as plain text. In order to encrypt them, set
 * `encodeCommonAttributes` to `true` in the constructor options and use a {@link PayloadCodec} that can encrypt /
 * decrypt Payloads in your {@link WorkerOptions.dataConverter | Worker} and
 * {@link ClientOptions.dataConverter | Client options}.
 */
class DefaultFailureConverter {
    constructor(options) {
        const { encodeCommonAttributes } = options ?? {};
        this.options = {
            encodeCommonAttributes: encodeCommonAttributes ?? false,
        };
    }
    /**
     * Converts a Failure proto message to a JS Error object.
     *
     * Does not set common properties, that is done in {@link failureToError}.
     */
    failureToErrorInner(failure, payloadConverter) {
        if (failure.applicationFailureInfo) {
            return new failure_1.ApplicationFailure(failure.message ?? undefined, failure.applicationFailureInfo.type, Boolean(failure.applicationFailureInfo.nonRetryable), (0, payload_converter_1.arrayFromPayloads)(payloadConverter, failure.applicationFailureInfo.details?.payloads), this.optionalFailureToOptionalError(failure.cause, payloadConverter));
        }
        if (failure.serverFailureInfo) {
            return new failure_1.ServerFailure(failure.message ?? undefined, Boolean(failure.serverFailureInfo.nonRetryable), this.optionalFailureToOptionalError(failure.cause, payloadConverter));
        }
        if (failure.timeoutFailureInfo) {
            return new failure_1.TimeoutFailure(failure.message ?? undefined, (0, payload_converter_1.fromPayloadsAtIndex)(payloadConverter, 0, failure.timeoutFailureInfo.lastHeartbeatDetails?.payloads), (0, failure_1.decodeTimeoutType)(failure.timeoutFailureInfo.timeoutType));
        }
        if (failure.terminatedFailureInfo) {
            return new failure_1.TerminatedFailure(failure.message ?? undefined, this.optionalFailureToOptionalError(failure.cause, payloadConverter));
        }
        if (failure.canceledFailureInfo) {
            return new failure_1.CancelledFailure(failure.message ?? undefined, (0, payload_converter_1.arrayFromPayloads)(payloadConverter, failure.canceledFailureInfo.details?.payloads), this.optionalFailureToOptionalError(failure.cause, payloadConverter));
        }
        if (failure.resetWorkflowFailureInfo) {
            return new failure_1.ApplicationFailure(failure.message ?? undefined, 'ResetWorkflow', false, (0, payload_converter_1.arrayFromPayloads)(payloadConverter, failure.resetWorkflowFailureInfo.lastHeartbeatDetails?.payloads), this.optionalFailureToOptionalError(failure.cause, payloadConverter));
        }
        if (failure.childWorkflowExecutionFailureInfo) {
            const { namespace, workflowType, workflowExecution, retryState } = failure.childWorkflowExecutionFailureInfo;
            if (!(workflowType?.name && workflowExecution)) {
                throw new TypeError('Missing attributes on childWorkflowExecutionFailureInfo');
            }
            return new failure_1.ChildWorkflowFailure(namespace ?? undefined, workflowExecution, workflowType.name, (0, failure_1.decodeRetryState)(retryState), this.optionalFailureToOptionalError(failure.cause, payloadConverter));
        }
        if (failure.activityFailureInfo) {
            if (!failure.activityFailureInfo.activityType?.name) {
                throw new TypeError('Missing activityType?.name on activityFailureInfo');
            }
            return new failure_1.ActivityFailure(failure.message ?? undefined, failure.activityFailureInfo.activityType.name, failure.activityFailureInfo.activityId ?? undefined, (0, failure_1.decodeRetryState)(failure.activityFailureInfo.retryState), failure.activityFailureInfo.identity ?? undefined, this.optionalFailureToOptionalError(failure.cause, payloadConverter));
        }
        return new failure_1.TemporalFailure(failure.message ?? undefined, this.optionalFailureToOptionalError(failure.cause, payloadConverter));
    }
    failureToError(failure, payloadConverter) {
        if (failure.encodedAttributes) {
            const attrs = payloadConverter.fromPayload(failure.encodedAttributes);
            // Don't apply encodedAttributes unless they conform to an expected schema
            if (typeof attrs === 'object' && attrs !== null) {
                const { message, stack_trace } = attrs;
                // Avoid mutating the argument
                failure = { ...failure };
                if (typeof message === 'string') {
                    failure.message = message;
                }
                if (typeof stack_trace === 'string') {
                    failure.stackTrace = stack_trace;
                }
            }
        }
        const err = this.failureToErrorInner(failure, payloadConverter);
        err.stack = failure.stackTrace ?? '';
        err.failure = failure;
        return err;
    }
    errorToFailure(err, payloadConverter) {
        const failure = this.errorToFailureInner(err, payloadConverter);
        if (this.options.encodeCommonAttributes) {
            const { message, stackTrace } = failure;
            failure.message = 'Encoded failure';
            failure.stackTrace = '';
            failure.encodedAttributes = payloadConverter.toPayload({ message, stack_trace: stackTrace });
        }
        return failure;
    }
    errorToFailureInner(err, payloadConverter) {
        if (err instanceof failure_1.TemporalFailure) {
            if (err.failure)
                return err.failure;
            const base = {
                message: err.message,
                stackTrace: cutoffStackTrace(err.stack),
                cause: this.optionalErrorToOptionalFailure(err.cause, payloadConverter),
                source: failure_1.FAILURE_SOURCE,
            };
            if (err instanceof failure_1.ActivityFailure) {
                return {
                    ...base,
                    activityFailureInfo: {
                        ...err,
                        retryState: (0, failure_1.encodeRetryState)(err.retryState),
                        activityType: { name: err.activityType },
                    },
                };
            }
            if (err instanceof failure_1.ChildWorkflowFailure) {
                return {
                    ...base,
                    childWorkflowExecutionFailureInfo: {
                        ...err,
                        retryState: (0, failure_1.encodeRetryState)(err.retryState),
                        workflowExecution: err.execution,
                        workflowType: { name: err.workflowType },
                    },
                };
            }
            if (err instanceof failure_1.ApplicationFailure) {
                return {
                    ...base,
                    applicationFailureInfo: {
                        type: err.type,
                        nonRetryable: err.nonRetryable,
                        details: err.details && err.details.length
                            ? { payloads: (0, payload_converter_1.toPayloads)(payloadConverter, ...err.details) }
                            : undefined,
                        nextRetryDelay: (0, time_1.msOptionalToTs)(err.nextRetryDelay),
                    },
                };
            }
            if (err instanceof failure_1.CancelledFailure) {
                return {
                    ...base,
                    canceledFailureInfo: {
                        details: err.details && err.details.length
                            ? { payloads: (0, payload_converter_1.toPayloads)(payloadConverter, ...err.details) }
                            : undefined,
                    },
                };
            }
            if (err instanceof failure_1.TimeoutFailure) {
                return {
                    ...base,
                    timeoutFailureInfo: {
                        timeoutType: (0, failure_1.encodeTimeoutType)(err.timeoutType),
                        lastHeartbeatDetails: err.lastHeartbeatDetails
                            ? { payloads: (0, payload_converter_1.toPayloads)(payloadConverter, err.lastHeartbeatDetails) }
                            : undefined,
                    },
                };
            }
            if (err instanceof failure_1.ServerFailure) {
                return {
                    ...base,
                    serverFailureInfo: { nonRetryable: err.nonRetryable },
                };
            }
            if (err instanceof failure_1.TerminatedFailure) {
                return {
                    ...base,
                    terminatedFailureInfo: {},
                };
            }
            // Just a TemporalFailure
            return base;
        }
        const base = {
            source: failure_1.FAILURE_SOURCE,
        };
        if ((0, type_helpers_1.isError)(err)) {
            return {
                ...base,
                message: String(err.message) ?? '',
                stackTrace: cutoffStackTrace(err.stack),
                cause: this.optionalErrorToOptionalFailure(err.cause, payloadConverter),
            };
        }
        const recommendation = ` [A non-Error value was thrown from your code. We recommend throwing Error objects so that we can provide a stack trace]`;
        if (typeof err === 'string') {
            return { ...base, message: err + recommendation };
        }
        if (typeof err === 'object') {
            let message = '';
            try {
                message = JSON.stringify(err);
            }
            catch (_err) {
                message = String(err);
            }
            return { ...base, message: message + recommendation };
        }
        return { ...base, message: String(err) + recommendation };
    }
    /**
     * Converts a Failure proto message to a JS Error object if defined or returns undefined.
     */
    optionalFailureToOptionalError(failure, payloadConverter) {
        return failure ? this.failureToError(failure, payloadConverter) : undefined;
    }
    /**
     * Converts an error to a Failure proto message if defined or returns undefined
     */
    optionalErrorToOptionalFailure(err, payloadConverter) {
        return err ? this.errorToFailure(err, payloadConverter) : undefined;
    }
}
exports.DefaultFailureConverter = DefaultFailureConverter;


/***/ }),

/***/ "../../node_modules/@temporalio/common/lib/converter/payload-codec.js":
/*!****************************************************************************!*\
  !*** ../../node_modules/@temporalio/common/lib/converter/payload-codec.js ***!
  \****************************************************************************/
/***/ ((__unused_webpack_module, exports) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({ value: true }));


/***/ }),

/***/ "../../node_modules/@temporalio/common/lib/converter/payload-converter.js":
/*!********************************************************************************!*\
  !*** ../../node_modules/@temporalio/common/lib/converter/payload-converter.js ***!
  \********************************************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.defaultPayloadConverter = exports.DefaultPayloadConverter = exports.searchAttributePayloadConverter = exports.SearchAttributePayloadConverter = exports.JsonPayloadConverter = exports.BinaryPayloadConverter = exports.UndefinedPayloadConverter = exports.CompositePayloadConverter = void 0;
exports.toPayloads = toPayloads;
exports.mapToPayloads = mapToPayloads;
exports.fromPayloadsAtIndex = fromPayloadsAtIndex;
exports.arrayFromPayloads = arrayFromPayloads;
exports.mapFromPayloads = mapFromPayloads;
const encoding_1 = __webpack_require__(/*! ../encoding */ "../../node_modules/@temporalio/common/lib/encoding.js");
const errors_1 = __webpack_require__(/*! ../errors */ "../../node_modules/@temporalio/common/lib/errors.js");
const types_1 = __webpack_require__(/*! ./types */ "../../node_modules/@temporalio/common/lib/converter/types.js");
/**
 * Implements conversion of a list of values.
 *
 * @param converter
 * @param values JS values to convert to Payloads
 * @return list of {@link Payload}s
 * @throws {@link ValueError} if conversion of the value passed as parameter failed for any
 *     reason.
 */
function toPayloads(converter, ...values) {
    if (values.length === 0) {
        return undefined;
    }
    return values.map((value) => converter.toPayload(value));
}
/**
 * Run {@link PayloadConverter.toPayload} on each value in the map.
 *
 * @throws {@link ValueError} if conversion of any value in the map fails
 */
function mapToPayloads(converter, map) {
    return Object.fromEntries(Object.entries(map).map(([k, v]) => [k, converter.toPayload(v)]));
}
/**
 * Implements conversion of an array of values of different types. Useful for deserializing
 * arguments of function invocations.
 *
 * @param converter
 * @param index index of the value in the payloads
 * @param payloads serialized value to convert to JS values.
 * @return converted JS value
 * @throws {@link PayloadConverterError} if conversion of the data passed as parameter failed for any
 *     reason.
 */
function fromPayloadsAtIndex(converter, index, payloads) {
    // To make adding arguments a backwards compatible change
    if (payloads === undefined || payloads === null || index >= payloads.length) {
        return undefined;
    }
    return converter.fromPayload(payloads[index]);
}
/**
 * Run {@link PayloadConverter.fromPayload} on each value in the array.
 */
function arrayFromPayloads(converter, payloads) {
    if (!payloads) {
        return [];
    }
    return payloads.map((payload) => converter.fromPayload(payload));
}
function mapFromPayloads(converter, map) {
    if (map == null)
        return undefined;
    return Object.fromEntries(Object.entries(map).map(([k, payload]) => {
        const value = converter.fromPayload(payload);
        return [k, value];
    }));
}
/**
 * Tries to convert values to {@link Payload}s using the {@link PayloadConverterWithEncoding}s provided to the constructor, in the order provided.
 *
 * Converts Payloads to values based on the `Payload.metadata.encoding` field, which matches the {@link PayloadConverterWithEncoding.encodingType}
 * of the converter that created the Payload.
 */
class CompositePayloadConverter {
    constructor(...converters) {
        this.converterByEncoding = new Map();
        if (converters.length === 0) {
            throw new errors_1.PayloadConverterError('Must provide at least one PayloadConverterWithEncoding');
        }
        this.converters = converters;
        for (const converter of converters) {
            this.converterByEncoding.set(converter.encodingType, converter);
        }
    }
    /**
     * Tries to run `.toPayload(value)` on each converter in the order provided at construction.
     * Returns the first successful result, throws {@link ValueError} if there is no converter that can handle the value.
     */
    toPayload(value) {
        for (const converter of this.converters) {
            const result = converter.toPayload(value);
            if (result !== undefined) {
                return result;
            }
        }
        throw new errors_1.ValueError(`Unable to convert ${value} to payload`);
    }
    /**
     * Run {@link PayloadConverterWithEncoding.fromPayload} based on the `encoding` metadata of the {@link Payload}.
     */
    fromPayload(payload) {
        if (payload.metadata === undefined || payload.metadata === null) {
            throw new errors_1.ValueError('Missing payload metadata');
        }
        const encoding = (0, encoding_1.decode)(payload.metadata[types_1.METADATA_ENCODING_KEY]);
        const converter = this.converterByEncoding.get(encoding);
        if (converter === undefined) {
            throw new errors_1.ValueError(`Unknown encoding: ${encoding}`);
        }
        return converter.fromPayload(payload);
    }
}
exports.CompositePayloadConverter = CompositePayloadConverter;
/**
 * Converts between JS undefined and NULL Payload
 */
class UndefinedPayloadConverter {
    constructor() {
        this.encodingType = types_1.encodingTypes.METADATA_ENCODING_NULL;
    }
    toPayload(value) {
        if (value !== undefined) {
            return undefined;
        }
        return {
            metadata: {
                [types_1.METADATA_ENCODING_KEY]: types_1.encodingKeys.METADATA_ENCODING_NULL,
            },
        };
    }
    fromPayload(_content) {
        return undefined; // Just return undefined
    }
}
exports.UndefinedPayloadConverter = UndefinedPayloadConverter;
/**
 * Converts between binary data types and RAW Payload
 */
class BinaryPayloadConverter {
    constructor() {
        this.encodingType = types_1.encodingTypes.METADATA_ENCODING_RAW;
    }
    toPayload(value) {
        if (!(value instanceof Uint8Array)) {
            return undefined;
        }
        return {
            metadata: {
                [types_1.METADATA_ENCODING_KEY]: types_1.encodingKeys.METADATA_ENCODING_RAW,
            },
            data: value,
        };
    }
    fromPayload(content) {
        return (
        // Wrap with Uint8Array from this context to ensure `instanceof` works
        (content.data ? new Uint8Array(content.data.buffer, content.data.byteOffset, content.data.length) : content.data));
    }
}
exports.BinaryPayloadConverter = BinaryPayloadConverter;
/**
 * Converts between non-undefined values and serialized JSON Payload
 */
class JsonPayloadConverter {
    constructor() {
        this.encodingType = types_1.encodingTypes.METADATA_ENCODING_JSON;
    }
    toPayload(value) {
        if (value === undefined) {
            return undefined;
        }
        let json;
        try {
            json = JSON.stringify(value);
        }
        catch (_err) {
            return undefined;
        }
        return {
            metadata: {
                [types_1.METADATA_ENCODING_KEY]: types_1.encodingKeys.METADATA_ENCODING_JSON,
            },
            data: (0, encoding_1.encode)(json),
        };
    }
    fromPayload(content) {
        if (content.data === undefined || content.data === null) {
            throw new errors_1.ValueError('Got payload with no data');
        }
        return JSON.parse((0, encoding_1.decode)(content.data));
    }
}
exports.JsonPayloadConverter = JsonPayloadConverter;
/**
 * Converts Search Attribute values using JsonPayloadConverter
 */
class SearchAttributePayloadConverter {
    constructor() {
        this.jsonConverter = new JsonPayloadConverter();
        this.validNonDateTypes = ['string', 'number', 'boolean'];
    }
    toPayload(values) {
        if (!Array.isArray(values)) {
            throw new errors_1.ValueError(`SearchAttribute value must be an array`);
        }
        if (values.length > 0) {
            const firstValue = values[0];
            const firstType = typeof firstValue;
            if (firstType === 'object') {
                for (const [idx, value] of values.entries()) {
                    if (!(value instanceof Date)) {
                        throw new errors_1.ValueError(`SearchAttribute values must arrays of strings, numbers, booleans, or Dates. The value ${value} at index ${idx} is of type ${typeof value}`);
                    }
                }
            }
            else {
                if (!this.validNonDateTypes.includes(firstType)) {
                    throw new errors_1.ValueError(`SearchAttribute array values must be: string | number | boolean | Date`);
                }
                for (const [idx, value] of values.entries()) {
                    if (typeof value !== firstType) {
                        throw new errors_1.ValueError(`All SearchAttribute array values must be of the same type. The first value ${firstValue} of type ${firstType} doesn't match value ${value} of type ${typeof value} at index ${idx}`);
                    }
                }
            }
        }
        // JSON.stringify takes care of converting Dates to ISO strings
        const ret = this.jsonConverter.toPayload(values);
        if (ret === undefined) {
            throw new errors_1.ValueError('Could not convert search attributes to payloads');
        }
        return ret;
    }
    /**
     * Datetime Search Attribute values are converted to `Date`s
     */
    fromPayload(payload) {
        if (payload.metadata === undefined || payload.metadata === null) {
            throw new errors_1.ValueError('Missing payload metadata');
        }
        const value = this.jsonConverter.fromPayload(payload);
        let arrayWrappedValue = Array.isArray(value) ? value : [value];
        const searchAttributeType = (0, encoding_1.decode)(payload.metadata.type);
        if (searchAttributeType === 'Datetime') {
            arrayWrappedValue = arrayWrappedValue.map((dateString) => new Date(dateString));
        }
        return arrayWrappedValue;
    }
}
exports.SearchAttributePayloadConverter = SearchAttributePayloadConverter;
exports.searchAttributePayloadConverter = new SearchAttributePayloadConverter();
class DefaultPayloadConverter extends CompositePayloadConverter {
    // Match the order used in other SDKs, but exclude Protobuf converters so that the code, including
    // `proto3-json-serializer`, doesn't take space in Workflow bundles that don't use Protobufs. To use Protobufs, use
    // {@link DefaultPayloadConverterWithProtobufs}.
    //
    // Go SDK:
    // https://github.com/temporalio/sdk-go/blob/5e5645f0c550dcf717c095ae32c76a7087d2e985/converter/default_data_converter.go#L28
    constructor() {
        super(new UndefinedPayloadConverter(), new BinaryPayloadConverter(), new JsonPayloadConverter());
    }
}
exports.DefaultPayloadConverter = DefaultPayloadConverter;
/**
 * The default {@link PayloadConverter} used by the SDK. Supports `Uint8Array` and JSON serializables (so if
 * {@link https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/JSON/stringify#description | `JSON.stringify(yourArgOrRetval)`}
 * works, the default payload converter will work).
 *
 * To also support Protobufs, create a custom payload converter with {@link DefaultPayloadConverter}:
 *
 * `const myConverter = new DefaultPayloadConverter({ protobufRoot })`
 */
exports.defaultPayloadConverter = new DefaultPayloadConverter();


/***/ }),

/***/ "../../node_modules/@temporalio/common/lib/converter/types.js":
/*!********************************************************************!*\
  !*** ../../node_modules/@temporalio/common/lib/converter/types.js ***!
  \********************************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.METADATA_MESSAGE_TYPE_KEY = exports.encodingKeys = exports.encodingTypes = exports.METADATA_ENCODING_KEY = void 0;
const encoding_1 = __webpack_require__(/*! ../encoding */ "../../node_modules/@temporalio/common/lib/encoding.js");
exports.METADATA_ENCODING_KEY = 'encoding';
exports.encodingTypes = {
    METADATA_ENCODING_NULL: 'binary/null',
    METADATA_ENCODING_RAW: 'binary/plain',
    METADATA_ENCODING_JSON: 'json/plain',
    METADATA_ENCODING_PROTOBUF_JSON: 'json/protobuf',
    METADATA_ENCODING_PROTOBUF: 'binary/protobuf',
};
exports.encodingKeys = {
    METADATA_ENCODING_NULL: (0, encoding_1.encode)(exports.encodingTypes.METADATA_ENCODING_NULL),
    METADATA_ENCODING_RAW: (0, encoding_1.encode)(exports.encodingTypes.METADATA_ENCODING_RAW),
    METADATA_ENCODING_JSON: (0, encoding_1.encode)(exports.encodingTypes.METADATA_ENCODING_JSON),
    METADATA_ENCODING_PROTOBUF_JSON: (0, encoding_1.encode)(exports.encodingTypes.METADATA_ENCODING_PROTOBUF_JSON),
    METADATA_ENCODING_PROTOBUF: (0, encoding_1.encode)(exports.encodingTypes.METADATA_ENCODING_PROTOBUF),
};
exports.METADATA_MESSAGE_TYPE_KEY = 'messageType';


/***/ }),

/***/ "../../node_modules/@temporalio/common/lib/deprecated-time.js":
/*!********************************************************************!*\
  !*** ../../node_modules/@temporalio/common/lib/deprecated-time.js ***!
  \********************************************************************/
/***/ (function(__unused_webpack_module, exports, __webpack_require__) {

"use strict";

var __createBinding = (this && this.__createBinding) || (Object.create ? (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    var desc = Object.getOwnPropertyDescriptor(m, k);
    if (!desc || ("get" in desc ? !m.__esModule : desc.writable || desc.configurable)) {
      desc = { enumerable: true, get: function() { return m[k]; } };
    }
    Object.defineProperty(o, k2, desc);
}) : (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    o[k2] = m[k];
}));
var __setModuleDefault = (this && this.__setModuleDefault) || (Object.create ? (function(o, v) {
    Object.defineProperty(o, "default", { enumerable: true, value: v });
}) : function(o, v) {
    o["default"] = v;
});
var __importStar = (this && this.__importStar) || function (mod) {
    if (mod && mod.__esModule) return mod;
    var result = {};
    if (mod != null) for (var k in mod) if (k !== "default" && Object.prototype.hasOwnProperty.call(mod, k)) __createBinding(result, mod, k);
    __setModuleDefault(result, mod);
    return result;
};
Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.optionalTsToMs = optionalTsToMs;
exports.tsToMs = tsToMs;
exports.msNumberToTs = msNumberToTs;
exports.msToTs = msToTs;
exports.msOptionalToTs = msOptionalToTs;
exports.msOptionalToNumber = msOptionalToNumber;
exports.msToNumber = msToNumber;
exports.tsToDate = tsToDate;
exports.optionalTsToDate = optionalTsToDate;
const time = __importStar(__webpack_require__(/*! ./time */ "../../node_modules/@temporalio/common/lib/time.js"));
/**
 * Lossy conversion function from Timestamp to number due to possible overflow.
 * If ts is null or undefined returns undefined.
 *
 * @hidden
 * @deprecated - meant for internal use only
 */
function optionalTsToMs(ts) {
    return time.optionalTsToMs(ts);
}
/**
 * Lossy conversion function from Timestamp to number due to possible overflow
 *
 * @hidden
 * @deprecated - meant for internal use only
 * @deprecated - meant for internal use only
 */
function tsToMs(ts) {
    return time.tsToMs(ts);
}
/**
 * @hidden
 * @deprecated - meant for internal use only
 */
function msNumberToTs(millis) {
    return time.msNumberToTs(millis);
}
/**
 * @hidden
 * @deprecated - meant for internal use only
 */
function msToTs(str) {
    return time.msToTs(str);
}
/**
 * @hidden
 * @deprecated - meant for internal use only
 */
function msOptionalToTs(str) {
    return time.msOptionalToTs(str);
}
/**
 * @hidden
 * @deprecated - meant for internal use only
 */
function msOptionalToNumber(val) {
    return time.msOptionalToNumber(val);
}
/**
 * @hidden
 * @deprecated - meant for internal use only
 */
function msToNumber(val) {
    return time.msToNumber(val);
}
/**
 * @hidden
 * @deprecated - meant for internal use only
 */
function tsToDate(ts) {
    return time.tsToDate(ts);
}
/**
 * @hidden
 * @deprecated - meant for internal use only
 */
function optionalTsToDate(ts) {
    return time.optionalTsToDate(ts);
}


/***/ }),

/***/ "../../node_modules/@temporalio/common/lib/encoding.js":
/*!*************************************************************!*\
  !*** ../../node_modules/@temporalio/common/lib/encoding.js ***!
  \*************************************************************/
/***/ ((__unused_webpack_module, exports) => {

"use strict";

// Pasted with modifications from: https://raw.githubusercontent.com/anonyco/FastestSmallestTextEncoderDecoder/master/EncoderDecoderTogether.src.js
/* eslint no-fallthrough: 0 */
Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.TextEncoder = exports.TextDecoder = void 0;
exports.encode = encode;
exports.decode = decode;
const fromCharCode = String.fromCharCode;
const encoderRegexp = /[\x80-\uD7ff\uDC00-\uFFFF]|[\uD800-\uDBFF][\uDC00-\uDFFF]?/g;
const tmpBufferU16 = new Uint16Array(32);
class TextDecoder {
    decode(inputArrayOrBuffer) {
        const inputAs8 = inputArrayOrBuffer instanceof Uint8Array ? inputArrayOrBuffer : new Uint8Array(inputArrayOrBuffer);
        let resultingString = '', tmpStr = '', index = 0, nextEnd = 0, cp0 = 0, codePoint = 0, minBits = 0, cp1 = 0, pos = 0, tmp = -1;
        const len = inputAs8.length | 0;
        const lenMinus32 = (len - 32) | 0;
        // Note that tmp represents the 2nd half of a surrogate pair incase a surrogate gets divided between blocks
        for (; index < len;) {
            nextEnd = index <= lenMinus32 ? 32 : (len - index) | 0;
            for (; pos < nextEnd; index = (index + 1) | 0, pos = (pos + 1) | 0) {
                cp0 = inputAs8[index] & 0xff;
                switch (cp0 >> 4) {
                    case 15:
                        cp1 = inputAs8[(index = (index + 1) | 0)] & 0xff;
                        if (cp1 >> 6 !== 0b10 || 0b11110111 < cp0) {
                            index = (index - 1) | 0;
                            break;
                        }
                        codePoint = ((cp0 & 0b111) << 6) | (cp1 & 0b00111111);
                        minBits = 5; // 20 ensures it never passes -> all invalid replacements
                        cp0 = 0x100; //  keep track of th bit size
                    case 14:
                        cp1 = inputAs8[(index = (index + 1) | 0)] & 0xff;
                        codePoint <<= 6;
                        codePoint |= ((cp0 & 0b1111) << 6) | (cp1 & 0b00111111);
                        minBits = cp1 >> 6 === 0b10 ? (minBits + 4) | 0 : 24; // 24 ensures it never passes -> all invalid replacements
                        cp0 = (cp0 + 0x100) & 0x300; // keep track of th bit size
                    case 13:
                    case 12:
                        cp1 = inputAs8[(index = (index + 1) | 0)] & 0xff;
                        codePoint <<= 6;
                        codePoint |= ((cp0 & 0b11111) << 6) | (cp1 & 0b00111111);
                        minBits = (minBits + 7) | 0;
                        // Now, process the code point
                        if (index < len && cp1 >> 6 === 0b10 && codePoint >> minBits && codePoint < 0x110000) {
                            cp0 = codePoint;
                            codePoint = (codePoint - 0x10000) | 0;
                            if (0 <= codePoint /*0xffff < codePoint*/) {
                                // BMP code point
                                //nextEnd = nextEnd - 1|0;
                                tmp = ((codePoint >> 10) + 0xd800) | 0; // highSurrogate
                                cp0 = ((codePoint & 0x3ff) + 0xdc00) | 0; // lowSurrogate (will be inserted later in the switch-statement)
                                if (pos < 31) {
                                    // notice 31 instead of 32
                                    tmpBufferU16[pos] = tmp;
                                    pos = (pos + 1) | 0;
                                    tmp = -1;
                                }
                                else {
                                    // else, we are at the end of the inputAs8 and let tmp0 be filled in later on
                                    // NOTE that cp1 is being used as a temporary variable for the swapping of tmp with cp0
                                    cp1 = tmp;
                                    tmp = cp0;
                                    cp0 = cp1;
                                }
                            }
                            else
                                nextEnd = (nextEnd + 1) | 0; // because we are advancing i without advancing pos
                        }
                        else {
                            // invalid code point means replacing the whole thing with null replacement characters
                            cp0 >>= 8;
                            index = (index - cp0 - 1) | 0; // reset index  back to what it was before
                            cp0 = 0xfffd;
                        }
                        // Finally, reset the variables for the next go-around
                        minBits = 0;
                        codePoint = 0;
                        nextEnd = index <= lenMinus32 ? 32 : (len - index) | 0;
                    /*case 11:
                  case 10:
                  case 9:
                  case 8:
                    codePoint ? codePoint = 0 : cp0 = 0xfffd; // fill with invalid replacement character
                  case 7:
                  case 6:
                  case 5:
                  case 4:
                  case 3:
                  case 2:
                  case 1:
                  case 0:
                    tmpBufferU16[pos] = cp0;
                    continue;*/
                    default: // fill with invalid replacement character
                        tmpBufferU16[pos] = cp0;
                        continue;
                    case 11:
                    case 10:
                    case 9:
                    case 8:
                }
                tmpBufferU16[pos] = 0xfffd; // fill with invalid replacement character
            }
            tmpStr += fromCharCode(tmpBufferU16[0], tmpBufferU16[1], tmpBufferU16[2], tmpBufferU16[3], tmpBufferU16[4], tmpBufferU16[5], tmpBufferU16[6], tmpBufferU16[7], tmpBufferU16[8], tmpBufferU16[9], tmpBufferU16[10], tmpBufferU16[11], tmpBufferU16[12], tmpBufferU16[13], tmpBufferU16[14], tmpBufferU16[15], tmpBufferU16[16], tmpBufferU16[17], tmpBufferU16[18], tmpBufferU16[19], tmpBufferU16[20], tmpBufferU16[21], tmpBufferU16[22], tmpBufferU16[23], tmpBufferU16[24], tmpBufferU16[25], tmpBufferU16[26], tmpBufferU16[27], tmpBufferU16[28], tmpBufferU16[29], tmpBufferU16[30], tmpBufferU16[31]);
            if (pos < 32)
                tmpStr = tmpStr.slice(0, (pos - 32) | 0); //-(32-pos));
            if (index < len) {
                //fromCharCode.apply(0, tmpBufferU16 : Uint8Array ?  tmpBufferU16.subarray(0,pos) : tmpBufferU16.slice(0,pos));
                tmpBufferU16[0] = tmp;
                pos = ~tmp >>> 31; //tmp !== -1 ? 1 : 0;
                tmp = -1;
                if (tmpStr.length < resultingString.length)
                    continue;
            }
            else if (tmp !== -1) {
                tmpStr += fromCharCode(tmp);
            }
            resultingString += tmpStr;
            tmpStr = '';
        }
        return resultingString;
    }
}
exports.TextDecoder = TextDecoder;
//////////////////////////////////////////////////////////////////////////////////////
function encoderReplacer(nonAsciiChars) {
    // make the UTF string into a binary UTF-8 encoded string
    let point = nonAsciiChars.charCodeAt(0) | 0;
    if (0xd800 <= point) {
        if (point <= 0xdbff) {
            const nextcode = nonAsciiChars.charCodeAt(1) | 0; // defaults to 0 when NaN, causing null replacement character
            if (0xdc00 <= nextcode && nextcode <= 0xdfff) {
                //point = ((point - 0xD800)<<10) + nextcode - 0xDC00 + 0x10000|0;
                point = ((point << 10) + nextcode - 0x35fdc00) | 0;
                if (point > 0xffff)
                    return fromCharCode((0x1e /*0b11110*/ << 3) | (point >> 18), (0x2 /*0b10*/ << 6) | ((point >> 12) & 0x3f) /*0b00111111*/, (0x2 /*0b10*/ << 6) | ((point >> 6) & 0x3f) /*0b00111111*/, (0x2 /*0b10*/ << 6) | (point & 0x3f) /*0b00111111*/);
            }
            else
                point = 65533 /*0b1111111111111101*/; //return '\xEF\xBF\xBD';//fromCharCode(0xef, 0xbf, 0xbd);
        }
        else if (point <= 0xdfff) {
            point = 65533 /*0b1111111111111101*/; //return '\xEF\xBF\xBD';//fromCharCode(0xef, 0xbf, 0xbd);
        }
    }
    /*if (point <= 0x007f) return nonAsciiChars;
    else */ if (point <= 0x07ff) {
        return fromCharCode((0x6 << 5) | (point >> 6), (0x2 << 6) | (point & 0x3f));
    }
    else
        return fromCharCode((0xe /*0b1110*/ << 4) | (point >> 12), (0x2 /*0b10*/ << 6) | ((point >> 6) & 0x3f) /*0b00111111*/, (0x2 /*0b10*/ << 6) | (point & 0x3f) /*0b00111111*/);
}
class TextEncoder {
    encode(inputString) {
        // 0xc0 => 0b11000000; 0xff => 0b11111111; 0xc0-0xff => 0b11xxxxxx
        // 0x80 => 0b10000000; 0xbf => 0b10111111; 0x80-0xbf => 0b10xxxxxx
        const encodedString = inputString === void 0 ? '' : '' + inputString, len = encodedString.length | 0;
        let result = new Uint8Array(((len << 1) + 8) | 0);
        let tmpResult;
        let i = 0, pos = 0, point = 0, nextcode = 0;
        let upgradededArraySize = !Uint8Array; // normal arrays are auto-expanding
        for (i = 0; i < len; i = (i + 1) | 0, pos = (pos + 1) | 0) {
            point = encodedString.charCodeAt(i) | 0;
            if (point <= 0x007f) {
                result[pos] = point;
            }
            else if (point <= 0x07ff) {
                result[pos] = (0x6 << 5) | (point >> 6);
                result[(pos = (pos + 1) | 0)] = (0x2 << 6) | (point & 0x3f);
            }
            else {
                widenCheck: {
                    if (0xd800 <= point) {
                        if (point <= 0xdbff) {
                            nextcode = encodedString.charCodeAt((i = (i + 1) | 0)) | 0; // defaults to 0 when NaN, causing null replacement character
                            if (0xdc00 <= nextcode && nextcode <= 0xdfff) {
                                //point = ((point - 0xD800)<<10) + nextcode - 0xDC00 + 0x10000|0;
                                point = ((point << 10) + nextcode - 0x35fdc00) | 0;
                                if (point > 0xffff) {
                                    result[pos] = (0x1e /*0b11110*/ << 3) | (point >> 18);
                                    result[(pos = (pos + 1) | 0)] = (0x2 /*0b10*/ << 6) | ((point >> 12) & 0x3f) /*0b00111111*/;
                                    result[(pos = (pos + 1) | 0)] = (0x2 /*0b10*/ << 6) | ((point >> 6) & 0x3f) /*0b00111111*/;
                                    result[(pos = (pos + 1) | 0)] = (0x2 /*0b10*/ << 6) | (point & 0x3f) /*0b00111111*/;
                                    continue;
                                }
                                break widenCheck;
                            }
                            point = 65533 /*0b1111111111111101*/; //return '\xEF\xBF\xBD';//fromCharCode(0xef, 0xbf, 0xbd);
                        }
                        else if (point <= 0xdfff) {
                            point = 65533 /*0b1111111111111101*/; //return '\xEF\xBF\xBD';//fromCharCode(0xef, 0xbf, 0xbd);
                        }
                    }
                    if (!upgradededArraySize && i << 1 < pos && i << 1 < ((pos - 7) | 0)) {
                        upgradededArraySize = true;
                        tmpResult = new Uint8Array(len * 3);
                        tmpResult.set(result);
                        result = tmpResult;
                    }
                }
                result[pos] = (0xe /*0b1110*/ << 4) | (point >> 12);
                result[(pos = (pos + 1) | 0)] = (0x2 /*0b10*/ << 6) | ((point >> 6) & 0x3f) /*0b00111111*/;
                result[(pos = (pos + 1) | 0)] = (0x2 /*0b10*/ << 6) | (point & 0x3f) /*0b00111111*/;
            }
        }
        return Uint8Array ? result.subarray(0, pos) : result.slice(0, pos);
    }
    encodeInto(inputString, u8Arr) {
        const encodedString = inputString === void 0 ? '' : ('' + inputString).replace(encoderRegexp, encoderReplacer);
        let len = encodedString.length | 0, i = 0, char = 0, read = 0;
        const u8ArrLen = u8Arr.length | 0;
        const inputLength = inputString.length | 0;
        if (u8ArrLen < len)
            len = u8ArrLen;
        putChars: {
            for (; i < len; i = (i + 1) | 0) {
                char = encodedString.charCodeAt(i) | 0;
                switch (char >> 4) {
                    case 0:
                    case 1:
                    case 2:
                    case 3:
                    case 4:
                    case 5:
                    case 6:
                    case 7:
                        read = (read + 1) | 0;
                    // extension points:
                    case 8:
                    case 9:
                    case 10:
                    case 11:
                        break;
                    case 12:
                    case 13:
                        if (((i + 1) | 0) < u8ArrLen) {
                            read = (read + 1) | 0;
                            break;
                        }
                    case 14:
                        if (((i + 2) | 0) < u8ArrLen) {
                            //if (!(char === 0xEF && encodedString.substr(i+1|0,2) === "\xBF\xBD"))
                            read = (read + 1) | 0;
                            break;
                        }
                    case 15:
                        if (((i + 3) | 0) < u8ArrLen) {
                            read = (read + 1) | 0;
                            break;
                        }
                    default:
                        break putChars;
                }
                //read = read + ((char >> 6) !== 2) |0;
                u8Arr[i] = char;
            }
        }
        return { written: i, read: inputLength < read ? inputLength : read };
    }
}
exports.TextEncoder = TextEncoder;
/**
 * Encode a UTF-8 string into a Uint8Array
 */
function encode(s) {
    return TextEncoder.prototype.encode(s);
}
/**
 * Decode a Uint8Array into a UTF-8 string
 */
function decode(a) {
    return TextDecoder.prototype.decode(a);
}


/***/ }),

/***/ "../../node_modules/@temporalio/common/lib/errors.js":
/*!***********************************************************!*\
  !*** ../../node_modules/@temporalio/common/lib/errors.js ***!
  \***********************************************************/
/***/ (function(__unused_webpack_module, exports, __webpack_require__) {

"use strict";

var __decorate = (this && this.__decorate) || function (decorators, target, key, desc) {
    var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;
    if (typeof Reflect === "object" && typeof Reflect.decorate === "function") r = Reflect.decorate(decorators, target, key, desc);
    else for (var i = decorators.length - 1; i >= 0; i--) if (d = decorators[i]) r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;
    return c > 3 && r && Object.defineProperty(target, key, r), r;
};
Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.NamespaceNotFoundError = exports.WorkflowNotFoundError = exports.IllegalStateError = exports.PayloadConverterError = exports.ValueError = void 0;
const type_helpers_1 = __webpack_require__(/*! ./type-helpers */ "../../node_modules/@temporalio/common/lib/type-helpers.js");
/**
 * Thrown from code that receives a value that is unexpected or that it's unable to handle.
 */
let ValueError = class ValueError extends Error {
    constructor(message, cause) {
        super(message ?? undefined);
        this.cause = cause;
    }
};
exports.ValueError = ValueError;
exports.ValueError = ValueError = __decorate([
    (0, type_helpers_1.SymbolBasedInstanceOfError)('ValueError')
], ValueError);
/**
 * Thrown when a Payload Converter is misconfigured.
 */
let PayloadConverterError = class PayloadConverterError extends ValueError {
};
exports.PayloadConverterError = PayloadConverterError;
exports.PayloadConverterError = PayloadConverterError = __decorate([
    (0, type_helpers_1.SymbolBasedInstanceOfError)('PayloadConverterError')
], PayloadConverterError);
/**
 * Used in different parts of the SDK to note that something unexpected has happened.
 */
let IllegalStateError = class IllegalStateError extends Error {
};
exports.IllegalStateError = IllegalStateError;
exports.IllegalStateError = IllegalStateError = __decorate([
    (0, type_helpers_1.SymbolBasedInstanceOfError)('IllegalStateError')
], IllegalStateError);
/**
 * Thrown when a Workflow with the given Id is not known to Temporal Server.
 * It could be because:
 * - Id passed is incorrect
 * - Workflow is closed (for some calls, e.g. `terminate`)
 * - Workflow was deleted from the Server after reaching its retention limit
 */
let WorkflowNotFoundError = class WorkflowNotFoundError extends Error {
    constructor(message, workflowId, runId) {
        super(message);
        this.workflowId = workflowId;
        this.runId = runId;
    }
};
exports.WorkflowNotFoundError = WorkflowNotFoundError;
exports.WorkflowNotFoundError = WorkflowNotFoundError = __decorate([
    (0, type_helpers_1.SymbolBasedInstanceOfError)('WorkflowNotFoundError')
], WorkflowNotFoundError);
/**
 * Thrown when the specified namespace is not known to Temporal Server.
 */
let NamespaceNotFoundError = class NamespaceNotFoundError extends Error {
    constructor(namespace) {
        super(`Namespace not found: '${namespace}'`);
        this.namespace = namespace;
    }
};
exports.NamespaceNotFoundError = NamespaceNotFoundError;
exports.NamespaceNotFoundError = NamespaceNotFoundError = __decorate([
    (0, type_helpers_1.SymbolBasedInstanceOfError)('NamespaceNotFoundError')
], NamespaceNotFoundError);


/***/ }),

/***/ "../../node_modules/@temporalio/common/lib/failure.js":
/*!************************************************************!*\
  !*** ../../node_modules/@temporalio/common/lib/failure.js ***!
  \************************************************************/
/***/ (function(__unused_webpack_module, exports, __webpack_require__) {

"use strict";

var __decorate = (this && this.__decorate) || function (decorators, target, key, desc) {
    var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;
    if (typeof Reflect === "object" && typeof Reflect.decorate === "function") r = Reflect.decorate(decorators, target, key, desc);
    else for (var i = decorators.length - 1; i >= 0; i--) if (d = decorators[i]) r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;
    return c > 3 && r && Object.defineProperty(target, key, r), r;
};
var _a, _b;
Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.WorkflowExecutionAlreadyStartedError = exports.ChildWorkflowFailure = exports.ActivityFailure = exports.TimeoutFailure = exports.TerminatedFailure = exports.CancelledFailure = exports.ApplicationFailure = exports.ServerFailure = exports.TemporalFailure = exports.decodeRetryState = exports.encodeRetryState = exports.RetryState = exports.decodeTimeoutType = exports.encodeTimeoutType = exports.TimeoutType = exports.FAILURE_SOURCE = void 0;
exports.ensureApplicationFailure = ensureApplicationFailure;
exports.ensureTemporalFailure = ensureTemporalFailure;
exports.rootCause = rootCause;
const type_helpers_1 = __webpack_require__(/*! ./type-helpers */ "../../node_modules/@temporalio/common/lib/type-helpers.js");
const internal_workflow_1 = __webpack_require__(/*! ./internal-workflow */ "../../node_modules/@temporalio/common/lib/internal-workflow/index.js");
exports.FAILURE_SOURCE = 'TypeScriptSDK';
exports.TimeoutType = {
    START_TO_CLOSE: 'START_TO_CLOSE',
    SCHEDULE_TO_START: 'SCHEDULE_TO_START',
    SCHEDULE_TO_CLOSE: 'SCHEDULE_TO_CLOSE',
    HEARTBEAT: 'HEARTBEAT',
    /** @deprecated Use {@link START_TO_CLOSE} instead. */
    TIMEOUT_TYPE_START_TO_CLOSE: 'START_TO_CLOSE', // eslint-disable-line deprecation/deprecation
    /** @deprecated Use {@link SCHEDULE_TO_START} instead. */
    TIMEOUT_TYPE_SCHEDULE_TO_START: 'SCHEDULE_TO_START', // eslint-disable-line deprecation/deprecation
    /** @deprecated Use {@link SCHEDULE_TO_CLOSE} instead. */
    TIMEOUT_TYPE_SCHEDULE_TO_CLOSE: 'SCHEDULE_TO_CLOSE', // eslint-disable-line deprecation/deprecation
    /** @deprecated Use {@link HEARTBEAT} instead. */
    TIMEOUT_TYPE_HEARTBEAT: 'HEARTBEAT', // eslint-disable-line deprecation/deprecation
    /** @deprecated Use `undefined` instead. */
    TIMEOUT_TYPE_UNSPECIFIED: undefined, // eslint-disable-line deprecation/deprecation
};
_a = (0, internal_workflow_1.makeProtoEnumConverters)({
    [exports.TimeoutType.START_TO_CLOSE]: 1,
    [exports.TimeoutType.SCHEDULE_TO_START]: 2,
    [exports.TimeoutType.SCHEDULE_TO_CLOSE]: 3,
    [exports.TimeoutType.HEARTBEAT]: 4,
    UNSPECIFIED: 0,
}, 'TIMEOUT_TYPE_'), exports.encodeTimeoutType = _a[0], exports.decodeTimeoutType = _a[1];
exports.RetryState = {
    IN_PROGRESS: 'IN_PROGRESS',
    NON_RETRYABLE_FAILURE: 'NON_RETRYABLE_FAILURE',
    TIMEOUT: 'TIMEOUT',
    MAXIMUM_ATTEMPTS_REACHED: 'MAXIMUM_ATTEMPTS_REACHED',
    RETRY_POLICY_NOT_SET: 'RETRY_POLICY_NOT_SET',
    INTERNAL_SERVER_ERROR: 'INTERNAL_SERVER_ERROR',
    CANCEL_REQUESTED: 'CANCEL_REQUESTED',
    /** @deprecated Use {@link IN_PROGRESS} instead. */
    RETRY_STATE_IN_PROGRESS: 'IN_PROGRESS', // eslint-disable-line deprecation/deprecation
    /** @deprecated Use {@link NON_RETRYABLE_FAILURE} instead. */
    RETRY_STATE_NON_RETRYABLE_FAILURE: 'NON_RETRYABLE_FAILURE', // eslint-disable-line deprecation/deprecation
    /** @deprecated Use {@link TIMEOUT} instead. */
    RETRY_STATE_TIMEOUT: 'TIMEOUT', // eslint-disable-line deprecation/deprecation
    /** @deprecated Use {@link MAXIMUM_ATTEMPTS_REACHED} instead. */
    RETRY_STATE_MAXIMUM_ATTEMPTS_REACHED: 'MAXIMUM_ATTEMPTS_REACHED', // eslint-disable-line deprecation/deprecation
    /** @deprecated Use {@link RETRY_POLICY_NOT_SET} instead. */
    RETRY_STATE_RETRY_POLICY_NOT_SET: 'RETRY_POLICY_NOT_SET', // eslint-disable-line deprecation/deprecation
    /** @deprecated Use {@link INTERNAL_SERVER_ERROR} instead. */
    RETRY_STATE_INTERNAL_SERVER_ERROR: 'INTERNAL_SERVER_ERROR', // eslint-disable-line deprecation/deprecation
    /** @deprecated Use {@link CANCEL_REQUESTED} instead. */
    RETRY_STATE_CANCEL_REQUESTED: 'CANCEL_REQUESTED', // eslint-disable-line deprecation/deprecation
    /** @deprecated Use `undefined` instead. */
    RETRY_STATE_UNSPECIFIED: undefined, // eslint-disable-line deprecation/deprecation
};
_b = (0, internal_workflow_1.makeProtoEnumConverters)({
    [exports.RetryState.IN_PROGRESS]: 1,
    [exports.RetryState.NON_RETRYABLE_FAILURE]: 2,
    [exports.RetryState.TIMEOUT]: 3,
    [exports.RetryState.MAXIMUM_ATTEMPTS_REACHED]: 4,
    [exports.RetryState.RETRY_POLICY_NOT_SET]: 5,
    [exports.RetryState.INTERNAL_SERVER_ERROR]: 6,
    [exports.RetryState.CANCEL_REQUESTED]: 7,
    UNSPECIFIED: 0,
}, 'RETRY_STATE_'), exports.encodeRetryState = _b[0], exports.decodeRetryState = _b[1];
/**
 * Represents failures that can cross Workflow and Activity boundaries.
 *
 * **Never extend this class or any of its children.**
 *
 * The only child class you should ever throw from your code is {@link ApplicationFailure}.
 */
let TemporalFailure = class TemporalFailure extends Error {
    constructor(message, cause) {
        super(message ?? undefined);
        this.cause = cause;
    }
};
exports.TemporalFailure = TemporalFailure;
exports.TemporalFailure = TemporalFailure = __decorate([
    (0, type_helpers_1.SymbolBasedInstanceOfError)('TemporalFailure')
], TemporalFailure);
/** Exceptions originated at the Temporal service. */
let ServerFailure = class ServerFailure extends TemporalFailure {
    constructor(message, nonRetryable, cause) {
        super(message, cause);
        this.nonRetryable = nonRetryable;
    }
};
exports.ServerFailure = ServerFailure;
exports.ServerFailure = ServerFailure = __decorate([
    (0, type_helpers_1.SymbolBasedInstanceOfError)('ServerFailure')
], ServerFailure);
/**
 * `ApplicationFailure`s are used to communicate application-specific failures in Workflows and Activities.
 *
 * The {@link type} property is matched against {@link RetryPolicy.nonRetryableErrorTypes} to determine if an instance
 * of this error is retryable. Another way to avoid retrying is by setting the {@link nonRetryable} flag to `true`.
 *
 * In Workflows, if you throw a non-`ApplicationFailure`, the Workflow Task will fail and be retried. If you throw an
 * `ApplicationFailure`, the Workflow Execution will fail.
 *
 * In Activities, you can either throw an `ApplicationFailure` or another `Error` to fail the Activity Task. In the
 * latter case, the `Error` will be converted to an `ApplicationFailure`. The conversion is done as following:
 *
 * - `type` is set to `error.constructor?.name ?? error.name`
 * - `message` is set to `error.message`
 * - `nonRetryable` is set to false
 * - `details` are set to null
 * - stack trace is copied from the original error
 *
 * When an {@link https://docs.temporal.io/concepts/what-is-an-activity-execution | Activity Execution} fails, the
 * `ApplicationFailure` from the last Activity Task will be the `cause` of the {@link ActivityFailure} thrown in the
 * Workflow.
 */
let ApplicationFailure = class ApplicationFailure extends TemporalFailure {
    /**
     * Alternatively, use {@link fromError} or {@link create}.
     */
    constructor(message, type, nonRetryable, details, cause, nextRetryDelay) {
        super(message, cause);
        this.type = type;
        this.nonRetryable = nonRetryable;
        this.details = details;
        this.nextRetryDelay = nextRetryDelay;
    }
    /**
     * Create a new `ApplicationFailure` from an Error object.
     *
     * First calls {@link ensureApplicationFailure | `ensureApplicationFailure(error)`} and then overrides any fields
     * provided in `overrides`.
     */
    static fromError(error, overrides) {
        const failure = ensureApplicationFailure(error);
        Object.assign(failure, overrides);
        return failure;
    }
    /**
     * Create a new `ApplicationFailure`.
     *
     * By default, will be retryable (unless its `type` is included in {@link RetryPolicy.nonRetryableErrorTypes}).
     */
    static create(options) {
        const { message, type, nonRetryable = false, details, nextRetryDelay, cause } = options;
        return new this(message, type, nonRetryable, details, cause, nextRetryDelay);
    }
    /**
     * Get a new `ApplicationFailure` with the {@link nonRetryable} flag set to false. Note that this error will still
     * not be retried if its `type` is included in {@link RetryPolicy.nonRetryableErrorTypes}.
     *
     * @param message Optional error message
     * @param type Optional error type (used by {@link RetryPolicy.nonRetryableErrorTypes})
     * @param details Optional details about the failure. Serialized by the Worker's {@link PayloadConverter}.
     */
    static retryable(message, type, ...details) {
        return new this(message, type ?? 'Error', false, details);
    }
    /**
     * Get a new `ApplicationFailure` with the {@link nonRetryable} flag set to true.
     *
     * When thrown from an Activity or Workflow, the Activity or Workflow will not be retried (even if `type` is not
     * listed in {@link RetryPolicy.nonRetryableErrorTypes}).
     *
     * @param message Optional error message
     * @param type Optional error type
     * @param details Optional details about the failure. Serialized by the Worker's {@link PayloadConverter}.
     */
    static nonRetryable(message, type, ...details) {
        return new this(message, type ?? 'Error', true, details);
    }
};
exports.ApplicationFailure = ApplicationFailure;
exports.ApplicationFailure = ApplicationFailure = __decorate([
    (0, type_helpers_1.SymbolBasedInstanceOfError)('ApplicationFailure')
], ApplicationFailure);
/**
 * This error is thrown when Cancellation has been requested. To allow Cancellation to happen, let it propagate. To
 * ignore Cancellation, catch it and continue executing. Note that Cancellation can only be requested a single time, so
 * your Workflow/Activity Execution will not receive further Cancellation requests.
 *
 * When a Workflow or Activity has been successfully cancelled, a `CancelledFailure` will be the `cause`.
 */
let CancelledFailure = class CancelledFailure extends TemporalFailure {
    constructor(message, details = [], cause) {
        super(message, cause);
        this.details = details;
    }
};
exports.CancelledFailure = CancelledFailure;
exports.CancelledFailure = CancelledFailure = __decorate([
    (0, type_helpers_1.SymbolBasedInstanceOfError)('CancelledFailure')
], CancelledFailure);
/**
 * Used as the `cause` when a Workflow has been terminated
 */
let TerminatedFailure = class TerminatedFailure extends TemporalFailure {
    constructor(message, cause) {
        super(message, cause);
    }
};
exports.TerminatedFailure = TerminatedFailure;
exports.TerminatedFailure = TerminatedFailure = __decorate([
    (0, type_helpers_1.SymbolBasedInstanceOfError)('TerminatedFailure')
], TerminatedFailure);
/**
 * Used to represent timeouts of Activities and Workflows
 */
let TimeoutFailure = class TimeoutFailure extends TemporalFailure {
    constructor(message, lastHeartbeatDetails, timeoutType) {
        super(message);
        this.lastHeartbeatDetails = lastHeartbeatDetails;
        this.timeoutType = timeoutType;
    }
};
exports.TimeoutFailure = TimeoutFailure;
exports.TimeoutFailure = TimeoutFailure = __decorate([
    (0, type_helpers_1.SymbolBasedInstanceOfError)('TimeoutFailure')
], TimeoutFailure);
/**
 * Contains information about an Activity failure. Always contains the original reason for the failure as its `cause`.
 * For example, if an Activity timed out, the cause will be a {@link TimeoutFailure}.
 *
 * This exception is expected to be thrown only by the framework code.
 */
let ActivityFailure = class ActivityFailure extends TemporalFailure {
    constructor(message, activityType, activityId, retryState, identity, cause) {
        super(message, cause);
        this.activityType = activityType;
        this.activityId = activityId;
        this.retryState = retryState;
        this.identity = identity;
    }
};
exports.ActivityFailure = ActivityFailure;
exports.ActivityFailure = ActivityFailure = __decorate([
    (0, type_helpers_1.SymbolBasedInstanceOfError)('ActivityFailure')
], ActivityFailure);
/**
 * Contains information about a Child Workflow failure. Always contains the reason for the failure as its {@link cause}.
 * For example, if the Child was Terminated, the `cause` is a {@link TerminatedFailure}.
 *
 * This exception is expected to be thrown only by the framework code.
 */
let ChildWorkflowFailure = class ChildWorkflowFailure extends TemporalFailure {
    constructor(namespace, execution, workflowType, retryState, cause) {
        super('Child Workflow execution failed', cause);
        this.namespace = namespace;
        this.execution = execution;
        this.workflowType = workflowType;
        this.retryState = retryState;
    }
};
exports.ChildWorkflowFailure = ChildWorkflowFailure;
exports.ChildWorkflowFailure = ChildWorkflowFailure = __decorate([
    (0, type_helpers_1.SymbolBasedInstanceOfError)('ChildWorkflowFailure')
], ChildWorkflowFailure);
/**
 * This exception is thrown in the following cases:
 *  - Workflow with the same Workflow ID is currently running and the {@link WorkflowOptions.workflowIdConflictPolicy} is `WORKFLOW_ID_CONFLICT_POLICY_FAIL`
 *  - There is a closed Workflow with the same Workflow Id and the {@link WorkflowOptions.workflowIdReusePolicy}
 *    is `WORKFLOW_ID_REUSE_POLICY_REJECT_DUPLICATE`
 *  - There is closed Workflow in the `Completed` state with the same Workflow Id and the {@link WorkflowOptions.workflowIdReusePolicy}
 *    is `WORKFLOW_ID_REUSE_POLICY_ALLOW_DUPLICATE_FAILED_ONLY`
 */
let WorkflowExecutionAlreadyStartedError = class WorkflowExecutionAlreadyStartedError extends TemporalFailure {
    constructor(message, workflowId, workflowType) {
        super(message);
        this.workflowId = workflowId;
        this.workflowType = workflowType;
    }
};
exports.WorkflowExecutionAlreadyStartedError = WorkflowExecutionAlreadyStartedError;
exports.WorkflowExecutionAlreadyStartedError = WorkflowExecutionAlreadyStartedError = __decorate([
    (0, type_helpers_1.SymbolBasedInstanceOfError)('WorkflowExecutionAlreadyStartedError')
], WorkflowExecutionAlreadyStartedError);
/**
 * If `error` is already an `ApplicationFailure`, returns `error`.
 *
 * Otherwise, converts `error` into an `ApplicationFailure` with:
 *
 * - `message`: `error.message` or `String(error)`
 * - `type`: `error.constructor.name` or `error.name`
 * - `stack`: `error.stack` or `''`
 */
function ensureApplicationFailure(error) {
    if (error instanceof ApplicationFailure) {
        return error;
    }
    const message = ((0, type_helpers_1.isRecord)(error) && String(error.message)) || String(error);
    const type = ((0, type_helpers_1.isRecord)(error) && (error.constructor?.name ?? error.name)) || undefined;
    const failure = ApplicationFailure.create({ message, type, nonRetryable: false });
    failure.stack = ((0, type_helpers_1.isRecord)(error) && String(error.stack)) || '';
    return failure;
}
/**
 * If `err` is an Error it is turned into an `ApplicationFailure`.
 *
 * If `err` was already a `TemporalFailure`, returns the original error.
 *
 * Otherwise returns an `ApplicationFailure` with `String(err)` as the message.
 */
function ensureTemporalFailure(err) {
    if (err instanceof TemporalFailure) {
        return err;
    }
    return ensureApplicationFailure(err);
}
/**
 * Get the root cause message of given `error`.
 *
 * In case `error` is a {@link TemporalFailure}, recurse the `cause` chain and return the root `cause.message`.
 * Otherwise, return `error.message`.
 */
function rootCause(error) {
    if (error instanceof TemporalFailure) {
        return error.cause ? rootCause(error.cause) : error.message;
    }
    return (0, type_helpers_1.errorMessage)(error);
}


/***/ }),

/***/ "../../node_modules/@temporalio/common/lib/index.js":
/*!**********************************************************!*\
  !*** ../../node_modules/@temporalio/common/lib/index.js ***!
  \**********************************************************/
/***/ (function(__unused_webpack_module, exports, __webpack_require__) {

"use strict";

/**
 * Common library for code that's used across the Client, Worker, and/or Workflow
 *
 * @module
 */
var __createBinding = (this && this.__createBinding) || (Object.create ? (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    var desc = Object.getOwnPropertyDescriptor(m, k);
    if (!desc || ("get" in desc ? !m.__esModule : desc.writable || desc.configurable)) {
      desc = { enumerable: true, get: function() { return m[k]; } };
    }
    Object.defineProperty(o, k2, desc);
}) : (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    o[k2] = m[k];
}));
var __setModuleDefault = (this && this.__setModuleDefault) || (Object.create ? (function(o, v) {
    Object.defineProperty(o, "default", { enumerable: true, value: v });
}) : function(o, v) {
    o["default"] = v;
});
var __importStar = (this && this.__importStar) || function (mod) {
    if (mod && mod.__esModule) return mod;
    var result = {};
    if (mod != null) for (var k in mod) if (k !== "default" && Object.prototype.hasOwnProperty.call(mod, k)) __createBinding(result, mod, k);
    __setModuleDefault(result, mod);
    return result;
};
var __exportStar = (this && this.__exportStar) || function(m, exports) {
    for (var p in m) if (p !== "default" && !Object.prototype.hasOwnProperty.call(exports, p)) __createBinding(exports, m, p);
};
Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.u8 = u8;
exports.str = str;
exports.errorMessage = errorMessage;
exports.errorCode = errorCode;
const encoding = __importStar(__webpack_require__(/*! ./encoding */ "../../node_modules/@temporalio/common/lib/encoding.js"));
const helpers = __importStar(__webpack_require__(/*! ./type-helpers */ "../../node_modules/@temporalio/common/lib/type-helpers.js"));
__exportStar(__webpack_require__(/*! ./activity-options */ "../../node_modules/@temporalio/common/lib/activity-options.js"), exports);
__exportStar(__webpack_require__(/*! ./converter/data-converter */ "../../node_modules/@temporalio/common/lib/converter/data-converter.js"), exports);
__exportStar(__webpack_require__(/*! ./converter/failure-converter */ "../../node_modules/@temporalio/common/lib/converter/failure-converter.js"), exports);
__exportStar(__webpack_require__(/*! ./converter/payload-codec */ "../../node_modules/@temporalio/common/lib/converter/payload-codec.js"), exports);
__exportStar(__webpack_require__(/*! ./converter/payload-converter */ "../../node_modules/@temporalio/common/lib/converter/payload-converter.js"), exports);
__exportStar(__webpack_require__(/*! ./converter/types */ "../../node_modules/@temporalio/common/lib/converter/types.js"), exports);
__exportStar(__webpack_require__(/*! ./deprecated-time */ "../../node_modules/@temporalio/common/lib/deprecated-time.js"), exports);
__exportStar(__webpack_require__(/*! ./errors */ "../../node_modules/@temporalio/common/lib/errors.js"), exports);
__exportStar(__webpack_require__(/*! ./failure */ "../../node_modules/@temporalio/common/lib/failure.js"), exports);
__exportStar(__webpack_require__(/*! ./interfaces */ "../../node_modules/@temporalio/common/lib/interfaces.js"), exports);
__exportStar(__webpack_require__(/*! ./logger */ "../../node_modules/@temporalio/common/lib/logger.js"), exports);
__exportStar(__webpack_require__(/*! ./retry-policy */ "../../node_modules/@temporalio/common/lib/retry-policy.js"), exports);
__exportStar(__webpack_require__(/*! ./workflow-handle */ "../../node_modules/@temporalio/common/lib/workflow-handle.js"), exports);
__exportStar(__webpack_require__(/*! ./workflow-options */ "../../node_modules/@temporalio/common/lib/workflow-options.js"), exports);
__exportStar(__webpack_require__(/*! ./versioning-intent */ "../../node_modules/@temporalio/common/lib/versioning-intent.js"), exports);
/**
 * Encode a UTF-8 string into a Uint8Array
 *
 * @hidden
 * @deprecated - meant for internal use only
 */
function u8(s) {
    return encoding.encode(s);
}
/**
 * Decode a Uint8Array into a UTF-8 string
 *
 * @hidden
 * @deprecated - meant for internal use only
 */
function str(arr) {
    return encoding.decode(arr);
}
/**
 * Get `error.message` (or `undefined` if not present)
 *
 * @hidden
 * @deprecated - meant for internal use only
 */
function errorMessage(error) {
    return helpers.errorMessage(error);
}
/**
 * Get `error.code` (or `undefined` if not present)
 *
 * @hidden
 * @deprecated - meant for internal use only
 */
function errorCode(error) {
    return helpers.errorCode(error);
}


/***/ }),

/***/ "../../node_modules/@temporalio/common/lib/interfaces.js":
/*!***************************************************************!*\
  !*** ../../node_modules/@temporalio/common/lib/interfaces.js ***!
  \***************************************************************/
/***/ ((__unused_webpack_module, exports) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.HandlerUnfinishedPolicy = void 0;
/**
 * Policy defining actions taken when a workflow exits while update or signal handlers are running.
 * The workflow exit may be due to successful return, failure, cancellation, or continue-as-new.
 */
exports.HandlerUnfinishedPolicy = {
    /**
     * Issue a warning in addition to abandoning the handler execution. The warning will not be issued if the workflow fails.
     */
    WARN_AND_ABANDON: 'WARN_AND_ABANDON',
    /**
     * Abandon the handler execution.
     *
     * In the case of an update handler this means that the client will receive an error rather than
     * the update result.
     */
    ABANDON: 'ABANDON',
};


/***/ }),

/***/ "../../node_modules/@temporalio/common/lib/internal-workflow/enums-helpers.js":
/*!************************************************************************************!*\
  !*** ../../node_modules/@temporalio/common/lib/internal-workflow/enums-helpers.js ***!
  \************************************************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.makeProtoEnumConverters = makeProtoEnumConverters;
const errors_1 = __webpack_require__(/*! ../errors */ "../../node_modules/@temporalio/common/lib/errors.js");
/**
 * Create encoding and decoding functions to convert between the numeric `enum` types produced by our
 * Protobuf compiler and "const object of strings" enum values that we expose in our public APIs.
 *
 * ### Usage
 *
 * Newly introduced enums should follow the following pattern:
 *
 * ```ts
 *     type ParentClosePolicy = (typeof ParentClosePolicy)[keyof typeof ParentClosePolicy];
 *     const ParentClosePolicy = {
 *       TERMINATE: 'TERMINATE',
 *       ABANDON: 'ABANDON',
 *       REQUEST_CANCEL: 'REQUEST_CANCEL',
 *     } as const;
 *
 *     const [encodeParentClosePolicy, decodeParentClosePolicy] = //
 *       makeProtoEnumConverters<
 *         coresdk.child_workflow.ParentClosePolicy,
 *         typeof coresdk.child_workflow.ParentClosePolicy,
 *         keyof typeof coresdk.child_workflow.ParentClosePolicy,
 *         typeof ParentClosePolicy,
 *         'PARENT_CLOSE_POLICY_'  // This may be an empty string if the proto enum doesn't add a repeated prefix on values
 *       >(
 *         {
 *           [ParentClosePolicy.TERMINATE]: 1, // These numbers must match the ones in the proto enum
 *           [ParentClosePolicy.ABANDON]: 2,
 *           [ParentClosePolicy.REQUEST_CANCEL]: 3,
 *
 *           UNSPECIFIED: 0,
 *         } as const,
 *         'PARENT_CLOSE_POLICY_'
 *       );
 * ```
 *
 * `makeProtoEnumConverters` supports other usage patterns, but they are only meant for
 * backward compatibility with former enum definitions and should not be used for new enums.
 *
 * ### Context
 *
 * Temporal's Protobuf APIs define several `enum` types; our Protobuf compiler transforms these to
 * traditional (i.e. non-const) [TypeScript numeric `enum`s](https://www.typescriptlang.org/docs/handbook/enums.html#numeric-enums).
 *
 * For various reasons, this is far from ideal:
 *
 *  - Due to the dual nature of non-const TypeScript `enum`s (they are both a type and a value),
 *    it is not possible to refer to an enum value from code without a "real" import of the enum type
 *    (i.e. can't simply do `import type ...`). In Workflow code, such an import would result in
 *    loading our entire Protobuf definitions into the workflow sandbox, adding several megabytes to
 *    the per-workflow memory footprint, which is unacceptable; to avoid that, we need to maintain
 *    a mirror copy of each enum types used by in-workflow APIs, and export these from either
 *    `@temporalio/common` or `@temporalio/workflow`.
 *  - It is not desirable for users to need an explicit dependency on `@temporalio/proto` just to
 *    get access to these enum types; we therefore made it a common practice to reexport these enums
 *    from our public facing packages. However, experience demontrated that these reexports effectively
 *    resulted in poor and inconsistent documentation coverage compared to mirrored enums types.
 *  - Our Protobuf enum types tend to follow a verbose and redundant naming convention, which feels
 *    unatural and excessive according to most TypeScript style guides; e.g. instead of
 *    `workflowIdReusePolicy: WorkflowIdReusePolicy.WORKFLOW_ID_REUSE_POLICY_REJECT_DUPLICATE`,
 *    a TypeScript developer would generally expect to be able to write something similar to
 *    `workflowIdReusePolicy: 'REJECT_DUPLICATE'`.
 *  - Because of the way Protobuf works, many of our enum types contain an `UNSPECIFIED` value, which
 *    is used to explicitly identify a value that is unset. In TypeScript code, the `undefined` value
 *    already serves that purpose, and is definitely more idiomatic to TS developers, whereas these
 *    `UNSPECIFIED` values create noise and confusion in our APIs.
 *  - TypeScript editors generally do a very bad job at providing autocompletion that implies reaching
 *    for values of a TypeScript enum type, forcing developers to explicitly type in at least part
 *    of the name of the enum type before they can get autocompletion for its values. On the other
 *    hand, all TS editors immediately provide autocompletion for string union types.
 *  - The [TypeScript's official documentation](https://www.typescriptlang.org/docs/handbook/enums.html#objects-vs-enums)
 *    itself suggests that, in modern TypeScript, the use of `as const` objects may generally suffice
 *    and may be advantageous over the use of `enum` types.
 *
 * A const object of strings, combined with a union type of possible string values, provides a much
 * more idiomatic syntax and a better DX for TypeScript developers. This however requires a way to
 * convert back and forth between the `enum` values produced by the Protobuf compiler and the
 * equivalent string values.
 *
 * This helper dynamically creates these conversion functions for a given Protobuf enum type,
 * strongly building upon specific conventions that we have adopted in our Protobuf definitions.
 *
 * ### Validations
 *
 * The complex type signature of this helper is there to prevent most potential incoherencies
 * that could result from having to manually synchronize the const object of strings enum and the
 * conversion table with the proto enum, while not requiring a regular import on the Protobuf enum
 * itself (so it can be used safely for enums meant to be used from workflow code).
 *
 * In particular, failing any of the following invariants will result in build time errors:
 *
 * - For every key of the form `PREFIX_KEY: number` in the proto enum, excluding the `UNSPECIFIED` key:
 *   - There MUST be a corresponding `KEY: 'KEY'` entry in the const object of strings enum;
 *   - There MAY be a corresponding `PREFIX_KEY: 'KEY'` in the const object of strings enum
 *     (this is meant to preserve backward compatibility with the former syntax; such aliases should
 *     not be added for new enums and enum entries introduced going forward);
 *   - There MUST be a corresponding `KEY: number` in the mapping table.
 * - If the proto enum contains a `PREFIX_UNSPECIFIED` entry, then:
 *   - There MAY be a corresponding `PREFIX_UNSPECIFIED: undefined` and/or `UNSPECIFIED: undefined`
 *     entries in the const object of strings enum — this is meant to preserve backward compatibility
 *     with the former syntax; this alias should not be added for new enums introduced going forward;
 *   - There MUST be an `UNSPECIFIED: 0` in the mapping table.
 * - The const object of strings enum MUST NOT contain any other keys than the ones mandated or
 *   optionally allowed be the preceeding rules.
 * - The mapping table MUST NOT contain any other keys than the ones mandated above.
 *
 * These rules notably ensure that whenever a new value is added to an existing Proto enum, the code
 * will fail to compile until the corresponding entry is added on the const object of strings enum
 * and the mapping table.
 *
 * @internal
 */
function makeProtoEnumConverters(mapTable, prefix) {
    const reverseTable = Object.fromEntries(Object.entries(mapTable).map(([k, v]) => [v, k]));
    const hasUnspecified = mapTable['UNSPECIFIED'] === 0 || mapTable[`${prefix}UNSPECIFIED`] === 0;
    function isShortStringEnumKeys(x) {
        return typeof x === 'string' && x in mapTable;
    }
    function isNumericEnumValue(x) {
        return typeof x === 'number' && x in reverseTable;
    }
    function encode(input) {
        if (input == null) {
            return undefined;
        }
        else if (typeof input === 'string') {
            let shorten = input;
            if (shorten.startsWith(prefix)) {
                shorten = shorten.slice(prefix.length);
            }
            if (isShortStringEnumKeys(shorten)) {
                return mapTable[shorten];
            }
            throw new errors_1.ValueError(`Invalid enum value: '${input}'`);
        }
        else if (typeof input === 'number') {
            return input;
        }
        else {
            throw new errors_1.ValueError(`Invalid enum value: '${input}' of type ${typeof input}`);
        }
    }
    function decode(input) {
        if (input == null) {
            return undefined;
        }
        else if (typeof input === 'number') {
            if (hasUnspecified && input === 0) {
                return undefined;
            }
            if (isNumericEnumValue(input)) {
                return reverseTable[input];
            }
            // We got a proto enum value that we don't yet know about (i.e. it didn't exist when this code
            // was compiled). This is certainly a possibility, but given how our APIs evolve, this is is
            // unlikely to be a terribly bad thing by itself (we avoid adding new enum values in places
            // that would break backward compatibility with existing deployed code). Therefore, throwing
            // on "unexpected" values is likely to end up causing more problems than it might avoid,
            // especially given that the decoded value may actually never get read anwyay.
            //
            // Therefore, we instead cheat on type constraints and return a string of the form "unknown_23".
            // That somewhat mirrors the behavior we'd get with the pure numerical approach.
            return `unknown_${input}`;
        }
        throw new errors_1.ValueError(`Invalid proto enum value: '${input}' of type ${typeof input}`);
    }
    return [encode, decode];
}


/***/ }),

/***/ "../../node_modules/@temporalio/common/lib/internal-workflow/index.js":
/*!****************************************************************************!*\
  !*** ../../node_modules/@temporalio/common/lib/internal-workflow/index.js ***!
  \****************************************************************************/
/***/ (function(__unused_webpack_module, exports, __webpack_require__) {

"use strict";

var __createBinding = (this && this.__createBinding) || (Object.create ? (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    var desc = Object.getOwnPropertyDescriptor(m, k);
    if (!desc || ("get" in desc ? !m.__esModule : desc.writable || desc.configurable)) {
      desc = { enumerable: true, get: function() { return m[k]; } };
    }
    Object.defineProperty(o, k2, desc);
}) : (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    o[k2] = m[k];
}));
var __exportStar = (this && this.__exportStar) || function(m, exports) {
    for (var p in m) if (p !== "default" && !Object.prototype.hasOwnProperty.call(exports, p)) __createBinding(exports, m, p);
};
Object.defineProperty(exports, "__esModule", ({ value: true }));
__exportStar(__webpack_require__(/*! ./enums-helpers */ "../../node_modules/@temporalio/common/lib/internal-workflow/enums-helpers.js"), exports);


/***/ }),

/***/ "../../node_modules/@temporalio/common/lib/logger.js":
/*!***********************************************************!*\
  !*** ../../node_modules/@temporalio/common/lib/logger.js ***!
  \***********************************************************/
/***/ ((__unused_webpack_module, exports) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.SdkComponent = void 0;
/**
 * Possible values of the `sdkComponent` meta attributes on log messages. This
 * attribute indicates which subsystem emitted the log message; this may for
 * example be used to implement fine-grained filtering of log messages.
 *
 * Note that there is no guarantee that this list will remain stable in the
 * future; values may be added or removed, and messages that are currently
 * emitted with some `sdkComponent` value may use a different value in the future.
 */
var SdkComponent;
(function (SdkComponent) {
    /**
     * Component name for messages emited from Workflow code, using the {@link Workflow context logger|workflow.log}.
     * The SDK itself never publishes messages with this component name.
     */
    SdkComponent["workflow"] = "workflow";
    /**
     * Component name for messages emited from an activity, using the {@link activity context logger|Context.log}.
     * The SDK itself never publishes messages with this component name.
     */
    SdkComponent["activity"] = "activity";
    /**
     * Component name for messages emited from a Temporal Worker instance.
     *
     * This notably includes:
     * - Issues with Worker or runtime configuration, or the JS execution environment;
     * - Worker's, Activity's, and Workflow's lifecycle events;
     * - Workflow Activation and Activity Task processing events;
     * - Workflow bundling messages;
     * - Sink processing issues.
     */
    SdkComponent["worker"] = "worker";
    /**
     * Component name for all messages emitted by the Rust Core SDK library.
     */
    SdkComponent["core"] = "core";
})(SdkComponent || (exports.SdkComponent = SdkComponent = {}));


/***/ }),

/***/ "../../node_modules/@temporalio/common/lib/retry-policy.js":
/*!*****************************************************************!*\
  !*** ../../node_modules/@temporalio/common/lib/retry-policy.js ***!
  \*****************************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.compileRetryPolicy = compileRetryPolicy;
exports.decompileRetryPolicy = decompileRetryPolicy;
const errors_1 = __webpack_require__(/*! ./errors */ "../../node_modules/@temporalio/common/lib/errors.js");
const time_1 = __webpack_require__(/*! ./time */ "../../node_modules/@temporalio/common/lib/time.js");
/**
 * Turn a TS RetryPolicy into a proto compatible RetryPolicy
 */
function compileRetryPolicy(retryPolicy) {
    if (retryPolicy.backoffCoefficient != null && retryPolicy.backoffCoefficient <= 0) {
        throw new errors_1.ValueError('RetryPolicy.backoffCoefficient must be greater than 0');
    }
    if (retryPolicy.maximumAttempts != null) {
        if (retryPolicy.maximumAttempts === Number.POSITIVE_INFINITY) {
            // drop field (Infinity is the default)
            const { maximumAttempts: _, ...without } = retryPolicy;
            retryPolicy = without;
        }
        else if (retryPolicy.maximumAttempts <= 0) {
            throw new errors_1.ValueError('RetryPolicy.maximumAttempts must be a positive integer');
        }
        else if (!Number.isInteger(retryPolicy.maximumAttempts)) {
            throw new errors_1.ValueError('RetryPolicy.maximumAttempts must be an integer');
        }
    }
    const maximumInterval = (0, time_1.msOptionalToNumber)(retryPolicy.maximumInterval);
    const initialInterval = (0, time_1.msToNumber)(retryPolicy.initialInterval ?? 1000);
    if (maximumInterval === 0) {
        throw new errors_1.ValueError('RetryPolicy.maximumInterval cannot be 0');
    }
    if (initialInterval === 0) {
        throw new errors_1.ValueError('RetryPolicy.initialInterval cannot be 0');
    }
    if (maximumInterval != null && maximumInterval < initialInterval) {
        throw new errors_1.ValueError('RetryPolicy.maximumInterval cannot be less than its initialInterval');
    }
    return {
        maximumAttempts: retryPolicy.maximumAttempts,
        initialInterval: (0, time_1.msToTs)(initialInterval),
        maximumInterval: (0, time_1.msOptionalToTs)(maximumInterval),
        backoffCoefficient: retryPolicy.backoffCoefficient,
        nonRetryableErrorTypes: retryPolicy.nonRetryableErrorTypes,
    };
}
/**
 * Turn a proto compatible RetryPolicy into a TS RetryPolicy
 */
function decompileRetryPolicy(retryPolicy) {
    if (!retryPolicy) {
        return undefined;
    }
    return {
        backoffCoefficient: retryPolicy.backoffCoefficient ?? undefined,
        maximumAttempts: retryPolicy.maximumAttempts ?? undefined,
        maximumInterval: (0, time_1.optionalTsToMs)(retryPolicy.maximumInterval),
        initialInterval: (0, time_1.optionalTsToMs)(retryPolicy.initialInterval),
        nonRetryableErrorTypes: retryPolicy.nonRetryableErrorTypes ?? undefined,
    };
}


/***/ }),

/***/ "../../node_modules/@temporalio/common/lib/time.js":
/*!*********************************************************!*\
  !*** ../../node_modules/@temporalio/common/lib/time.js ***!
  \*********************************************************/
/***/ (function(__unused_webpack_module, exports, __webpack_require__) {

"use strict";

var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.optionalTsToMs = optionalTsToMs;
exports.requiredTsToMs = requiredTsToMs;
exports.tsToMs = tsToMs;
exports.msNumberToTs = msNumberToTs;
exports.msToTs = msToTs;
exports.msOptionalToTs = msOptionalToTs;
exports.msOptionalToNumber = msOptionalToNumber;
exports.msToNumber = msToNumber;
exports.tsToDate = tsToDate;
exports.requiredTsToDate = requiredTsToDate;
exports.optionalTsToDate = optionalTsToDate;
exports.optionalDateToTs = optionalDateToTs;
const long_1 = __importDefault(__webpack_require__(/*! long */ "../../node_modules/long/umd/index.js")); // eslint-disable-line import/no-named-as-default
const ms_1 = __importDefault(__webpack_require__(/*! ms */ "../../node_modules/@temporalio/common/node_modules/ms/dist/index.cjs"));
const errors_1 = __webpack_require__(/*! ./errors */ "../../node_modules/@temporalio/common/lib/errors.js");
/**
 * Lossy conversion function from Timestamp to number due to possible overflow.
 * If ts is null or undefined returns undefined.
 */
function optionalTsToMs(ts) {
    if (ts === undefined || ts === null) {
        return undefined;
    }
    return tsToMs(ts);
}
/**
 * Lossy conversion function from Timestamp to number due to possible overflow.
 * If ts is null or undefined, throws a TypeError, with error message including the name of the field.
 */
function requiredTsToMs(ts, fieldName) {
    if (ts === undefined || ts === null) {
        throw new TypeError(`Expected ${fieldName} to be a timestamp, got ${ts}`);
    }
    return tsToMs(ts);
}
/**
 * Lossy conversion function from Timestamp to number due to possible overflow
 */
function tsToMs(ts) {
    if (ts === undefined || ts === null) {
        throw new Error(`Expected timestamp, got ${ts}`);
    }
    const { seconds, nanos } = ts;
    return (seconds || long_1.default.UZERO)
        .mul(1000)
        .add(Math.floor((nanos || 0) / 1000000))
        .toNumber();
}
function msNumberToTs(millis) {
    const seconds = Math.floor(millis / 1000);
    const nanos = (millis % 1000) * 1000000;
    if (Number.isNaN(seconds) || Number.isNaN(nanos)) {
        throw new errors_1.ValueError(`Invalid millis ${millis}`);
    }
    return { seconds: long_1.default.fromNumber(seconds), nanos };
}
function msToTs(str) {
    return msNumberToTs(msToNumber(str));
}
function msOptionalToTs(str) {
    return str ? msToTs(str) : undefined;
}
function msOptionalToNumber(val) {
    if (val === undefined)
        return undefined;
    return msToNumber(val);
}
function msToNumber(val) {
    if (typeof val === 'number') {
        return val;
    }
    return msWithValidation(val);
}
function msWithValidation(str) {
    const millis = (0, ms_1.default)(str);
    if (millis == null || isNaN(millis)) {
        throw new TypeError(`Invalid duration string: '${str}'`);
    }
    return millis;
}
function tsToDate(ts) {
    return new Date(tsToMs(ts));
}
// ts-prune-ignore-next
function requiredTsToDate(ts, fieldName) {
    return new Date(requiredTsToMs(ts, fieldName));
}
function optionalTsToDate(ts) {
    if (ts === undefined || ts === null) {
        return undefined;
    }
    return new Date(tsToMs(ts));
}
// ts-prune-ignore-next (imported via schedule-helpers.ts)
function optionalDateToTs(date) {
    if (date === undefined || date === null) {
        return undefined;
    }
    return msToTs(date.getTime());
}


/***/ }),

/***/ "../../node_modules/@temporalio/common/lib/type-helpers.js":
/*!*****************************************************************!*\
  !*** ../../node_modules/@temporalio/common/lib/type-helpers.js ***!
  \*****************************************************************/
/***/ ((__unused_webpack_module, exports) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.checkExtends = checkExtends;
exports.isRecord = isRecord;
exports.hasOwnProperty = hasOwnProperty;
exports.hasOwnProperties = hasOwnProperties;
exports.isError = isError;
exports.isAbortError = isAbortError;
exports.errorMessage = errorMessage;
exports.errorCode = errorCode;
exports.assertNever = assertNever;
exports.SymbolBasedInstanceOfError = SymbolBasedInstanceOfError;
exports.deepFreeze = deepFreeze;
/** Verify that an type _Copy extends _Orig */
function checkExtends() {
    // noop, just type check
}
function isRecord(value) {
    return typeof value === 'object' && value !== null;
}
function hasOwnProperty(record, prop) {
    return prop in record;
}
function hasOwnProperties(record, props) {
    return props.every((prop) => prop in record);
}
function isError(error) {
    return (isRecord(error) &&
        typeof error.name === 'string' &&
        typeof error.message === 'string' &&
        (error.stack == null || typeof error.stack === 'string'));
}
function isAbortError(error) {
    return isError(error) && error.name === 'AbortError';
}
/**
 * Get `error.message` (or `undefined` if not present)
 */
function errorMessage(error) {
    if (isError(error)) {
        return error.message;
    }
    else if (typeof error === 'string') {
        return error;
    }
    return undefined;
}
function isErrorWithCode(error) {
    return isRecord(error) && typeof error.code === 'string';
}
/**
 * Get `error.code` (or `undefined` if not present)
 */
function errorCode(error) {
    if (isErrorWithCode(error)) {
        return error.code;
    }
    return undefined;
}
/**
 * Asserts that some type is the never type
 */
function assertNever(msg, x) {
    throw new TypeError(msg + ': ' + x);
}
/**
 * A decorator to be used on error classes. It adds the 'name' property AND provides a custom
 * 'instanceof' handler that works correctly across execution contexts.
 *
 * ### Details ###
 *
 * According to the EcmaScript's spec, the default behavior of JavaScript's `x instanceof Y` operator is to walk up the
 * prototype chain of object 'x', checking if any constructor in that hierarchy is _exactly the same object_ as the
 * constructor function 'Y'.
 *
 * Unfortunately, it happens in various situations that different constructor function objects get created for what
 * appears to be the very same class. This leads to surprising behavior where `instanceof` returns false though it is
 * known that the object is indeed an instance of that class. One particular case where this happens is when constructor
 * 'Y' belongs to a different realm than the constuctor with which 'x' was instantiated. Another case is when two copies
 * of the same library gets loaded in the same realm.
 *
 * In practice, this tends to cause issues when crossing the workflow-sandboxing boundary (since Node's vm module
 * really creates new execution realms), as well as when running tests using Jest (see https://github.com/jestjs/jest/issues/2549
 * for some details on that one).
 *
 * This function injects a custom 'instanceof' handler into the prototype of 'clazz', which is both cross-realm safe and
 * cross-copies-of-the-same-lib safe. It works by adding a special symbol property to the prototype of 'clazz', and then
 * checking for the presence of that symbol.
 */
function SymbolBasedInstanceOfError(markerName) {
    return (clazz) => {
        const marker = Symbol.for(`__temporal_is${markerName}`);
        Object.defineProperty(clazz.prototype, 'name', { value: markerName, enumerable: true });
        Object.defineProperty(clazz.prototype, marker, { value: true, enumerable: false });
        Object.defineProperty(clazz, Symbol.hasInstance, {
            // eslint-disable-next-line object-shorthand
            value: function (error) {
                if (this === clazz) {
                    return isRecord(error) && error[marker] === true;
                }
                else {
                    // 'this' must be a _subclass_ of clazz that doesn't redefined [Symbol.hasInstance], so that it inherited
                    // from clazz's [Symbol.hasInstance]. If we don't handle this particular situation, then
                    // `x instanceof SubclassOfParent` would return true for any instance of 'Parent', which is clearly wrong.
                    //
                    // Ideally, it'd be preferable to avoid this case entirely, by making sure that all subclasses of 'clazz'
                    // redefine [Symbol.hasInstance], but we can't enforce that. We therefore fallback to the default instanceof
                    // behavior (which is NOT cross-realm safe).
                    return this.prototype.isPrototypeOf(error); // eslint-disable-line no-prototype-builtins
                }
            },
        });
    };
}
// Thanks MDN: https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Object/freeze
function deepFreeze(object) {
    // Retrieve the property names defined on object
    const propNames = Object.getOwnPropertyNames(object);
    // Freeze properties before freezing self
    for (const name of propNames) {
        const value = object[name];
        if (value && typeof value === 'object') {
            try {
                deepFreeze(value);
            }
            catch (_err) {
                // This is okay, there are some typed arrays that cannot be frozen (encodingKeys)
            }
        }
        else if (typeof value === 'function') {
            Object.freeze(value);
        }
    }
    return Object.freeze(object);
}


/***/ }),

/***/ "../../node_modules/@temporalio/common/lib/versioning-intent.js":
/*!**********************************************************************!*\
  !*** ../../node_modules/@temporalio/common/lib/versioning-intent.js ***!
  \**********************************************************************/
/***/ ((__unused_webpack_module, exports) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({ value: true }));


/***/ }),

/***/ "../../node_modules/@temporalio/common/lib/workflow-handle.js":
/*!********************************************************************!*\
  !*** ../../node_modules/@temporalio/common/lib/workflow-handle.js ***!
  \********************************************************************/
/***/ ((__unused_webpack_module, exports) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({ value: true }));


/***/ }),

/***/ "../../node_modules/@temporalio/common/lib/workflow-options.js":
/*!*********************************************************************!*\
  !*** ../../node_modules/@temporalio/common/lib/workflow-options.js ***!
  \*********************************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";

var _a, _b;
Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.decodeWorkflowIdConflictPolicy = exports.encodeWorkflowIdConflictPolicy = exports.WorkflowIdConflictPolicy = exports.decodeWorkflowIdReusePolicy = exports.encodeWorkflowIdReusePolicy = exports.WorkflowIdReusePolicy = void 0;
exports.extractWorkflowType = extractWorkflowType;
const internal_workflow_1 = __webpack_require__(/*! ./internal-workflow */ "../../node_modules/@temporalio/common/lib/internal-workflow/index.js");
/**
 * Defines what happens when trying to start a Workflow with the same ID as a *Closed* Workflow.
 *
 * See {@link WorkflowOptions.workflowIdConflictPolicy} for what happens when trying to start a
 * Workflow with the same ID as a *Running* Workflow.
 *
 * Concept: {@link https://docs.temporal.io/concepts/what-is-a-workflow-id-reuse-policy/ | Workflow Id Reuse Policy}
 *
 * *Note: It is not possible to have two actively running Workflows with the same ID.*
 *
 */
exports.WorkflowIdReusePolicy = {
    /**
     * The Workflow can be started if the previous Workflow is in a Closed state.
     * @default
     */
    ALLOW_DUPLICATE: 'ALLOW_DUPLICATE',
    /**
     * The Workflow can be started if the previous Workflow is in a Closed state that is not Completed.
     */
    ALLOW_DUPLICATE_FAILED_ONLY: 'ALLOW_DUPLICATE_FAILED_ONLY',
    /**
     * The Workflow cannot be started.
     */
    REJECT_DUPLICATE: 'REJECT_DUPLICATE',
    /**
     * Terminate the current Workflow if one is already running; otherwise allow reusing the Workflow ID.
     *
     * @deprecated Use {@link WORKFLOW_ID_REUSE_POLICY_ALLOW_DUPLICATE} instead, and
     *             set `WorkflowOptions.workflowIdConflictPolicy` to
     *             {@link WorkflowIdConflictPolicy.WORKFLOW_ID_CONFLICT_POLICY_TERMINATE_EXISTING}.
     *             When using this option, `WorkflowOptions.workflowIdConflictPolicy` must be left unspecified.
     */
    TERMINATE_IF_RUNNING: 'TERMINATE_IF_RUNNING', // eslint-disable-line deprecation/deprecation
    /// Anything below this line has been deprecated
    /**
     * No need to use this. If a `WorkflowIdReusePolicy` is set to this, or is not set at all, the default value will be used.
     *
     * @deprecated Either leave property `undefined`, or use {@link ALLOW_DUPLICATE} instead.
     */
    WORKFLOW_ID_REUSE_POLICY_UNSPECIFIED: undefined, // eslint-disable-line deprecation/deprecation
    /** @deprecated Use {@link ALLOW_DUPLICATE} instead. */
    WORKFLOW_ID_REUSE_POLICY_ALLOW_DUPLICATE: 'ALLOW_DUPLICATE', // eslint-disable-line deprecation/deprecation
    /** @deprecated Use {@link ALLOW_DUPLICATE_FAILED_ONLY} instead. */
    WORKFLOW_ID_REUSE_POLICY_ALLOW_DUPLICATE_FAILED_ONLY: 'ALLOW_DUPLICATE_FAILED_ONLY', // eslint-disable-line deprecation/deprecation
    /** @deprecated Use {@link REJECT_DUPLICATE} instead. */
    WORKFLOW_ID_REUSE_POLICY_REJECT_DUPLICATE: 'REJECT_DUPLICATE', // eslint-disable-line deprecation/deprecation
    /** @deprecated Use {@link TERMINATE_IF_RUNNING} instead. */
    WORKFLOW_ID_REUSE_POLICY_TERMINATE_IF_RUNNING: 'TERMINATE_IF_RUNNING', // eslint-disable-line deprecation/deprecation
};
_a = (0, internal_workflow_1.makeProtoEnumConverters)({
    [exports.WorkflowIdReusePolicy.ALLOW_DUPLICATE]: 1,
    [exports.WorkflowIdReusePolicy.ALLOW_DUPLICATE_FAILED_ONLY]: 2,
    [exports.WorkflowIdReusePolicy.REJECT_DUPLICATE]: 3,
    [exports.WorkflowIdReusePolicy.TERMINATE_IF_RUNNING]: 4, // eslint-disable-line deprecation/deprecation
    UNSPECIFIED: 0,
}, 'WORKFLOW_ID_REUSE_POLICY_'), exports.encodeWorkflowIdReusePolicy = _a[0], exports.decodeWorkflowIdReusePolicy = _a[1];
exports.WorkflowIdConflictPolicy = {
    /**
     * Do not start a new Workflow. Instead raise a `WorkflowExecutionAlreadyStartedError`.
     */
    FAIL: 'FAIL',
    /**
     * Do not start a new Workflow. Instead return a Workflow Handle for the already Running Workflow.
     */
    USE_EXISTING: 'USE_EXISTING',
    /**
     * Start a new Workflow, terminating the current workflow if one is already running.
     */
    TERMINATE_EXISTING: 'TERMINATE_EXISTING',
};
_b = (0, internal_workflow_1.makeProtoEnumConverters)({
    [exports.WorkflowIdConflictPolicy.FAIL]: 1,
    [exports.WorkflowIdConflictPolicy.USE_EXISTING]: 2,
    [exports.WorkflowIdConflictPolicy.TERMINATE_EXISTING]: 3,
    UNSPECIFIED: 0,
}, 'WORKFLOW_ID_CONFLICT_POLICY_'), exports.encodeWorkflowIdConflictPolicy = _b[0], exports.decodeWorkflowIdConflictPolicy = _b[1];
function extractWorkflowType(workflowTypeOrFunc) {
    if (typeof workflowTypeOrFunc === 'string')
        return workflowTypeOrFunc;
    if (typeof workflowTypeOrFunc === 'function') {
        if (workflowTypeOrFunc?.name)
            return workflowTypeOrFunc.name;
        throw new TypeError('Invalid workflow type: the workflow function is anonymous');
    }
    throw new TypeError(`Invalid workflow type: expected either a string or a function, got '${typeof workflowTypeOrFunc}'`);
}


/***/ }),

/***/ "../../node_modules/@temporalio/workflow/lib/alea.js":
/*!***********************************************************!*\
  !*** ../../node_modules/@temporalio/workflow/lib/alea.js ***!
  \***********************************************************/
/***/ ((__unused_webpack_module, exports) => {

"use strict";

// A port of an algorithm by Johannes Baagøe <baagoe@baagoe.com>, 2010
// http://baagoe.com/en/RandomMusings/javascript/
// https://github.com/nquinlan/better-random-numbers-for-javascript-mirror
// Original work is under MIT license -
Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.Mash = exports.alea = void 0;
// Copyright (C) 2010 by Johannes Baagøe <baagoe@baagoe.org>
//
// Permission is hereby granted, free of charge, to any person obtaining a copy
// of this software and associated documentation files (the "Software"), to deal
// in the Software without restriction, including without limitation the rights
// to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
// copies of the Software, and to permit persons to whom the Software is
// furnished to do so, subject to the following conditions:
//
// The above copyright notice and this permission notice shall be included in
// all copies or substantial portions of the Software.
//
// THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
// IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
// FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
// AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
// LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
// OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN
// THE SOFTWARE.
// Taken and modified from https://github.com/davidbau/seedrandom/blob/released/lib/alea.js
class Alea {
    constructor(seed) {
        const mash = new Mash();
        // Apply the seeding algorithm from Baagoe.
        this.c = 1;
        this.s0 = mash.mash([32]);
        this.s1 = mash.mash([32]);
        this.s2 = mash.mash([32]);
        this.s0 -= mash.mash(seed);
        if (this.s0 < 0) {
            this.s0 += 1;
        }
        this.s1 -= mash.mash(seed);
        if (this.s1 < 0) {
            this.s1 += 1;
        }
        this.s2 -= mash.mash(seed);
        if (this.s2 < 0) {
            this.s2 += 1;
        }
    }
    next() {
        const t = 2091639 * this.s0 + this.c * 2.3283064365386963e-10; // 2^-32
        this.s0 = this.s1;
        this.s1 = this.s2;
        return (this.s2 = t - (this.c = t | 0));
    }
}
function alea(seed) {
    const xg = new Alea(seed);
    return xg.next.bind(xg);
}
exports.alea = alea;
class Mash {
    constructor() {
        this.n = 0xefc8249d;
    }
    mash(data) {
        let { n } = this;
        for (let i = 0; i < data.length; i++) {
            n += data[i];
            let h = 0.02519603282416938 * n;
            n = h >>> 0;
            h -= n;
            h *= n;
            n = h >>> 0;
            h -= n;
            n += h * 0x100000000; // 2^32
        }
        this.n = n;
        return (n >>> 0) * 2.3283064365386963e-10; // 2^-32
    }
}
exports.Mash = Mash;


/***/ }),

/***/ "../../node_modules/@temporalio/workflow/lib/cancellation-scope.js":
/*!*************************************************************************!*\
  !*** ../../node_modules/@temporalio/workflow/lib/cancellation-scope.js ***!
  \*************************************************************************/
/***/ (function(__unused_webpack_module, exports, __webpack_require__) {

"use strict";

var __classPrivateFieldSet = (this && this.__classPrivateFieldSet) || function (receiver, state, value, kind, f) {
    if (kind === "m") throw new TypeError("Private method is not writable");
    if (kind === "a" && !f) throw new TypeError("Private accessor was defined without a setter");
    if (typeof state === "function" ? receiver !== state || !f : !state.has(receiver)) throw new TypeError("Cannot write private member to an object whose class did not declare it");
    return (kind === "a" ? f.call(receiver, value) : f ? f.value = value : state.set(receiver, value)), value;
};
var __classPrivateFieldGet = (this && this.__classPrivateFieldGet) || function (receiver, state, kind, f) {
    if (kind === "a" && !f) throw new TypeError("Private accessor was defined without a getter");
    if (typeof state === "function" ? receiver !== state || !f : !state.has(receiver)) throw new TypeError("Cannot read private member from an object whose class did not declare it");
    return kind === "m" ? f : kind === "a" ? f.call(receiver) : f ? f.value : state.get(receiver);
};
var _CancellationScope_cancelRequested;
Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.registerSleepImplementation = exports.RootCancellationScope = exports.disableStorage = exports.CancellationScope = exports.AsyncLocalStorage = void 0;
const common_1 = __webpack_require__(/*! @temporalio/common */ "../../node_modules/@temporalio/workflow/node_modules/@temporalio/common/lib/index.js");
const stack_helpers_1 = __webpack_require__(/*! ./stack-helpers */ "../../node_modules/@temporalio/workflow/lib/stack-helpers.js");
// AsyncLocalStorage is injected via vm module into global scope.
// In case Workflow code is imported in Node.js context, replace with an empty class.
exports.AsyncLocalStorage = globalThis.AsyncLocalStorage ?? class {
};
/** Magic symbol used to create the root scope - intentionally not exported */
const NO_PARENT = Symbol('NO_PARENT');
/**
 * In the SDK, Workflows are represented internally by a tree of scopes where the `execute` function runs in the root scope.
 * Cancellation propagates from outer scopes to inner ones and is handled by catching {@link CancelledFailure}s
 * thrown by cancellable operations (see below).
 *
 * Scopes are created using the `CancellationScope` constructor or the static helper methods
 * {@link cancellable}, {@link nonCancellable} and {@link withTimeout}.
 *
 * When a `CancellationScope` is cancelled, it will propagate cancellation any child scopes and any cancellable
 * operations created within it, such as:
 *
 * - Activities
 * - Child Workflows
 * - Timers (created with the {@link sleep} function)
 * - {@link Trigger}s
 *
 * @example
 *
 * ```ts
 * await CancellationScope.cancellable(async () => {
 *   const promise = someActivity();
 *   CancellationScope.current().cancel(); // Cancels the activity
 *   await promise; // Throws `ActivityFailure` with `cause` set to `CancelledFailure`
 * });
 * ```
 *
 * @example
 *
 * ```ts
 * const scope = new CancellationScope();
 * const promise = scope.run(someActivity);
 * scope.cancel(); // Cancels the activity
 * await promise; // Throws `ActivityFailure` with `cause` set to `CancelledFailure`
 * ```
 */
class CancellationScope {
    constructor(options) {
        _CancellationScope_cancelRequested.set(this, false);
        this.timeout = options?.timeout;
        this.cancellable = options?.cancellable ?? true;
        this.cancelRequested = new Promise((_, reject) => {
            // Typescript does not understand that the Promise executor runs synchronously
            // eslint-disable-next-line @typescript-eslint/ban-ts-comment
            // @ts-ignore
            this.reject = (err) => {
                __classPrivateFieldSet(this, _CancellationScope_cancelRequested, true, "f");
                reject(err);
            };
        });
        (0, stack_helpers_1.untrackPromise)(this.cancelRequested);
        // Avoid unhandled rejections
        (0, stack_helpers_1.untrackPromise)(this.cancelRequested.catch(() => undefined));
        if (options?.parent !== NO_PARENT) {
            this.parent = options?.parent || CancellationScope.current();
            __classPrivateFieldSet(this, _CancellationScope_cancelRequested, __classPrivateFieldGet(this.parent, _CancellationScope_cancelRequested, "f"), "f");
            this.parent.cancelRequested.catch((err) => {
                this.reject(err);
            });
        }
    }
    get consideredCancelled() {
        return __classPrivateFieldGet(this, _CancellationScope_cancelRequested, "f") && this.cancellable;
    }
    /**
     * Activate the scope as current and run  `fn`
     *
     * Any timers, Activities, Triggers and CancellationScopes created in the body of `fn`
     * automatically link their cancellation to this scope.
     *
     * @return the result of `fn`
     */
    run(fn) {
        return storage.run(this, this.runInContext.bind(this, fn));
    }
    /**
     * Method that runs a function in AsyncLocalStorage context.
     *
     * Could have been written as anonymous function, made into a method for improved stack traces.
     */
    async runInContext(fn) {
        if (this.timeout) {
            (0, stack_helpers_1.untrackPromise)(sleep(this.timeout).then(() => this.cancel(), () => {
                // scope was already cancelled, ignore
            }));
        }
        return await fn();
    }
    /**
     * Request to cancel the scope and linked children
     */
    cancel() {
        this.reject(new common_1.CancelledFailure('Cancellation scope cancelled'));
    }
    /**
     * Get the current "active" scope
     */
    static current() {
        // Using globals directly instead of a helper function to avoid circular import
        return storage.getStore() ?? globalThis.__TEMPORAL_ACTIVATOR__.rootScope;
    }
    /** Alias to `new CancellationScope({ cancellable: true }).run(fn)` */
    static cancellable(fn) {
        return new this({ cancellable: true }).run(fn);
    }
    /** Alias to `new CancellationScope({ cancellable: false }).run(fn)` */
    static nonCancellable(fn) {
        return new this({ cancellable: false }).run(fn);
    }
    /** Alias to `new CancellationScope({ cancellable: true, timeout }).run(fn)` */
    static withTimeout(timeout, fn) {
        return new this({ cancellable: true, timeout }).run(fn);
    }
}
exports.CancellationScope = CancellationScope;
_CancellationScope_cancelRequested = new WeakMap();
const storage = new exports.AsyncLocalStorage();
/**
 * Avoid exposing the storage directly so it doesn't get frozen
 */
function disableStorage() {
    storage.disable();
}
exports.disableStorage = disableStorage;
class RootCancellationScope extends CancellationScope {
    constructor() {
        super({ cancellable: true, parent: NO_PARENT });
    }
    cancel() {
        this.reject(new common_1.CancelledFailure('Workflow cancelled'));
    }
}
exports.RootCancellationScope = RootCancellationScope;
/** This function is here to avoid a circular dependency between this module and workflow.ts */
let sleep = (_) => {
    throw new common_1.IllegalStateError('Workflow has not been properly initialized');
};
function registerSleepImplementation(fn) {
    sleep = fn;
}
exports.registerSleepImplementation = registerSleepImplementation;


/***/ }),

/***/ "../../node_modules/@temporalio/workflow/lib/errors.js":
/*!*************************************************************!*\
  !*** ../../node_modules/@temporalio/workflow/lib/errors.js ***!
  \*************************************************************/
/***/ (function(__unused_webpack_module, exports, __webpack_require__) {

"use strict";

var __decorate = (this && this.__decorate) || function (decorators, target, key, desc) {
    var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;
    if (typeof Reflect === "object" && typeof Reflect.decorate === "function") r = Reflect.decorate(decorators, target, key, desc);
    else for (var i = decorators.length - 1; i >= 0; i--) if (d = decorators[i]) r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;
    return c > 3 && r && Object.defineProperty(target, key, r), r;
};
Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.isCancellation = exports.LocalActivityDoBackoff = exports.DeterminismViolationError = exports.WorkflowError = void 0;
const common_1 = __webpack_require__(/*! @temporalio/common */ "../../node_modules/@temporalio/workflow/node_modules/@temporalio/common/lib/index.js");
const type_helpers_1 = __webpack_require__(/*! @temporalio/common/lib/type-helpers */ "../../node_modules/@temporalio/workflow/node_modules/@temporalio/common/lib/type-helpers.js");
/**
 * Base class for all workflow errors
 */
let WorkflowError = class WorkflowError extends Error {
};
exports.WorkflowError = WorkflowError;
exports.WorkflowError = WorkflowError = __decorate([
    (0, type_helpers_1.SymbolBasedInstanceOfError)('WorkflowError')
], WorkflowError);
/**
 * Thrown in workflow when it tries to do something that non-deterministic such as construct a WeakRef()
 */
let DeterminismViolationError = class DeterminismViolationError extends WorkflowError {
};
exports.DeterminismViolationError = DeterminismViolationError;
exports.DeterminismViolationError = DeterminismViolationError = __decorate([
    (0, type_helpers_1.SymbolBasedInstanceOfError)('DeterminismViolationError')
], DeterminismViolationError);
/**
 * A class that acts as a marker for this special result type
 */
let LocalActivityDoBackoff = class LocalActivityDoBackoff extends Error {
    constructor(backoff) {
        super();
        this.backoff = backoff;
    }
};
exports.LocalActivityDoBackoff = LocalActivityDoBackoff;
exports.LocalActivityDoBackoff = LocalActivityDoBackoff = __decorate([
    (0, type_helpers_1.SymbolBasedInstanceOfError)('LocalActivityDoBackoff')
], LocalActivityDoBackoff);
/**
 * Returns whether provided `err` is caused by cancellation
 */
function isCancellation(err) {
    return (err instanceof common_1.CancelledFailure ||
        ((err instanceof common_1.ActivityFailure || err instanceof common_1.ChildWorkflowFailure) && err.cause instanceof common_1.CancelledFailure));
}
exports.isCancellation = isCancellation;


/***/ }),

/***/ "../../node_modules/@temporalio/workflow/lib/global-attributes.js":
/*!************************************************************************!*\
  !*** ../../node_modules/@temporalio/workflow/lib/global-attributes.js ***!
  \************************************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.getActivator = exports.assertInWorkflowContext = exports.maybeGetActivator = exports.setActivatorUntyped = exports.maybeGetActivatorUntyped = void 0;
const common_1 = __webpack_require__(/*! @temporalio/common */ "../../node_modules/@temporalio/workflow/node_modules/@temporalio/common/lib/index.js");
function maybeGetActivatorUntyped() {
    return globalThis.__TEMPORAL_ACTIVATOR__;
}
exports.maybeGetActivatorUntyped = maybeGetActivatorUntyped;
function setActivatorUntyped(activator) {
    globalThis.__TEMPORAL_ACTIVATOR__ = activator;
}
exports.setActivatorUntyped = setActivatorUntyped;
function maybeGetActivator() {
    return maybeGetActivatorUntyped();
}
exports.maybeGetActivator = maybeGetActivator;
function assertInWorkflowContext(message) {
    const activator = maybeGetActivator();
    if (activator == null)
        throw new common_1.IllegalStateError(message);
    return activator;
}
exports.assertInWorkflowContext = assertInWorkflowContext;
function getActivator() {
    const activator = maybeGetActivator();
    if (activator === undefined) {
        throw new common_1.IllegalStateError('Workflow uninitialized');
    }
    return activator;
}
exports.getActivator = getActivator;


/***/ }),

/***/ "../../node_modules/@temporalio/workflow/lib/index.js":
/*!************************************************************!*\
  !*** ../../node_modules/@temporalio/workflow/lib/index.js ***!
  \************************************************************/
/***/ (function(__unused_webpack_module, exports, __webpack_require__) {

"use strict";

/**
 * This library provides tools required for authoring workflows.
 *
 * ## Usage
 * See the {@link https://docs.temporal.io/typescript/hello-world#workflows | tutorial} for writing your first workflow.
 *
 * ### Timers
 *
 * The recommended way of scheduling timers is by using the {@link sleep} function. We've replaced `setTimeout` and
 * `clearTimeout` with deterministic versions so these are also usable but have a limitation that they don't play well
 * with {@link https://docs.temporal.io/typescript/cancellation-scopes | cancellation scopes}.
 *
 * <!--SNIPSTART typescript-sleep-workflow-->
 * <!--SNIPEND-->
 *
 * ### Activities
 *
 * To schedule Activities, use {@link proxyActivities} to obtain an Activity function and call.
 *
 * <!--SNIPSTART typescript-schedule-activity-workflow-->
 * <!--SNIPEND-->
 *
 * ### Updates, Signals and Queries
 *
 * Use {@link setHandler} to set handlers for Updates, Signals, and Queries.
 *
 * Update and Signal handlers can be either async or non-async functions. Update handlers may return a value, but signal
 * handlers may not (return `void` or `Promise<void>`). You may use Activities, Timers, child Workflows, etc in Update
 * and Signal handlers, but this should be done cautiously: for example, note that if you await async operations such as
 * these in an Update or Signal handler, then you are responsible for ensuring that the workflow does not complete first.
 *
 * Query handlers may **not** be async functions, and may **not** mutate any variables or use Activities, Timers,
 * child Workflows, etc.
 *
 * #### Implementation
 *
 * <!--SNIPSTART typescript-workflow-update-signal-query-example-->
 * <!--SNIPEND-->
 *
 * ### More
 *
 * - [Deterministic built-ins](https://docs.temporal.io/typescript/determinism#sources-of-non-determinism)
 * - [Cancellation and scopes](https://docs.temporal.io/typescript/cancellation-scopes)
 *   - {@link CancellationScope}
 *   - {@link Trigger}
 * - [Sinks](https://docs.temporal.io/application-development/observability/?lang=ts#logging)
 *   - {@link Sinks}
 *
 * @module
 */
var __createBinding = (this && this.__createBinding) || (Object.create ? (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    var desc = Object.getOwnPropertyDescriptor(m, k);
    if (!desc || ("get" in desc ? !m.__esModule : desc.writable || desc.configurable)) {
      desc = { enumerable: true, get: function() { return m[k]; } };
    }
    Object.defineProperty(o, k2, desc);
}) : (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    o[k2] = m[k];
}));
var __exportStar = (this && this.__exportStar) || function(m, exports) {
    for (var p in m) if (p !== "default" && !Object.prototype.hasOwnProperty.call(exports, p)) __createBinding(exports, m, p);
};
Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.Trigger = exports.log = exports.proxySinks = exports.ParentClosePolicy = exports.ContinueAsNew = exports.ChildWorkflowCancellationType = exports.CancellationScope = exports.AsyncLocalStorage = exports.TimeoutFailure = exports.TerminatedFailure = exports.TemporalFailure = exports.ServerFailure = exports.rootCause = exports.defaultPayloadConverter = exports.ChildWorkflowFailure = exports.CancelledFailure = exports.ApplicationFailure = exports.ActivityFailure = exports.ActivityCancellationType = void 0;
var common_1 = __webpack_require__(/*! @temporalio/common */ "../../node_modules/@temporalio/workflow/node_modules/@temporalio/common/lib/index.js");
Object.defineProperty(exports, "ActivityCancellationType", ({ enumerable: true, get: function () { return common_1.ActivityCancellationType; } }));
Object.defineProperty(exports, "ActivityFailure", ({ enumerable: true, get: function () { return common_1.ActivityFailure; } }));
Object.defineProperty(exports, "ApplicationFailure", ({ enumerable: true, get: function () { return common_1.ApplicationFailure; } }));
Object.defineProperty(exports, "CancelledFailure", ({ enumerable: true, get: function () { return common_1.CancelledFailure; } }));
Object.defineProperty(exports, "ChildWorkflowFailure", ({ enumerable: true, get: function () { return common_1.ChildWorkflowFailure; } }));
Object.defineProperty(exports, "defaultPayloadConverter", ({ enumerable: true, get: function () { return common_1.defaultPayloadConverter; } }));
Object.defineProperty(exports, "rootCause", ({ enumerable: true, get: function () { return common_1.rootCause; } }));
Object.defineProperty(exports, "ServerFailure", ({ enumerable: true, get: function () { return common_1.ServerFailure; } }));
Object.defineProperty(exports, "TemporalFailure", ({ enumerable: true, get: function () { return common_1.TemporalFailure; } }));
Object.defineProperty(exports, "TerminatedFailure", ({ enumerable: true, get: function () { return common_1.TerminatedFailure; } }));
Object.defineProperty(exports, "TimeoutFailure", ({ enumerable: true, get: function () { return common_1.TimeoutFailure; } }));
__exportStar(__webpack_require__(/*! @temporalio/common/lib/errors */ "../../node_modules/@temporalio/workflow/node_modules/@temporalio/common/lib/errors.js"), exports);
__exportStar(__webpack_require__(/*! @temporalio/common/lib/workflow-handle */ "../../node_modules/@temporalio/workflow/node_modules/@temporalio/common/lib/workflow-handle.js"), exports);
__exportStar(__webpack_require__(/*! @temporalio/common/lib/workflow-options */ "../../node_modules/@temporalio/workflow/node_modules/@temporalio/common/lib/workflow-options.js"), exports);
var cancellation_scope_1 = __webpack_require__(/*! ./cancellation-scope */ "../../node_modules/@temporalio/workflow/lib/cancellation-scope.js");
Object.defineProperty(exports, "AsyncLocalStorage", ({ enumerable: true, get: function () { return cancellation_scope_1.AsyncLocalStorage; } }));
Object.defineProperty(exports, "CancellationScope", ({ enumerable: true, get: function () { return cancellation_scope_1.CancellationScope; } }));
__exportStar(__webpack_require__(/*! ./errors */ "../../node_modules/@temporalio/workflow/lib/errors.js"), exports);
__exportStar(__webpack_require__(/*! ./interceptors */ "../../node_modules/@temporalio/workflow/lib/interceptors.js"), exports);
var interfaces_1 = __webpack_require__(/*! ./interfaces */ "../../node_modules/@temporalio/workflow/lib/interfaces.js");
Object.defineProperty(exports, "ChildWorkflowCancellationType", ({ enumerable: true, get: function () { return interfaces_1.ChildWorkflowCancellationType; } }));
Object.defineProperty(exports, "ContinueAsNew", ({ enumerable: true, get: function () { return interfaces_1.ContinueAsNew; } }));
Object.defineProperty(exports, "ParentClosePolicy", ({ enumerable: true, get: function () { return interfaces_1.ParentClosePolicy; } }));
var sinks_1 = __webpack_require__(/*! ./sinks */ "../../node_modules/@temporalio/workflow/lib/sinks.js");
Object.defineProperty(exports, "proxySinks", ({ enumerable: true, get: function () { return sinks_1.proxySinks; } }));
var logs_1 = __webpack_require__(/*! ./logs */ "../../node_modules/@temporalio/workflow/lib/logs.js");
Object.defineProperty(exports, "log", ({ enumerable: true, get: function () { return logs_1.log; } }));
var trigger_1 = __webpack_require__(/*! ./trigger */ "../../node_modules/@temporalio/workflow/lib/trigger.js");
Object.defineProperty(exports, "Trigger", ({ enumerable: true, get: function () { return trigger_1.Trigger; } }));
__exportStar(__webpack_require__(/*! ./workflow */ "../../node_modules/@temporalio/workflow/lib/workflow.js"), exports);


/***/ }),

/***/ "../../node_modules/@temporalio/workflow/lib/interceptors.js":
/*!*******************************************************************!*\
  !*** ../../node_modules/@temporalio/workflow/lib/interceptors.js ***!
  \*******************************************************************/
/***/ ((__unused_webpack_module, exports) => {

"use strict";

/**
 * Type definitions and generic helpers for interceptors.
 *
 * The Workflow specific interceptors are defined here.
 *
 * @module
 */
Object.defineProperty(exports, "__esModule", ({ value: true }));


/***/ }),

/***/ "../../node_modules/@temporalio/workflow/lib/interfaces.js":
/*!*****************************************************************!*\
  !*** ../../node_modules/@temporalio/workflow/lib/interfaces.js ***!
  \*****************************************************************/
/***/ (function(__unused_webpack_module, exports, __webpack_require__) {

"use strict";

var __decorate = (this && this.__decorate) || function (decorators, target, key, desc) {
    var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;
    if (typeof Reflect === "object" && typeof Reflect.decorate === "function") r = Reflect.decorate(decorators, target, key, desc);
    else for (var i = decorators.length - 1; i >= 0; i--) if (d = decorators[i]) r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;
    return c > 3 && r && Object.defineProperty(target, key, r), r;
};
Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.ParentClosePolicy = exports.ChildWorkflowCancellationType = exports.ContinueAsNew = void 0;
const type_helpers_1 = __webpack_require__(/*! @temporalio/common/lib/type-helpers */ "../../node_modules/@temporalio/workflow/node_modules/@temporalio/common/lib/type-helpers.js");
/**
 * Not an actual error, used by the Workflow runtime to abort execution when {@link continueAsNew} is called
 */
let ContinueAsNew = class ContinueAsNew extends Error {
    constructor(command) {
        super('Workflow continued as new');
        this.command = command;
    }
};
exports.ContinueAsNew = ContinueAsNew;
exports.ContinueAsNew = ContinueAsNew = __decorate([
    (0, type_helpers_1.SymbolBasedInstanceOfError)('ContinueAsNew')
], ContinueAsNew);
/**
 * Specifies:
 * - whether cancellation requests are sent to the Child
 * - whether and when a {@link CanceledFailure} is thrown from {@link executeChild} or
 *   {@link ChildWorkflowHandle.result}
 *
 * @default {@link ChildWorkflowCancellationType.WAIT_CANCELLATION_COMPLETED}
 */
var ChildWorkflowCancellationType;
(function (ChildWorkflowCancellationType) {
    /**
     * Don't send a cancellation request to the Child.
     */
    ChildWorkflowCancellationType[ChildWorkflowCancellationType["ABANDON"] = 0] = "ABANDON";
    /**
     * Send a cancellation request to the Child. Immediately throw the error.
     */
    ChildWorkflowCancellationType[ChildWorkflowCancellationType["TRY_CANCEL"] = 1] = "TRY_CANCEL";
    /**
     * Send a cancellation request to the Child. The Child may respect cancellation, in which case an error will be thrown
     * when cancellation has completed, and {@link isCancellation}(error) will be true. On the other hand, the Child may
     * ignore the cancellation request, in which case an error might be thrown with a different cause, or the Child may
     * complete successfully.
     *
     * @default
     */
    ChildWorkflowCancellationType[ChildWorkflowCancellationType["WAIT_CANCELLATION_COMPLETED"] = 2] = "WAIT_CANCELLATION_COMPLETED";
    /**
     * Send a cancellation request to the Child. Throw the error once the Server receives the Child cancellation request.
     */
    ChildWorkflowCancellationType[ChildWorkflowCancellationType["WAIT_CANCELLATION_REQUESTED"] = 3] = "WAIT_CANCELLATION_REQUESTED";
})(ChildWorkflowCancellationType || (exports.ChildWorkflowCancellationType = ChildWorkflowCancellationType = {}));
(0, type_helpers_1.checkExtends)();
(0, type_helpers_1.checkExtends)();
/**
 * How a Child Workflow reacts to the Parent Workflow reaching a Closed state.
 *
 * @see {@link https://docs.temporal.io/concepts/what-is-a-parent-close-policy/ | Parent Close Policy}
 */
var ParentClosePolicy;
(function (ParentClosePolicy) {
    /**
     * If a `ParentClosePolicy` is set to this, or is not set at all, the server default value will be used.
     */
    ParentClosePolicy[ParentClosePolicy["PARENT_CLOSE_POLICY_UNSPECIFIED"] = 0] = "PARENT_CLOSE_POLICY_UNSPECIFIED";
    /**
     * When the Parent is Closed, the Child is Terminated.
     *
     * @default
     */
    ParentClosePolicy[ParentClosePolicy["PARENT_CLOSE_POLICY_TERMINATE"] = 1] = "PARENT_CLOSE_POLICY_TERMINATE";
    /**
     * When the Parent is Closed, nothing is done to the Child.
     */
    ParentClosePolicy[ParentClosePolicy["PARENT_CLOSE_POLICY_ABANDON"] = 2] = "PARENT_CLOSE_POLICY_ABANDON";
    /**
     * When the Parent is Closed, the Child is Cancelled.
     */
    ParentClosePolicy[ParentClosePolicy["PARENT_CLOSE_POLICY_REQUEST_CANCEL"] = 3] = "PARENT_CLOSE_POLICY_REQUEST_CANCEL";
})(ParentClosePolicy || (exports.ParentClosePolicy = ParentClosePolicy = {}));
(0, type_helpers_1.checkExtends)();
(0, type_helpers_1.checkExtends)();


/***/ }),

/***/ "../../node_modules/@temporalio/workflow/lib/internals.js":
/*!****************************************************************!*\
  !*** ../../node_modules/@temporalio/workflow/lib/internals.js ***!
  \****************************************************************/
/***/ (function(__unused_webpack_module, exports, __webpack_require__) {

"use strict";

var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.Activator = void 0;
const common_1 = __webpack_require__(/*! @temporalio/common */ "../../node_modules/@temporalio/workflow/node_modules/@temporalio/common/lib/index.js");
const interceptors_1 = __webpack_require__(/*! @temporalio/common/lib/interceptors */ "../../node_modules/@temporalio/workflow/node_modules/@temporalio/common/lib/interceptors.js");
const type_helpers_1 = __webpack_require__(/*! @temporalio/common/lib/type-helpers */ "../../node_modules/@temporalio/workflow/node_modules/@temporalio/common/lib/type-helpers.js");
const alea_1 = __webpack_require__(/*! ./alea */ "../../node_modules/@temporalio/workflow/lib/alea.js");
const cancellation_scope_1 = __webpack_require__(/*! ./cancellation-scope */ "../../node_modules/@temporalio/workflow/lib/cancellation-scope.js");
const errors_1 = __webpack_require__(/*! ./errors */ "../../node_modules/@temporalio/workflow/lib/errors.js");
const interfaces_1 = __webpack_require__(/*! ./interfaces */ "../../node_modules/@temporalio/workflow/lib/interfaces.js");
const stack_helpers_1 = __webpack_require__(/*! ./stack-helpers */ "../../node_modules/@temporalio/workflow/lib/stack-helpers.js");
const pkg_1 = __importDefault(__webpack_require__(/*! ./pkg */ "../../node_modules/@temporalio/workflow/lib/pkg.js"));
const logs_1 = __webpack_require__(/*! ./logs */ "../../node_modules/@temporalio/workflow/lib/logs.js");
var StartChildWorkflowExecutionFailedCause;
(function (StartChildWorkflowExecutionFailedCause) {
    StartChildWorkflowExecutionFailedCause[StartChildWorkflowExecutionFailedCause["START_CHILD_WORKFLOW_EXECUTION_FAILED_CAUSE_UNSPECIFIED"] = 0] = "START_CHILD_WORKFLOW_EXECUTION_FAILED_CAUSE_UNSPECIFIED";
    StartChildWorkflowExecutionFailedCause[StartChildWorkflowExecutionFailedCause["START_CHILD_WORKFLOW_EXECUTION_FAILED_CAUSE_WORKFLOW_ALREADY_EXISTS"] = 1] = "START_CHILD_WORKFLOW_EXECUTION_FAILED_CAUSE_WORKFLOW_ALREADY_EXISTS";
})(StartChildWorkflowExecutionFailedCause || (StartChildWorkflowExecutionFailedCause = {}));
(0, type_helpers_1.checkExtends)();
(0, type_helpers_1.checkExtends)();
/**
 * Keeps all of the Workflow runtime state like pending completions for activities and timers.
 *
 * Implements handlers for all workflow activation jobs.
 */
class Activator {
    constructor({ info, now, showStackTraceSources, sourceMap, getTimeOfDay, randomnessSeed, patches, registeredActivityNames, }) {
        /**
         * Cache for modules - referenced in reusable-vm.ts
         */
        this.moduleCache = new Map();
        /**
         * Map of task sequence to a Completion
         */
        this.completions = {
            timer: new Map(),
            activity: new Map(),
            childWorkflowStart: new Map(),
            childWorkflowComplete: new Map(),
            signalWorkflow: new Map(),
            cancelWorkflow: new Map(),
        };
        /**
         * Holds buffered Update calls until a handler is registered
         */
        this.bufferedUpdates = Array();
        /**
         * Holds buffered signal calls until a handler is registered
         */
        this.bufferedSignals = Array();
        /**
         * Holds buffered query calls until a handler is registered.
         *
         * **IMPORTANT** queries are only buffered until workflow is started.
         * This is required because async interceptors might block workflow function invocation
         * which delays query handler registration.
         */
        this.bufferedQueries = Array();
        /**
         * Mapping of update name to handler and validator
         */
        this.updateHandlers = new Map();
        /**
         * Mapping of signal name to handler
         */
        this.signalHandlers = new Map();
        this.promiseStackStore = {
            promiseToStack: new Map(),
            childToParent: new Map(),
        };
        this.rootScope = new cancellation_scope_1.RootCancellationScope();
        /**
         * Mapping of query name to handler
         */
        this.queryHandlers = new Map([
            [
                '__stack_trace',
                {
                    handler: () => {
                        return this.getStackTraces()
                            .map((s) => s.formatted)
                            .join('\n\n');
                    },
                    description: 'Returns a sensible stack trace.',
                },
            ],
            [
                '__enhanced_stack_trace',
                {
                    handler: () => {
                        const { sourceMap } = this;
                        const sdk = { name: 'typescript', version: pkg_1.default.version };
                        const stacks = this.getStackTraces().map(({ structured: locations }) => ({ locations }));
                        const sources = {};
                        if (this.showStackTraceSources) {
                            for (const { locations } of stacks) {
                                for (const { filePath } of locations) {
                                    if (!filePath)
                                        continue;
                                    const content = sourceMap?.sourcesContent?.[sourceMap?.sources.indexOf(filePath)];
                                    if (!content)
                                        continue;
                                    sources[filePath] = [
                                        {
                                            content,
                                            lineOffset: 0,
                                        },
                                    ];
                                }
                            }
                        }
                        return { sdk, stacks, sources };
                    },
                    description: 'Returns a stack trace annotated with source information.',
                },
            ],
            [
                '__temporal_workflow_metadata',
                {
                    handler: () => {
                        const workflowType = this.info.workflowType;
                        const queryDefinitions = Array.from(this.queryHandlers.entries()).map(([name, value]) => ({
                            name,
                            description: value.description,
                        }));
                        const signalDefinitions = Array.from(this.signalHandlers.entries()).map(([name, value]) => ({
                            name,
                            description: value.description,
                        }));
                        const updateDefinitions = Array.from(this.updateHandlers.entries()).map(([name, value]) => ({
                            name,
                            description: value.description,
                        }));
                        return {
                            definition: {
                                type: workflowType,
                                description: null, // For now, do not set the workflow description in the TS SDK.
                                queryDefinitions,
                                signalDefinitions,
                                updateDefinitions,
                            },
                        };
                    },
                    description: 'Returns metadata associated with this workflow.',
                },
            ],
        ]);
        /**
         * Loaded in {@link initRuntime}
         */
        this.interceptors = { inbound: [], outbound: [], internals: [] };
        /**
         * Buffer that stores all generated commands, reset after each activation
         */
        this.commands = [];
        /**
         * Stores all {@link condition}s that haven't been unblocked yet
         */
        this.blockedConditions = new Map();
        /**
         * Is this Workflow completed?
         *
         * A Workflow will be considered completed if it generates a command that the
         * system considers as a final Workflow command (e.g.
         * completeWorkflowExecution or failWorkflowExecution).
         */
        this.completed = false;
        /**
         * Was this Workflow cancelled?
         */
        this.cancelled = false;
        /**
         * This is tracked to allow buffering queries until a workflow function is called.
         * TODO(bergundy): I don't think this makes sense since queries run last in an activation and must be responded to in
         * the same activation.
         */
        this.workflowFunctionWasCalled = false;
        /**
         * The next (incremental) sequence to assign when generating completable commands
         */
        this.nextSeqs = {
            timer: 1,
            activity: 1,
            childWorkflow: 1,
            signalWorkflow: 1,
            cancelWorkflow: 1,
            condition: 1,
            // Used internally to keep track of active stack traces
            stack: 1,
        };
        this.payloadConverter = common_1.defaultPayloadConverter;
        this.failureConverter = common_1.defaultFailureConverter;
        /**
         * Patches we know the status of for this workflow, as in {@link patched}
         */
        this.knownPresentPatches = new Set();
        /**
         * Patches we sent to core {@link patched}
         */
        this.sentPatches = new Set();
        /**
         * Buffered sink calls per activation
         */
        this.sinkCalls = Array();
        this.getTimeOfDay = getTimeOfDay;
        this.info = info;
        this.now = now;
        this.showStackTraceSources = showStackTraceSources;
        this.sourceMap = sourceMap;
        this.random = (0, alea_1.alea)(randomnessSeed);
        this.registeredActivityNames = registeredActivityNames;
        if (info.unsafe.isReplaying) {
            for (const patchId of patches) {
                this.notifyHasPatch({ patchId });
            }
        }
    }
    mutateWorkflowInfo(fn) {
        this.info = fn(this.info);
    }
    getStackTraces() {
        const { childToParent, promiseToStack } = this.promiseStackStore;
        const internalNodes = [...childToParent.values()].reduce((acc, curr) => {
            for (const p of curr) {
                acc.add(p);
            }
            return acc;
        }, new Set());
        const stacks = new Map();
        for (const child of childToParent.keys()) {
            if (!internalNodes.has(child)) {
                const stack = promiseToStack.get(child);
                if (!stack || !stack.formatted)
                    continue;
                stacks.set(stack.formatted, stack);
            }
        }
        // Not 100% sure where this comes from, just filter it out
        stacks.delete('    at Promise.then (<anonymous>)');
        stacks.delete('    at Promise.then (<anonymous>)\n');
        return [...stacks].map(([_, stack]) => stack);
    }
    getAndResetSinkCalls() {
        const { sinkCalls } = this;
        this.sinkCalls = [];
        return sinkCalls;
    }
    /**
     * Buffer a Workflow command to be collected at the end of the current activation.
     *
     * Prevents commands from being added after Workflow completion.
     */
    pushCommand(cmd, complete = false) {
        // Only query responses may be sent after completion
        if (this.completed && !cmd.respondToQuery)
            return;
        this.commands.push(cmd);
        if (complete) {
            this.completed = true;
        }
    }
    getAndResetCommands() {
        const commands = this.commands;
        this.commands = [];
        return commands;
    }
    async startWorkflowNextHandler({ args }) {
        const { workflow } = this;
        if (workflow === undefined) {
            throw new common_1.IllegalStateError('Workflow uninitialized');
        }
        let promise;
        try {
            promise = workflow(...args);
        }
        finally {
            // Queries must be handled even if there was an exception when invoking the Workflow function.
            this.workflowFunctionWasCalled = true;
            // Empty the buffer
            const buffer = this.bufferedQueries.splice(0);
            for (const activation of buffer) {
                this.queryWorkflow(activation);
            }
        }
        return await promise;
    }
    startWorkflow(activation) {
        const execute = (0, interceptors_1.composeInterceptors)(this.interceptors.inbound, 'execute', this.startWorkflowNextHandler.bind(this));
        (0, stack_helpers_1.untrackPromise)((0, logs_1.executeWithLifecycleLogging)(() => execute({
            headers: activation.headers ?? {},
            args: (0, common_1.arrayFromPayloads)(this.payloadConverter, activation.arguments),
        })).then(this.completeWorkflow.bind(this), this.handleWorkflowFailure.bind(this)));
    }
    cancelWorkflow(_activation) {
        this.cancelled = true;
        this.rootScope.cancel();
    }
    fireTimer(activation) {
        // Timers are a special case where their completion might not be in Workflow state,
        // this is due to immediate timer cancellation that doesn't go wait for Core.
        const completion = this.maybeConsumeCompletion('timer', getSeq(activation));
        completion?.resolve(undefined);
    }
    resolveActivity(activation) {
        if (!activation.result) {
            throw new TypeError('Got ResolveActivity activation with no result');
        }
        const { resolve, reject } = this.consumeCompletion('activity', getSeq(activation));
        if (activation.result.completed) {
            const completed = activation.result.completed;
            const result = completed.result ? this.payloadConverter.fromPayload(completed.result) : undefined;
            resolve(result);
        }
        else if (activation.result.failed) {
            const { failure } = activation.result.failed;
            const err = failure ? this.failureToError(failure) : undefined;
            reject(err);
        }
        else if (activation.result.cancelled) {
            const { failure } = activation.result.cancelled;
            const err = failure ? this.failureToError(failure) : undefined;
            reject(err);
        }
        else if (activation.result.backoff) {
            reject(new errors_1.LocalActivityDoBackoff(activation.result.backoff));
        }
    }
    resolveChildWorkflowExecutionStart(activation) {
        const { resolve, reject } = this.consumeCompletion('childWorkflowStart', getSeq(activation));
        if (activation.succeeded) {
            resolve(activation.succeeded.runId);
        }
        else if (activation.failed) {
            if (activation.failed.cause !==
                StartChildWorkflowExecutionFailedCause.START_CHILD_WORKFLOW_EXECUTION_FAILED_CAUSE_WORKFLOW_ALREADY_EXISTS) {
                throw new common_1.IllegalStateError('Got unknown StartChildWorkflowExecutionFailedCause');
            }
            if (!(activation.seq && activation.failed.workflowId && activation.failed.workflowType)) {
                throw new TypeError('Missing attributes in activation job');
            }
            reject(new common_1.WorkflowExecutionAlreadyStartedError('Workflow execution already started', activation.failed.workflowId, activation.failed.workflowType));
        }
        else if (activation.cancelled) {
            if (!activation.cancelled.failure) {
                throw new TypeError('Got no failure in cancelled variant');
            }
            reject(this.failureToError(activation.cancelled.failure));
        }
        else {
            throw new TypeError('Got ResolveChildWorkflowExecutionStart with no status');
        }
    }
    resolveChildWorkflowExecution(activation) {
        if (!activation.result) {
            throw new TypeError('Got ResolveChildWorkflowExecution activation with no result');
        }
        const { resolve, reject } = this.consumeCompletion('childWorkflowComplete', getSeq(activation));
        if (activation.result.completed) {
            const completed = activation.result.completed;
            const result = completed.result ? this.payloadConverter.fromPayload(completed.result) : undefined;
            resolve(result);
        }
        else if (activation.result.failed) {
            const { failure } = activation.result.failed;
            if (failure === undefined || failure === null) {
                throw new TypeError('Got failed result with no failure attribute');
            }
            reject(this.failureToError(failure));
        }
        else if (activation.result.cancelled) {
            const { failure } = activation.result.cancelled;
            if (failure === undefined || failure === null) {
                throw new TypeError('Got cancelled result with no failure attribute');
            }
            reject(this.failureToError(failure));
        }
    }
    // Intentionally non-async function so this handler doesn't show up in the stack trace
    queryWorkflowNextHandler({ queryName, args }) {
        const fn = this.queryHandlers.get(queryName)?.handler;
        if (fn === undefined) {
            const knownQueryTypes = [...this.queryHandlers.keys()].join(' ');
            // Fail the query
            return Promise.reject(new ReferenceError(`Workflow did not register a handler for ${queryName}. Registered queries: [${knownQueryTypes}]`));
        }
        try {
            const ret = fn(...args);
            if (ret instanceof Promise) {
                return Promise.reject(new errors_1.DeterminismViolationError('Query handlers should not return a Promise'));
            }
            return Promise.resolve(ret);
        }
        catch (err) {
            return Promise.reject(err);
        }
    }
    queryWorkflow(activation) {
        if (!this.workflowFunctionWasCalled) {
            this.bufferedQueries.push(activation);
            return;
        }
        const { queryType, queryId, headers } = activation;
        if (!(queryType && queryId)) {
            throw new TypeError('Missing query activation attributes');
        }
        const execute = (0, interceptors_1.composeInterceptors)(this.interceptors.inbound, 'handleQuery', this.queryWorkflowNextHandler.bind(this));
        execute({
            queryName: queryType,
            args: (0, common_1.arrayFromPayloads)(this.payloadConverter, activation.arguments),
            queryId,
            headers: headers ?? {},
        }).then((result) => this.completeQuery(queryId, result), (reason) => this.failQuery(queryId, reason));
    }
    doUpdate(activation) {
        const { id: updateId, protocolInstanceId, name, headers, runValidator } = activation;
        if (!updateId) {
            throw new TypeError('Missing activation update id');
        }
        if (!name) {
            throw new TypeError('Missing activation update name');
        }
        if (!protocolInstanceId) {
            throw new TypeError('Missing activation update protocolInstanceId');
        }
        if (!this.updateHandlers.has(name)) {
            this.bufferedUpdates.push(activation);
            return;
        }
        const makeInput = () => ({
            updateId,
            args: (0, common_1.arrayFromPayloads)(this.payloadConverter, activation.input),
            name,
            headers: headers ?? {},
        });
        // The implementation below is responsible for upholding, and constrained
        // by, the following contract:
        //
        // 1. If no validator is present then validation interceptors will not be run.
        //
        // 2. During validation, any error must fail the Update; during the Update
        //    itself, Temporal errors fail the Update whereas other errors fail the
        //    activation.
        //
        // 3. The handler must not see any mutations of the arguments made by the
        //    validator.
        //
        // 4. Any error when decoding/deserializing input must be caught and result
        //    in rejection of the Update before it is accepted, even if there is no
        //    validator.
        //
        // 5. The initial synchronous portion of the (async) Update handler should
        //    be executed after the (sync) validator completes such that there is
        //    minimal opportunity for a different concurrent task to be scheduled
        //    between them.
        //
        // 6. The stack trace view provided in the Temporal UI must not be polluted
        //    by promises that do not derive from user code. This implies that
        //    async/await syntax may not be used.
        //
        // Note that there is a deliberately unhandled promise rejection below.
        // These are caught elsewhere and fail the corresponding activation.
        let input;
        try {
            if (runValidator && this.updateHandlers.get(name)?.validator) {
                const validate = (0, interceptors_1.composeInterceptors)(this.interceptors.inbound, 'validateUpdate', this.validateUpdateNextHandler.bind(this));
                validate(makeInput());
            }
            input = makeInput();
        }
        catch (error) {
            this.rejectUpdate(protocolInstanceId, error);
            return;
        }
        const execute = (0, interceptors_1.composeInterceptors)(this.interceptors.inbound, 'handleUpdate', this.updateNextHandler.bind(this));
        this.acceptUpdate(protocolInstanceId);
        (0, stack_helpers_1.untrackPromise)(execute(input)
            .then((result) => this.completeUpdate(protocolInstanceId, result))
            .catch((error) => {
            if (error instanceof common_1.TemporalFailure) {
                this.rejectUpdate(protocolInstanceId, error);
            }
            else {
                throw error;
            }
        }));
    }
    async updateNextHandler({ name, args }) {
        const entry = this.updateHandlers.get(name);
        if (!entry) {
            return Promise.reject(new common_1.IllegalStateError(`No registered update handler for update: ${name}`));
        }
        const { handler } = entry;
        return await handler(...args);
    }
    validateUpdateNextHandler({ name, args }) {
        const { validator } = this.updateHandlers.get(name) ?? {};
        if (validator) {
            validator(...args);
        }
    }
    dispatchBufferedUpdates() {
        const bufferedUpdates = this.bufferedUpdates;
        while (bufferedUpdates.length) {
            const foundIndex = bufferedUpdates.findIndex((update) => this.updateHandlers.has(update.name));
            if (foundIndex === -1) {
                // No buffered Updates have a handler yet.
                break;
            }
            const [update] = bufferedUpdates.splice(foundIndex, 1);
            this.doUpdate(update);
        }
    }
    rejectBufferedUpdates() {
        while (this.bufferedUpdates.length) {
            const update = this.bufferedUpdates.shift();
            if (update) {
                this.rejectUpdate(
                /* eslint-disable @typescript-eslint/no-non-null-assertion */
                update.protocolInstanceId, common_1.ApplicationFailure.nonRetryable(`No registered handler for update: ${update.name}`));
            }
        }
    }
    async signalWorkflowNextHandler({ signalName, args }) {
        const fn = this.signalHandlers.get(signalName)?.handler;
        if (fn) {
            return await fn(...args);
        }
        else if (this.defaultSignalHandler) {
            return await this.defaultSignalHandler(signalName, ...args);
        }
        else {
            throw new common_1.IllegalStateError(`No registered signal handler for signal: ${signalName}`);
        }
    }
    signalWorkflow(activation) {
        const { signalName, headers } = activation;
        if (!signalName) {
            throw new TypeError('Missing activation signalName');
        }
        if (!this.signalHandlers.has(signalName) && !this.defaultSignalHandler) {
            this.bufferedSignals.push(activation);
            return;
        }
        const execute = (0, interceptors_1.composeInterceptors)(this.interceptors.inbound, 'handleSignal', this.signalWorkflowNextHandler.bind(this));
        execute({
            args: (0, common_1.arrayFromPayloads)(this.payloadConverter, activation.input),
            signalName,
            headers: headers ?? {},
        }).catch(this.handleWorkflowFailure.bind(this));
    }
    dispatchBufferedSignals() {
        const bufferedSignals = this.bufferedSignals;
        while (bufferedSignals.length) {
            if (this.defaultSignalHandler) {
                // We have a default signal handler, so all signals are dispatchable
                // eslint-disable-next-line @typescript-eslint/no-non-null-assertion
                this.signalWorkflow(bufferedSignals.shift());
            }
            else {
                const foundIndex = bufferedSignals.findIndex((signal) => this.signalHandlers.has(signal.signalName));
                if (foundIndex === -1)
                    break;
                const [signal] = bufferedSignals.splice(foundIndex, 1);
                this.signalWorkflow(signal);
            }
        }
    }
    resolveSignalExternalWorkflow(activation) {
        const { resolve, reject } = this.consumeCompletion('signalWorkflow', getSeq(activation));
        if (activation.failure) {
            reject(this.failureToError(activation.failure));
        }
        else {
            resolve(undefined);
        }
    }
    resolveRequestCancelExternalWorkflow(activation) {
        const { resolve, reject } = this.consumeCompletion('cancelWorkflow', getSeq(activation));
        if (activation.failure) {
            reject(this.failureToError(activation.failure));
        }
        else {
            resolve(undefined);
        }
    }
    updateRandomSeed(activation) {
        if (!activation.randomnessSeed) {
            throw new TypeError('Expected activation with randomnessSeed attribute');
        }
        this.random = (0, alea_1.alea)(activation.randomnessSeed.toBytes());
    }
    notifyHasPatch(activation) {
        if (!activation.patchId) {
            throw new TypeError('Notify has patch missing patch name');
        }
        this.knownPresentPatches.add(activation.patchId);
    }
    removeFromCache() {
        throw new common_1.IllegalStateError('removeFromCache activation job should not reach workflow');
    }
    /**
     * Transforms failures into a command to be sent to the server.
     * Used to handle any failure emitted by the Workflow.
     */
    async handleWorkflowFailure(error) {
        if (this.cancelled && (0, errors_1.isCancellation)(error)) {
            this.pushCommand({ cancelWorkflowExecution: {} }, true);
        }
        else if (error instanceof interfaces_1.ContinueAsNew) {
            this.pushCommand({ continueAsNewWorkflowExecution: error.command }, true);
        }
        else {
            if (!(error instanceof common_1.TemporalFailure)) {
                // This results in an unhandled rejection which will fail the activation
                // preventing it from completing.
                throw error;
            }
            this.pushCommand({
                failWorkflowExecution: {
                    failure: this.errorToFailure(error),
                },
            }, true);
        }
    }
    completeQuery(queryId, result) {
        this.pushCommand({
            respondToQuery: { queryId, succeeded: { response: this.payloadConverter.toPayload(result) } },
        });
    }
    failQuery(queryId, error) {
        this.pushCommand({
            respondToQuery: {
                queryId,
                failed: this.errorToFailure((0, common_1.ensureTemporalFailure)(error)),
            },
        });
    }
    acceptUpdate(protocolInstanceId) {
        this.pushCommand({ updateResponse: { protocolInstanceId, accepted: {} } });
    }
    completeUpdate(protocolInstanceId, result) {
        this.pushCommand({
            updateResponse: { protocolInstanceId, completed: this.payloadConverter.toPayload(result) },
        });
    }
    rejectUpdate(protocolInstanceId, error) {
        this.pushCommand({
            updateResponse: {
                protocolInstanceId,
                rejected: this.errorToFailure((0, common_1.ensureTemporalFailure)(error)),
            },
        });
    }
    /** Consume a completion if it exists in Workflow state */
    maybeConsumeCompletion(type, taskSeq) {
        const completion = this.completions[type].get(taskSeq);
        if (completion !== undefined) {
            this.completions[type].delete(taskSeq);
        }
        return completion;
    }
    /** Consume a completion if it exists in Workflow state, throws if it doesn't */
    consumeCompletion(type, taskSeq) {
        const completion = this.maybeConsumeCompletion(type, taskSeq);
        if (completion === undefined) {
            throw new common_1.IllegalStateError(`No completion for taskSeq ${taskSeq}`);
        }
        return completion;
    }
    completeWorkflow(result) {
        this.pushCommand({
            completeWorkflowExecution: {
                result: this.payloadConverter.toPayload(result),
            },
        }, true);
    }
    errorToFailure(err) {
        return this.failureConverter.errorToFailure(err, this.payloadConverter);
    }
    failureToError(failure) {
        return this.failureConverter.failureToError(failure, this.payloadConverter);
    }
}
exports.Activator = Activator;
function getSeq(activation) {
    const seq = activation.seq;
    if (seq === undefined || seq === null) {
        throw new TypeError(`Got activation with no seq attribute`);
    }
    return seq;
}


/***/ }),

/***/ "../../node_modules/@temporalio/workflow/lib/logs.js":
/*!***********************************************************!*\
  !*** ../../node_modules/@temporalio/workflow/lib/logs.js ***!
  \***********************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.workflowLogAttributes = exports.executeWithLifecycleLogging = exports.log = void 0;
const interceptors_1 = __webpack_require__(/*! @temporalio/common/lib/interceptors */ "../../node_modules/@temporalio/workflow/node_modules/@temporalio/common/lib/interceptors.js");
const common_1 = __webpack_require__(/*! @temporalio/common */ "../../node_modules/@temporalio/workflow/node_modules/@temporalio/common/lib/index.js");
const stack_helpers_1 = __webpack_require__(/*! ./stack-helpers */ "../../node_modules/@temporalio/workflow/lib/stack-helpers.js");
const sinks_1 = __webpack_require__(/*! ./sinks */ "../../node_modules/@temporalio/workflow/lib/sinks.js");
const errors_1 = __webpack_require__(/*! ./errors */ "../../node_modules/@temporalio/workflow/lib/errors.js");
const interfaces_1 = __webpack_require__(/*! ./interfaces */ "../../node_modules/@temporalio/workflow/lib/interfaces.js");
const global_attributes_1 = __webpack_require__(/*! ./global-attributes */ "../../node_modules/@temporalio/workflow/lib/global-attributes.js");
const loggerSink = (0, sinks_1.proxySinks)().__temporal_logger;
/**
 * Symbol used by the SDK logger to extract a timestamp from log attributes.
 * Also defined in `worker/logger.ts` - intentionally not shared.
 */
const LogTimestamp = Symbol.for('log_timestamp');
/**
 * Default workflow logger.
 *
 * This logger is replay-aware and will omit log messages on workflow replay. Messages emitted by this logger are
 * funnelled through a sink that forwards them to the logger registered on {@link Runtime.logger}.
 *
 * Attributes from the current Workflow Execution context are automatically included as metadata on every log
 * entries. An extra `sdkComponent` metadata attribute is also added, with value `workflow`; this can be used for
 * fine-grained filtering of log entries further downstream.
 *
 * To customize log attributes, register a {@link WorkflowOutboundCallsInterceptor} that intercepts the
 * `getLogAttributes()` method.
 *
 * Notice that since sinks are used to power this logger, any log attributes must be transferable via the
 * {@link https://nodejs.org/api/worker_threads.html#worker_threads_port_postmessage_value_transferlist | postMessage}
 * API.
 *
 * NOTE: Specifying a custom logger through {@link defaultSink} or by manually registering a sink named
 * `defaultWorkerLogger` has been deprecated. Please use {@link Runtime.logger} instead.
 */
exports.log = Object.fromEntries(['trace', 'debug', 'info', 'warn', 'error'].map((level) => {
    return [
        level,
        (message, attrs) => {
            const activator = (0, global_attributes_1.assertInWorkflowContext)('Workflow.log(...) may only be used from workflow context.');
            const getLogAttributes = (0, interceptors_1.composeInterceptors)(activator.interceptors.outbound, 'getLogAttributes', (a) => a);
            return loggerSink[level](message, {
                // Inject the call time in nanosecond resolution as expected by the worker logger.
                [LogTimestamp]: activator.getTimeOfDay(),
                sdkComponent: common_1.SdkComponent.workflow,
                ...getLogAttributes(workflowLogAttributes(activator.info)),
                ...attrs,
            });
        },
    ];
}));
function executeWithLifecycleLogging(fn) {
    exports.log.debug('Workflow started', { sdkComponent: common_1.SdkComponent.worker });
    const p = fn().then((res) => {
        exports.log.debug('Workflow completed', { sdkComponent: common_1.SdkComponent.worker });
        return res;
    }, (error) => {
        // Avoid using instanceof checks in case the modules they're defined in loaded more than once,
        // e.g. by jest or when multiple versions are installed.
        if (typeof error === 'object' && error != null) {
            if ((0, errors_1.isCancellation)(error)) {
                exports.log.debug('Workflow completed as cancelled', { sdkComponent: common_1.SdkComponent.worker });
                throw error;
            }
            else if (error instanceof interfaces_1.ContinueAsNew) {
                exports.log.debug('Workflow continued as new', { sdkComponent: common_1.SdkComponent.worker });
                throw error;
            }
        }
        exports.log.warn('Workflow failed', { error, sdkComponent: common_1.SdkComponent.worker });
        throw error;
    });
    // Avoid showing this interceptor in stack trace query
    (0, stack_helpers_1.untrackPromise)(p);
    return p;
}
exports.executeWithLifecycleLogging = executeWithLifecycleLogging;
/**
 * Returns a map of attributes to be set _by default_ on log messages for a given Workflow.
 * Note that this function may be called from outside of the Workflow context (eg. by the worker itself).
 */
function workflowLogAttributes(info) {
    return {
        namespace: info.namespace,
        taskQueue: info.taskQueue,
        workflowId: info.workflowId,
        runId: info.runId,
        workflowType: info.workflowType,
    };
}
exports.workflowLogAttributes = workflowLogAttributes;


/***/ }),

/***/ "../../node_modules/@temporalio/workflow/lib/pkg.js":
/*!**********************************************************!*\
  !*** ../../node_modules/@temporalio/workflow/lib/pkg.js ***!
  \**********************************************************/
/***/ (function(__unused_webpack_module, exports, __webpack_require__) {

"use strict";

var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", ({ value: true }));
// ../package.json is outside of the TS project rootDir which causes TS to complain about this import.
// We do not want to change the rootDir because it messes up the output structure.
// eslint-disable-next-line @typescript-eslint/ban-ts-comment
// @ts-ignore
const package_json_1 = __importDefault(__webpack_require__(/*! ../package.json */ "../../node_modules/@temporalio/workflow/package.json"));
exports["default"] = package_json_1.default;


/***/ }),

/***/ "../../node_modules/@temporalio/workflow/lib/sinks.js":
/*!************************************************************!*\
  !*** ../../node_modules/@temporalio/workflow/lib/sinks.js ***!
  \************************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";

/**
 * Type definitions for the Workflow end of the sinks mechanism.
 *
 * Sinks are a mechanism for exporting data from the Workflow isolate to the
 * Node.js environment, they are necessary because the Workflow has no way to
 * communicate with the outside World.
 *
 * Sinks are typically used for exporting logs, metrics and traces out from the
 * Workflow.
 *
 * Sink functions may not return values to the Workflow in order to prevent
 * breaking determinism.
 *
 * @module
 */
Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.proxySinks = void 0;
const global_attributes_1 = __webpack_require__(/*! ./global-attributes */ "../../node_modules/@temporalio/workflow/lib/global-attributes.js");
/**
 * Get a reference to Sinks for exporting data out of the Workflow.
 *
 * These Sinks **must** be registered with the Worker in order for this
 * mechanism to work.
 *
 * @example
 * ```ts
 * import { proxySinks, Sinks } from '@temporalio/workflow';
 *
 * interface MySinks extends Sinks {
 *   logger: {
 *     info(message: string): void;
 *     error(message: string): void;
 *   };
 * }
 *
 * const { logger } = proxySinks<MyDependencies>();
 * logger.info('setting up');
 *
 * export function myWorkflow() {
 *   return {
 *     async execute() {
 *       logger.info("hey ho");
 *       logger.error("lets go");
 *     }
 *   };
 * }
 * ```
 */
function proxySinks() {
    return new Proxy({}, {
        get(_, ifaceName) {
            return new Proxy({}, {
                get(_, fnName) {
                    return (...args) => {
                        const activator = (0, global_attributes_1.assertInWorkflowContext)('Proxied sinks functions may only be used from a Workflow Execution.');
                        activator.sinkCalls.push({
                            ifaceName: ifaceName,
                            fnName: fnName,
                            // Sink function doesn't get called immediately. Make a clone of the sink's args, so that further mutations
                            // to these objects don't corrupt the args that the sink function will receive. Only available from node 17.
                            args: globalThis.structuredClone ? globalThis.structuredClone(args) : args,
                            // activator.info is internally copy-on-write. This ensure that any further mutations
                            // to the workflow state in the context of the present activation will not corrupt the
                            // workflowInfo state that gets passed when the sink function actually gets called.
                            workflowInfo: activator.info,
                        });
                    };
                },
            });
        },
    });
}
exports.proxySinks = proxySinks;


/***/ }),

/***/ "../../node_modules/@temporalio/workflow/lib/stack-helpers.js":
/*!********************************************************************!*\
  !*** ../../node_modules/@temporalio/workflow/lib/stack-helpers.js ***!
  \********************************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.untrackPromise = void 0;
const global_attributes_1 = __webpack_require__(/*! ./global-attributes */ "../../node_modules/@temporalio/workflow/lib/global-attributes.js");
/**
 * Helper function to remove a promise from being tracked for stack trace query purposes
 */
function untrackPromise(promise) {
    const store = (0, global_attributes_1.maybeGetActivatorUntyped)()?.promiseStackStore;
    if (!store)
        return;
    store.childToParent.delete(promise);
    store.promiseToStack.delete(promise);
}
exports.untrackPromise = untrackPromise;


/***/ }),

/***/ "../../node_modules/@temporalio/workflow/lib/trigger.js":
/*!**************************************************************!*\
  !*** ../../node_modules/@temporalio/workflow/lib/trigger.js ***!
  \**************************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.Trigger = void 0;
const cancellation_scope_1 = __webpack_require__(/*! ./cancellation-scope */ "../../node_modules/@temporalio/workflow/lib/cancellation-scope.js");
const stack_helpers_1 = __webpack_require__(/*! ./stack-helpers */ "../../node_modules/@temporalio/workflow/lib/stack-helpers.js");
/**
 * A `PromiseLike` helper which exposes its `resolve` and `reject` methods.
 *
 * Trigger is CancellationScope-aware: it is linked to the current scope on
 * construction and throws when that scope is cancelled.
 *
 * Useful for e.g. waiting for unblocking a Workflow from a Signal.
 *
 * @example
 * <!--SNIPSTART typescript-trigger-workflow-->
 * <!--SNIPEND-->
 */
class Trigger {
    constructor() {
        this.promise = new Promise((resolve, reject) => {
            const scope = cancellation_scope_1.CancellationScope.current();
            if (scope.consideredCancelled || scope.cancellable) {
                (0, stack_helpers_1.untrackPromise)(scope.cancelRequested.catch(reject));
            }
            // eslint-disable-next-line @typescript-eslint/ban-ts-comment
            // @ts-ignore
            this.resolve = resolve;
            // eslint-disable-next-line @typescript-eslint/ban-ts-comment
            // @ts-ignore
            this.reject = reject;
        });
        // Avoid unhandled rejections
        (0, stack_helpers_1.untrackPromise)(this.promise.catch(() => undefined));
    }
    then(onfulfilled, onrejected) {
        return this.promise.then(onfulfilled, onrejected);
    }
}
exports.Trigger = Trigger;


/***/ }),

/***/ "../../node_modules/@temporalio/workflow/lib/worker-interface.js":
/*!***********************************************************************!*\
  !*** ../../node_modules/@temporalio/workflow/lib/worker-interface.js ***!
  \***********************************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.dispose = exports.shouldUnblockConditions = exports.tryUnblockConditions = exports.getAndResetSinkCalls = exports.concludeActivation = exports.activate = exports.initRuntime = exports.overrideGlobals = void 0;
/**
 * Exported functions for the Worker to interact with the Workflow isolate
 *
 * @module
 */
const common_1 = __webpack_require__(/*! @temporalio/common */ "../../node_modules/@temporalio/workflow/node_modules/@temporalio/common/lib/index.js");
const time_1 = __webpack_require__(/*! @temporalio/common/lib/time */ "../../node_modules/@temporalio/workflow/node_modules/@temporalio/common/lib/time.js");
const interceptors_1 = __webpack_require__(/*! @temporalio/common/lib/interceptors */ "../../node_modules/@temporalio/workflow/node_modules/@temporalio/common/lib/interceptors.js");
const cancellation_scope_1 = __webpack_require__(/*! ./cancellation-scope */ "../../node_modules/@temporalio/workflow/lib/cancellation-scope.js");
const errors_1 = __webpack_require__(/*! ./errors */ "../../node_modules/@temporalio/workflow/lib/errors.js");
const internals_1 = __webpack_require__(/*! ./internals */ "../../node_modules/@temporalio/workflow/lib/internals.js");
const global_attributes_1 = __webpack_require__(/*! ./global-attributes */ "../../node_modules/@temporalio/workflow/lib/global-attributes.js");
const global = globalThis;
const OriginalDate = globalThis.Date;
function overrideGlobals() {
    // Mock any weak reference because GC is non-deterministic and the effect is observable from the Workflow.
    // Workflow developer will get a meaningful exception if they try to use these.
    global.WeakRef = function () {
        throw new errors_1.DeterminismViolationError('WeakRef cannot be used in Workflows because v8 GC is non-deterministic');
    };
    global.FinalizationRegistry = function () {
        throw new errors_1.DeterminismViolationError('FinalizationRegistry cannot be used in Workflows because v8 GC is non-deterministic');
    };
    global.Date = function (...args) {
        if (args.length > 0) {
            return new OriginalDate(...args);
        }
        return new OriginalDate((0, global_attributes_1.getActivator)().now);
    };
    global.Date.now = function () {
        return (0, global_attributes_1.getActivator)().now;
    };
    global.Date.parse = OriginalDate.parse.bind(OriginalDate);
    global.Date.UTC = OriginalDate.UTC.bind(OriginalDate);
    global.Date.prototype = OriginalDate.prototype;
    /**
     * @param ms sleep duration -  number of milliseconds. If given a negative number, value will be set to 1.
     */
    global.setTimeout = function (cb, ms, ...args) {
        const activator = (0, global_attributes_1.getActivator)();
        ms = Math.max(1, ms);
        const seq = activator.nextSeqs.timer++;
        // Create a Promise for AsyncLocalStorage to be able to track this completion using promise hooks.
        new Promise((resolve, reject) => {
            activator.completions.timer.set(seq, { resolve, reject });
            activator.pushCommand({
                startTimer: {
                    seq,
                    startToFireTimeout: (0, time_1.msToTs)(ms),
                },
            });
        }).then(() => cb(...args), () => undefined /* ignore cancellation */);
        return seq;
    };
    global.clearTimeout = function (handle) {
        const activator = (0, global_attributes_1.getActivator)();
        activator.nextSeqs.timer++;
        activator.completions.timer.delete(handle);
        activator.pushCommand({
            cancelTimer: {
                seq: handle,
            },
        });
    };
    // activator.random is mutable, don't hardcode its reference
    Math.random = () => (0, global_attributes_1.getActivator)().random();
}
exports.overrideGlobals = overrideGlobals;
/**
 * Initialize the isolate runtime.
 *
 * Sets required internal state and instantiates the workflow and interceptors.
 */
function initRuntime(options) {
    const activator = new internals_1.Activator({
        ...options,
        info: fixPrototypes({
            ...options.info,
            unsafe: { ...options.info.unsafe, now: OriginalDate.now },
        }),
    });
    // There's on activator per workflow instance, set it globally on the context.
    // We do this before importing any user code so user code can statically reference @temporalio/workflow functions
    // as well as Date and Math.random.
    (0, global_attributes_1.setActivatorUntyped)(activator);
    // webpack alias to payloadConverterPath
    // eslint-disable-next-line @typescript-eslint/no-var-requires
    const customPayloadConverter = (__webpack_require__(/*! __temporal_custom_payload_converter */ "../temporal/build/payload-converter.cjs").payloadConverter);
    // The `payloadConverter` export is validated in the Worker
    if (customPayloadConverter != null) {
        activator.payloadConverter = customPayloadConverter;
    }
    // webpack alias to failureConverterPath
    // eslint-disable-next-line @typescript-eslint/no-var-requires
    const customFailureConverter = (__webpack_require__(/*! __temporal_custom_failure_converter */ "?75e1").failureConverter);
    // The `failureConverter` export is validated in the Worker
    if (customFailureConverter != null) {
        activator.failureConverter = customFailureConverter;
    }
    const { importWorkflows, importInterceptors } = global.__TEMPORAL__;
    if (importWorkflows === undefined || importInterceptors === undefined) {
        throw new common_1.IllegalStateError('Workflow bundle did not register import hooks');
    }
    const interceptors = importInterceptors();
    for (const mod of interceptors) {
        const factory = mod.interceptors;
        if (factory !== undefined) {
            if (typeof factory !== 'function') {
                throw new TypeError(`Failed to initialize workflows interceptors: expected a function, but got: '${factory}'`);
            }
            const interceptors = factory();
            activator.interceptors.inbound.push(...(interceptors.inbound ?? []));
            activator.interceptors.outbound.push(...(interceptors.outbound ?? []));
            activator.interceptors.internals.push(...(interceptors.internals ?? []));
        }
    }
    const mod = importWorkflows();
    const workflowFn = mod[activator.info.workflowType];
    const defaultWorkflowFn = mod['default'];
    if (typeof workflowFn === 'function') {
        activator.workflow = workflowFn;
    }
    else if (typeof defaultWorkflowFn === 'function') {
        activator.workflow = defaultWorkflowFn;
    }
    else {
        const details = workflowFn === undefined
            ? 'no such function is exported by the workflow bundle'
            : `expected a function, but got: '${typeof workflowFn}'`;
        throw new TypeError(`Failed to initialize workflow of type '${activator.info.workflowType}': ${details}`);
    }
}
exports.initRuntime = initRuntime;
/**
 * Objects transfered to the VM from outside have prototypes belonging to the
 * outer context, which means that instanceof won't work inside the VM. This
 * function recursively walks over the content of an object, and recreate some
 * of these objects (notably Array, Date and Objects).
 */
function fixPrototypes(obj) {
    if (obj != null && typeof obj === 'object') {
        switch (Object.getPrototypeOf(obj)?.constructor?.name) {
            case 'Array':
                return Array.from(obj.map(fixPrototypes));
            case 'Date':
                return new Date(obj);
            default:
                return Object.fromEntries(Object.entries(obj).map(([k, v]) => [k, fixPrototypes(v)]));
        }
    }
    else
        return obj;
}
/**
 * Run a chunk of activation jobs
 * @returns a boolean indicating whether job was processed or ignored
 */
function activate(activation, batchIndex) {
    const activator = (0, global_attributes_1.getActivator)();
    const intercept = (0, interceptors_1.composeInterceptors)(activator.interceptors.internals, 'activate', ({ activation, batchIndex }) => {
        if (batchIndex === 0) {
            if (!activation.jobs) {
                throw new TypeError('Got activation with no jobs');
            }
            if (activation.timestamp != null) {
                // timestamp will not be updated for activation that contain only queries
                activator.now = (0, time_1.tsToMs)(activation.timestamp);
            }
            // The Rust Core ensures that these activation fields are not null
            activator.mutateWorkflowInfo((info) => ({
                ...info,
                historyLength: activation.historyLength,
                // Exact truncation for multi-petabyte histories
                // historySize === 0 means WFT was generated by pre-1.20.0 server, and the history size is unknown
                historySize: activation.historySizeBytes?.toNumber() || 0,
                continueAsNewSuggested: activation.continueAsNewSuggested ?? false,
                currentBuildId: activation.buildIdForCurrentTask ?? undefined,
                unsafe: {
                    ...info.unsafe,
                    isReplaying: activation.isReplaying ?? false,
                },
            }));
        }
        // Cast from the interface to the class which has the `variant` attribute.
        // This is safe because we know that activation is a proto class.
        const jobs = activation.jobs;
        for (const job of jobs) {
            if (job.variant === undefined) {
                throw new TypeError('Expected job.variant to be defined');
            }
            const variant = job[job.variant];
            if (!variant) {
                throw new TypeError(`Expected job.${job.variant} to be set`);
            }
            // The only job that can be executed on a completed workflow is a query.
            // We might get other jobs after completion for instance when a single
            // activation contains multiple jobs and the first one completes the workflow.
            if (activator.completed && job.variant !== 'queryWorkflow') {
                return;
            }
            activator[job.variant](variant /* TS can't infer this type */);
            if (shouldUnblockConditions(job)) {
                tryUnblockConditions();
            }
        }
    });
    intercept({
        activation,
        batchIndex,
    });
}
exports.activate = activate;
/**
 * Conclude a single activation.
 * Should be called after processing all activation jobs and queued microtasks.
 *
 * Activation failures are handled in the main Node.js isolate.
 */
function concludeActivation() {
    const activator = (0, global_attributes_1.getActivator)();
    activator.rejectBufferedUpdates();
    const intercept = (0, interceptors_1.composeInterceptors)(activator.interceptors.internals, 'concludeActivation', (input) => input);
    const { info } = activator;
    const { commands } = intercept({ commands: activator.getAndResetCommands() });
    return {
        runId: info.runId,
        successful: { commands },
    };
}
exports.concludeActivation = concludeActivation;
function getAndResetSinkCalls() {
    return (0, global_attributes_1.getActivator)().getAndResetSinkCalls();
}
exports.getAndResetSinkCalls = getAndResetSinkCalls;
/**
 * Loop through all blocked conditions, evaluate and unblock if possible.
 *
 * @returns number of unblocked conditions.
 */
function tryUnblockConditions() {
    let numUnblocked = 0;
    for (;;) {
        const prevUnblocked = numUnblocked;
        for (const [seq, cond] of (0, global_attributes_1.getActivator)().blockedConditions.entries()) {
            if (cond.fn()) {
                cond.resolve();
                numUnblocked++;
                // It is safe to delete elements during map iteration
                (0, global_attributes_1.getActivator)().blockedConditions.delete(seq);
            }
        }
        if (prevUnblocked === numUnblocked) {
            break;
        }
    }
    return numUnblocked;
}
exports.tryUnblockConditions = tryUnblockConditions;
/**
 * Predicate used to prevent triggering conditions for non-query and non-patch jobs.
 */
function shouldUnblockConditions(job) {
    return !job.queryWorkflow && !job.notifyHasPatch;
}
exports.shouldUnblockConditions = shouldUnblockConditions;
function dispose() {
    const dispose = (0, interceptors_1.composeInterceptors)((0, global_attributes_1.getActivator)().interceptors.internals, 'dispose', async () => {
        (0, cancellation_scope_1.disableStorage)();
    });
    dispose({});
}
exports.dispose = dispose;


/***/ }),

/***/ "../../node_modules/@temporalio/workflow/lib/workflow.js":
/*!***************************************************************!*\
  !*** ../../node_modules/@temporalio/workflow/lib/workflow.js ***!
  \***************************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.workflowMetadataQuery = exports.enhancedStackTraceQuery = exports.stackTraceQuery = exports.upsertSearchAttributes = exports.setDefaultSignalHandler = exports.setHandler = exports.defineQuery = exports.defineSignal = exports.defineUpdate = exports.condition = exports.deprecatePatch = exports.patched = exports.uuid4 = exports.continueAsNew = exports.makeContinueAsNewFunc = exports.inWorkflowContext = exports.workflowInfo = exports.executeChild = exports.startChild = exports.getExternalWorkflowHandle = exports.proxyLocalActivities = exports.proxyActivities = exports.NotAnActivityMethod = exports.scheduleLocalActivity = exports.scheduleActivity = exports.sleep = exports.addDefaultWorkflowOptions = void 0;
const common_1 = __webpack_require__(/*! @temporalio/common */ "../../node_modules/@temporalio/workflow/node_modules/@temporalio/common/lib/index.js");
const versioning_intent_enum_1 = __webpack_require__(/*! @temporalio/common/lib/versioning-intent-enum */ "../../node_modules/@temporalio/workflow/node_modules/@temporalio/common/lib/versioning-intent-enum.js");
const time_1 = __webpack_require__(/*! @temporalio/common/lib/time */ "../../node_modules/@temporalio/workflow/node_modules/@temporalio/common/lib/time.js");
const interceptors_1 = __webpack_require__(/*! @temporalio/common/lib/interceptors */ "../../node_modules/@temporalio/workflow/node_modules/@temporalio/common/lib/interceptors.js");
const cancellation_scope_1 = __webpack_require__(/*! ./cancellation-scope */ "../../node_modules/@temporalio/workflow/lib/cancellation-scope.js");
const interfaces_1 = __webpack_require__(/*! ./interfaces */ "../../node_modules/@temporalio/workflow/lib/interfaces.js");
const errors_1 = __webpack_require__(/*! ./errors */ "../../node_modules/@temporalio/workflow/lib/errors.js");
const global_attributes_1 = __webpack_require__(/*! ./global-attributes */ "../../node_modules/@temporalio/workflow/lib/global-attributes.js");
const stack_helpers_1 = __webpack_require__(/*! ./stack-helpers */ "../../node_modules/@temporalio/workflow/lib/stack-helpers.js");
// Avoid a circular dependency
(0, cancellation_scope_1.registerSleepImplementation)(sleep);
/**
 * Adds default values to `workflowId` and `workflowIdReusePolicy` to given workflow options.
 */
function addDefaultWorkflowOptions(opts) {
    const { args, workflowId, ...rest } = opts;
    return {
        workflowId: workflowId ?? uuid4(),
        args: args ?? [],
        cancellationType: interfaces_1.ChildWorkflowCancellationType.WAIT_CANCELLATION_COMPLETED,
        ...rest,
    };
}
exports.addDefaultWorkflowOptions = addDefaultWorkflowOptions;
/**
 * Push a startTimer command into state accumulator and register completion
 */
function timerNextHandler(input) {
    const activator = (0, global_attributes_1.getActivator)();
    return new Promise((resolve, reject) => {
        const scope = cancellation_scope_1.CancellationScope.current();
        if (scope.consideredCancelled) {
            (0, stack_helpers_1.untrackPromise)(scope.cancelRequested.catch(reject));
            return;
        }
        if (scope.cancellable) {
            (0, stack_helpers_1.untrackPromise)(scope.cancelRequested.catch((err) => {
                if (!activator.completions.timer.delete(input.seq)) {
                    return; // Already resolved or never scheduled
                }
                activator.pushCommand({
                    cancelTimer: {
                        seq: input.seq,
                    },
                });
                reject(err);
            }));
        }
        activator.pushCommand({
            startTimer: {
                seq: input.seq,
                startToFireTimeout: (0, time_1.msToTs)(input.durationMs),
            },
        });
        activator.completions.timer.set(input.seq, {
            resolve,
            reject,
        });
    });
}
/**
 * Asynchronous sleep.
 *
 * Schedules a timer on the Temporal service.
 *
 * @param ms sleep duration - number of milliseconds or {@link https://www.npmjs.com/package/ms | ms-formatted string}.
 * If given a negative number or 0, value will be set to 1.
 */
function sleep(ms) {
    const activator = (0, global_attributes_1.assertInWorkflowContext)('Workflow.sleep(...) may only be used from a Workflow Execution');
    const seq = activator.nextSeqs.timer++;
    const durationMs = Math.max(1, (0, time_1.msToNumber)(ms));
    const execute = (0, interceptors_1.composeInterceptors)(activator.interceptors.outbound, 'startTimer', timerNextHandler);
    return execute({
        durationMs,
        seq,
    });
}
exports.sleep = sleep;
function validateActivityOptions(options) {
    if (options.scheduleToCloseTimeout === undefined && options.startToCloseTimeout === undefined) {
        throw new TypeError('Required either scheduleToCloseTimeout or startToCloseTimeout');
    }
}
// Use same validation we use for normal activities
const validateLocalActivityOptions = validateActivityOptions;
/**
 * Push a scheduleActivity command into activator accumulator and register completion
 */
function scheduleActivityNextHandler({ options, args, headers, seq, activityType }) {
    const activator = (0, global_attributes_1.getActivator)();
    validateActivityOptions(options);
    return new Promise((resolve, reject) => {
        const scope = cancellation_scope_1.CancellationScope.current();
        if (scope.consideredCancelled) {
            (0, stack_helpers_1.untrackPromise)(scope.cancelRequested.catch(reject));
            return;
        }
        if (scope.cancellable) {
            (0, stack_helpers_1.untrackPromise)(scope.cancelRequested.catch(() => {
                if (!activator.completions.activity.has(seq)) {
                    return; // Already resolved or never scheduled
                }
                activator.pushCommand({
                    requestCancelActivity: {
                        seq,
                    },
                });
            }));
        }
        activator.pushCommand({
            scheduleActivity: {
                seq,
                activityId: options.activityId ?? `${seq}`,
                activityType,
                arguments: (0, common_1.toPayloads)(activator.payloadConverter, ...args),
                retryPolicy: options.retry ? (0, common_1.compileRetryPolicy)(options.retry) : undefined,
                taskQueue: options.taskQueue || activator.info.taskQueue,
                heartbeatTimeout: (0, time_1.msOptionalToTs)(options.heartbeatTimeout),
                scheduleToCloseTimeout: (0, time_1.msOptionalToTs)(options.scheduleToCloseTimeout),
                startToCloseTimeout: (0, time_1.msOptionalToTs)(options.startToCloseTimeout),
                scheduleToStartTimeout: (0, time_1.msOptionalToTs)(options.scheduleToStartTimeout),
                headers,
                cancellationType: options.cancellationType,
                doNotEagerlyExecute: !(options.allowEagerDispatch ?? true),
                versioningIntent: (0, versioning_intent_enum_1.versioningIntentToProto)(options.versioningIntent),
            },
        });
        activator.completions.activity.set(seq, {
            resolve,
            reject,
        });
    });
}
/**
 * Push a scheduleActivity command into state accumulator and register completion
 */
async function scheduleLocalActivityNextHandler({ options, args, headers, seq, activityType, attempt, originalScheduleTime, }) {
    const activator = (0, global_attributes_1.getActivator)();
    // Eagerly fail the local activity (which will in turn fail the workflow task.
    // Do not fail on replay where the local activities may not be registered on the replay worker.
    if (!activator.info.unsafe.isReplaying && !activator.registeredActivityNames.has(activityType)) {
        throw new ReferenceError(`Local activity of type '${activityType}' not registered on worker`);
    }
    validateLocalActivityOptions(options);
    return new Promise((resolve, reject) => {
        const scope = cancellation_scope_1.CancellationScope.current();
        if (scope.consideredCancelled) {
            (0, stack_helpers_1.untrackPromise)(scope.cancelRequested.catch(reject));
            return;
        }
        if (scope.cancellable) {
            (0, stack_helpers_1.untrackPromise)(scope.cancelRequested.catch(() => {
                if (!activator.completions.activity.has(seq)) {
                    return; // Already resolved or never scheduled
                }
                activator.pushCommand({
                    requestCancelLocalActivity: {
                        seq,
                    },
                });
            }));
        }
        activator.pushCommand({
            scheduleLocalActivity: {
                seq,
                attempt,
                originalScheduleTime,
                // Intentionally not exposing activityId as an option
                activityId: `${seq}`,
                activityType,
                arguments: (0, common_1.toPayloads)(activator.payloadConverter, ...args),
                retryPolicy: options.retry ? (0, common_1.compileRetryPolicy)(options.retry) : undefined,
                scheduleToCloseTimeout: (0, time_1.msOptionalToTs)(options.scheduleToCloseTimeout),
                startToCloseTimeout: (0, time_1.msOptionalToTs)(options.startToCloseTimeout),
                scheduleToStartTimeout: (0, time_1.msOptionalToTs)(options.scheduleToStartTimeout),
                localRetryThreshold: (0, time_1.msOptionalToTs)(options.localRetryThreshold),
                headers,
                cancellationType: options.cancellationType,
            },
        });
        activator.completions.activity.set(seq, {
            resolve,
            reject,
        });
    });
}
/**
 * Schedule an activity and run outbound interceptors
 * @hidden
 */
function scheduleActivity(activityType, args, options) {
    const activator = (0, global_attributes_1.assertInWorkflowContext)('Workflow.scheduleActivity(...) may only be used from a Workflow Execution');
    if (options === undefined) {
        throw new TypeError('Got empty activity options');
    }
    const seq = activator.nextSeqs.activity++;
    const execute = (0, interceptors_1.composeInterceptors)(activator.interceptors.outbound, 'scheduleActivity', scheduleActivityNextHandler);
    return execute({
        activityType,
        headers: {},
        options,
        args,
        seq,
    });
}
exports.scheduleActivity = scheduleActivity;
/**
 * Schedule an activity and run outbound interceptors
 * @hidden
 */
async function scheduleLocalActivity(activityType, args, options) {
    const activator = (0, global_attributes_1.assertInWorkflowContext)('Workflow.scheduleLocalActivity(...) may only be used from a Workflow Execution');
    if (options === undefined) {
        throw new TypeError('Got empty activity options');
    }
    let attempt = 1;
    let originalScheduleTime = undefined;
    for (;;) {
        const seq = activator.nextSeqs.activity++;
        const execute = (0, interceptors_1.composeInterceptors)(activator.interceptors.outbound, 'scheduleLocalActivity', scheduleLocalActivityNextHandler);
        try {
            return (await execute({
                activityType,
                headers: {},
                options,
                args,
                seq,
                attempt,
                originalScheduleTime,
            }));
        }
        catch (err) {
            if (err instanceof errors_1.LocalActivityDoBackoff) {
                await sleep((0, time_1.tsToMs)(err.backoff.backoffDuration));
                if (typeof err.backoff.attempt !== 'number') {
                    throw new TypeError('Invalid backoff attempt type');
                }
                attempt = err.backoff.attempt;
                originalScheduleTime = err.backoff.originalScheduleTime ?? undefined;
            }
            else {
                throw err;
            }
        }
    }
}
exports.scheduleLocalActivity = scheduleLocalActivity;
function startChildWorkflowExecutionNextHandler({ options, headers, workflowType, seq, }) {
    const activator = (0, global_attributes_1.getActivator)();
    const workflowId = options.workflowId ?? uuid4();
    const startPromise = new Promise((resolve, reject) => {
        const scope = cancellation_scope_1.CancellationScope.current();
        if (scope.consideredCancelled) {
            (0, stack_helpers_1.untrackPromise)(scope.cancelRequested.catch(reject));
            return;
        }
        if (scope.cancellable) {
            (0, stack_helpers_1.untrackPromise)(scope.cancelRequested.catch(() => {
                const complete = !activator.completions.childWorkflowComplete.has(seq);
                if (!complete) {
                    activator.pushCommand({
                        cancelChildWorkflowExecution: { childWorkflowSeq: seq },
                    });
                }
                // Nothing to cancel otherwise
            }));
        }
        activator.pushCommand({
            startChildWorkflowExecution: {
                seq,
                workflowId,
                workflowType,
                input: (0, common_1.toPayloads)(activator.payloadConverter, ...options.args),
                retryPolicy: options.retry ? (0, common_1.compileRetryPolicy)(options.retry) : undefined,
                taskQueue: options.taskQueue || activator.info.taskQueue,
                workflowExecutionTimeout: (0, time_1.msOptionalToTs)(options.workflowExecutionTimeout),
                workflowRunTimeout: (0, time_1.msOptionalToTs)(options.workflowRunTimeout),
                workflowTaskTimeout: (0, time_1.msOptionalToTs)(options.workflowTaskTimeout),
                namespace: activator.info.namespace, // Not configurable
                headers,
                cancellationType: options.cancellationType,
                workflowIdReusePolicy: options.workflowIdReusePolicy,
                parentClosePolicy: options.parentClosePolicy,
                cronSchedule: options.cronSchedule,
                searchAttributes: options.searchAttributes
                    ? (0, common_1.mapToPayloads)(common_1.searchAttributePayloadConverter, options.searchAttributes)
                    : undefined,
                memo: options.memo && (0, common_1.mapToPayloads)(activator.payloadConverter, options.memo),
                versioningIntent: (0, versioning_intent_enum_1.versioningIntentToProto)(options.versioningIntent),
            },
        });
        activator.completions.childWorkflowStart.set(seq, {
            resolve,
            reject,
        });
    });
    // We construct a Promise for the completion of the child Workflow before we know
    // if the Workflow code will await it to capture the result in case it does.
    const completePromise = new Promise((resolve, reject) => {
        // Chain start Promise rejection to the complete Promise.
        (0, stack_helpers_1.untrackPromise)(startPromise.catch(reject));
        activator.completions.childWorkflowComplete.set(seq, {
            resolve,
            reject,
        });
    });
    (0, stack_helpers_1.untrackPromise)(startPromise);
    (0, stack_helpers_1.untrackPromise)(completePromise);
    // Prevent unhandled rejection because the completion might not be awaited
    (0, stack_helpers_1.untrackPromise)(completePromise.catch(() => undefined));
    const ret = new Promise((resolve) => resolve([startPromise, completePromise]));
    (0, stack_helpers_1.untrackPromise)(ret);
    return ret;
}
function signalWorkflowNextHandler({ seq, signalName, args, target, headers }) {
    const activator = (0, global_attributes_1.getActivator)();
    return new Promise((resolve, reject) => {
        const scope = cancellation_scope_1.CancellationScope.current();
        if (scope.consideredCancelled) {
            (0, stack_helpers_1.untrackPromise)(scope.cancelRequested.catch(reject));
            return;
        }
        if (scope.cancellable) {
            (0, stack_helpers_1.untrackPromise)(scope.cancelRequested.catch(() => {
                if (!activator.completions.signalWorkflow.has(seq)) {
                    return;
                }
                activator.pushCommand({ cancelSignalWorkflow: { seq } });
            }));
        }
        activator.pushCommand({
            signalExternalWorkflowExecution: {
                seq,
                args: (0, common_1.toPayloads)(activator.payloadConverter, ...args),
                headers,
                signalName,
                ...(target.type === 'external'
                    ? {
                        workflowExecution: {
                            namespace: activator.info.namespace,
                            ...target.workflowExecution,
                        },
                    }
                    : {
                        childWorkflowId: target.childWorkflowId,
                    }),
            },
        });
        activator.completions.signalWorkflow.set(seq, { resolve, reject });
    });
}
/**
 * Symbol used in the return type of proxy methods to mark that an attribute on the source type is not a method.
 *
 * @see {@link ActivityInterfaceFor}
 * @see {@link proxyActivities}
 * @see {@link proxyLocalActivities}
 */
exports.NotAnActivityMethod = Symbol.for('__TEMPORAL_NOT_AN_ACTIVITY_METHOD');
/**
 * Configure Activity functions with given {@link ActivityOptions}.
 *
 * This method may be called multiple times to setup Activities with different options.
 *
 * @return a {@link https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Proxy | Proxy} for
 *         which each attribute is a callable Activity function
 *
 * @example
 * ```ts
 * import { proxyActivities } from '@temporalio/workflow';
 * import * as activities from '../activities';
 *
 * // Setup Activities from module exports
 * const { httpGet, otherActivity } = proxyActivities<typeof activities>({
 *   startToCloseTimeout: '30 minutes',
 * });
 *
 * // Setup Activities from an explicit interface (e.g. when defined by another SDK)
 * interface JavaActivities {
 *   httpGetFromJava(url: string): Promise<string>
 *   someOtherJavaActivity(arg1: number, arg2: string): Promise<string>;
 * }
 *
 * const {
 *   httpGetFromJava,
 *   someOtherJavaActivity
 * } = proxyActivities<JavaActivities>({
 *   taskQueue: 'java-worker-taskQueue',
 *   startToCloseTimeout: '5m',
 * });
 *
 * export function execute(): Promise<void> {
 *   const response = await httpGet("http://example.com");
 *   // ...
 * }
 * ```
 */
function proxyActivities(options) {
    if (options === undefined) {
        throw new TypeError('options must be defined');
    }
    // Validate as early as possible for immediate user feedback
    validateActivityOptions(options);
    return new Proxy({}, {
        get(_, activityType) {
            if (typeof activityType !== 'string') {
                throw new TypeError(`Only strings are supported for Activity types, got: ${String(activityType)}`);
            }
            return function activityProxyFunction(...args) {
                return scheduleActivity(activityType, args, options);
            };
        },
    });
}
exports.proxyActivities = proxyActivities;
/**
 * Configure Local Activity functions with given {@link LocalActivityOptions}.
 *
 * This method may be called multiple times to setup Activities with different options.
 *
 * @return a {@link https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Proxy | Proxy}
 *         for which each attribute is a callable Activity function
 *
 * @see {@link proxyActivities} for examples
 */
function proxyLocalActivities(options) {
    if (options === undefined) {
        throw new TypeError('options must be defined');
    }
    // Validate as early as possible for immediate user feedback
    validateLocalActivityOptions(options);
    return new Proxy({}, {
        get(_, activityType) {
            if (typeof activityType !== 'string') {
                throw new TypeError(`Only strings are supported for Activity types, got: ${String(activityType)}`);
            }
            return function localActivityProxyFunction(...args) {
                return scheduleLocalActivity(activityType, args, options);
            };
        },
    });
}
exports.proxyLocalActivities = proxyLocalActivities;
// TODO: deprecate this patch after "enough" time has passed
const EXTERNAL_WF_CANCEL_PATCH = '__temporal_internal_connect_external_handle_cancel_to_scope';
// The name of this patch comes from an attempt to build a generic internal patching mechanism.
// That effort has been abandoned in favor of a newer WorkflowTaskCompletedMetadata based mechanism.
const CONDITION_0_PATCH = '__sdk_internal_patch_number:1';
/**
 * Returns a client-side handle that can be used to signal and cancel an existing Workflow execution.
 * It takes a Workflow ID and optional run ID.
 */
function getExternalWorkflowHandle(workflowId, runId) {
    const activator = (0, global_attributes_1.assertInWorkflowContext)('Workflow.getExternalWorkflowHandle(...) may only be used from a Workflow Execution. Consider using Client.workflow.getHandle(...) instead.)');
    return {
        workflowId,
        runId,
        cancel() {
            return new Promise((resolve, reject) => {
                // Connect this cancel operation to the current cancellation scope.
                // This is behavior was introduced after v0.22.0 and is incompatible
                // with histories generated with previous SDK versions and thus requires
                // patching.
                //
                // We try to delay patching as much as possible to avoid polluting
                // histories unless strictly required.
                const scope = cancellation_scope_1.CancellationScope.current();
                if (scope.cancellable) {
                    (0, stack_helpers_1.untrackPromise)(scope.cancelRequested.catch((err) => {
                        if (patched(EXTERNAL_WF_CANCEL_PATCH)) {
                            reject(err);
                        }
                    }));
                }
                if (scope.consideredCancelled) {
                    if (patched(EXTERNAL_WF_CANCEL_PATCH)) {
                        return;
                    }
                }
                const seq = activator.nextSeqs.cancelWorkflow++;
                activator.pushCommand({
                    requestCancelExternalWorkflowExecution: {
                        seq,
                        workflowExecution: {
                            namespace: activator.info.namespace,
                            workflowId,
                            runId,
                        },
                    },
                });
                activator.completions.cancelWorkflow.set(seq, { resolve, reject });
            });
        },
        signal(def, ...args) {
            return (0, interceptors_1.composeInterceptors)(activator.interceptors.outbound, 'signalWorkflow', signalWorkflowNextHandler)({
                seq: activator.nextSeqs.signalWorkflow++,
                signalName: typeof def === 'string' ? def : def.name,
                args,
                target: {
                    type: 'external',
                    workflowExecution: { workflowId, runId },
                },
                headers: {},
            });
        },
    };
}
exports.getExternalWorkflowHandle = getExternalWorkflowHandle;
async function startChild(workflowTypeOrFunc, options) {
    const activator = (0, global_attributes_1.assertInWorkflowContext)('Workflow.startChild(...) may only be used from a Workflow Execution. Consider using Client.workflow.start(...) instead.)');
    const optionsWithDefaults = addDefaultWorkflowOptions(options ?? {});
    const workflowType = (0, common_1.extractWorkflowType)(workflowTypeOrFunc);
    const execute = (0, interceptors_1.composeInterceptors)(activator.interceptors.outbound, 'startChildWorkflowExecution', startChildWorkflowExecutionNextHandler);
    const [started, completed] = await execute({
        seq: activator.nextSeqs.childWorkflow++,
        options: optionsWithDefaults,
        headers: {},
        workflowType,
    });
    const firstExecutionRunId = await started;
    return {
        workflowId: optionsWithDefaults.workflowId,
        firstExecutionRunId,
        async result() {
            return (await completed);
        },
        async signal(def, ...args) {
            return (0, interceptors_1.composeInterceptors)(activator.interceptors.outbound, 'signalWorkflow', signalWorkflowNextHandler)({
                seq: activator.nextSeqs.signalWorkflow++,
                signalName: typeof def === 'string' ? def : def.name,
                args,
                target: {
                    type: 'child',
                    childWorkflowId: optionsWithDefaults.workflowId,
                },
                headers: {},
            });
        },
    };
}
exports.startChild = startChild;
async function executeChild(workflowTypeOrFunc, options) {
    const activator = (0, global_attributes_1.assertInWorkflowContext)('Workflow.executeChild(...) may only be used from a Workflow Execution. Consider using Client.workflow.execute(...) instead.');
    const optionsWithDefaults = addDefaultWorkflowOptions(options ?? {});
    const workflowType = (0, common_1.extractWorkflowType)(workflowTypeOrFunc);
    const execute = (0, interceptors_1.composeInterceptors)(activator.interceptors.outbound, 'startChildWorkflowExecution', startChildWorkflowExecutionNextHandler);
    const execPromise = execute({
        seq: activator.nextSeqs.childWorkflow++,
        options: optionsWithDefaults,
        headers: {},
        workflowType,
    });
    (0, stack_helpers_1.untrackPromise)(execPromise);
    const completedPromise = execPromise.then(([_started, completed]) => completed);
    (0, stack_helpers_1.untrackPromise)(completedPromise);
    return completedPromise;
}
exports.executeChild = executeChild;
/**
 * Get information about the current Workflow.
 *
 * WARNING: This function returns a frozen copy of WorkflowInfo, at the point where this method has been called.
 * Changes happening at later point in workflow execution will not be reflected in the returned object.
 *
 * For this reason, we recommend calling `workflowInfo()` on every access to {@link WorkflowInfo}'s fields,
 * rather than caching the `WorkflowInfo` object (or part of it) in a local variable. For example:
 *
 * ```ts
 * // GOOD
 * function myWorkflow() {
 *   doSomething(workflowInfo().searchAttributes)
 *   ...
 *   doSomethingElse(workflowInfo().searchAttributes)
 * }
 * ```
 *
 * vs
 *
 * ```ts
 * // BAD
 * function myWorkflow() {
 *   const attributes = workflowInfo().searchAttributes
 *   doSomething(attributes)
 *   ...
 *   doSomethingElse(attributes)
 * }
 * ```
 */
function workflowInfo() {
    const activator = (0, global_attributes_1.assertInWorkflowContext)('Workflow.workflowInfo(...) may only be used from a Workflow Execution.');
    return activator.info;
}
exports.workflowInfo = workflowInfo;
/**
 * Returns whether or not code is executing in workflow context
 */
function inWorkflowContext() {
    return (0, global_attributes_1.maybeGetActivator)() !== undefined;
}
exports.inWorkflowContext = inWorkflowContext;
/**
 * Returns a function `f` that will cause the current Workflow to ContinueAsNew when called.
 *
 * `f` takes the same arguments as the Workflow function supplied to typeparam `F`.
 *
 * Once `f` is called, Workflow Execution immediately completes.
 */
function makeContinueAsNewFunc(options) {
    const activator = (0, global_attributes_1.assertInWorkflowContext)('Workflow.continueAsNew(...) and Workflow.makeContinueAsNewFunc(...) may only be used from a Workflow Execution.');
    const info = activator.info;
    const { workflowType, taskQueue, ...rest } = options ?? {};
    const requiredOptions = {
        workflowType: workflowType ?? info.workflowType,
        taskQueue: taskQueue ?? info.taskQueue,
        ...rest,
    };
    return (...args) => {
        const fn = (0, interceptors_1.composeInterceptors)(activator.interceptors.outbound, 'continueAsNew', async (input) => {
            const { headers, args, options } = input;
            throw new interfaces_1.ContinueAsNew({
                workflowType: options.workflowType,
                arguments: (0, common_1.toPayloads)(activator.payloadConverter, ...args),
                headers,
                taskQueue: options.taskQueue,
                memo: options.memo && (0, common_1.mapToPayloads)(activator.payloadConverter, options.memo),
                searchAttributes: options.searchAttributes
                    ? (0, common_1.mapToPayloads)(common_1.searchAttributePayloadConverter, options.searchAttributes)
                    : undefined,
                workflowRunTimeout: (0, time_1.msOptionalToTs)(options.workflowRunTimeout),
                workflowTaskTimeout: (0, time_1.msOptionalToTs)(options.workflowTaskTimeout),
                versioningIntent: (0, versioning_intent_enum_1.versioningIntentToProto)(options.versioningIntent),
            });
        });
        return fn({
            args,
            headers: {},
            options: requiredOptions,
        });
    };
}
exports.makeContinueAsNewFunc = makeContinueAsNewFunc;
/**
 * {@link https://docs.temporal.io/concepts/what-is-continue-as-new/ | Continues-As-New} the current Workflow Execution
 * with default options.
 *
 * Shorthand for `makeContinueAsNewFunc<F>()(...args)`. (See: {@link makeContinueAsNewFunc}.)
 *
 * @example
 *
 *```ts
 *import { continueAsNew } from '@temporalio/workflow';
 *
 *export async function myWorkflow(n: number): Promise<void> {
 *  // ... Workflow logic
 *  await continueAsNew<typeof myWorkflow>(n + 1);
 *}
 *```
 */
function continueAsNew(...args) {
    return makeContinueAsNewFunc()(...args);
}
exports.continueAsNew = continueAsNew;
/**
 * Generate an RFC compliant V4 uuid.
 * Uses the workflow's deterministic PRNG making it safe for use within a workflow.
 * This function is cryptographically insecure.
 * See the {@link https://stackoverflow.com/questions/105034/how-to-create-a-guid-uuid | stackoverflow discussion}.
 */
function uuid4() {
    // Return the hexadecimal text representation of number `n`, padded with zeroes to be of length `p`
    const ho = (n, p) => n.toString(16).padStart(p, '0');
    // Create a view backed by a 16-byte buffer
    const view = new DataView(new ArrayBuffer(16));
    // Fill buffer with random values
    view.setUint32(0, (Math.random() * 0x100000000) >>> 0);
    view.setUint32(4, (Math.random() * 0x100000000) >>> 0);
    view.setUint32(8, (Math.random() * 0x100000000) >>> 0);
    view.setUint32(12, (Math.random() * 0x100000000) >>> 0);
    // Patch the 6th byte to reflect a version 4 UUID
    view.setUint8(6, (view.getUint8(6) & 0xf) | 0x40);
    // Patch the 8th byte to reflect a variant 1 UUID (version 4 UUIDs are)
    view.setUint8(8, (view.getUint8(8) & 0x3f) | 0x80);
    // Compile the canonical textual form from the array data
    return `${ho(view.getUint32(0), 8)}-${ho(view.getUint16(4), 4)}-${ho(view.getUint16(6), 4)}-${ho(view.getUint16(8), 4)}-${ho(view.getUint32(10), 8)}${ho(view.getUint16(14), 4)}`;
}
exports.uuid4 = uuid4;
/**
 * Patch or upgrade workflow code by checking or stating that this workflow has a certain patch.
 *
 * See {@link https://docs.temporal.io/typescript/versioning | docs page} for info.
 *
 * If the workflow is replaying an existing history, then this function returns true if that
 * history was produced by a worker which also had a `patched` call with the same `patchId`.
 * If the history was produced by a worker *without* such a call, then it will return false.
 *
 * If the workflow is not currently replaying, then this call *always* returns true.
 *
 * Your workflow code should run the "new" code if this returns true, if it returns false, you
 * should run the "old" code. By doing this, you can maintain determinism.
 *
 * @param patchId An identifier that should be unique to this patch. It is OK to use multiple
 * calls with the same ID, which means all such calls will always return the same value.
 */
function patched(patchId) {
    return patchInternal(patchId, false);
}
exports.patched = patched;
/**
 * Indicate that a patch is being phased out.
 *
 * See {@link https://docs.temporal.io/typescript/versioning | docs page} for info.
 *
 * Workflows with this call may be deployed alongside workflows with a {@link patched} call, but
 * they must *not* be deployed while any workers still exist running old code without a
 * {@link patched} call, or any runs with histories produced by such workers exist. If either kind
 * of worker encounters a history produced by the other, their behavior is undefined.
 *
 * Once all live workflow runs have been produced by workers with this call, you can deploy workers
 * which are free of either kind of patch call for this ID. Workers with and without this call
 * may coexist, as long as they are both running the "new" code.
 *
 * @param patchId An identifier that should be unique to this patch. It is OK to use multiple
 * calls with the same ID, which means all such calls will always return the same value.
 */
function deprecatePatch(patchId) {
    patchInternal(patchId, true);
}
exports.deprecatePatch = deprecatePatch;
function patchInternal(patchId, deprecated) {
    const activator = (0, global_attributes_1.assertInWorkflowContext)('Workflow.patch(...) and Workflow.deprecatePatch may only be used from a Workflow Execution.');
    // Patch operation does not support interception at the moment, if it did,
    // this would be the place to start the interception chain
    if (activator.workflow === undefined) {
        throw new common_1.IllegalStateError('Patches cannot be used before Workflow starts');
    }
    const usePatch = !activator.info.unsafe.isReplaying || activator.knownPresentPatches.has(patchId);
    // Avoid sending commands for patches core already knows about.
    // This optimization enables development of automatic patching tools.
    if (usePatch && !activator.sentPatches.has(patchId)) {
        activator.pushCommand({
            setPatchMarker: { patchId, deprecated },
        });
        activator.sentPatches.add(patchId);
    }
    return usePatch;
}
async function condition(fn, timeout) {
    (0, global_attributes_1.assertInWorkflowContext)('Workflow.condition(...) may only be used from a Workflow Execution.');
    // Prior to 1.5.0, `condition(fn, 0)` was treated as equivalent to `condition(fn, undefined)`
    if (timeout === 0 && !patched(CONDITION_0_PATCH)) {
        return conditionInner(fn);
    }
    if (typeof timeout === 'number' || typeof timeout === 'string') {
        return cancellation_scope_1.CancellationScope.cancellable(async () => {
            try {
                return await Promise.race([sleep(timeout).then(() => false), conditionInner(fn).then(() => true)]);
            }
            finally {
                cancellation_scope_1.CancellationScope.current().cancel();
            }
        });
    }
    return conditionInner(fn);
}
exports.condition = condition;
function conditionInner(fn) {
    const activator = (0, global_attributes_1.getActivator)();
    return new Promise((resolve, reject) => {
        const scope = cancellation_scope_1.CancellationScope.current();
        if (scope.consideredCancelled) {
            (0, stack_helpers_1.untrackPromise)(scope.cancelRequested.catch(reject));
            return;
        }
        const seq = activator.nextSeqs.condition++;
        if (scope.cancellable) {
            (0, stack_helpers_1.untrackPromise)(scope.cancelRequested.catch((err) => {
                activator.blockedConditions.delete(seq);
                reject(err);
            }));
        }
        // Eager evaluation
        if (fn()) {
            resolve();
            return;
        }
        activator.blockedConditions.set(seq, { fn, resolve });
    });
}
/**
 * Define an update method for a Workflow.
 *
 * Definitions are used to register handler in the Workflow via {@link setHandler} and to update Workflows using a {@link WorkflowHandle}, {@link ChildWorkflowHandle} or {@link ExternalWorkflowHandle}.
 * Definitions can be reused in multiple Workflows.
 */
function defineUpdate(name) {
    return {
        type: 'update',
        name,
    };
}
exports.defineUpdate = defineUpdate;
/**
 * Define a signal method for a Workflow.
 *
 * Definitions are used to register handler in the Workflow via {@link setHandler} and to signal Workflows using a {@link WorkflowHandle}, {@link ChildWorkflowHandle} or {@link ExternalWorkflowHandle}.
 * Definitions can be reused in multiple Workflows.
 */
function defineSignal(name) {
    return {
        type: 'signal',
        name,
    };
}
exports.defineSignal = defineSignal;
/**
 * Define a query method for a Workflow.
 *
 * Definitions are used to register handler in the Workflow via {@link setHandler} and to query Workflows using a {@link WorkflowHandle}.
 * Definitions can be reused in multiple Workflows.
 */
function defineQuery(name) {
    return {
        type: 'query',
        name,
    };
}
exports.defineQuery = defineQuery;
// For Updates and Signals we want to make a public guarantee something like the
// following:
//
//   "If a WFT contains a Signal/Update, and if a handler is available for that
//   Signal/Update, then the handler will be executed.""
//
// However, that statement is not well-defined, leaving several questions open:
//
// 1. What does it mean for a handler to be "available"? What happens if the
//    handler is not present initially but is set at some point during the
//    Workflow code that is executed in that WFT? What happens if the handler is
//    set and then deleted, or replaced with a different handler?
//
// 2. When is the handler executed? (When it first becomes available? At the end
//    of the activation?) What are the execution semantics of Workflow and
//    Signal/Update handler code given that they are concurrent? Can the user
//    rely on Signal/Update side effects being reflected in the Workflow return
//    value, or in the value passed to Continue-As-New? If the handler is an
//    async function / coroutine, how much of it is executed and when is the
//    rest executed?
//
// 3. What happens if the handler is not executed? (i.e. because it wasn't
//    available in the sense defined by (1))
//
// 4. In the case of Update, when is the validation function executed?
//
// The implementation for Typescript is as follows:
//
// 1. sdk-core sorts Signal and Update jobs (and Patches) ahead of all other
//    jobs. Thus if the handler is available at the start of the Activation then
//    the Signal/Update will be executed before Workflow code is executed. If it
//    is not, then the Signal/Update calls is pushed to a buffer.
//
// 2. On each call to setHandler for a given Signal/Update, we make a pass
//    through the buffer list. If a buffered job is associated with the just-set
//    handler, then the job is removed from the buffer and the initial
//    synchronous portion of the handler is invoked on that input (i.e.
//    preempting workflow code).
//
// Thus in the case of Typescript the questions above are answered as follows:
//
// 1. A handler is "available" if it is set at the start of the Activation or
//    becomes set at any point during the Activation. If the handler is not set
//    initially then it is executed as soon as it is set. Subsequent deletion or
//    replacement by a different handler has no impact because the jobs it was
//    handling have already been handled and are no longer in the buffer.
//
// 2. The handler is executed as soon as it becomes available. I.e. if the
//    handler is set at the start of the Activation then it is executed when
//    first attempting to process the Signal/Update job; alternatively, if it is
//    set by a setHandler call made by Workflow code, then it is executed as
//    part of that call (preempting Workflow code). Therefore, a user can rely
//    on Signal/Update side effects being reflected in e.g. the Workflow return
//    value, and in the value passed to Continue-As-New. Activation jobs are
//    processed in the order supplied by sdk-core, i.e. Signals, then Updates,
//    then other jobs. Within each group, the order sent by the server is
//    preserved. If the handler is async, it is executed up to its first yield
//    point.
//
// 3. Signal case: If a handler does not become available for a Signal job then
//    the job remains in the buffer. If a handler for the Signal becomes
//    available in a subsequent Activation (of the same or a subsequent WFT)
//    then the handler will be executed. If not, then the Signal will never be
//    responded to and this causes no error.
//
//    Update case: If a handler does not become available for an Update job then
//    the Update is rejected at the end of the Activation. Thus, if a user does
//    not want an Update to be rejected for this reason, then it is their
//    responsibility to ensure that their application and workflow code interact
//    such that a handler is available for the Update during any Activation
//    which might contain their Update job. (Note that the user often has
//    uncertainty about which WFT their Signal/Update will appear in. For
//    example, if they call startWorkflow() followed by startUpdate(), then they
//    will typically not know whether these will be delivered in one or two
//    WFTs. On the other hand there are situations where they would have reason
//    to believe they are in the same WFT, for example if they do not start
//    Worker polling until after they have verified that both requests have
//    succeeded.)
//
// 5. If an Update has a validation function then it is executed immediately
//    prior to the handler. (Note that the validation function is required to be
//    synchronous).
function setHandler(def, handler, options) {
    const activator = (0, global_attributes_1.assertInWorkflowContext)('Workflow.setHandler(...) may only be used from a Workflow Execution.');
    const description = options?.description;
    if (def.type === 'update') {
        if (typeof handler === 'function') {
            const updateOptions = options;
            const validator = updateOptions?.validator;
            activator.updateHandlers.set(def.name, { handler, validator, description });
            activator.dispatchBufferedUpdates();
        }
        else if (handler == null) {
            activator.updateHandlers.delete(def.name);
        }
        else {
            throw new TypeError(`Expected handler to be either a function or 'undefined'. Got: '${typeof handler}'`);
        }
    }
    else if (def.type === 'signal') {
        if (typeof handler === 'function') {
            activator.signalHandlers.set(def.name, { handler: handler, description });
            activator.dispatchBufferedSignals();
        }
        else if (handler == null) {
            activator.signalHandlers.delete(def.name);
        }
        else {
            throw new TypeError(`Expected handler to be either a function or 'undefined'. Got: '${typeof handler}'`);
        }
    }
    else if (def.type === 'query') {
        if (typeof handler === 'function') {
            activator.queryHandlers.set(def.name, { handler: handler, description });
        }
        else if (handler == null) {
            activator.queryHandlers.delete(def.name);
        }
        else {
            throw new TypeError(`Expected handler to be either a function or 'undefined'. Got: '${typeof handler}'`);
        }
    }
    else {
        throw new TypeError(`Invalid definition type: ${def.type}`);
    }
}
exports.setHandler = setHandler;
/**
 * Set a signal handler function that will handle signals calls for non-registered signal names.
 *
 * Signals are dispatched to the default signal handler in the order that they were accepted by the server.
 *
 * If this function is called multiple times for a given signal or query name the last handler will overwrite any previous calls.
 *
 * @param handler a function that will handle signals for non-registered signal names, or `undefined` to unset the handler.
 */
function setDefaultSignalHandler(handler) {
    const activator = (0, global_attributes_1.assertInWorkflowContext)('Workflow.setDefaultSignalHandler(...) may only be used from a Workflow Execution.');
    if (typeof handler === 'function') {
        activator.defaultSignalHandler = handler;
        activator.dispatchBufferedSignals();
    }
    else if (handler == null) {
        activator.defaultSignalHandler = undefined;
    }
    else {
        throw new TypeError(`Expected handler to be either a function or 'undefined'. Got: '${typeof handler}'`);
    }
}
exports.setDefaultSignalHandler = setDefaultSignalHandler;
/**
 * Updates this Workflow's Search Attributes by merging the provided `searchAttributes` with the existing Search
 * Attributes, `workflowInfo().searchAttributes`.
 *
 * For example, this Workflow code:
 *
 * ```ts
 * upsertSearchAttributes({
 *   CustomIntField: [1],
 *   CustomBoolField: [true]
 * });
 * upsertSearchAttributes({
 *   CustomIntField: [42],
 *   CustomKeywordField: ['durable code', 'is great']
 * });
 * ```
 *
 * would result in the Workflow having these Search Attributes:
 *
 * ```ts
 * {
 *   CustomIntField: [42],
 *   CustomBoolField: [true],
 *   CustomKeywordField: ['durable code', 'is great']
 * }
 * ```
 *
 * @param searchAttributes The Record to merge. Use a value of `[]` to clear a Search Attribute.
 */
function upsertSearchAttributes(searchAttributes) {
    const activator = (0, global_attributes_1.assertInWorkflowContext)('Workflow.upsertSearchAttributes(...) may only be used from a Workflow Execution.');
    if (searchAttributes == null) {
        throw new Error('searchAttributes must be a non-null SearchAttributes');
    }
    activator.pushCommand({
        upsertWorkflowSearchAttributes: {
            searchAttributes: (0, common_1.mapToPayloads)(common_1.searchAttributePayloadConverter, searchAttributes),
        },
    });
    activator.mutateWorkflowInfo((info) => {
        return {
            ...info,
            searchAttributes: {
                ...info.searchAttributes,
                ...searchAttributes,
            },
        };
    });
}
exports.upsertSearchAttributes = upsertSearchAttributes;
exports.stackTraceQuery = defineQuery('__stack_trace');
exports.enhancedStackTraceQuery = defineQuery('__enhanced_stack_trace');
exports.workflowMetadataQuery = defineQuery('__temporal_workflow_metadata');


/***/ }),

/***/ "../../node_modules/@temporalio/workflow/node_modules/@temporalio/common/lib/activity-options.js":
/*!*******************************************************************************************************!*\
  !*** ../../node_modules/@temporalio/workflow/node_modules/@temporalio/common/lib/activity-options.js ***!
  \*******************************************************************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.ActivityCancellationType = void 0;
const type_helpers_1 = __webpack_require__(/*! ./type-helpers */ "../../node_modules/@temporalio/workflow/node_modules/@temporalio/common/lib/type-helpers.js");
// Avoid importing the proto implementation to reduce workflow bundle size
// Copied from coresdk.workflow_commands.ActivityCancellationType
var ActivityCancellationType;
(function (ActivityCancellationType) {
    ActivityCancellationType[ActivityCancellationType["TRY_CANCEL"] = 0] = "TRY_CANCEL";
    ActivityCancellationType[ActivityCancellationType["WAIT_CANCELLATION_COMPLETED"] = 1] = "WAIT_CANCELLATION_COMPLETED";
    ActivityCancellationType[ActivityCancellationType["ABANDON"] = 2] = "ABANDON";
})(ActivityCancellationType || (exports.ActivityCancellationType = ActivityCancellationType = {}));
(0, type_helpers_1.checkExtends)();
(0, type_helpers_1.checkExtends)();


/***/ }),

/***/ "../../node_modules/@temporalio/workflow/node_modules/@temporalio/common/lib/converter/data-converter.js":
/*!***************************************************************************************************************!*\
  !*** ../../node_modules/@temporalio/workflow/node_modules/@temporalio/common/lib/converter/data-converter.js ***!
  \***************************************************************************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.defaultDataConverter = exports.defaultFailureConverter = void 0;
const failure_converter_1 = __webpack_require__(/*! ./failure-converter */ "../../node_modules/@temporalio/workflow/node_modules/@temporalio/common/lib/converter/failure-converter.js");
const payload_converter_1 = __webpack_require__(/*! ./payload-converter */ "../../node_modules/@temporalio/workflow/node_modules/@temporalio/common/lib/converter/payload-converter.js");
/**
 * The default {@link FailureConverter} used by the SDK.
 *
 * Error messages and stack traces are serizalized as plain text.
 */
exports.defaultFailureConverter = new failure_converter_1.DefaultFailureConverter();
/**
 * A "loaded" data converter that uses the default set of failure and payload converters.
 */
exports.defaultDataConverter = {
    payloadConverter: payload_converter_1.defaultPayloadConverter,
    failureConverter: exports.defaultFailureConverter,
    payloadCodecs: [],
};


/***/ }),

/***/ "../../node_modules/@temporalio/workflow/node_modules/@temporalio/common/lib/converter/failure-converter.js":
/*!******************************************************************************************************************!*\
  !*** ../../node_modules/@temporalio/workflow/node_modules/@temporalio/common/lib/converter/failure-converter.js ***!
  \******************************************************************************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.DefaultFailureConverter = exports.cutoffStackTrace = void 0;
const failure_1 = __webpack_require__(/*! ../failure */ "../../node_modules/@temporalio/workflow/node_modules/@temporalio/common/lib/failure.js");
const type_helpers_1 = __webpack_require__(/*! ../type-helpers */ "../../node_modules/@temporalio/workflow/node_modules/@temporalio/common/lib/type-helpers.js");
const payload_converter_1 = __webpack_require__(/*! ./payload-converter */ "../../node_modules/@temporalio/workflow/node_modules/@temporalio/common/lib/converter/payload-converter.js");
function combineRegExp(...regexps) {
    return new RegExp(regexps.map((x) => `(?:${x.source})`).join('|'));
}
/**
 * Stack traces will be cutoff when on of these patterns is matched
 */
const CUTOFF_STACK_PATTERNS = combineRegExp(
/** Activity execution */
/\s+at Activity\.execute \(.*[\\/]worker[\\/](?:src|lib)[\\/]activity\.[jt]s:\d+:\d+\)/, 
/** Workflow activation */
/\s+at Activator\.\S+NextHandler \(.*[\\/]workflow[\\/](?:src|lib)[\\/]internals\.[jt]s:\d+:\d+\)/, 
/** Workflow run anything in context */
/\s+at Script\.runInContext \((?:node:vm|vm\.js):\d+:\d+\)/);
/**
 * Any stack trace frames that match any of those wil be dopped.
 * The "null." prefix on some cases is to avoid https://github.com/nodejs/node/issues/42417
 */
const DROPPED_STACK_FRAMES_PATTERNS = combineRegExp(
/** Internal functions used to recursively chain interceptors */
/\s+at (null\.)?next \(.*[\\/]common[\\/](?:src|lib)[\\/]interceptors\.[jt]s:\d+:\d+\)/, 
/** Internal functions used to recursively chain interceptors */
/\s+at (null\.)?executeNextHandler \(.*[\\/]worker[\\/](?:src|lib)[\\/]activity\.[jt]s:\d+:\d+\)/);
/**
 * Cuts out the framework part of a stack trace, leaving only user code entries
 */
function cutoffStackTrace(stack) {
    const lines = (stack ?? '').split(/\r?\n/);
    const acc = Array();
    for (const line of lines) {
        if (CUTOFF_STACK_PATTERNS.test(line))
            break;
        if (!DROPPED_STACK_FRAMES_PATTERNS.test(line))
            acc.push(line);
    }
    return acc.join('\n');
}
exports.cutoffStackTrace = cutoffStackTrace;
/**
 * Default, cross-language-compatible Failure converter.
 *
 * By default, it will leave error messages and stack traces as plain text. In order to encrypt them, set
 * `encodeCommonAttributes` to `true` in the constructor options and use a {@link PayloadCodec} that can encrypt /
 * decrypt Payloads in your {@link WorkerOptions.dataConverter | Worker} and
 * {@link ClientOptions.dataConverter | Client options}.
 */
class DefaultFailureConverter {
    constructor(options) {
        const { encodeCommonAttributes } = options ?? {};
        this.options = {
            encodeCommonAttributes: encodeCommonAttributes ?? false,
        };
    }
    /**
     * Converts a Failure proto message to a JS Error object.
     *
     * Does not set common properties, that is done in {@link failureToError}.
     */
    failureToErrorInner(failure, payloadConverter) {
        if (failure.applicationFailureInfo) {
            return new failure_1.ApplicationFailure(failure.message ?? undefined, failure.applicationFailureInfo.type, Boolean(failure.applicationFailureInfo.nonRetryable), (0, payload_converter_1.arrayFromPayloads)(payloadConverter, failure.applicationFailureInfo.details?.payloads), this.optionalFailureToOptionalError(failure.cause, payloadConverter));
        }
        if (failure.serverFailureInfo) {
            return new failure_1.ServerFailure(failure.message ?? undefined, Boolean(failure.serverFailureInfo.nonRetryable), this.optionalFailureToOptionalError(failure.cause, payloadConverter));
        }
        if (failure.timeoutFailureInfo) {
            return new failure_1.TimeoutFailure(failure.message ?? undefined, (0, payload_converter_1.fromPayloadsAtIndex)(payloadConverter, 0, failure.timeoutFailureInfo.lastHeartbeatDetails?.payloads), failure.timeoutFailureInfo.timeoutType ?? failure_1.TimeoutType.TIMEOUT_TYPE_UNSPECIFIED);
        }
        if (failure.terminatedFailureInfo) {
            return new failure_1.TerminatedFailure(failure.message ?? undefined, this.optionalFailureToOptionalError(failure.cause, payloadConverter));
        }
        if (failure.canceledFailureInfo) {
            return new failure_1.CancelledFailure(failure.message ?? undefined, (0, payload_converter_1.arrayFromPayloads)(payloadConverter, failure.canceledFailureInfo.details?.payloads), this.optionalFailureToOptionalError(failure.cause, payloadConverter));
        }
        if (failure.resetWorkflowFailureInfo) {
            return new failure_1.ApplicationFailure(failure.message ?? undefined, 'ResetWorkflow', false, (0, payload_converter_1.arrayFromPayloads)(payloadConverter, failure.resetWorkflowFailureInfo.lastHeartbeatDetails?.payloads), this.optionalFailureToOptionalError(failure.cause, payloadConverter));
        }
        if (failure.childWorkflowExecutionFailureInfo) {
            const { namespace, workflowType, workflowExecution, retryState } = failure.childWorkflowExecutionFailureInfo;
            if (!(workflowType?.name && workflowExecution)) {
                throw new TypeError('Missing attributes on childWorkflowExecutionFailureInfo');
            }
            return new failure_1.ChildWorkflowFailure(namespace ?? undefined, workflowExecution, workflowType.name, retryState ?? failure_1.RetryState.RETRY_STATE_UNSPECIFIED, this.optionalFailureToOptionalError(failure.cause, payloadConverter));
        }
        if (failure.activityFailureInfo) {
            if (!failure.activityFailureInfo.activityType?.name) {
                throw new TypeError('Missing activityType?.name on activityFailureInfo');
            }
            return new failure_1.ActivityFailure(failure.message ?? undefined, failure.activityFailureInfo.activityType.name, failure.activityFailureInfo.activityId ?? undefined, failure.activityFailureInfo.retryState ?? failure_1.RetryState.RETRY_STATE_UNSPECIFIED, failure.activityFailureInfo.identity ?? undefined, this.optionalFailureToOptionalError(failure.cause, payloadConverter));
        }
        return new failure_1.TemporalFailure(failure.message ?? undefined, this.optionalFailureToOptionalError(failure.cause, payloadConverter));
    }
    failureToError(failure, payloadConverter) {
        if (failure.encodedAttributes) {
            const attrs = payloadConverter.fromPayload(failure.encodedAttributes);
            // Don't apply encodedAttributes unless they conform to an expected schema
            if (typeof attrs === 'object' && attrs !== null) {
                const { message, stack_trace } = attrs;
                // Avoid mutating the argument
                failure = { ...failure };
                if (typeof message === 'string') {
                    failure.message = message;
                }
                if (typeof stack_trace === 'string') {
                    failure.stackTrace = stack_trace;
                }
            }
        }
        const err = this.failureToErrorInner(failure, payloadConverter);
        err.stack = failure.stackTrace ?? '';
        err.failure = failure;
        return err;
    }
    errorToFailure(err, payloadConverter) {
        const failure = this.errorToFailureInner(err, payloadConverter);
        if (this.options.encodeCommonAttributes) {
            const { message, stackTrace } = failure;
            failure.message = 'Encoded failure';
            failure.stackTrace = '';
            failure.encodedAttributes = payloadConverter.toPayload({ message, stack_trace: stackTrace });
        }
        return failure;
    }
    errorToFailureInner(err, payloadConverter) {
        if (err instanceof failure_1.TemporalFailure) {
            if (err.failure)
                return err.failure;
            const base = {
                message: err.message,
                stackTrace: cutoffStackTrace(err.stack),
                cause: this.optionalErrorToOptionalFailure(err.cause, payloadConverter),
                source: failure_1.FAILURE_SOURCE,
            };
            if (err instanceof failure_1.ActivityFailure) {
                return {
                    ...base,
                    activityFailureInfo: {
                        ...err,
                        activityType: { name: err.activityType },
                    },
                };
            }
            if (err instanceof failure_1.ChildWorkflowFailure) {
                return {
                    ...base,
                    childWorkflowExecutionFailureInfo: {
                        ...err,
                        workflowExecution: err.execution,
                        workflowType: { name: err.workflowType },
                    },
                };
            }
            if (err instanceof failure_1.ApplicationFailure) {
                return {
                    ...base,
                    applicationFailureInfo: {
                        type: err.type,
                        nonRetryable: err.nonRetryable,
                        details: err.details && err.details.length
                            ? { payloads: (0, payload_converter_1.toPayloads)(payloadConverter, ...err.details) }
                            : undefined,
                    },
                };
            }
            if (err instanceof failure_1.CancelledFailure) {
                return {
                    ...base,
                    canceledFailureInfo: {
                        details: err.details && err.details.length
                            ? { payloads: (0, payload_converter_1.toPayloads)(payloadConverter, ...err.details) }
                            : undefined,
                    },
                };
            }
            if (err instanceof failure_1.TimeoutFailure) {
                return {
                    ...base,
                    timeoutFailureInfo: {
                        timeoutType: err.timeoutType,
                        lastHeartbeatDetails: err.lastHeartbeatDetails
                            ? { payloads: (0, payload_converter_1.toPayloads)(payloadConverter, err.lastHeartbeatDetails) }
                            : undefined,
                    },
                };
            }
            if (err instanceof failure_1.ServerFailure) {
                return {
                    ...base,
                    serverFailureInfo: { nonRetryable: err.nonRetryable },
                };
            }
            if (err instanceof failure_1.TerminatedFailure) {
                return {
                    ...base,
                    terminatedFailureInfo: {},
                };
            }
            // Just a TemporalFailure
            return base;
        }
        const base = {
            source: failure_1.FAILURE_SOURCE,
        };
        if ((0, type_helpers_1.isError)(err)) {
            return {
                ...base,
                message: String(err.message) ?? '',
                stackTrace: cutoffStackTrace(err.stack),
                cause: this.optionalErrorToOptionalFailure(err.cause, payloadConverter),
            };
        }
        const recommendation = ` [A non-Error value was thrown from your code. We recommend throwing Error objects so that we can provide a stack trace]`;
        if (typeof err === 'string') {
            return { ...base, message: err + recommendation };
        }
        if (typeof err === 'object') {
            let message = '';
            try {
                message = JSON.stringify(err);
            }
            catch (_err) {
                message = String(err);
            }
            return { ...base, message: message + recommendation };
        }
        return { ...base, message: String(err) + recommendation };
    }
    /**
     * Converts a Failure proto message to a JS Error object if defined or returns undefined.
     */
    optionalFailureToOptionalError(failure, payloadConverter) {
        return failure ? this.failureToError(failure, payloadConverter) : undefined;
    }
    /**
     * Converts an error to a Failure proto message if defined or returns undefined
     */
    optionalErrorToOptionalFailure(err, payloadConverter) {
        return err ? this.errorToFailure(err, payloadConverter) : undefined;
    }
}
exports.DefaultFailureConverter = DefaultFailureConverter;


/***/ }),

/***/ "../../node_modules/@temporalio/workflow/node_modules/@temporalio/common/lib/converter/payload-codec.js":
/*!**************************************************************************************************************!*\
  !*** ../../node_modules/@temporalio/workflow/node_modules/@temporalio/common/lib/converter/payload-codec.js ***!
  \**************************************************************************************************************/
/***/ ((__unused_webpack_module, exports) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({ value: true }));


/***/ }),

/***/ "../../node_modules/@temporalio/workflow/node_modules/@temporalio/common/lib/converter/payload-converter.js":
/*!******************************************************************************************************************!*\
  !*** ../../node_modules/@temporalio/workflow/node_modules/@temporalio/common/lib/converter/payload-converter.js ***!
  \******************************************************************************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.defaultPayloadConverter = exports.DefaultPayloadConverter = exports.searchAttributePayloadConverter = exports.SearchAttributePayloadConverter = exports.JsonPayloadConverter = exports.BinaryPayloadConverter = exports.UndefinedPayloadConverter = exports.CompositePayloadConverter = exports.mapFromPayloads = exports.arrayFromPayloads = exports.fromPayloadsAtIndex = exports.mapToPayloads = exports.toPayloads = void 0;
const encoding_1 = __webpack_require__(/*! ../encoding */ "../../node_modules/@temporalio/workflow/node_modules/@temporalio/common/lib/encoding.js");
const errors_1 = __webpack_require__(/*! ../errors */ "../../node_modules/@temporalio/workflow/node_modules/@temporalio/common/lib/errors.js");
const types_1 = __webpack_require__(/*! ./types */ "../../node_modules/@temporalio/workflow/node_modules/@temporalio/common/lib/converter/types.js");
/**
 * Implements conversion of a list of values.
 *
 * @param converter
 * @param values JS values to convert to Payloads
 * @return list of {@link Payload}s
 * @throws {@link ValueError} if conversion of the value passed as parameter failed for any
 *     reason.
 */
function toPayloads(converter, ...values) {
    if (values.length === 0) {
        return undefined;
    }
    return values.map((value) => converter.toPayload(value));
}
exports.toPayloads = toPayloads;
/**
 * Run {@link PayloadConverter.toPayload} on each value in the map.
 *
 * @throws {@link ValueError} if conversion of any value in the map fails
 */
function mapToPayloads(converter, map) {
    return Object.fromEntries(Object.entries(map).map(([k, v]) => [k, converter.toPayload(v)]));
}
exports.mapToPayloads = mapToPayloads;
/**
 * Implements conversion of an array of values of different types. Useful for deserializing
 * arguments of function invocations.
 *
 * @param converter
 * @param index index of the value in the payloads
 * @param payloads serialized value to convert to JS values.
 * @return converted JS value
 * @throws {@link PayloadConverterError} if conversion of the data passed as parameter failed for any
 *     reason.
 */
function fromPayloadsAtIndex(converter, index, payloads) {
    // To make adding arguments a backwards compatible change
    if (payloads === undefined || payloads === null || index >= payloads.length) {
        return undefined;
    }
    return converter.fromPayload(payloads[index]);
}
exports.fromPayloadsAtIndex = fromPayloadsAtIndex;
/**
 * Run {@link PayloadConverter.fromPayload} on each value in the array.
 */
function arrayFromPayloads(converter, payloads) {
    if (!payloads) {
        return [];
    }
    return payloads.map((payload) => converter.fromPayload(payload));
}
exports.arrayFromPayloads = arrayFromPayloads;
function mapFromPayloads(converter, map) {
    if (map == null)
        return map;
    return Object.fromEntries(Object.entries(map).map(([k, payload]) => {
        const value = converter.fromPayload(payload);
        return [k, value];
    }));
}
exports.mapFromPayloads = mapFromPayloads;
/**
 * Tries to convert values to {@link Payload}s using the {@link PayloadConverterWithEncoding}s provided to the constructor, in the order provided.
 *
 * Converts Payloads to values based on the `Payload.metadata.encoding` field, which matches the {@link PayloadConverterWithEncoding.encodingType}
 * of the converter that created the Payload.
 */
class CompositePayloadConverter {
    constructor(...converters) {
        this.converterByEncoding = new Map();
        if (converters.length === 0) {
            throw new errors_1.PayloadConverterError('Must provide at least one PayloadConverterWithEncoding');
        }
        this.converters = converters;
        for (const converter of converters) {
            this.converterByEncoding.set(converter.encodingType, converter);
        }
    }
    /**
     * Tries to run `.toPayload(value)` on each converter in the order provided at construction.
     * Returns the first successful result, throws {@link ValueError} if there is no converter that can handle the value.
     */
    toPayload(value) {
        for (const converter of this.converters) {
            const result = converter.toPayload(value);
            if (result !== undefined) {
                return result;
            }
        }
        throw new errors_1.ValueError(`Unable to convert ${value} to payload`);
    }
    /**
     * Run {@link PayloadConverterWithEncoding.fromPayload} based on the `encoding` metadata of the {@link Payload}.
     */
    fromPayload(payload) {
        if (payload.metadata === undefined || payload.metadata === null) {
            throw new errors_1.ValueError('Missing payload metadata');
        }
        const encoding = (0, encoding_1.decode)(payload.metadata[types_1.METADATA_ENCODING_KEY]);
        const converter = this.converterByEncoding.get(encoding);
        if (converter === undefined) {
            throw new errors_1.ValueError(`Unknown encoding: ${encoding}`);
        }
        return converter.fromPayload(payload);
    }
}
exports.CompositePayloadConverter = CompositePayloadConverter;
/**
 * Converts between JS undefined and NULL Payload
 */
class UndefinedPayloadConverter {
    constructor() {
        this.encodingType = types_1.encodingTypes.METADATA_ENCODING_NULL;
    }
    toPayload(value) {
        if (value !== undefined) {
            return undefined;
        }
        return {
            metadata: {
                [types_1.METADATA_ENCODING_KEY]: types_1.encodingKeys.METADATA_ENCODING_NULL,
            },
        };
    }
    fromPayload(_content) {
        return undefined; // Just return undefined
    }
}
exports.UndefinedPayloadConverter = UndefinedPayloadConverter;
/**
 * Converts between binary data types and RAW Payload
 */
class BinaryPayloadConverter {
    constructor() {
        this.encodingType = types_1.encodingTypes.METADATA_ENCODING_RAW;
    }
    toPayload(value) {
        if (!(value instanceof Uint8Array)) {
            return undefined;
        }
        return {
            metadata: {
                [types_1.METADATA_ENCODING_KEY]: types_1.encodingKeys.METADATA_ENCODING_RAW,
            },
            data: value,
        };
    }
    fromPayload(content) {
        return (
        // Wrap with Uint8Array from this context to ensure `instanceof` works
        (content.data ? new Uint8Array(content.data.buffer, content.data.byteOffset, content.data.length) : content.data));
    }
}
exports.BinaryPayloadConverter = BinaryPayloadConverter;
/**
 * Converts between non-undefined values and serialized JSON Payload
 */
class JsonPayloadConverter {
    constructor() {
        this.encodingType = types_1.encodingTypes.METADATA_ENCODING_JSON;
    }
    toPayload(value) {
        if (value === undefined) {
            return undefined;
        }
        let json;
        try {
            json = JSON.stringify(value);
        }
        catch (err) {
            return undefined;
        }
        return {
            metadata: {
                [types_1.METADATA_ENCODING_KEY]: types_1.encodingKeys.METADATA_ENCODING_JSON,
            },
            data: (0, encoding_1.encode)(json),
        };
    }
    fromPayload(content) {
        if (content.data === undefined || content.data === null) {
            throw new errors_1.ValueError('Got payload with no data');
        }
        return JSON.parse((0, encoding_1.decode)(content.data));
    }
}
exports.JsonPayloadConverter = JsonPayloadConverter;
/**
 * Converts Search Attribute values using JsonPayloadConverter
 */
class SearchAttributePayloadConverter {
    constructor() {
        this.jsonConverter = new JsonPayloadConverter();
        this.validNonDateTypes = ['string', 'number', 'boolean'];
    }
    toPayload(values) {
        if (!Array.isArray(values)) {
            throw new errors_1.ValueError(`SearchAttribute value must be an array`);
        }
        if (values.length > 0) {
            const firstValue = values[0];
            const firstType = typeof firstValue;
            if (firstType === 'object') {
                for (const [idx, value] of values.entries()) {
                    if (!(value instanceof Date)) {
                        throw new errors_1.ValueError(`SearchAttribute values must arrays of strings, numbers, booleans, or Dates. The value ${value} at index ${idx} is of type ${typeof value}`);
                    }
                }
            }
            else {
                if (!this.validNonDateTypes.includes(firstType)) {
                    throw new errors_1.ValueError(`SearchAttribute array values must be: string | number | boolean | Date`);
                }
                for (const [idx, value] of values.entries()) {
                    if (typeof value !== firstType) {
                        throw new errors_1.ValueError(`All SearchAttribute array values must be of the same type. The first value ${firstValue} of type ${firstType} doesn't match value ${value} of type ${typeof value} at index ${idx}`);
                    }
                }
            }
        }
        // JSON.stringify takes care of converting Dates to ISO strings
        const ret = this.jsonConverter.toPayload(values);
        if (ret === undefined) {
            throw new errors_1.ValueError('Could not convert search attributes to payloads');
        }
        return ret;
    }
    /**
     * Datetime Search Attribute values are converted to `Date`s
     */
    fromPayload(payload) {
        if (payload.metadata === undefined || payload.metadata === null) {
            throw new errors_1.ValueError('Missing payload metadata');
        }
        const value = this.jsonConverter.fromPayload(payload);
        let arrayWrappedValue = Array.isArray(value) ? value : [value];
        const searchAttributeType = (0, encoding_1.decode)(payload.metadata.type);
        if (searchAttributeType === 'Datetime') {
            arrayWrappedValue = arrayWrappedValue.map((dateString) => new Date(dateString));
        }
        return arrayWrappedValue;
    }
}
exports.SearchAttributePayloadConverter = SearchAttributePayloadConverter;
exports.searchAttributePayloadConverter = new SearchAttributePayloadConverter();
class DefaultPayloadConverter extends CompositePayloadConverter {
    // Match the order used in other SDKs, but exclude Protobuf converters so that the code, including
    // `proto3-json-serializer`, doesn't take space in Workflow bundles that don't use Protobufs. To use Protobufs, use
    // {@link DefaultPayloadConverterWithProtobufs}.
    //
    // Go SDK:
    // https://github.com/temporalio/sdk-go/blob/5e5645f0c550dcf717c095ae32c76a7087d2e985/converter/default_data_converter.go#L28
    constructor() {
        super(new UndefinedPayloadConverter(), new BinaryPayloadConverter(), new JsonPayloadConverter());
    }
}
exports.DefaultPayloadConverter = DefaultPayloadConverter;
/**
 * The default {@link PayloadConverter} used by the SDK. Supports `Uint8Array` and JSON serializables (so if
 * {@link https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/JSON/stringify#description | `JSON.stringify(yourArgOrRetval)`}
 * works, the default payload converter will work).
 *
 * To also support Protobufs, create a custom payload converter with {@link DefaultPayloadConverter}:
 *
 * `const myConverter = new DefaultPayloadConverter({ protobufRoot })`
 */
exports.defaultPayloadConverter = new DefaultPayloadConverter();


/***/ }),

/***/ "../../node_modules/@temporalio/workflow/node_modules/@temporalio/common/lib/converter/types.js":
/*!******************************************************************************************************!*\
  !*** ../../node_modules/@temporalio/workflow/node_modules/@temporalio/common/lib/converter/types.js ***!
  \******************************************************************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.METADATA_MESSAGE_TYPE_KEY = exports.encodingKeys = exports.encodingTypes = exports.METADATA_ENCODING_KEY = void 0;
const encoding_1 = __webpack_require__(/*! ../encoding */ "../../node_modules/@temporalio/workflow/node_modules/@temporalio/common/lib/encoding.js");
exports.METADATA_ENCODING_KEY = 'encoding';
exports.encodingTypes = {
    METADATA_ENCODING_NULL: 'binary/null',
    METADATA_ENCODING_RAW: 'binary/plain',
    METADATA_ENCODING_JSON: 'json/plain',
    METADATA_ENCODING_PROTOBUF_JSON: 'json/protobuf',
    METADATA_ENCODING_PROTOBUF: 'binary/protobuf',
};
exports.encodingKeys = {
    METADATA_ENCODING_NULL: (0, encoding_1.encode)(exports.encodingTypes.METADATA_ENCODING_NULL),
    METADATA_ENCODING_RAW: (0, encoding_1.encode)(exports.encodingTypes.METADATA_ENCODING_RAW),
    METADATA_ENCODING_JSON: (0, encoding_1.encode)(exports.encodingTypes.METADATA_ENCODING_JSON),
    METADATA_ENCODING_PROTOBUF_JSON: (0, encoding_1.encode)(exports.encodingTypes.METADATA_ENCODING_PROTOBUF_JSON),
    METADATA_ENCODING_PROTOBUF: (0, encoding_1.encode)(exports.encodingTypes.METADATA_ENCODING_PROTOBUF),
};
exports.METADATA_MESSAGE_TYPE_KEY = 'messageType';


/***/ }),

/***/ "../../node_modules/@temporalio/workflow/node_modules/@temporalio/common/lib/deprecated-time.js":
/*!******************************************************************************************************!*\
  !*** ../../node_modules/@temporalio/workflow/node_modules/@temporalio/common/lib/deprecated-time.js ***!
  \******************************************************************************************************/
/***/ (function(__unused_webpack_module, exports, __webpack_require__) {

"use strict";

var __createBinding = (this && this.__createBinding) || (Object.create ? (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    var desc = Object.getOwnPropertyDescriptor(m, k);
    if (!desc || ("get" in desc ? !m.__esModule : desc.writable || desc.configurable)) {
      desc = { enumerable: true, get: function() { return m[k]; } };
    }
    Object.defineProperty(o, k2, desc);
}) : (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    o[k2] = m[k];
}));
var __setModuleDefault = (this && this.__setModuleDefault) || (Object.create ? (function(o, v) {
    Object.defineProperty(o, "default", { enumerable: true, value: v });
}) : function(o, v) {
    o["default"] = v;
});
var __importStar = (this && this.__importStar) || function (mod) {
    if (mod && mod.__esModule) return mod;
    var result = {};
    if (mod != null) for (var k in mod) if (k !== "default" && Object.prototype.hasOwnProperty.call(mod, k)) __createBinding(result, mod, k);
    __setModuleDefault(result, mod);
    return result;
};
Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.optionalTsToDate = exports.tsToDate = exports.msToNumber = exports.msOptionalToNumber = exports.msOptionalToTs = exports.msToTs = exports.msNumberToTs = exports.tsToMs = exports.optionalTsToMs = void 0;
const time = __importStar(__webpack_require__(/*! ./time */ "../../node_modules/@temporalio/workflow/node_modules/@temporalio/common/lib/time.js"));
/**
 * Lossy conversion function from Timestamp to number due to possible overflow.
 * If ts is null or undefined returns undefined.
 *
 * @hidden
 * @deprecated - meant for internal use only
 */
function optionalTsToMs(ts) {
    return time.optionalTsToMs(ts);
}
exports.optionalTsToMs = optionalTsToMs;
/**
 * Lossy conversion function from Timestamp to number due to possible overflow
 *
 * @hidden
 * @deprecated - meant for internal use only
 * @deprecated - meant for internal use only
 */
function tsToMs(ts) {
    return time.tsToMs(ts);
}
exports.tsToMs = tsToMs;
/**
 * @hidden
 * @deprecated - meant for internal use only
 */
function msNumberToTs(millis) {
    return time.msNumberToTs(millis);
}
exports.msNumberToTs = msNumberToTs;
/**
 * @hidden
 * @deprecated - meant for internal use only
 */
function msToTs(str) {
    return time.msToTs(str);
}
exports.msToTs = msToTs;
/**
 * @hidden
 * @deprecated - meant for internal use only
 */
function msOptionalToTs(str) {
    return time.msOptionalToTs(str);
}
exports.msOptionalToTs = msOptionalToTs;
/**
 * @hidden
 * @deprecated - meant for internal use only
 */
function msOptionalToNumber(val) {
    return time.msOptionalToNumber(val);
}
exports.msOptionalToNumber = msOptionalToNumber;
/**
 * @hidden
 * @deprecated - meant for internal use only
 */
function msToNumber(val) {
    return time.msToNumber(val);
}
exports.msToNumber = msToNumber;
/**
 * @hidden
 * @deprecated - meant for internal use only
 */
function tsToDate(ts) {
    return time.tsToDate(ts);
}
exports.tsToDate = tsToDate;
/**
 * @hidden
 * @deprecated - meant for internal use only
 */
function optionalTsToDate(ts) {
    return time.optionalTsToDate(ts);
}
exports.optionalTsToDate = optionalTsToDate;


/***/ }),

/***/ "../../node_modules/@temporalio/workflow/node_modules/@temporalio/common/lib/encoding.js":
/*!***********************************************************************************************!*\
  !*** ../../node_modules/@temporalio/workflow/node_modules/@temporalio/common/lib/encoding.js ***!
  \***********************************************************************************************/
/***/ ((__unused_webpack_module, exports) => {

"use strict";

// Pasted with modifications from: https://raw.githubusercontent.com/anonyco/FastestSmallestTextEncoderDecoder/master/EncoderDecoderTogether.src.js
/* eslint no-fallthrough: 0 */
Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.decode = exports.encode = exports.TextEncoder = exports.TextDecoder = void 0;
const fromCharCode = String.fromCharCode;
const encoderRegexp = /[\x80-\uD7ff\uDC00-\uFFFF]|[\uD800-\uDBFF][\uDC00-\uDFFF]?/g;
const tmpBufferU16 = new Uint16Array(32);
class TextDecoder {
    decode(inputArrayOrBuffer) {
        const inputAs8 = inputArrayOrBuffer instanceof Uint8Array ? inputArrayOrBuffer : new Uint8Array(inputArrayOrBuffer);
        let resultingString = '', tmpStr = '', index = 0, nextEnd = 0, cp0 = 0, codePoint = 0, minBits = 0, cp1 = 0, pos = 0, tmp = -1;
        const len = inputAs8.length | 0;
        const lenMinus32 = (len - 32) | 0;
        // Note that tmp represents the 2nd half of a surrogate pair incase a surrogate gets divided between blocks
        for (; index < len;) {
            nextEnd = index <= lenMinus32 ? 32 : (len - index) | 0;
            for (; pos < nextEnd; index = (index + 1) | 0, pos = (pos + 1) | 0) {
                cp0 = inputAs8[index] & 0xff;
                switch (cp0 >> 4) {
                    case 15:
                        cp1 = inputAs8[(index = (index + 1) | 0)] & 0xff;
                        if (cp1 >> 6 !== 0b10 || 0b11110111 < cp0) {
                            index = (index - 1) | 0;
                            break;
                        }
                        codePoint = ((cp0 & 0b111) << 6) | (cp1 & 0b00111111);
                        minBits = 5; // 20 ensures it never passes -> all invalid replacements
                        cp0 = 0x100; //  keep track of th bit size
                    case 14:
                        cp1 = inputAs8[(index = (index + 1) | 0)] & 0xff;
                        codePoint <<= 6;
                        codePoint |= ((cp0 & 0b1111) << 6) | (cp1 & 0b00111111);
                        minBits = cp1 >> 6 === 0b10 ? (minBits + 4) | 0 : 24; // 24 ensures it never passes -> all invalid replacements
                        cp0 = (cp0 + 0x100) & 0x300; // keep track of th bit size
                    case 13:
                    case 12:
                        cp1 = inputAs8[(index = (index + 1) | 0)] & 0xff;
                        codePoint <<= 6;
                        codePoint |= ((cp0 & 0b11111) << 6) | (cp1 & 0b00111111);
                        minBits = (minBits + 7) | 0;
                        // Now, process the code point
                        if (index < len && cp1 >> 6 === 0b10 && codePoint >> minBits && codePoint < 0x110000) {
                            cp0 = codePoint;
                            codePoint = (codePoint - 0x10000) | 0;
                            if (0 <= codePoint /*0xffff < codePoint*/) {
                                // BMP code point
                                //nextEnd = nextEnd - 1|0;
                                tmp = ((codePoint >> 10) + 0xd800) | 0; // highSurrogate
                                cp0 = ((codePoint & 0x3ff) + 0xdc00) | 0; // lowSurrogate (will be inserted later in the switch-statement)
                                if (pos < 31) {
                                    // notice 31 instead of 32
                                    tmpBufferU16[pos] = tmp;
                                    pos = (pos + 1) | 0;
                                    tmp = -1;
                                }
                                else {
                                    // else, we are at the end of the inputAs8 and let tmp0 be filled in later on
                                    // NOTE that cp1 is being used as a temporary variable for the swapping of tmp with cp0
                                    cp1 = tmp;
                                    tmp = cp0;
                                    cp0 = cp1;
                                }
                            }
                            else
                                nextEnd = (nextEnd + 1) | 0; // because we are advancing i without advancing pos
                        }
                        else {
                            // invalid code point means replacing the whole thing with null replacement characters
                            cp0 >>= 8;
                            index = (index - cp0 - 1) | 0; // reset index  back to what it was before
                            cp0 = 0xfffd;
                        }
                        // Finally, reset the variables for the next go-around
                        minBits = 0;
                        codePoint = 0;
                        nextEnd = index <= lenMinus32 ? 32 : (len - index) | 0;
                    /*case 11:
                  case 10:
                  case 9:
                  case 8:
                    codePoint ? codePoint = 0 : cp0 = 0xfffd; // fill with invalid replacement character
                  case 7:
                  case 6:
                  case 5:
                  case 4:
                  case 3:
                  case 2:
                  case 1:
                  case 0:
                    tmpBufferU16[pos] = cp0;
                    continue;*/
                    default: // fill with invalid replacement character
                        tmpBufferU16[pos] = cp0;
                        continue;
                    case 11:
                    case 10:
                    case 9:
                    case 8:
                }
                tmpBufferU16[pos] = 0xfffd; // fill with invalid replacement character
            }
            tmpStr += fromCharCode(tmpBufferU16[0], tmpBufferU16[1], tmpBufferU16[2], tmpBufferU16[3], tmpBufferU16[4], tmpBufferU16[5], tmpBufferU16[6], tmpBufferU16[7], tmpBufferU16[8], tmpBufferU16[9], tmpBufferU16[10], tmpBufferU16[11], tmpBufferU16[12], tmpBufferU16[13], tmpBufferU16[14], tmpBufferU16[15], tmpBufferU16[16], tmpBufferU16[17], tmpBufferU16[18], tmpBufferU16[19], tmpBufferU16[20], tmpBufferU16[21], tmpBufferU16[22], tmpBufferU16[23], tmpBufferU16[24], tmpBufferU16[25], tmpBufferU16[26], tmpBufferU16[27], tmpBufferU16[28], tmpBufferU16[29], tmpBufferU16[30], tmpBufferU16[31]);
            if (pos < 32)
                tmpStr = tmpStr.slice(0, (pos - 32) | 0); //-(32-pos));
            if (index < len) {
                //fromCharCode.apply(0, tmpBufferU16 : Uint8Array ?  tmpBufferU16.subarray(0,pos) : tmpBufferU16.slice(0,pos));
                tmpBufferU16[0] = tmp;
                pos = ~tmp >>> 31; //tmp !== -1 ? 1 : 0;
                tmp = -1;
                if (tmpStr.length < resultingString.length)
                    continue;
            }
            else if (tmp !== -1) {
                tmpStr += fromCharCode(tmp);
            }
            resultingString += tmpStr;
            tmpStr = '';
        }
        return resultingString;
    }
}
exports.TextDecoder = TextDecoder;
//////////////////////////////////////////////////////////////////////////////////////
function encoderReplacer(nonAsciiChars) {
    // make the UTF string into a binary UTF-8 encoded string
    let point = nonAsciiChars.charCodeAt(0) | 0;
    if (0xd800 <= point) {
        if (point <= 0xdbff) {
            const nextcode = nonAsciiChars.charCodeAt(1) | 0; // defaults to 0 when NaN, causing null replacement character
            if (0xdc00 <= nextcode && nextcode <= 0xdfff) {
                //point = ((point - 0xD800)<<10) + nextcode - 0xDC00 + 0x10000|0;
                point = ((point << 10) + nextcode - 0x35fdc00) | 0;
                if (point > 0xffff)
                    return fromCharCode((0x1e /*0b11110*/ << 3) | (point >> 18), (0x2 /*0b10*/ << 6) | ((point >> 12) & 0x3f) /*0b00111111*/, (0x2 /*0b10*/ << 6) | ((point >> 6) & 0x3f) /*0b00111111*/, (0x2 /*0b10*/ << 6) | (point & 0x3f) /*0b00111111*/);
            }
            else
                point = 65533 /*0b1111111111111101*/; //return '\xEF\xBF\xBD';//fromCharCode(0xef, 0xbf, 0xbd);
        }
        else if (point <= 0xdfff) {
            point = 65533 /*0b1111111111111101*/; //return '\xEF\xBF\xBD';//fromCharCode(0xef, 0xbf, 0xbd);
        }
    }
    /*if (point <= 0x007f) return nonAsciiChars;
    else */ if (point <= 0x07ff) {
        return fromCharCode((0x6 << 5) | (point >> 6), (0x2 << 6) | (point & 0x3f));
    }
    else
        return fromCharCode((0xe /*0b1110*/ << 4) | (point >> 12), (0x2 /*0b10*/ << 6) | ((point >> 6) & 0x3f) /*0b00111111*/, (0x2 /*0b10*/ << 6) | (point & 0x3f) /*0b00111111*/);
}
class TextEncoder {
    encode(inputString) {
        // 0xc0 => 0b11000000; 0xff => 0b11111111; 0xc0-0xff => 0b11xxxxxx
        // 0x80 => 0b10000000; 0xbf => 0b10111111; 0x80-0xbf => 0b10xxxxxx
        const encodedString = inputString === void 0 ? '' : '' + inputString, len = encodedString.length | 0;
        let result = new Uint8Array(((len << 1) + 8) | 0);
        let tmpResult;
        let i = 0, pos = 0, point = 0, nextcode = 0;
        let upgradededArraySize = !Uint8Array; // normal arrays are auto-expanding
        for (i = 0; i < len; i = (i + 1) | 0, pos = (pos + 1) | 0) {
            point = encodedString.charCodeAt(i) | 0;
            if (point <= 0x007f) {
                result[pos] = point;
            }
            else if (point <= 0x07ff) {
                result[pos] = (0x6 << 5) | (point >> 6);
                result[(pos = (pos + 1) | 0)] = (0x2 << 6) | (point & 0x3f);
            }
            else {
                widenCheck: {
                    if (0xd800 <= point) {
                        if (point <= 0xdbff) {
                            nextcode = encodedString.charCodeAt((i = (i + 1) | 0)) | 0; // defaults to 0 when NaN, causing null replacement character
                            if (0xdc00 <= nextcode && nextcode <= 0xdfff) {
                                //point = ((point - 0xD800)<<10) + nextcode - 0xDC00 + 0x10000|0;
                                point = ((point << 10) + nextcode - 0x35fdc00) | 0;
                                if (point > 0xffff) {
                                    result[pos] = (0x1e /*0b11110*/ << 3) | (point >> 18);
                                    result[(pos = (pos + 1) | 0)] = (0x2 /*0b10*/ << 6) | ((point >> 12) & 0x3f) /*0b00111111*/;
                                    result[(pos = (pos + 1) | 0)] = (0x2 /*0b10*/ << 6) | ((point >> 6) & 0x3f) /*0b00111111*/;
                                    result[(pos = (pos + 1) | 0)] = (0x2 /*0b10*/ << 6) | (point & 0x3f) /*0b00111111*/;
                                    continue;
                                }
                                break widenCheck;
                            }
                            point = 65533 /*0b1111111111111101*/; //return '\xEF\xBF\xBD';//fromCharCode(0xef, 0xbf, 0xbd);
                        }
                        else if (point <= 0xdfff) {
                            point = 65533 /*0b1111111111111101*/; //return '\xEF\xBF\xBD';//fromCharCode(0xef, 0xbf, 0xbd);
                        }
                    }
                    if (!upgradededArraySize && i << 1 < pos && i << 1 < ((pos - 7) | 0)) {
                        upgradededArraySize = true;
                        tmpResult = new Uint8Array(len * 3);
                        tmpResult.set(result);
                        result = tmpResult;
                    }
                }
                result[pos] = (0xe /*0b1110*/ << 4) | (point >> 12);
                result[(pos = (pos + 1) | 0)] = (0x2 /*0b10*/ << 6) | ((point >> 6) & 0x3f) /*0b00111111*/;
                result[(pos = (pos + 1) | 0)] = (0x2 /*0b10*/ << 6) | (point & 0x3f) /*0b00111111*/;
            }
        }
        return Uint8Array ? result.subarray(0, pos) : result.slice(0, pos);
    }
    encodeInto(inputString, u8Arr) {
        const encodedString = inputString === void 0 ? '' : ('' + inputString).replace(encoderRegexp, encoderReplacer);
        let len = encodedString.length | 0, i = 0, char = 0, read = 0;
        const u8ArrLen = u8Arr.length | 0;
        const inputLength = inputString.length | 0;
        if (u8ArrLen < len)
            len = u8ArrLen;
        putChars: {
            for (; i < len; i = (i + 1) | 0) {
                char = encodedString.charCodeAt(i) | 0;
                switch (char >> 4) {
                    case 0:
                    case 1:
                    case 2:
                    case 3:
                    case 4:
                    case 5:
                    case 6:
                    case 7:
                        read = (read + 1) | 0;
                    // extension points:
                    case 8:
                    case 9:
                    case 10:
                    case 11:
                        break;
                    case 12:
                    case 13:
                        if (((i + 1) | 0) < u8ArrLen) {
                            read = (read + 1) | 0;
                            break;
                        }
                    case 14:
                        if (((i + 2) | 0) < u8ArrLen) {
                            //if (!(char === 0xEF && encodedString.substr(i+1|0,2) === "\xBF\xBD"))
                            read = (read + 1) | 0;
                            break;
                        }
                    case 15:
                        if (((i + 3) | 0) < u8ArrLen) {
                            read = (read + 1) | 0;
                            break;
                        }
                    default:
                        break putChars;
                }
                //read = read + ((char >> 6) !== 2) |0;
                u8Arr[i] = char;
            }
        }
        return { written: i, read: inputLength < read ? inputLength : read };
    }
}
exports.TextEncoder = TextEncoder;
/**
 * Encode a UTF-8 string into a Uint8Array
 */
function encode(s) {
    return TextEncoder.prototype.encode(s);
}
exports.encode = encode;
/**
 * Decode a Uint8Array into a UTF-8 string
 */
function decode(a) {
    return TextDecoder.prototype.decode(a);
}
exports.decode = decode;


/***/ }),

/***/ "../../node_modules/@temporalio/workflow/node_modules/@temporalio/common/lib/errors.js":
/*!*********************************************************************************************!*\
  !*** ../../node_modules/@temporalio/workflow/node_modules/@temporalio/common/lib/errors.js ***!
  \*********************************************************************************************/
/***/ (function(__unused_webpack_module, exports, __webpack_require__) {

"use strict";

var __decorate = (this && this.__decorate) || function (decorators, target, key, desc) {
    var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;
    if (typeof Reflect === "object" && typeof Reflect.decorate === "function") r = Reflect.decorate(decorators, target, key, desc);
    else for (var i = decorators.length - 1; i >= 0; i--) if (d = decorators[i]) r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;
    return c > 3 && r && Object.defineProperty(target, key, r), r;
};
Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.NamespaceNotFoundError = exports.WorkflowNotFoundError = exports.WorkflowExecutionAlreadyStartedError = exports.IllegalStateError = exports.PayloadConverterError = exports.ValueError = void 0;
const failure_1 = __webpack_require__(/*! ./failure */ "../../node_modules/@temporalio/workflow/node_modules/@temporalio/common/lib/failure.js");
const type_helpers_1 = __webpack_require__(/*! ./type-helpers */ "../../node_modules/@temporalio/workflow/node_modules/@temporalio/common/lib/type-helpers.js");
/**
 * Thrown from code that receives a value that is unexpected or that it's unable to handle.
 */
let ValueError = class ValueError extends Error {
    constructor(message, cause) {
        super(message ?? undefined);
        this.cause = cause;
    }
};
exports.ValueError = ValueError;
exports.ValueError = ValueError = __decorate([
    (0, type_helpers_1.SymbolBasedInstanceOfError)('ValueError')
], ValueError);
/**
 * Thrown when a Payload Converter is misconfigured.
 */
let PayloadConverterError = class PayloadConverterError extends ValueError {
};
exports.PayloadConverterError = PayloadConverterError;
exports.PayloadConverterError = PayloadConverterError = __decorate([
    (0, type_helpers_1.SymbolBasedInstanceOfError)('PayloadConverterError')
], PayloadConverterError);
/**
 * Used in different parts of the SDK to note that something unexpected has happened.
 */
let IllegalStateError = class IllegalStateError extends Error {
};
exports.IllegalStateError = IllegalStateError;
exports.IllegalStateError = IllegalStateError = __decorate([
    (0, type_helpers_1.SymbolBasedInstanceOfError)('IllegalStateError')
], IllegalStateError);
/**
 * This exception is thrown in the following cases:
 *  - Workflow with the same Workflow Id is currently running
 *  - There is a closed Workflow with the same Workflow Id and the {@link WorkflowOptions.workflowIdReusePolicy}
 *    is `WORKFLOW_ID_REUSE_POLICY_REJECT_DUPLICATE`
 *  - There is closed Workflow in the `Completed` state with the same Workflow Id and the {@link WorkflowOptions.workflowIdReusePolicy}
 *    is `WORKFLOW_ID_REUSE_POLICY_ALLOW_DUPLICATE_FAILED_ONLY`
 */
let WorkflowExecutionAlreadyStartedError = class WorkflowExecutionAlreadyStartedError extends failure_1.TemporalFailure {
    constructor(message, workflowId, workflowType) {
        super(message);
        this.workflowId = workflowId;
        this.workflowType = workflowType;
    }
};
exports.WorkflowExecutionAlreadyStartedError = WorkflowExecutionAlreadyStartedError;
exports.WorkflowExecutionAlreadyStartedError = WorkflowExecutionAlreadyStartedError = __decorate([
    (0, type_helpers_1.SymbolBasedInstanceOfError)('WorkflowExecutionAlreadyStartedError')
], WorkflowExecutionAlreadyStartedError);
/**
 * Thrown when a Workflow with the given Id is not known to Temporal Server.
 * It could be because:
 * - Id passed is incorrect
 * - Workflow is closed (for some calls, e.g. `terminate`)
 * - Workflow was deleted from the Server after reaching its retention limit
 */
let WorkflowNotFoundError = class WorkflowNotFoundError extends Error {
    constructor(message, workflowId, runId) {
        super(message);
        this.workflowId = workflowId;
        this.runId = runId;
    }
};
exports.WorkflowNotFoundError = WorkflowNotFoundError;
exports.WorkflowNotFoundError = WorkflowNotFoundError = __decorate([
    (0, type_helpers_1.SymbolBasedInstanceOfError)('WorkflowNotFoundError')
], WorkflowNotFoundError);
/**
 * Thrown when the specified namespace is not known to Temporal Server.
 */
let NamespaceNotFoundError = class NamespaceNotFoundError extends Error {
    constructor(namespace) {
        super(`Namespace not found: '${namespace}'`);
        this.namespace = namespace;
    }
};
exports.NamespaceNotFoundError = NamespaceNotFoundError;
exports.NamespaceNotFoundError = NamespaceNotFoundError = __decorate([
    (0, type_helpers_1.SymbolBasedInstanceOfError)('NamespaceNotFoundError')
], NamespaceNotFoundError);


/***/ }),

/***/ "../../node_modules/@temporalio/workflow/node_modules/@temporalio/common/lib/failure.js":
/*!**********************************************************************************************!*\
  !*** ../../node_modules/@temporalio/workflow/node_modules/@temporalio/common/lib/failure.js ***!
  \**********************************************************************************************/
/***/ (function(__unused_webpack_module, exports, __webpack_require__) {

"use strict";

var __decorate = (this && this.__decorate) || function (decorators, target, key, desc) {
    var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;
    if (typeof Reflect === "object" && typeof Reflect.decorate === "function") r = Reflect.decorate(decorators, target, key, desc);
    else for (var i = decorators.length - 1; i >= 0; i--) if (d = decorators[i]) r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;
    return c > 3 && r && Object.defineProperty(target, key, r), r;
};
Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.rootCause = exports.ensureTemporalFailure = exports.ensureApplicationFailure = exports.ChildWorkflowFailure = exports.ActivityFailure = exports.TimeoutFailure = exports.TerminatedFailure = exports.CancelledFailure = exports.ApplicationFailure = exports.ServerFailure = exports.TemporalFailure = exports.RetryState = exports.TimeoutType = exports.FAILURE_SOURCE = void 0;
const type_helpers_1 = __webpack_require__(/*! ./type-helpers */ "../../node_modules/@temporalio/workflow/node_modules/@temporalio/common/lib/type-helpers.js");
exports.FAILURE_SOURCE = 'TypeScriptSDK';
// Avoid importing the proto implementation to reduce workflow bundle size
// Copied from temporal.api.enums.v1.TimeoutType
var TimeoutType;
(function (TimeoutType) {
    TimeoutType[TimeoutType["TIMEOUT_TYPE_UNSPECIFIED"] = 0] = "TIMEOUT_TYPE_UNSPECIFIED";
    TimeoutType[TimeoutType["TIMEOUT_TYPE_START_TO_CLOSE"] = 1] = "TIMEOUT_TYPE_START_TO_CLOSE";
    TimeoutType[TimeoutType["TIMEOUT_TYPE_SCHEDULE_TO_START"] = 2] = "TIMEOUT_TYPE_SCHEDULE_TO_START";
    TimeoutType[TimeoutType["TIMEOUT_TYPE_SCHEDULE_TO_CLOSE"] = 3] = "TIMEOUT_TYPE_SCHEDULE_TO_CLOSE";
    TimeoutType[TimeoutType["TIMEOUT_TYPE_HEARTBEAT"] = 4] = "TIMEOUT_TYPE_HEARTBEAT";
})(TimeoutType || (exports.TimeoutType = TimeoutType = {}));
(0, type_helpers_1.checkExtends)();
(0, type_helpers_1.checkExtends)();
// Avoid importing the proto implementation to reduce workflow bundle size
// Copied from temporal.api.enums.v1.RetryState
var RetryState;
(function (RetryState) {
    RetryState[RetryState["RETRY_STATE_UNSPECIFIED"] = 0] = "RETRY_STATE_UNSPECIFIED";
    RetryState[RetryState["RETRY_STATE_IN_PROGRESS"] = 1] = "RETRY_STATE_IN_PROGRESS";
    RetryState[RetryState["RETRY_STATE_NON_RETRYABLE_FAILURE"] = 2] = "RETRY_STATE_NON_RETRYABLE_FAILURE";
    RetryState[RetryState["RETRY_STATE_TIMEOUT"] = 3] = "RETRY_STATE_TIMEOUT";
    RetryState[RetryState["RETRY_STATE_MAXIMUM_ATTEMPTS_REACHED"] = 4] = "RETRY_STATE_MAXIMUM_ATTEMPTS_REACHED";
    RetryState[RetryState["RETRY_STATE_RETRY_POLICY_NOT_SET"] = 5] = "RETRY_STATE_RETRY_POLICY_NOT_SET";
    RetryState[RetryState["RETRY_STATE_INTERNAL_SERVER_ERROR"] = 6] = "RETRY_STATE_INTERNAL_SERVER_ERROR";
    RetryState[RetryState["RETRY_STATE_CANCEL_REQUESTED"] = 7] = "RETRY_STATE_CANCEL_REQUESTED";
})(RetryState || (exports.RetryState = RetryState = {}));
(0, type_helpers_1.checkExtends)();
(0, type_helpers_1.checkExtends)();
/**
 * Represents failures that can cross Workflow and Activity boundaries.
 *
 * **Never extend this class or any of its children.**
 *
 * The only child class you should ever throw from your code is {@link ApplicationFailure}.
 */
let TemporalFailure = class TemporalFailure extends Error {
    constructor(message, cause) {
        super(message ?? undefined);
        this.cause = cause;
    }
};
exports.TemporalFailure = TemporalFailure;
exports.TemporalFailure = TemporalFailure = __decorate([
    (0, type_helpers_1.SymbolBasedInstanceOfError)('TemporalFailure')
], TemporalFailure);
/** Exceptions originated at the Temporal service. */
let ServerFailure = class ServerFailure extends TemporalFailure {
    constructor(message, nonRetryable, cause) {
        super(message, cause);
        this.nonRetryable = nonRetryable;
    }
};
exports.ServerFailure = ServerFailure;
exports.ServerFailure = ServerFailure = __decorate([
    (0, type_helpers_1.SymbolBasedInstanceOfError)('ServerFailure')
], ServerFailure);
/**
 * `ApplicationFailure`s are used to communicate application-specific failures in Workflows and Activities.
 *
 * The {@link type} property is matched against {@link RetryPolicy.nonRetryableErrorTypes} to determine if an instance
 * of this error is retryable. Another way to avoid retrying is by setting the {@link nonRetryable} flag to `true`.
 *
 * In Workflows, if you throw a non-`ApplicationFailure`, the Workflow Task will fail and be retried. If you throw an
 * `ApplicationFailure`, the Workflow Execution will fail.
 *
 * In Activities, you can either throw an `ApplicationFailure` or another `Error` to fail the Activity Task. In the
 * latter case, the `Error` will be converted to an `ApplicationFailure`. The conversion is done as following:
 *
 * - `type` is set to `error.constructor?.name ?? error.name`
 * - `message` is set to `error.message`
 * - `nonRetryable` is set to false
 * - `details` are set to null
 * - stack trace is copied from the original error
 *
 * When an {@link https://docs.temporal.io/concepts/what-is-an-activity-execution | Activity Execution} fails, the
 * `ApplicationFailure` from the last Activity Task will be the `cause` of the {@link ActivityFailure} thrown in the
 * Workflow.
 */
let ApplicationFailure = class ApplicationFailure extends TemporalFailure {
    /**
     * Alternatively, use {@link fromError} or {@link create}.
     */
    constructor(message, type, nonRetryable, details, cause) {
        super(message, cause);
        this.type = type;
        this.nonRetryable = nonRetryable;
        this.details = details;
    }
    /**
     * Create a new `ApplicationFailure` from an Error object.
     *
     * First calls {@link ensureApplicationFailure | `ensureApplicationFailure(error)`} and then overrides any fields
     * provided in `overrides`.
     */
    static fromError(error, overrides) {
        const failure = ensureApplicationFailure(error);
        Object.assign(failure, overrides);
        return failure;
    }
    /**
     * Create a new `ApplicationFailure`.
     *
     * By default, will be retryable (unless its `type` is included in {@link RetryPolicy.nonRetryableErrorTypes}).
     */
    static create(options) {
        const { message, type, nonRetryable = false, details, cause } = options;
        return new this(message, type, nonRetryable, details, cause);
    }
    /**
     * Get a new `ApplicationFailure` with the {@link nonRetryable} flag set to false. Note that this error will still
     * not be retried if its `type` is included in {@link RetryPolicy.nonRetryableErrorTypes}.
     *
     * @param message Optional error message
     * @param type Optional error type (used by {@link RetryPolicy.nonRetryableErrorTypes})
     * @param details Optional details about the failure. Serialized by the Worker's {@link PayloadConverter}.
     */
    static retryable(message, type, ...details) {
        return new this(message, type ?? 'Error', false, details);
    }
    /**
     * Get a new `ApplicationFailure` with the {@link nonRetryable} flag set to true.
     *
     * When thrown from an Activity or Workflow, the Activity or Workflow will not be retried (even if `type` is not
     * listed in {@link RetryPolicy.nonRetryableErrorTypes}).
     *
     * @param message Optional error message
     * @param type Optional error type
     * @param details Optional details about the failure. Serialized by the Worker's {@link PayloadConverter}.
     */
    static nonRetryable(message, type, ...details) {
        return new this(message, type ?? 'Error', true, details);
    }
};
exports.ApplicationFailure = ApplicationFailure;
exports.ApplicationFailure = ApplicationFailure = __decorate([
    (0, type_helpers_1.SymbolBasedInstanceOfError)('ApplicationFailure')
], ApplicationFailure);
/**
 * This error is thrown when Cancellation has been requested. To allow Cancellation to happen, let it propagate. To
 * ignore Cancellation, catch it and continue executing. Note that Cancellation can only be requested a single time, so
 * your Workflow/Activity Execution will not receive further Cancellation requests.
 *
 * When a Workflow or Activity has been successfully cancelled, a `CancelledFailure` will be the `cause`.
 */
let CancelledFailure = class CancelledFailure extends TemporalFailure {
    constructor(message, details = [], cause) {
        super(message, cause);
        this.details = details;
    }
};
exports.CancelledFailure = CancelledFailure;
exports.CancelledFailure = CancelledFailure = __decorate([
    (0, type_helpers_1.SymbolBasedInstanceOfError)('CancelledFailure')
], CancelledFailure);
/**
 * Used as the `cause` when a Workflow has been terminated
 */
let TerminatedFailure = class TerminatedFailure extends TemporalFailure {
    constructor(message, cause) {
        super(message, cause);
    }
};
exports.TerminatedFailure = TerminatedFailure;
exports.TerminatedFailure = TerminatedFailure = __decorate([
    (0, type_helpers_1.SymbolBasedInstanceOfError)('TerminatedFailure')
], TerminatedFailure);
/**
 * Used to represent timeouts of Activities and Workflows
 */
let TimeoutFailure = class TimeoutFailure extends TemporalFailure {
    constructor(message, lastHeartbeatDetails, timeoutType) {
        super(message);
        this.lastHeartbeatDetails = lastHeartbeatDetails;
        this.timeoutType = timeoutType;
    }
};
exports.TimeoutFailure = TimeoutFailure;
exports.TimeoutFailure = TimeoutFailure = __decorate([
    (0, type_helpers_1.SymbolBasedInstanceOfError)('TimeoutFailure')
], TimeoutFailure);
/**
 * Contains information about an Activity failure. Always contains the original reason for the failure as its `cause`.
 * For example, if an Activity timed out, the cause will be a {@link TimeoutFailure}.
 *
 * This exception is expected to be thrown only by the framework code.
 */
let ActivityFailure = class ActivityFailure extends TemporalFailure {
    constructor(message, activityType, activityId, retryState, identity, cause) {
        super(message, cause);
        this.activityType = activityType;
        this.activityId = activityId;
        this.retryState = retryState;
        this.identity = identity;
    }
};
exports.ActivityFailure = ActivityFailure;
exports.ActivityFailure = ActivityFailure = __decorate([
    (0, type_helpers_1.SymbolBasedInstanceOfError)('ActivityFailure')
], ActivityFailure);
/**
 * Contains information about a Child Workflow failure. Always contains the reason for the failure as its {@link cause}.
 * For example, if the Child was Terminated, the `cause` is a {@link TerminatedFailure}.
 *
 * This exception is expected to be thrown only by the framework code.
 */
let ChildWorkflowFailure = class ChildWorkflowFailure extends TemporalFailure {
    constructor(namespace, execution, workflowType, retryState, cause) {
        super('Child Workflow execution failed', cause);
        this.namespace = namespace;
        this.execution = execution;
        this.workflowType = workflowType;
        this.retryState = retryState;
    }
};
exports.ChildWorkflowFailure = ChildWorkflowFailure;
exports.ChildWorkflowFailure = ChildWorkflowFailure = __decorate([
    (0, type_helpers_1.SymbolBasedInstanceOfError)('ChildWorkflowFailure')
], ChildWorkflowFailure);
/**
 * If `error` is already an `ApplicationFailure`, returns `error`.
 *
 * Otherwise, converts `error` into an `ApplicationFailure` with:
 *
 * - `message`: `error.message` or `String(error)`
 * - `type`: `error.constructor.name` or `error.name`
 * - `stack`: `error.stack` or `''`
 */
function ensureApplicationFailure(error) {
    if (error instanceof ApplicationFailure) {
        return error;
    }
    const message = ((0, type_helpers_1.isRecord)(error) && String(error.message)) || String(error);
    const type = ((0, type_helpers_1.isRecord)(error) && (error.constructor?.name ?? error.name)) || undefined;
    const failure = ApplicationFailure.create({ message, type, nonRetryable: false });
    failure.stack = ((0, type_helpers_1.isRecord)(error) && String(error.stack)) || '';
    return failure;
}
exports.ensureApplicationFailure = ensureApplicationFailure;
/**
 * If `err` is an Error it is turned into an `ApplicationFailure`.
 *
 * If `err` was already a `TemporalFailure`, returns the original error.
 *
 * Otherwise returns an `ApplicationFailure` with `String(err)` as the message.
 */
function ensureTemporalFailure(err) {
    if (err instanceof TemporalFailure) {
        return err;
    }
    return ensureApplicationFailure(err);
}
exports.ensureTemporalFailure = ensureTemporalFailure;
/**
 * Get the root cause message of given `error`.
 *
 * In case `error` is a {@link TemporalFailure}, recurse the `cause` chain and return the root `cause.message`.
 * Otherwise, return `error.message`.
 */
function rootCause(error) {
    if (error instanceof TemporalFailure) {
        return error.cause ? rootCause(error.cause) : error.message;
    }
    return (0, type_helpers_1.errorMessage)(error);
}
exports.rootCause = rootCause;


/***/ }),

/***/ "../../node_modules/@temporalio/workflow/node_modules/@temporalio/common/lib/index.js":
/*!********************************************************************************************!*\
  !*** ../../node_modules/@temporalio/workflow/node_modules/@temporalio/common/lib/index.js ***!
  \********************************************************************************************/
/***/ (function(__unused_webpack_module, exports, __webpack_require__) {

"use strict";

/**
 * Common library for code that's used across the Client, Worker, and/or Workflow
 *
 * @module
 */
var __createBinding = (this && this.__createBinding) || (Object.create ? (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    var desc = Object.getOwnPropertyDescriptor(m, k);
    if (!desc || ("get" in desc ? !m.__esModule : desc.writable || desc.configurable)) {
      desc = { enumerable: true, get: function() { return m[k]; } };
    }
    Object.defineProperty(o, k2, desc);
}) : (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    o[k2] = m[k];
}));
var __setModuleDefault = (this && this.__setModuleDefault) || (Object.create ? (function(o, v) {
    Object.defineProperty(o, "default", { enumerable: true, value: v });
}) : function(o, v) {
    o["default"] = v;
});
var __importStar = (this && this.__importStar) || function (mod) {
    if (mod && mod.__esModule) return mod;
    var result = {};
    if (mod != null) for (var k in mod) if (k !== "default" && Object.prototype.hasOwnProperty.call(mod, k)) __createBinding(result, mod, k);
    __setModuleDefault(result, mod);
    return result;
};
var __exportStar = (this && this.__exportStar) || function(m, exports) {
    for (var p in m) if (p !== "default" && !Object.prototype.hasOwnProperty.call(exports, p)) __createBinding(exports, m, p);
};
Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.errorCode = exports.errorMessage = exports.str = exports.u8 = void 0;
const encoding = __importStar(__webpack_require__(/*! ./encoding */ "../../node_modules/@temporalio/workflow/node_modules/@temporalio/common/lib/encoding.js"));
const helpers = __importStar(__webpack_require__(/*! ./type-helpers */ "../../node_modules/@temporalio/workflow/node_modules/@temporalio/common/lib/type-helpers.js"));
__exportStar(__webpack_require__(/*! ./activity-options */ "../../node_modules/@temporalio/workflow/node_modules/@temporalio/common/lib/activity-options.js"), exports);
__exportStar(__webpack_require__(/*! ./converter/data-converter */ "../../node_modules/@temporalio/workflow/node_modules/@temporalio/common/lib/converter/data-converter.js"), exports);
__exportStar(__webpack_require__(/*! ./converter/failure-converter */ "../../node_modules/@temporalio/workflow/node_modules/@temporalio/common/lib/converter/failure-converter.js"), exports);
__exportStar(__webpack_require__(/*! ./converter/payload-codec */ "../../node_modules/@temporalio/workflow/node_modules/@temporalio/common/lib/converter/payload-codec.js"), exports);
__exportStar(__webpack_require__(/*! ./converter/payload-converter */ "../../node_modules/@temporalio/workflow/node_modules/@temporalio/common/lib/converter/payload-converter.js"), exports);
__exportStar(__webpack_require__(/*! ./converter/types */ "../../node_modules/@temporalio/workflow/node_modules/@temporalio/common/lib/converter/types.js"), exports);
__exportStar(__webpack_require__(/*! ./deprecated-time */ "../../node_modules/@temporalio/workflow/node_modules/@temporalio/common/lib/deprecated-time.js"), exports);
__exportStar(__webpack_require__(/*! ./errors */ "../../node_modules/@temporalio/workflow/node_modules/@temporalio/common/lib/errors.js"), exports);
__exportStar(__webpack_require__(/*! ./failure */ "../../node_modules/@temporalio/workflow/node_modules/@temporalio/common/lib/failure.js"), exports);
__exportStar(__webpack_require__(/*! ./interfaces */ "../../node_modules/@temporalio/workflow/node_modules/@temporalio/common/lib/interfaces.js"), exports);
__exportStar(__webpack_require__(/*! ./logger */ "../../node_modules/@temporalio/workflow/node_modules/@temporalio/common/lib/logger.js"), exports);
__exportStar(__webpack_require__(/*! ./retry-policy */ "../../node_modules/@temporalio/workflow/node_modules/@temporalio/common/lib/retry-policy.js"), exports);
__exportStar(__webpack_require__(/*! ./workflow-handle */ "../../node_modules/@temporalio/workflow/node_modules/@temporalio/common/lib/workflow-handle.js"), exports);
__exportStar(__webpack_require__(/*! ./workflow-options */ "../../node_modules/@temporalio/workflow/node_modules/@temporalio/common/lib/workflow-options.js"), exports);
__exportStar(__webpack_require__(/*! ./versioning-intent */ "../../node_modules/@temporalio/workflow/node_modules/@temporalio/common/lib/versioning-intent.js"), exports);
/**
 * Encode a UTF-8 string into a Uint8Array
 *
 * @hidden
 * @deprecated - meant for internal use only
 */
function u8(s) {
    return encoding.encode(s);
}
exports.u8 = u8;
/**
 * Decode a Uint8Array into a UTF-8 string
 *
 * @hidden
 * @deprecated - meant for internal use only
 */
function str(arr) {
    return encoding.decode(arr);
}
exports.str = str;
/**
 * Get `error.message` (or `undefined` if not present)
 *
 * @hidden
 * @deprecated - meant for internal use only
 */
function errorMessage(error) {
    return helpers.errorMessage(error);
}
exports.errorMessage = errorMessage;
/**
 * Get `error.code` (or `undefined` if not present)
 *
 * @hidden
 * @deprecated - meant for internal use only
 */
function errorCode(error) {
    return helpers.errorCode(error);
}
exports.errorCode = errorCode;


/***/ }),

/***/ "../../node_modules/@temporalio/workflow/node_modules/@temporalio/common/lib/interceptors.js":
/*!***************************************************************************************************!*\
  !*** ../../node_modules/@temporalio/workflow/node_modules/@temporalio/common/lib/interceptors.js ***!
  \***************************************************************************************************/
/***/ ((__unused_webpack_module, exports) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.composeInterceptors = void 0;
/**
 * Compose all interceptor methods into a single function.
 *
 * Calling the composed function results in calling each of the provided interceptor, in order (from the first to
 * the last), followed by the original function provided as argument to `composeInterceptors()`.
 *
 * @param interceptors a list of interceptors
 * @param method the name of the interceptor method to compose
 * @param next the original function to be executed at the end of the interception chain
 */
// ts-prune-ignore-next (imported via lib/interceptors)
function composeInterceptors(interceptors, method, next) {
    for (let i = interceptors.length - 1; i >= 0; --i) {
        const interceptor = interceptors[i];
        if (interceptor[method] !== undefined) {
            const prev = next;
            // We lose type safety here because Typescript can't deduce that interceptor[method] is a function that returns
            // the same type as Next<I, M>
            next = ((input) => interceptor[method](input, prev));
        }
    }
    return next;
}
exports.composeInterceptors = composeInterceptors;


/***/ }),

/***/ "../../node_modules/@temporalio/workflow/node_modules/@temporalio/common/lib/interfaces.js":
/*!*************************************************************************************************!*\
  !*** ../../node_modules/@temporalio/workflow/node_modules/@temporalio/common/lib/interfaces.js ***!
  \*************************************************************************************************/
/***/ ((__unused_webpack_module, exports) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({ value: true }));


/***/ }),

/***/ "../../node_modules/@temporalio/workflow/node_modules/@temporalio/common/lib/logger.js":
/*!*********************************************************************************************!*\
  !*** ../../node_modules/@temporalio/workflow/node_modules/@temporalio/common/lib/logger.js ***!
  \*********************************************************************************************/
/***/ ((__unused_webpack_module, exports) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.SdkComponent = void 0;
/**
 * Possible values of the `sdkComponent` meta attributes on log messages. This
 * attribute indicates which subsystem emitted the log message; this may for
 * example be used to implement fine-grained filtering of log messages.
 *
 * Note that there is no guarantee that this list will remain stable in the
 * future; values may be added or removed, and messages that are currently
 * emitted with some `sdkComponent` value may use a different value in the future.
 */
var SdkComponent;
(function (SdkComponent) {
    /**
     * Component name for messages emited from Workflow code, using the {@link Workflow context logger|workflow.log}.
     * The SDK itself never publishes messages with this component name.
     */
    SdkComponent["workflow"] = "workflow";
    /**
     * Component name for messages emited from an activity, using the {@link activity context logger|Context.log}.
     * The SDK itself never publishes messages with this component name.
     */
    SdkComponent["activity"] = "activity";
    /**
     * Component name for messages emited from a Temporal Worker instance.
     *
     * This notably includes:
     * - Issues with Worker or runtime configuration, or the JS execution environment;
     * - Worker's, Activity's, and Workflow's lifecycle events;
     * - Workflow Activation and Activity Task processing events;
     * - Workflow bundling messages;
     * - Sink processing issues.
     */
    SdkComponent["worker"] = "worker";
    /**
     * Component name for all messages emitted by the Rust Core SDK library.
     */
    SdkComponent["core"] = "core";
})(SdkComponent || (exports.SdkComponent = SdkComponent = {}));


/***/ }),

/***/ "../../node_modules/@temporalio/workflow/node_modules/@temporalio/common/lib/retry-policy.js":
/*!***************************************************************************************************!*\
  !*** ../../node_modules/@temporalio/workflow/node_modules/@temporalio/common/lib/retry-policy.js ***!
  \***************************************************************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.decompileRetryPolicy = exports.compileRetryPolicy = void 0;
const errors_1 = __webpack_require__(/*! ./errors */ "../../node_modules/@temporalio/workflow/node_modules/@temporalio/common/lib/errors.js");
const time_1 = __webpack_require__(/*! ./time */ "../../node_modules/@temporalio/workflow/node_modules/@temporalio/common/lib/time.js");
/**
 * Turn a TS RetryPolicy into a proto compatible RetryPolicy
 */
function compileRetryPolicy(retryPolicy) {
    if (retryPolicy.backoffCoefficient != null && retryPolicy.backoffCoefficient <= 0) {
        throw new errors_1.ValueError('RetryPolicy.backoffCoefficient must be greater than 0');
    }
    if (retryPolicy.maximumAttempts != null) {
        if (retryPolicy.maximumAttempts === Number.POSITIVE_INFINITY) {
            // drop field (Infinity is the default)
            const { maximumAttempts: _, ...without } = retryPolicy;
            retryPolicy = without;
        }
        else if (retryPolicy.maximumAttempts <= 0) {
            throw new errors_1.ValueError('RetryPolicy.maximumAttempts must be a positive integer');
        }
        else if (!Number.isInteger(retryPolicy.maximumAttempts)) {
            throw new errors_1.ValueError('RetryPolicy.maximumAttempts must be an integer');
        }
    }
    const maximumInterval = (0, time_1.msOptionalToNumber)(retryPolicy.maximumInterval);
    const initialInterval = (0, time_1.msToNumber)(retryPolicy.initialInterval ?? 1000);
    if (maximumInterval === 0) {
        throw new errors_1.ValueError('RetryPolicy.maximumInterval cannot be 0');
    }
    if (initialInterval === 0) {
        throw new errors_1.ValueError('RetryPolicy.initialInterval cannot be 0');
    }
    if (maximumInterval != null && maximumInterval < initialInterval) {
        throw new errors_1.ValueError('RetryPolicy.maximumInterval cannot be less than its initialInterval');
    }
    return {
        maximumAttempts: retryPolicy.maximumAttempts,
        initialInterval: (0, time_1.msToTs)(initialInterval),
        maximumInterval: (0, time_1.msOptionalToTs)(maximumInterval),
        backoffCoefficient: retryPolicy.backoffCoefficient,
        nonRetryableErrorTypes: retryPolicy.nonRetryableErrorTypes,
    };
}
exports.compileRetryPolicy = compileRetryPolicy;
/**
 * Turn a proto compatible RetryPolicy into a TS RetryPolicy
 */
function decompileRetryPolicy(retryPolicy) {
    if (!retryPolicy) {
        return undefined;
    }
    return {
        backoffCoefficient: retryPolicy.backoffCoefficient ?? undefined,
        maximumAttempts: retryPolicy.maximumAttempts ?? undefined,
        maximumInterval: (0, time_1.optionalTsToMs)(retryPolicy.maximumInterval),
        initialInterval: (0, time_1.optionalTsToMs)(retryPolicy.initialInterval),
        nonRetryableErrorTypes: retryPolicy.nonRetryableErrorTypes ?? undefined,
    };
}
exports.decompileRetryPolicy = decompileRetryPolicy;


/***/ }),

/***/ "../../node_modules/@temporalio/workflow/node_modules/@temporalio/common/lib/time.js":
/*!*******************************************************************************************!*\
  !*** ../../node_modules/@temporalio/workflow/node_modules/@temporalio/common/lib/time.js ***!
  \*******************************************************************************************/
/***/ (function(__unused_webpack_module, exports, __webpack_require__) {

"use strict";

var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.optionalDateToTs = exports.optionalTsToDate = exports.tsToDate = exports.msToNumber = exports.msOptionalToNumber = exports.msOptionalToTs = exports.msToTs = exports.msNumberToTs = exports.tsToMs = exports.optionalTsToMs = void 0;
const long_1 = __importDefault(__webpack_require__(/*! long */ "../../node_modules/long/umd/index.js")); // eslint-disable-line import/no-named-as-default
const ms_1 = __importDefault(__webpack_require__(/*! ms */ "../../node_modules/@temporalio/workflow/node_modules/ms/dist/index.cjs"));
const errors_1 = __webpack_require__(/*! ./errors */ "../../node_modules/@temporalio/workflow/node_modules/@temporalio/common/lib/errors.js");
/**
 * Lossy conversion function from Timestamp to number due to possible overflow.
 * If ts is null or undefined returns undefined.
 */
function optionalTsToMs(ts) {
    if (ts === undefined || ts === null) {
        return undefined;
    }
    return tsToMs(ts);
}
exports.optionalTsToMs = optionalTsToMs;
/**
 * Lossy conversion function from Timestamp to number due to possible overflow
 */
function tsToMs(ts) {
    if (ts === undefined || ts === null) {
        throw new Error(`Expected timestamp, got ${ts}`);
    }
    const { seconds, nanos } = ts;
    return (seconds || long_1.default.UZERO)
        .mul(1000)
        .add(Math.floor((nanos || 0) / 1000000))
        .toNumber();
}
exports.tsToMs = tsToMs;
function msNumberToTs(millis) {
    const seconds = Math.floor(millis / 1000);
    const nanos = (millis % 1000) * 1000000;
    if (Number.isNaN(seconds) || Number.isNaN(nanos)) {
        throw new errors_1.ValueError(`Invalid millis ${millis}`);
    }
    return { seconds: long_1.default.fromNumber(seconds), nanos };
}
exports.msNumberToTs = msNumberToTs;
function msToTs(str) {
    return msNumberToTs(msToNumber(str));
}
exports.msToTs = msToTs;
function msOptionalToTs(str) {
    return str ? msToTs(str) : undefined;
}
exports.msOptionalToTs = msOptionalToTs;
function msOptionalToNumber(val) {
    if (val === undefined)
        return undefined;
    return msToNumber(val);
}
exports.msOptionalToNumber = msOptionalToNumber;
function msToNumber(val) {
    if (typeof val === 'number') {
        return val;
    }
    return msWithValidation(val);
}
exports.msToNumber = msToNumber;
function msWithValidation(str) {
    const millis = (0, ms_1.default)(str);
    if (millis == null || isNaN(millis)) {
        throw new TypeError(`Invalid duration string: '${str}'`);
    }
    return millis;
}
function tsToDate(ts) {
    return new Date(tsToMs(ts));
}
exports.tsToDate = tsToDate;
function optionalTsToDate(ts) {
    if (ts === undefined || ts === null) {
        return undefined;
    }
    return new Date(tsToMs(ts));
}
exports.optionalTsToDate = optionalTsToDate;
// ts-prune-ignore-next (imported via schedule-helpers.ts)
function optionalDateToTs(date) {
    if (date === undefined || date === null) {
        return undefined;
    }
    return msToTs(date.getTime());
}
exports.optionalDateToTs = optionalDateToTs;


/***/ }),

/***/ "../../node_modules/@temporalio/workflow/node_modules/@temporalio/common/lib/type-helpers.js":
/*!***************************************************************************************************!*\
  !*** ../../node_modules/@temporalio/workflow/node_modules/@temporalio/common/lib/type-helpers.js ***!
  \***************************************************************************************************/
/***/ ((__unused_webpack_module, exports) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.deepFreeze = exports.SymbolBasedInstanceOfError = exports.assertNever = exports.errorCode = exports.errorMessage = exports.isAbortError = exports.isError = exports.hasOwnProperties = exports.hasOwnProperty = exports.isRecord = exports.checkExtends = void 0;
/** Verify that an type _Copy extends _Orig */
function checkExtends() {
    // noop, just type check
}
exports.checkExtends = checkExtends;
function isRecord(value) {
    return typeof value === 'object' && value !== null;
}
exports.isRecord = isRecord;
function hasOwnProperty(record, prop) {
    return prop in record;
}
exports.hasOwnProperty = hasOwnProperty;
function hasOwnProperties(record, props) {
    return props.every((prop) => prop in record);
}
exports.hasOwnProperties = hasOwnProperties;
function isError(error) {
    return (isRecord(error) &&
        typeof error.name === 'string' &&
        typeof error.message === 'string' &&
        (error.stack == null || typeof error.stack === 'string'));
}
exports.isError = isError;
function isAbortError(error) {
    return isError(error) && error.name === 'AbortError';
}
exports.isAbortError = isAbortError;
/**
 * Get `error.message` (or `undefined` if not present)
 */
function errorMessage(error) {
    if (isError(error)) {
        return error.message;
    }
    else if (typeof error === 'string') {
        return error;
    }
    return undefined;
}
exports.errorMessage = errorMessage;
function isErrorWithCode(error) {
    return isRecord(error) && typeof error.code === 'string';
}
/**
 * Get `error.code` (or `undefined` if not present)
 */
function errorCode(error) {
    if (isErrorWithCode(error)) {
        return error.code;
    }
    return undefined;
}
exports.errorCode = errorCode;
/**
 * Asserts that some type is the never type
 */
function assertNever(msg, x) {
    throw new TypeError(msg + ': ' + x);
}
exports.assertNever = assertNever;
/**
 * A decorator to be used on error classes. It adds the 'name' property AND provides a custom
 * 'instanceof' handler that works correctly across execution contexts.
 *
 * ### Details ###
 *
 * According to the EcmaScript's spec, the default behavior of JavaScript's `x instanceof Y` operator is to walk up the
 * prototype chain of object 'x', checking if any constructor in that hierarchy is _exactly the same object_ as the
 * constructor function 'Y'.
 *
 * Unfortunately, it happens in various situations that different constructor function objects get created for what
 * appears to be the very same class. This leads to surprising behavior where `instanceof` returns false though it is
 * known that the object is indeed an instance of that class. One particular case where this happens is when constructor
 * 'Y' belongs to a different realm than the constuctor with which 'x' was instantiated. Another case is when two copies
 * of the same library gets loaded in the same realm.
 *
 * In practice, this tends to cause issues when crossing the workflow-sandboxing boundary (since Node's vm module
 * really creates new execution realms), as well as when running tests using Jest (see https://github.com/jestjs/jest/issues/2549
 * for some details on that one).
 *
 * This function injects a custom 'instanceof' handler into the prototype of 'clazz', which is both cross-realm safe and
 * cross-copies-of-the-same-lib safe. It works by adding a special symbol property to the prototype of 'clazz', and then
 * checking for the presence of that symbol.
 */
function SymbolBasedInstanceOfError(markerName) {
    return (clazz) => {
        const marker = Symbol.for(`__temporal_is${markerName}`);
        Object.defineProperty(clazz.prototype, 'name', { value: markerName, enumerable: true });
        Object.defineProperty(clazz.prototype, marker, { value: true, enumerable: false });
        Object.defineProperty(clazz, Symbol.hasInstance, {
            // eslint-disable-next-line object-shorthand
            value: function (error) {
                if (this === clazz) {
                    return isRecord(error) && error[marker] === true;
                }
                else {
                    // 'this' must be a _subclass_ of clazz that doesn't redefined [Symbol.hasInstance], so that it inherited
                    // from clazz's [Symbol.hasInstance]. If we don't handle this particular situation, then
                    // `x instanceof SubclassOfParent` would return true for any instance of 'Parent', which is clearly wrong.
                    //
                    // Ideally, it'd be preferable to avoid this case entirely, by making sure that all subclasses of 'clazz'
                    // redefine [Symbol.hasInstance], but we can't enforce that. We therefore fallback to the default instanceof
                    // behavior (which is NOT cross-realm safe).
                    return this.prototype.isPrototypeOf(error); // eslint-disable-line no-prototype-builtins
                }
            },
        });
    };
}
exports.SymbolBasedInstanceOfError = SymbolBasedInstanceOfError;
// Thanks MDN: https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Object/freeze
function deepFreeze(object) {
    // Retrieve the property names defined on object
    const propNames = Object.getOwnPropertyNames(object);
    // Freeze properties before freezing self
    for (const name of propNames) {
        const value = object[name];
        if (value && typeof value === 'object') {
            try {
                deepFreeze(value);
            }
            catch (err) {
                // This is okay, there are some typed arrays that cannot be frozen (encodingKeys)
            }
        }
        else if (typeof value === 'function') {
            Object.freeze(value);
        }
    }
    return Object.freeze(object);
}
exports.deepFreeze = deepFreeze;


/***/ }),

/***/ "../../node_modules/@temporalio/workflow/node_modules/@temporalio/common/lib/versioning-intent-enum.js":
/*!*************************************************************************************************************!*\
  !*** ../../node_modules/@temporalio/workflow/node_modules/@temporalio/common/lib/versioning-intent-enum.js ***!
  \*************************************************************************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.versioningIntentToProto = exports.VersioningIntent = void 0;
const type_helpers_1 = __webpack_require__(/*! ./type-helpers */ "../../node_modules/@temporalio/workflow/node_modules/@temporalio/common/lib/type-helpers.js");
// Avoid importing the proto implementation to reduce workflow bundle size
// Copied from coresdk.common.VersioningIntent
/**
 * Protobuf enum representation of {@link VersioningIntentString}.
 *
 * @experimental
 */
var VersioningIntent;
(function (VersioningIntent) {
    VersioningIntent[VersioningIntent["UNSPECIFIED"] = 0] = "UNSPECIFIED";
    VersioningIntent[VersioningIntent["COMPATIBLE"] = 1] = "COMPATIBLE";
    VersioningIntent[VersioningIntent["DEFAULT"] = 2] = "DEFAULT";
})(VersioningIntent || (exports.VersioningIntent = VersioningIntent = {}));
(0, type_helpers_1.checkExtends)();
(0, type_helpers_1.checkExtends)();
function versioningIntentToProto(intent) {
    switch (intent) {
        case 'DEFAULT':
            return VersioningIntent.DEFAULT;
        case 'COMPATIBLE':
            return VersioningIntent.COMPATIBLE;
        case undefined:
            return VersioningIntent.UNSPECIFIED;
        default:
            (0, type_helpers_1.assertNever)('Unexpected VersioningIntent', intent);
    }
}
exports.versioningIntentToProto = versioningIntentToProto;


/***/ }),

/***/ "../../node_modules/@temporalio/workflow/node_modules/@temporalio/common/lib/versioning-intent.js":
/*!********************************************************************************************************!*\
  !*** ../../node_modules/@temporalio/workflow/node_modules/@temporalio/common/lib/versioning-intent.js ***!
  \********************************************************************************************************/
/***/ ((__unused_webpack_module, exports) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({ value: true }));


/***/ }),

/***/ "../../node_modules/@temporalio/workflow/node_modules/@temporalio/common/lib/workflow-handle.js":
/*!******************************************************************************************************!*\
  !*** ../../node_modules/@temporalio/workflow/node_modules/@temporalio/common/lib/workflow-handle.js ***!
  \******************************************************************************************************/
/***/ ((__unused_webpack_module, exports) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({ value: true }));


/***/ }),

/***/ "../../node_modules/@temporalio/workflow/node_modules/@temporalio/common/lib/workflow-options.js":
/*!*******************************************************************************************************!*\
  !*** ../../node_modules/@temporalio/workflow/node_modules/@temporalio/common/lib/workflow-options.js ***!
  \*******************************************************************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.extractWorkflowType = exports.WorkflowIdReusePolicy = void 0;
const type_helpers_1 = __webpack_require__(/*! ./type-helpers */ "../../node_modules/@temporalio/workflow/node_modules/@temporalio/common/lib/type-helpers.js");
// Avoid importing the proto implementation to reduce workflow bundle size
// Copied from temporal.api.enums.v1.WorkflowIdReusePolicy
/**
 * Concept: {@link https://docs.temporal.io/concepts/what-is-a-workflow-id-reuse-policy/ | Workflow Id Reuse Policy}
 *
 * Whether a Workflow can be started with a Workflow Id of a Closed Workflow.
 *
 * *Note: A Workflow can never be started with a Workflow Id of a Running Workflow.*
 */
var WorkflowIdReusePolicy;
(function (WorkflowIdReusePolicy) {
    /**
     * No need to use this.
     *
     * (If a `WorkflowIdReusePolicy` is set to this, or is not set at all, the default value will be used.)
     */
    WorkflowIdReusePolicy[WorkflowIdReusePolicy["WORKFLOW_ID_REUSE_POLICY_UNSPECIFIED"] = 0] = "WORKFLOW_ID_REUSE_POLICY_UNSPECIFIED";
    /**
     * The Workflow can be started if the previous Workflow is in a Closed state.
     * @default
     */
    WorkflowIdReusePolicy[WorkflowIdReusePolicy["WORKFLOW_ID_REUSE_POLICY_ALLOW_DUPLICATE"] = 1] = "WORKFLOW_ID_REUSE_POLICY_ALLOW_DUPLICATE";
    /**
     * The Workflow can be started if the previous Workflow is in a Closed state that is not Completed.
     */
    WorkflowIdReusePolicy[WorkflowIdReusePolicy["WORKFLOW_ID_REUSE_POLICY_ALLOW_DUPLICATE_FAILED_ONLY"] = 2] = "WORKFLOW_ID_REUSE_POLICY_ALLOW_DUPLICATE_FAILED_ONLY";
    /**
     * The Workflow cannot be started.
     */
    WorkflowIdReusePolicy[WorkflowIdReusePolicy["WORKFLOW_ID_REUSE_POLICY_REJECT_DUPLICATE"] = 3] = "WORKFLOW_ID_REUSE_POLICY_REJECT_DUPLICATE";
    /**
     * Terminate the current workflow if one is already running.
     */
    WorkflowIdReusePolicy[WorkflowIdReusePolicy["WORKFLOW_ID_REUSE_POLICY_TERMINATE_IF_RUNNING"] = 4] = "WORKFLOW_ID_REUSE_POLICY_TERMINATE_IF_RUNNING";
})(WorkflowIdReusePolicy || (exports.WorkflowIdReusePolicy = WorkflowIdReusePolicy = {}));
(0, type_helpers_1.checkExtends)();
(0, type_helpers_1.checkExtends)();
function extractWorkflowType(workflowTypeOrFunc) {
    if (typeof workflowTypeOrFunc === 'string')
        return workflowTypeOrFunc;
    if (typeof workflowTypeOrFunc === 'function') {
        if (workflowTypeOrFunc?.name)
            return workflowTypeOrFunc.name;
        throw new TypeError('Invalid workflow type: the workflow function is anonymous');
    }
    throw new TypeError(`Invalid workflow type: expected either a string or a function, got '${typeof workflowTypeOrFunc}'`);
}
exports.extractWorkflowType = extractWorkflowType;


/***/ }),

/***/ "../../node_modules/debug/node_modules/ms/index.js":
/*!*********************************************************!*\
  !*** ../../node_modules/debug/node_modules/ms/index.js ***!
  \*********************************************************/
/***/ ((module) => {

/**
 * Helpers.
 */

var s = 1000;
var m = s * 60;
var h = m * 60;
var d = h * 24;
var w = d * 7;
var y = d * 365.25;

/**
 * Parse or format the given `val`.
 *
 * Options:
 *
 *  - `long` verbose formatting [false]
 *
 * @param {String|Number} val
 * @param {Object} [options]
 * @throws {Error} throw an error if val is not a non-empty string or a number
 * @return {String|Number}
 * @api public
 */

module.exports = function(val, options) {
  options = options || {};
  var type = typeof val;
  if (type === 'string' && val.length > 0) {
    return parse(val);
  } else if (type === 'number' && isFinite(val)) {
    return options.long ? fmtLong(val) : fmtShort(val);
  }
  throw new Error(
    'val is not a non-empty string or a valid number. val=' +
      JSON.stringify(val)
  );
};

/**
 * Parse the given `str` and return milliseconds.
 *
 * @param {String} str
 * @return {Number}
 * @api private
 */

function parse(str) {
  str = String(str);
  if (str.length > 100) {
    return;
  }
  var match = /^(-?(?:\d+)?\.?\d+) *(milliseconds?|msecs?|ms|seconds?|secs?|s|minutes?|mins?|m|hours?|hrs?|h|days?|d|weeks?|w|years?|yrs?|y)?$/i.exec(
    str
  );
  if (!match) {
    return;
  }
  var n = parseFloat(match[1]);
  var type = (match[2] || 'ms').toLowerCase();
  switch (type) {
    case 'years':
    case 'year':
    case 'yrs':
    case 'yr':
    case 'y':
      return n * y;
    case 'weeks':
    case 'week':
    case 'w':
      return n * w;
    case 'days':
    case 'day':
    case 'd':
      return n * d;
    case 'hours':
    case 'hour':
    case 'hrs':
    case 'hr':
    case 'h':
      return n * h;
    case 'minutes':
    case 'minute':
    case 'mins':
    case 'min':
    case 'm':
      return n * m;
    case 'seconds':
    case 'second':
    case 'secs':
    case 'sec':
    case 's':
      return n * s;
    case 'milliseconds':
    case 'millisecond':
    case 'msecs':
    case 'msec':
    case 'ms':
      return n;
    default:
      return undefined;
  }
}

/**
 * Short format for `ms`.
 *
 * @param {Number} ms
 * @return {String}
 * @api private
 */

function fmtShort(ms) {
  var msAbs = Math.abs(ms);
  if (msAbs >= d) {
    return Math.round(ms / d) + 'd';
  }
  if (msAbs >= h) {
    return Math.round(ms / h) + 'h';
  }
  if (msAbs >= m) {
    return Math.round(ms / m) + 'm';
  }
  if (msAbs >= s) {
    return Math.round(ms / s) + 's';
  }
  return ms + 'ms';
}

/**
 * Long format for `ms`.
 *
 * @param {Number} ms
 * @return {String}
 * @api private
 */

function fmtLong(ms) {
  var msAbs = Math.abs(ms);
  if (msAbs >= d) {
    return plural(ms, msAbs, d, 'day');
  }
  if (msAbs >= h) {
    return plural(ms, msAbs, h, 'hour');
  }
  if (msAbs >= m) {
    return plural(ms, msAbs, m, 'minute');
  }
  if (msAbs >= s) {
    return plural(ms, msAbs, s, 'second');
  }
  return ms + ' ms';
}

/**
 * Pluralization helper.
 */

function plural(ms, msAbs, n, name) {
  var isPlural = msAbs >= n * 1.5;
  return Math.round(ms / n) + ' ' + name + (isPlural ? 's' : '');
}


/***/ }),

/***/ "../../node_modules/debug/src/browser.js":
/*!***********************************************!*\
  !*** ../../node_modules/debug/src/browser.js ***!
  \***********************************************/
/***/ ((module, exports, __webpack_require__) => {

/* eslint-env browser */

/**
 * This is the web browser implementation of `debug()`.
 */

exports.formatArgs = formatArgs;
exports.save = save;
exports.load = load;
exports.useColors = useColors;
exports.storage = localstorage();
exports.destroy = (() => {
	let warned = false;

	return () => {
		if (!warned) {
			warned = true;
			console.warn('Instance method `debug.destroy()` is deprecated and no longer does anything. It will be removed in the next major version of `debug`.');
		}
	};
})();

/**
 * Colors.
 */

exports.colors = [
	'#0000CC',
	'#0000FF',
	'#0033CC',
	'#0033FF',
	'#0066CC',
	'#0066FF',
	'#0099CC',
	'#0099FF',
	'#00CC00',
	'#00CC33',
	'#00CC66',
	'#00CC99',
	'#00CCCC',
	'#00CCFF',
	'#3300CC',
	'#3300FF',
	'#3333CC',
	'#3333FF',
	'#3366CC',
	'#3366FF',
	'#3399CC',
	'#3399FF',
	'#33CC00',
	'#33CC33',
	'#33CC66',
	'#33CC99',
	'#33CCCC',
	'#33CCFF',
	'#6600CC',
	'#6600FF',
	'#6633CC',
	'#6633FF',
	'#66CC00',
	'#66CC33',
	'#9900CC',
	'#9900FF',
	'#9933CC',
	'#9933FF',
	'#99CC00',
	'#99CC33',
	'#CC0000',
	'#CC0033',
	'#CC0066',
	'#CC0099',
	'#CC00CC',
	'#CC00FF',
	'#CC3300',
	'#CC3333',
	'#CC3366',
	'#CC3399',
	'#CC33CC',
	'#CC33FF',
	'#CC6600',
	'#CC6633',
	'#CC9900',
	'#CC9933',
	'#CCCC00',
	'#CCCC33',
	'#FF0000',
	'#FF0033',
	'#FF0066',
	'#FF0099',
	'#FF00CC',
	'#FF00FF',
	'#FF3300',
	'#FF3333',
	'#FF3366',
	'#FF3399',
	'#FF33CC',
	'#FF33FF',
	'#FF6600',
	'#FF6633',
	'#FF9900',
	'#FF9933',
	'#FFCC00',
	'#FFCC33'
];

/**
 * Currently only WebKit-based Web Inspectors, Firefox >= v31,
 * and the Firebug extension (any Firefox version) are known
 * to support "%c" CSS customizations.
 *
 * TODO: add a `localStorage` variable to explicitly enable/disable colors
 */

// eslint-disable-next-line complexity
function useColors() {
	// NB: In an Electron preload script, document will be defined but not fully
	// initialized. Since we know we're in Chrome, we'll just detect this case
	// explicitly
	if (typeof window !== 'undefined' && window.process && (window.process.type === 'renderer' || window.process.__nwjs)) {
		return true;
	}

	// Internet Explorer and Edge do not support colors.
	if (typeof navigator !== 'undefined' && navigator.userAgent && navigator.userAgent.toLowerCase().match(/(edge|trident)\/(\d+)/)) {
		return false;
	}

	let m;

	// Is webkit? http://stackoverflow.com/a/16459606/376773
	// document is undefined in react-native: https://github.com/facebook/react-native/pull/1632
	return (typeof document !== 'undefined' && document.documentElement && document.documentElement.style && document.documentElement.style.WebkitAppearance) ||
		// Is firebug? http://stackoverflow.com/a/398120/376773
		(typeof window !== 'undefined' && window.console && (window.console.firebug || (window.console.exception && window.console.table))) ||
		// Is firefox >= v31?
		// https://developer.mozilla.org/en-US/docs/Tools/Web_Console#Styling_messages
		(typeof navigator !== 'undefined' && navigator.userAgent && (m = navigator.userAgent.toLowerCase().match(/firefox\/(\d+)/)) && parseInt(m[1], 10) >= 31) ||
		// Double check webkit in userAgent just in case we are in a worker
		(typeof navigator !== 'undefined' && navigator.userAgent && navigator.userAgent.toLowerCase().match(/applewebkit\/(\d+)/));
}

/**
 * Colorize log arguments if enabled.
 *
 * @api public
 */

function formatArgs(args) {
	args[0] = (this.useColors ? '%c' : '') +
		this.namespace +
		(this.useColors ? ' %c' : ' ') +
		args[0] +
		(this.useColors ? '%c ' : ' ') +
		'+' + module.exports.humanize(this.diff);

	if (!this.useColors) {
		return;
	}

	const c = 'color: ' + this.color;
	args.splice(1, 0, c, 'color: inherit');

	// The final "%c" is somewhat tricky, because there could be other
	// arguments passed either before or after the %c, so we need to
	// figure out the correct index to insert the CSS into
	let index = 0;
	let lastC = 0;
	args[0].replace(/%[a-zA-Z%]/g, match => {
		if (match === '%%') {
			return;
		}
		index++;
		if (match === '%c') {
			// We only are interested in the *last* %c
			// (the user may have provided their own)
			lastC = index;
		}
	});

	args.splice(lastC, 0, c);
}

/**
 * Invokes `console.debug()` when available.
 * No-op when `console.debug` is not a "function".
 * If `console.debug` is not available, falls back
 * to `console.log`.
 *
 * @api public
 */
exports.log = console.debug || console.log || (() => {});

/**
 * Save `namespaces`.
 *
 * @param {String} namespaces
 * @api private
 */
function save(namespaces) {
	try {
		if (namespaces) {
			exports.storage.setItem('debug', namespaces);
		} else {
			exports.storage.removeItem('debug');
		}
	} catch (error) {
		// Swallow
		// XXX (@Qix-) should we be logging these?
	}
}

/**
 * Load `namespaces`.
 *
 * @return {String} returns the previously persisted debug modes
 * @api private
 */
function load() {
	let r;
	try {
		r = exports.storage.getItem('debug');
	} catch (error) {
		// Swallow
		// XXX (@Qix-) should we be logging these?
	}

	// If debug isn't set in LS, and we're in Electron, try to load $DEBUG
	if (!r && typeof process !== 'undefined' && 'env' in process) {
		r = process.env.DEBUG;
	}

	return r;
}

/**
 * Localstorage attempts to return the localstorage.
 *
 * This is necessary because safari throws
 * when a user disables cookies/localstorage
 * and you attempt to access it.
 *
 * @return {LocalStorage}
 * @api private
 */

function localstorage() {
	try {
		// TVMLKit (Apple TV JS Runtime) does not have a window object, just localStorage in the global context
		// The Browser also has localStorage in the global context.
		return localStorage;
	} catch (error) {
		// Swallow
		// XXX (@Qix-) should we be logging these?
	}
}

module.exports = __webpack_require__(/*! ./common */ "../../node_modules/debug/src/common.js")(exports);

const {formatters} = module.exports;

/**
 * Map %j to `JSON.stringify()`, since no Web Inspectors do that by default.
 */

formatters.j = function (v) {
	try {
		return JSON.stringify(v);
	} catch (error) {
		return '[UnexpectedJSONParseError]: ' + error.message;
	}
};


/***/ }),

/***/ "../../node_modules/debug/src/common.js":
/*!**********************************************!*\
  !*** ../../node_modules/debug/src/common.js ***!
  \**********************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {


/**
 * This is the common logic for both the Node.js and web browser
 * implementations of `debug()`.
 */

function setup(env) {
	createDebug.debug = createDebug;
	createDebug.default = createDebug;
	createDebug.coerce = coerce;
	createDebug.disable = disable;
	createDebug.enable = enable;
	createDebug.enabled = enabled;
	createDebug.humanize = __webpack_require__(/*! ms */ "../../node_modules/debug/node_modules/ms/index.js");
	createDebug.destroy = destroy;

	Object.keys(env).forEach(key => {
		createDebug[key] = env[key];
	});

	/**
	* The currently active debug mode names, and names to skip.
	*/

	createDebug.names = [];
	createDebug.skips = [];

	/**
	* Map of special "%n" handling functions, for the debug "format" argument.
	*
	* Valid key names are a single, lower or upper-case letter, i.e. "n" and "N".
	*/
	createDebug.formatters = {};

	/**
	* Selects a color for a debug namespace
	* @param {String} namespace The namespace string for the debug instance to be colored
	* @return {Number|String} An ANSI color code for the given namespace
	* @api private
	*/
	function selectColor(namespace) {
		let hash = 0;

		for (let i = 0; i < namespace.length; i++) {
			hash = ((hash << 5) - hash) + namespace.charCodeAt(i);
			hash |= 0; // Convert to 32bit integer
		}

		return createDebug.colors[Math.abs(hash) % createDebug.colors.length];
	}
	createDebug.selectColor = selectColor;

	/**
	* Create a debugger with the given `namespace`.
	*
	* @param {String} namespace
	* @return {Function}
	* @api public
	*/
	function createDebug(namespace) {
		let prevTime;
		let enableOverride = null;
		let namespacesCache;
		let enabledCache;

		function debug(...args) {
			// Disabled?
			if (!debug.enabled) {
				return;
			}

			const self = debug;

			// Set `diff` timestamp
			const curr = Number(new Date());
			const ms = curr - (prevTime || curr);
			self.diff = ms;
			self.prev = prevTime;
			self.curr = curr;
			prevTime = curr;

			args[0] = createDebug.coerce(args[0]);

			if (typeof args[0] !== 'string') {
				// Anything else let's inspect with %O
				args.unshift('%O');
			}

			// Apply any `formatters` transformations
			let index = 0;
			args[0] = args[0].replace(/%([a-zA-Z%])/g, (match, format) => {
				// If we encounter an escaped % then don't increase the array index
				if (match === '%%') {
					return '%';
				}
				index++;
				const formatter = createDebug.formatters[format];
				if (typeof formatter === 'function') {
					const val = args[index];
					match = formatter.call(self, val);

					// Now we need to remove `args[index]` since it's inlined in the `format`
					args.splice(index, 1);
					index--;
				}
				return match;
			});

			// Apply env-specific formatting (colors, etc.)
			createDebug.formatArgs.call(self, args);

			const logFn = self.log || createDebug.log;
			logFn.apply(self, args);
		}

		debug.namespace = namespace;
		debug.useColors = createDebug.useColors();
		debug.color = createDebug.selectColor(namespace);
		debug.extend = extend;
		debug.destroy = createDebug.destroy; // XXX Temporary. Will be removed in the next major release.

		Object.defineProperty(debug, 'enabled', {
			enumerable: true,
			configurable: false,
			get: () => {
				if (enableOverride !== null) {
					return enableOverride;
				}
				if (namespacesCache !== createDebug.namespaces) {
					namespacesCache = createDebug.namespaces;
					enabledCache = createDebug.enabled(namespace);
				}

				return enabledCache;
			},
			set: v => {
				enableOverride = v;
			}
		});

		// Env-specific initialization logic for debug instances
		if (typeof createDebug.init === 'function') {
			createDebug.init(debug);
		}

		return debug;
	}

	function extend(namespace, delimiter) {
		const newDebug = createDebug(this.namespace + (typeof delimiter === 'undefined' ? ':' : delimiter) + namespace);
		newDebug.log = this.log;
		return newDebug;
	}

	/**
	* Enables a debug mode by namespaces. This can include modes
	* separated by a colon and wildcards.
	*
	* @param {String} namespaces
	* @api public
	*/
	function enable(namespaces) {
		createDebug.save(namespaces);
		createDebug.namespaces = namespaces;

		createDebug.names = [];
		createDebug.skips = [];

		let i;
		const split = (typeof namespaces === 'string' ? namespaces : '').split(/[\s,]+/);
		const len = split.length;

		for (i = 0; i < len; i++) {
			if (!split[i]) {
				// ignore empty strings
				continue;
			}

			namespaces = split[i].replace(/\*/g, '.*?');

			if (namespaces[0] === '-') {
				createDebug.skips.push(new RegExp('^' + namespaces.slice(1) + '$'));
			} else {
				createDebug.names.push(new RegExp('^' + namespaces + '$'));
			}
		}
	}

	/**
	* Disable debug output.
	*
	* @return {String} namespaces
	* @api public
	*/
	function disable() {
		const namespaces = [
			...createDebug.names.map(toNamespace),
			...createDebug.skips.map(toNamespace).map(namespace => '-' + namespace)
		].join(',');
		createDebug.enable('');
		return namespaces;
	}

	/**
	* Returns true if the given mode name is enabled, false otherwise.
	*
	* @param {String} name
	* @return {Boolean}
	* @api public
	*/
	function enabled(name) {
		if (name[name.length - 1] === '*') {
			return true;
		}

		let i;
		let len;

		for (i = 0, len = createDebug.skips.length; i < len; i++) {
			if (createDebug.skips[i].test(name)) {
				return false;
			}
		}

		for (i = 0, len = createDebug.names.length; i < len; i++) {
			if (createDebug.names[i].test(name)) {
				return true;
			}
		}

		return false;
	}

	/**
	* Convert regexp to namespace
	*
	* @param {RegExp} regxep
	* @return {String} namespace
	* @api private
	*/
	function toNamespace(regexp) {
		return regexp.toString()
			.substring(2, regexp.toString().length - 2)
			.replace(/\.\*\?$/, '*');
	}

	/**
	* Coerce `val`.
	*
	* @param {Mixed} val
	* @return {Mixed}
	* @api private
	*/
	function coerce(val) {
		if (val instanceof Error) {
			return val.stack || val.message;
		}
		return val;
	}

	/**
	* XXX DO NOT USE. This is a temporary stub function.
	* XXX It WILL be removed in the next major release.
	*/
	function destroy() {
		console.warn('Instance method `debug.destroy()` is deprecated and no longer does anything. It will be removed in the next major version of `debug`.');
	}

	createDebug.enable(createDebug.load());

	return createDebug;
}

module.exports = setup;


/***/ }),

/***/ "../app/utils/assert.ts":
/*!******************************!*\
  !*** ../app/utils/assert.ts ***!
  \******************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   assert: () => (/* binding */ assert)
/* harmony export */ });
function assert(condition, msg) {
    if (!condition) throw new Error(msg || 'Assertion failed');
}


/***/ }),

/***/ "../app/utils/hexToBytea.ts":
/*!**********************************!*\
  !*** ../app/utils/hexToBytea.ts ***!
  \**********************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   hexToBytea: () => (/* binding */ hexToBytea)
/* harmony export */ });
/* harmony import */ var viem__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! viem */ "../../node_modules/viem/_esm/utils/data/isHex.js");
/* harmony import */ var _assert__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./assert */ "../app/utils/assert.ts");


/**
 * Converts a hex string to a Postgres bytea string.
 * @see https://www.postgresql.org/docs/16/functions-binarystring.html#ENCODE-FORMAT-HEX
 * @param str
 * @returns `\\x${string}`
 */ function hexToBytea(str) {
    (0,_assert__WEBPACK_IMPORTED_MODULE_0__.assert)((0,viem__WEBPACK_IMPORTED_MODULE_1__.isHex)(str), 'Hex string must start with 0x');
    return `\\x${str.slice(2).toLowerCase()}`;
}


/***/ }),

/***/ "./src/all-workflows.ts":
/*!******************************!*\
  !*** ./src/all-workflows.ts ***!
  \******************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   DistributionWorkflow: () => (/* reexport safe */ _distribution_workflow_workflow__WEBPACK_IMPORTED_MODULE_1__.DistributionWorkflow),
/* harmony export */   DistributionsWorkflow: () => (/* reexport safe */ _distribution_workflow_workflow__WEBPACK_IMPORTED_MODULE_1__.DistributionsWorkflow),
/* harmony export */   TransferWorkflow: () => (/* reexport safe */ _transfer_workflow_workflow__WEBPACK_IMPORTED_MODULE_0__.TransferWorkflow)
/* harmony export */ });
/* harmony import */ var _transfer_workflow_workflow__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./transfer-workflow/workflow */ "./src/transfer-workflow/workflow.ts");
/* harmony import */ var _distribution_workflow_workflow__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./distribution-workflow/workflow */ "./src/distribution-workflow/workflow.ts");




/***/ }),

/***/ "./src/distribution-workflow/workflow.ts":
/*!***********************************************!*\
  !*** ./src/distribution-workflow/workflow.ts ***!
  \***********************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   DistributionWorkflow: () => (/* binding */ DistributionWorkflow),
/* harmony export */   DistributionsWorkflow: () => (/* binding */ DistributionsWorkflow)
/* harmony export */ });
/* harmony import */ var _temporalio_workflow__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! @temporalio/workflow */ "../../node_modules/@temporalio/workflow/lib/index.js");
/* harmony import */ var _temporalio_workflow__WEBPACK_IMPORTED_MODULE_0___default = /*#__PURE__*/__webpack_require__.n(_temporalio_workflow__WEBPACK_IMPORTED_MODULE_0__);
// workflows.ts

const { calculateDistributionSharesActivity, fetchDistributionActivity, fetchAllOpenDistributionsActivity } = (0,_temporalio_workflow__WEBPACK_IMPORTED_MODULE_0__.proxyActivities)({
    startToCloseTimeout: '30 seconds'
});
async function DistributionWorkflow(distributionId) {
    const distribution = await fetchDistributionActivity(distributionId.toString());
    if (!distribution) throw new _temporalio_workflow__WEBPACK_IMPORTED_MODULE_0__.ApplicationFailure('Distribution not found');
    await calculateDistributionSharesActivity(distribution);
}
async function DistributionsWorkflow() {
    // fetch all distributions in qualification period
    const distributions = await fetchAllOpenDistributionsActivity();
    if (!distributions) throw new _temporalio_workflow__WEBPACK_IMPORTED_MODULE_0__.ApplicationFailure('No distributions found');
    for (const distribution of distributions){
        await DistributionWorkflow(distribution.id) // calculate one distribution at a time for now
        ;
    }
}


/***/ }),

/***/ "./src/transfer-workflow/workflow.ts":
/*!*******************************************!*\
  !*** ./src/transfer-workflow/workflow.ts ***!
  \*******************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   TransferWorkflow: () => (/* binding */ TransferWorkflow)
/* harmony export */ });
/* harmony import */ var _temporalio_workflow__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! @temporalio/workflow */ "../../node_modules/@temporalio/workflow/lib/index.js");
/* harmony import */ var _temporalio_workflow__WEBPACK_IMPORTED_MODULE_0___default = /*#__PURE__*/__webpack_require__.n(_temporalio_workflow__WEBPACK_IMPORTED_MODULE_0__);
/* harmony import */ var superjson__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! superjson */ "../../node_modules/superjson/dist/index.js");
/* harmony import */ var debug__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! debug */ "../../node_modules/debug/src/browser.js");
/* harmony import */ var debug__WEBPACK_IMPORTED_MODULE_2___default = /*#__PURE__*/__webpack_require__.n(debug__WEBPACK_IMPORTED_MODULE_2__);
/* harmony import */ var app_utils_hexToBytea__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! app/utils/hexToBytea */ "../app/utils/hexToBytea.ts");
function _define_property(obj, key, value) {
    if (key in obj) {
        Object.defineProperty(obj, key, {
            value: value,
            enumerable: true,
            configurable: true,
            writable: true
        });
    } else {
        obj[key] = value;
    }
    return obj;
}
function _object_spread(target) {
    for(var i = 1; i < arguments.length; i++){
        var source = arguments[i] != null ? arguments[i] : {};
        var ownKeys = Object.keys(source);
        if (typeof Object.getOwnPropertySymbols === "function") {
            ownKeys = ownKeys.concat(Object.getOwnPropertySymbols(source).filter(function(sym) {
                return Object.getOwnPropertyDescriptor(source, sym).enumerable;
            }));
        }
        ownKeys.forEach(function(key) {
            _define_property(target, key, source[key]);
        });
    }
    return target;
}
function ownKeys(object, enumerableOnly) {
    var keys = Object.keys(object);
    if (Object.getOwnPropertySymbols) {
        var symbols = Object.getOwnPropertySymbols(object);
        if (enumerableOnly) {
            symbols = symbols.filter(function(sym) {
                return Object.getOwnPropertyDescriptor(object, sym).enumerable;
            });
        }
        keys.push.apply(keys, symbols);
    }
    return keys;
}
function _object_spread_props(target, source) {
    source = source != null ? source : {};
    if (Object.getOwnPropertyDescriptors) {
        Object.defineProperties(target, Object.getOwnPropertyDescriptors(source));
    } else {
        ownKeys(Object(source)).forEach(function(key) {
            Object.defineProperty(target, key, Object.getOwnPropertyDescriptor(source, key));
        });
    }
    return target;
}




const log = debug__WEBPACK_IMPORTED_MODULE_2___default()('workflows:transfer');
const { upsertTemporalSendAccountTransferActivity, simulateTransferActivity, getBaseBlockNumberActivity, decodeTransferUserOpActivity, updateTemporalSendAccountTransferActivity, sendUserOpActivity, waitForTransactionReceiptActivity } = (0,_temporalio_workflow__WEBPACK_IMPORTED_MODULE_0__.proxyActivities)({
    // TODO: make this configurablea
    startToCloseTimeout: '10 minutes'
});
async function TransferWorkflow(userOp) {
    const workflowId = (0,_temporalio_workflow__WEBPACK_IMPORTED_MODULE_0__.workflowInfo)().workflowId;
    log('Starting SendTransfer Workflow with userOp:', workflowId);
    await upsertTemporalSendAccountTransferActivity({
        workflowId,
        data: {
            sender: (0,app_utils_hexToBytea__WEBPACK_IMPORTED_MODULE_3__.hexToBytea)(userOp.sender)
        }
    });
    log('Simulating transfer', workflowId);
    const _ = await simulateTransferActivity(workflowId, userOp);
    log('Successfully simulated transfer', workflowId);
    log('Getting latest base block', workflowId);
    const createdAtBlockNum = await getBaseBlockNumberActivity();
    log('Base block:', {
        workflowId,
        createdAtBlockNum: createdAtBlockNum.toString()
    });
    log('Decoding transfer userOp', workflowId);
    const { token, from, to, amount } = await decodeTransferUserOpActivity(workflowId, userOp);
    log('Decoded transfer userOp', {
        workflowId,
        token,
        from,
        to,
        amount: amount.toString()
    });
    log('Inserting temporal transfer into temporal.send_account_transfers', workflowId);
    const submittedTransfer = token ? await updateTemporalSendAccountTransferActivity({
        workflowId,
        status: 'submitted',
        createdAtBlockNum,
        data: {
            f: from,
            t: to,
            v: amount.toString(),
            log_addr: token
        }
    }) : await updateTemporalSendAccountTransferActivity({
        workflowId,
        status: 'submitted',
        createdAtBlockNum,
        data: {
            sender: from,
            value: amount.toString(),
            log_addr: to
        }
    });
    log('Inserted temporal transfer into temporal.send_account_transfers', workflowId);
    log('Sending UserOperation', superjson__WEBPACK_IMPORTED_MODULE_1__["default"].stringify(userOp));
    const hash = await sendUserOpActivity(workflowId, userOp);
    log('UserOperation sent, hash:', hash);
    const sentTransfer = await updateTemporalSendAccountTransferActivity({
        workflowId,
        status: 'sent',
        data: _object_spread_props(_object_spread({}, submittedTransfer.data), {
            user_op_hash: hash
        })
    });
    const receipt = await waitForTransactionReceiptActivity(workflowId, hash);
    log('Receipt received:', {
        tx_hash: receipt.transactionHash
    });
    await updateTemporalSendAccountTransferActivity({
        workflowId,
        status: 'confirmed',
        data: _object_spread_props(_object_spread({}, sentTransfer.data), {
            tx_hash: (0,app_utils_hexToBytea__WEBPACK_IMPORTED_MODULE_3__.hexToBytea)(receipt.transactionHash),
            block_num: receipt.blockNumber.toString()
        })
    });
    return hash;
}


/***/ }),

/***/ "?75e1":
/*!*****************************************************!*\
  !*** __temporal_custom_failure_converter (ignored) ***!
  \*****************************************************/
/***/ (() => {

/* (ignored) */

/***/ }),

/***/ "../../node_modules/@temporalio/common/node_modules/ms/dist/index.cjs":
/*!****************************************************************************!*\
  !*** ../../node_modules/@temporalio/common/node_modules/ms/dist/index.cjs ***!
  \****************************************************************************/
/***/ ((module, exports) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({ value: true }));
// Helpers.
const s = 1000;
const m = s * 60;
const h = m * 60;
const d = h * 24;
const w = d * 7;
const y = d * 365.25;
function ms(value, options) {
    try {
        if (typeof value === 'string' && value.length > 0) {
            return parse(value);
        }
        else if (typeof value === 'number' && isFinite(value)) {
            return options?.long ? fmtLong(value) : fmtShort(value);
        }
        throw new Error('Value is not a string or number.');
    }
    catch (error) {
        const message = isError(error)
            ? `${error.message}. value=${JSON.stringify(value)}`
            : 'An unknown error has occured.';
        throw new Error(message);
    }
}
/**
 * Parse the given `str` and return milliseconds.
 */
function parse(str) {
    str = String(str);
    if (str.length > 100) {
        throw new Error('Value exceeds the maximum length of 100 characters.');
    }
    const match = /^(-?(?:\d+)?\.?\d+) *(milliseconds?|msecs?|ms|seconds?|secs?|s|minutes?|mins?|m|hours?|hrs?|h|days?|d|weeks?|w|years?|yrs?|y)?$/i.exec(str);
    if (!match) {
        return NaN;
    }
    const n = parseFloat(match[1]);
    const type = (match[2] || 'ms').toLowerCase();
    switch (type) {
        case 'years':
        case 'year':
        case 'yrs':
        case 'yr':
        case 'y':
            return n * y;
        case 'weeks':
        case 'week':
        case 'w':
            return n * w;
        case 'days':
        case 'day':
        case 'd':
            return n * d;
        case 'hours':
        case 'hour':
        case 'hrs':
        case 'hr':
        case 'h':
            return n * h;
        case 'minutes':
        case 'minute':
        case 'mins':
        case 'min':
        case 'm':
            return n * m;
        case 'seconds':
        case 'second':
        case 'secs':
        case 'sec':
        case 's':
            return n * s;
        case 'milliseconds':
        case 'millisecond':
        case 'msecs':
        case 'msec':
        case 'ms':
            return n;
        default:
            // This should never occur.
            throw new Error(`The unit ${type} was matched, but no matching case exists.`);
    }
}
exports["default"] = ms;
/**
 * Short format for `ms`.
 */
function fmtShort(ms) {
    const msAbs = Math.abs(ms);
    if (msAbs >= d) {
        return `${Math.round(ms / d)}d`;
    }
    if (msAbs >= h) {
        return `${Math.round(ms / h)}h`;
    }
    if (msAbs >= m) {
        return `${Math.round(ms / m)}m`;
    }
    if (msAbs >= s) {
        return `${Math.round(ms / s)}s`;
    }
    return `${ms}ms`;
}
/**
 * Long format for `ms`.
 */
function fmtLong(ms) {
    const msAbs = Math.abs(ms);
    if (msAbs >= d) {
        return plural(ms, msAbs, d, 'day');
    }
    if (msAbs >= h) {
        return plural(ms, msAbs, h, 'hour');
    }
    if (msAbs >= m) {
        return plural(ms, msAbs, m, 'minute');
    }
    if (msAbs >= s) {
        return plural(ms, msAbs, s, 'second');
    }
    return `${ms} ms`;
}
/**
 * Pluralization helper.
 */
function plural(ms, msAbs, n, name) {
    const isPlural = msAbs >= n * 1.5;
    return `${Math.round(ms / n)} ${name}${isPlural ? 's' : ''}`;
}
/**
 * A type guard for errors.
 */
function isError(error) {
    return typeof error === 'object' && error !== null && 'message' in error;
}
module.exports = exports.default;
module.exports["default"] = exports.default;


/***/ }),

/***/ "../../node_modules/@temporalio/workflow/node_modules/ms/dist/index.cjs":
/*!******************************************************************************!*\
  !*** ../../node_modules/@temporalio/workflow/node_modules/ms/dist/index.cjs ***!
  \******************************************************************************/
/***/ ((module, exports) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({ value: true }));
// Helpers.
const s = 1000;
const m = s * 60;
const h = m * 60;
const d = h * 24;
const w = d * 7;
const y = d * 365.25;
function ms(value, options) {
    try {
        if (typeof value === 'string' && value.length > 0) {
            return parse(value);
        }
        else if (typeof value === 'number' && isFinite(value)) {
            return options?.long ? fmtLong(value) : fmtShort(value);
        }
        throw new Error('Value is not a string or number.');
    }
    catch (error) {
        const message = isError(error)
            ? `${error.message}. value=${JSON.stringify(value)}`
            : 'An unknown error has occured.';
        throw new Error(message);
    }
}
/**
 * Parse the given `str` and return milliseconds.
 */
function parse(str) {
    str = String(str);
    if (str.length > 100) {
        throw new Error('Value exceeds the maximum length of 100 characters.');
    }
    const match = /^(-?(?:\d+)?\.?\d+) *(milliseconds?|msecs?|ms|seconds?|secs?|s|minutes?|mins?|m|hours?|hrs?|h|days?|d|weeks?|w|years?|yrs?|y)?$/i.exec(str);
    if (!match) {
        return NaN;
    }
    const n = parseFloat(match[1]);
    const type = (match[2] || 'ms').toLowerCase();
    switch (type) {
        case 'years':
        case 'year':
        case 'yrs':
        case 'yr':
        case 'y':
            return n * y;
        case 'weeks':
        case 'week':
        case 'w':
            return n * w;
        case 'days':
        case 'day':
        case 'd':
            return n * d;
        case 'hours':
        case 'hour':
        case 'hrs':
        case 'hr':
        case 'h':
            return n * h;
        case 'minutes':
        case 'minute':
        case 'mins':
        case 'min':
        case 'm':
            return n * m;
        case 'seconds':
        case 'second':
        case 'secs':
        case 'sec':
        case 's':
            return n * s;
        case 'milliseconds':
        case 'millisecond':
        case 'msecs':
        case 'msec':
        case 'ms':
            return n;
        default:
            // This should never occur.
            throw new Error(`The unit ${type} was matched, but no matching case exists.`);
    }
}
exports["default"] = ms;
/**
 * Short format for `ms`.
 */
function fmtShort(ms) {
    const msAbs = Math.abs(ms);
    if (msAbs >= d) {
        return `${Math.round(ms / d)}d`;
    }
    if (msAbs >= h) {
        return `${Math.round(ms / h)}h`;
    }
    if (msAbs >= m) {
        return `${Math.round(ms / m)}m`;
    }
    if (msAbs >= s) {
        return `${Math.round(ms / s)}s`;
    }
    return `${ms}ms`;
}
/**
 * Long format for `ms`.
 */
function fmtLong(ms) {
    const msAbs = Math.abs(ms);
    if (msAbs >= d) {
        return plural(ms, msAbs, d, 'day');
    }
    if (msAbs >= h) {
        return plural(ms, msAbs, h, 'hour');
    }
    if (msAbs >= m) {
        return plural(ms, msAbs, m, 'minute');
    }
    if (msAbs >= s) {
        return plural(ms, msAbs, s, 'second');
    }
    return `${ms} ms`;
}
/**
 * Pluralization helper.
 */
function plural(ms, msAbs, n, name) {
    const isPlural = msAbs >= n * 1.5;
    return `${Math.round(ms / n)} ${name}${isPlural ? 's' : ''}`;
}
/**
 * A type guard for errors.
 */
function isError(error) {
    return typeof error === 'object' && error !== null && 'message' in error;
}
module.exports = exports.default;
module.exports["default"] = exports.default;


/***/ }),

/***/ "../../node_modules/long/umd/index.js":
/*!********************************************!*\
  !*** ../../node_modules/long/umd/index.js ***!
  \********************************************/
/***/ ((module, exports) => {

var __WEBPACK_AMD_DEFINE_ARRAY__, __WEBPACK_AMD_DEFINE_RESULT__;// GENERATED FILE. DO NOT EDIT.
var Long = (function(exports) {
  "use strict";
  
  Object.defineProperty(exports, "__esModule", {
    value: true
  });
  exports.default = void 0;
  
  /**
   * @license
   * Copyright 2009 The Closure Library Authors
   * Copyright 2020 Daniel Wirtz / The long.js Authors.
   *
   * Licensed under the Apache License, Version 2.0 (the "License");
   * you may not use this file except in compliance with the License.
   * You may obtain a copy of the License at
   *
   *     http://www.apache.org/licenses/LICENSE-2.0
   *
   * Unless required by applicable law or agreed to in writing, software
   * distributed under the License is distributed on an "AS IS" BASIS,
   * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
   * See the License for the specific language governing permissions and
   * limitations under the License.
   *
   * SPDX-License-Identifier: Apache-2.0
   */
  // WebAssembly optimizations to do native i64 multiplication and divide
  var wasm = null;
  
  try {
    wasm = new WebAssembly.Instance(new WebAssembly.Module(new Uint8Array([0, 97, 115, 109, 1, 0, 0, 0, 1, 13, 2, 96, 0, 1, 127, 96, 4, 127, 127, 127, 127, 1, 127, 3, 7, 6, 0, 1, 1, 1, 1, 1, 6, 6, 1, 127, 1, 65, 0, 11, 7, 50, 6, 3, 109, 117, 108, 0, 1, 5, 100, 105, 118, 95, 115, 0, 2, 5, 100, 105, 118, 95, 117, 0, 3, 5, 114, 101, 109, 95, 115, 0, 4, 5, 114, 101, 109, 95, 117, 0, 5, 8, 103, 101, 116, 95, 104, 105, 103, 104, 0, 0, 10, 191, 1, 6, 4, 0, 35, 0, 11, 36, 1, 1, 126, 32, 0, 173, 32, 1, 173, 66, 32, 134, 132, 32, 2, 173, 32, 3, 173, 66, 32, 134, 132, 126, 34, 4, 66, 32, 135, 167, 36, 0, 32, 4, 167, 11, 36, 1, 1, 126, 32, 0, 173, 32, 1, 173, 66, 32, 134, 132, 32, 2, 173, 32, 3, 173, 66, 32, 134, 132, 127, 34, 4, 66, 32, 135, 167, 36, 0, 32, 4, 167, 11, 36, 1, 1, 126, 32, 0, 173, 32, 1, 173, 66, 32, 134, 132, 32, 2, 173, 32, 3, 173, 66, 32, 134, 132, 128, 34, 4, 66, 32, 135, 167, 36, 0, 32, 4, 167, 11, 36, 1, 1, 126, 32, 0, 173, 32, 1, 173, 66, 32, 134, 132, 32, 2, 173, 32, 3, 173, 66, 32, 134, 132, 129, 34, 4, 66, 32, 135, 167, 36, 0, 32, 4, 167, 11, 36, 1, 1, 126, 32, 0, 173, 32, 1, 173, 66, 32, 134, 132, 32, 2, 173, 32, 3, 173, 66, 32, 134, 132, 130, 34, 4, 66, 32, 135, 167, 36, 0, 32, 4, 167, 11])), {}).exports;
  } catch (e) {// no wasm support :(
  }
  /**
   * Constructs a 64 bit two's-complement integer, given its low and high 32 bit values as *signed* integers.
   *  See the from* functions below for more convenient ways of constructing Longs.
   * @exports Long
   * @class A Long class for representing a 64 bit two's-complement integer value.
   * @param {number} low The low (signed) 32 bits of the long
   * @param {number} high The high (signed) 32 bits of the long
   * @param {boolean=} unsigned Whether unsigned or not, defaults to signed
   * @constructor
   */
  
  
  function Long(low, high, unsigned) {
    /**
     * The low 32 bits as a signed value.
     * @type {number}
     */
    this.low = low | 0;
    /**
     * The high 32 bits as a signed value.
     * @type {number}
     */
  
    this.high = high | 0;
    /**
     * Whether unsigned or not.
     * @type {boolean}
     */
  
    this.unsigned = !!unsigned;
  } // The internal representation of a long is the two given signed, 32-bit values.
  // We use 32-bit pieces because these are the size of integers on which
  // Javascript performs bit-operations.  For operations like addition and
  // multiplication, we split each number into 16 bit pieces, which can easily be
  // multiplied within Javascript's floating-point representation without overflow
  // or change in sign.
  //
  // In the algorithms below, we frequently reduce the negative case to the
  // positive case by negating the input(s) and then post-processing the result.
  // Note that we must ALWAYS check specially whether those values are MIN_VALUE
  // (-2^63) because -MIN_VALUE == MIN_VALUE (since 2^63 cannot be represented as
  // a positive number, it overflows back into a negative).  Not handling this
  // case would often result in infinite recursion.
  //
  // Common constant values ZERO, ONE, NEG_ONE, etc. are defined below the from*
  // methods on which they depend.
  
  /**
   * An indicator used to reliably determine if an object is a Long or not.
   * @type {boolean}
   * @const
   * @private
   */
  
  
  Long.prototype.__isLong__;
  Object.defineProperty(Long.prototype, "__isLong__", {
    value: true
  });
  /**
   * @function
   * @param {*} obj Object
   * @returns {boolean}
   * @inner
   */
  
  function isLong(obj) {
    return (obj && obj["__isLong__"]) === true;
  }
  /**
   * @function
   * @param {*} value number
   * @returns {number}
   * @inner
   */
  
  
  function ctz32(value) {
    var c = Math.clz32(value & -value);
    return value ? 31 - c : c;
  }
  /**
   * Tests if the specified object is a Long.
   * @function
   * @param {*} obj Object
   * @returns {boolean}
   */
  
  
  Long.isLong = isLong;
  /**
   * A cache of the Long representations of small integer values.
   * @type {!Object}
   * @inner
   */
  
  var INT_CACHE = {};
  /**
   * A cache of the Long representations of small unsigned integer values.
   * @type {!Object}
   * @inner
   */
  
  var UINT_CACHE = {};
  /**
   * @param {number} value
   * @param {boolean=} unsigned
   * @returns {!Long}
   * @inner
   */
  
  function fromInt(value, unsigned) {
    var obj, cachedObj, cache;
  
    if (unsigned) {
      value >>>= 0;
  
      if (cache = 0 <= value && value < 256) {
        cachedObj = UINT_CACHE[value];
        if (cachedObj) return cachedObj;
      }
  
      obj = fromBits(value, 0, true);
      if (cache) UINT_CACHE[value] = obj;
      return obj;
    } else {
      value |= 0;
  
      if (cache = -128 <= value && value < 128) {
        cachedObj = INT_CACHE[value];
        if (cachedObj) return cachedObj;
      }
  
      obj = fromBits(value, value < 0 ? -1 : 0, false);
      if (cache) INT_CACHE[value] = obj;
      return obj;
    }
  }
  /**
   * Returns a Long representing the given 32 bit integer value.
   * @function
   * @param {number} value The 32 bit integer in question
   * @param {boolean=} unsigned Whether unsigned or not, defaults to signed
   * @returns {!Long} The corresponding Long value
   */
  
  
  Long.fromInt = fromInt;
  /**
   * @param {number} value
   * @param {boolean=} unsigned
   * @returns {!Long}
   * @inner
   */
  
  function fromNumber(value, unsigned) {
    if (isNaN(value)) return unsigned ? UZERO : ZERO;
  
    if (unsigned) {
      if (value < 0) return UZERO;
      if (value >= TWO_PWR_64_DBL) return MAX_UNSIGNED_VALUE;
    } else {
      if (value <= -TWO_PWR_63_DBL) return MIN_VALUE;
      if (value + 1 >= TWO_PWR_63_DBL) return MAX_VALUE;
    }
  
    if (value < 0) return fromNumber(-value, unsigned).neg();
    return fromBits(value % TWO_PWR_32_DBL | 0, value / TWO_PWR_32_DBL | 0, unsigned);
  }
  /**
   * Returns a Long representing the given value, provided that it is a finite number. Otherwise, zero is returned.
   * @function
   * @param {number} value The number in question
   * @param {boolean=} unsigned Whether unsigned or not, defaults to signed
   * @returns {!Long} The corresponding Long value
   */
  
  
  Long.fromNumber = fromNumber;
  /**
   * @param {number} lowBits
   * @param {number} highBits
   * @param {boolean=} unsigned
   * @returns {!Long}
   * @inner
   */
  
  function fromBits(lowBits, highBits, unsigned) {
    return new Long(lowBits, highBits, unsigned);
  }
  /**
   * Returns a Long representing the 64 bit integer that comes by concatenating the given low and high bits. Each is
   *  assumed to use 32 bits.
   * @function
   * @param {number} lowBits The low 32 bits
   * @param {number} highBits The high 32 bits
   * @param {boolean=} unsigned Whether unsigned or not, defaults to signed
   * @returns {!Long} The corresponding Long value
   */
  
  
  Long.fromBits = fromBits;
  /**
   * @function
   * @param {number} base
   * @param {number} exponent
   * @returns {number}
   * @inner
   */
  
  var pow_dbl = Math.pow; // Used 4 times (4*8 to 15+4)
  
  /**
   * @param {string} str
   * @param {(boolean|number)=} unsigned
   * @param {number=} radix
   * @returns {!Long}
   * @inner
   */
  
  function fromString(str, unsigned, radix) {
    if (str.length === 0) throw Error('empty string');
  
    if (typeof unsigned === 'number') {
      // For goog.math.long compatibility
      radix = unsigned;
      unsigned = false;
    } else {
      unsigned = !!unsigned;
    }
  
    if (str === "NaN" || str === "Infinity" || str === "+Infinity" || str === "-Infinity") return unsigned ? UZERO : ZERO;
    radix = radix || 10;
    if (radix < 2 || 36 < radix) throw RangeError('radix');
    var p;
    if ((p = str.indexOf('-')) > 0) throw Error('interior hyphen');else if (p === 0) {
      return fromString(str.substring(1), unsigned, radix).neg();
    } // Do several (8) digits each time through the loop, so as to
    // minimize the calls to the very expensive emulated div.
  
    var radixToPower = fromNumber(pow_dbl(radix, 8));
    var result = ZERO;
  
    for (var i = 0; i < str.length; i += 8) {
      var size = Math.min(8, str.length - i),
          value = parseInt(str.substring(i, i + size), radix);
  
      if (size < 8) {
        var power = fromNumber(pow_dbl(radix, size));
        result = result.mul(power).add(fromNumber(value));
      } else {
        result = result.mul(radixToPower);
        result = result.add(fromNumber(value));
      }
    }
  
    result.unsigned = unsigned;
    return result;
  }
  /**
   * Returns a Long representation of the given string, written using the specified radix.
   * @function
   * @param {string} str The textual representation of the Long
   * @param {(boolean|number)=} unsigned Whether unsigned or not, defaults to signed
   * @param {number=} radix The radix in which the text is written (2-36), defaults to 10
   * @returns {!Long} The corresponding Long value
   */
  
  
  Long.fromString = fromString;
  /**
   * @function
   * @param {!Long|number|string|!{low: number, high: number, unsigned: boolean}} val
   * @param {boolean=} unsigned
   * @returns {!Long}
   * @inner
   */
  
  function fromValue(val, unsigned) {
    if (typeof val === 'number') return fromNumber(val, unsigned);
    if (typeof val === 'string') return fromString(val, unsigned); // Throws for non-objects, converts non-instanceof Long:
  
    return fromBits(val.low, val.high, typeof unsigned === 'boolean' ? unsigned : val.unsigned);
  }
  /**
   * Converts the specified value to a Long using the appropriate from* function for its type.
   * @function
   * @param {!Long|number|string|!{low: number, high: number, unsigned: boolean}} val Value
   * @param {boolean=} unsigned Whether unsigned or not, defaults to signed
   * @returns {!Long}
   */
  
  
  Long.fromValue = fromValue; // NOTE: the compiler should inline these constant values below and then remove these variables, so there should be
  // no runtime penalty for these.
  
  /**
   * @type {number}
   * @const
   * @inner
   */
  
  var TWO_PWR_16_DBL = 1 << 16;
  /**
   * @type {number}
   * @const
   * @inner
   */
  
  var TWO_PWR_24_DBL = 1 << 24;
  /**
   * @type {number}
   * @const
   * @inner
   */
  
  var TWO_PWR_32_DBL = TWO_PWR_16_DBL * TWO_PWR_16_DBL;
  /**
   * @type {number}
   * @const
   * @inner
   */
  
  var TWO_PWR_64_DBL = TWO_PWR_32_DBL * TWO_PWR_32_DBL;
  /**
   * @type {number}
   * @const
   * @inner
   */
  
  var TWO_PWR_63_DBL = TWO_PWR_64_DBL / 2;
  /**
   * @type {!Long}
   * @const
   * @inner
   */
  
  var TWO_PWR_24 = fromInt(TWO_PWR_24_DBL);
  /**
   * @type {!Long}
   * @inner
   */
  
  var ZERO = fromInt(0);
  /**
   * Signed zero.
   * @type {!Long}
   */
  
  Long.ZERO = ZERO;
  /**
   * @type {!Long}
   * @inner
   */
  
  var UZERO = fromInt(0, true);
  /**
   * Unsigned zero.
   * @type {!Long}
   */
  
  Long.UZERO = UZERO;
  /**
   * @type {!Long}
   * @inner
   */
  
  var ONE = fromInt(1);
  /**
   * Signed one.
   * @type {!Long}
   */
  
  Long.ONE = ONE;
  /**
   * @type {!Long}
   * @inner
   */
  
  var UONE = fromInt(1, true);
  /**
   * Unsigned one.
   * @type {!Long}
   */
  
  Long.UONE = UONE;
  /**
   * @type {!Long}
   * @inner
   */
  
  var NEG_ONE = fromInt(-1);
  /**
   * Signed negative one.
   * @type {!Long}
   */
  
  Long.NEG_ONE = NEG_ONE;
  /**
   * @type {!Long}
   * @inner
   */
  
  var MAX_VALUE = fromBits(0xFFFFFFFF | 0, 0x7FFFFFFF | 0, false);
  /**
   * Maximum signed value.
   * @type {!Long}
   */
  
  Long.MAX_VALUE = MAX_VALUE;
  /**
   * @type {!Long}
   * @inner
   */
  
  var MAX_UNSIGNED_VALUE = fromBits(0xFFFFFFFF | 0, 0xFFFFFFFF | 0, true);
  /**
   * Maximum unsigned value.
   * @type {!Long}
   */
  
  Long.MAX_UNSIGNED_VALUE = MAX_UNSIGNED_VALUE;
  /**
   * @type {!Long}
   * @inner
   */
  
  var MIN_VALUE = fromBits(0, 0x80000000 | 0, false);
  /**
   * Minimum signed value.
   * @type {!Long}
   */
  
  Long.MIN_VALUE = MIN_VALUE;
  /**
   * @alias Long.prototype
   * @inner
   */
  
  var LongPrototype = Long.prototype;
  /**
   * Converts the Long to a 32 bit integer, assuming it is a 32 bit integer.
   * @this {!Long}
   * @returns {number}
   */
  
  LongPrototype.toInt = function toInt() {
    return this.unsigned ? this.low >>> 0 : this.low;
  };
  /**
   * Converts the Long to a the nearest floating-point representation of this value (double, 53 bit mantissa).
   * @this {!Long}
   * @returns {number}
   */
  
  
  LongPrototype.toNumber = function toNumber() {
    if (this.unsigned) return (this.high >>> 0) * TWO_PWR_32_DBL + (this.low >>> 0);
    return this.high * TWO_PWR_32_DBL + (this.low >>> 0);
  };
  /**
   * Converts the Long to a string written in the specified radix.
   * @this {!Long}
   * @param {number=} radix Radix (2-36), defaults to 10
   * @returns {string}
   * @override
   * @throws {RangeError} If `radix` is out of range
   */
  
  
  LongPrototype.toString = function toString(radix) {
    radix = radix || 10;
    if (radix < 2 || 36 < radix) throw RangeError('radix');
    if (this.isZero()) return '0';
  
    if (this.isNegative()) {
      // Unsigned Longs are never negative
      if (this.eq(MIN_VALUE)) {
        // We need to change the Long value before it can be negated, so we remove
        // the bottom-most digit in this base and then recurse to do the rest.
        var radixLong = fromNumber(radix),
            div = this.div(radixLong),
            rem1 = div.mul(radixLong).sub(this);
        return div.toString(radix) + rem1.toInt().toString(radix);
      } else return '-' + this.neg().toString(radix);
    } // Do several (6) digits each time through the loop, so as to
    // minimize the calls to the very expensive emulated div.
  
  
    var radixToPower = fromNumber(pow_dbl(radix, 6), this.unsigned),
        rem = this;
    var result = '';
  
    while (true) {
      var remDiv = rem.div(radixToPower),
          intval = rem.sub(remDiv.mul(radixToPower)).toInt() >>> 0,
          digits = intval.toString(radix);
      rem = remDiv;
      if (rem.isZero()) return digits + result;else {
        while (digits.length < 6) digits = '0' + digits;
  
        result = '' + digits + result;
      }
    }
  };
  /**
   * Gets the high 32 bits as a signed integer.
   * @this {!Long}
   * @returns {number} Signed high bits
   */
  
  
  LongPrototype.getHighBits = function getHighBits() {
    return this.high;
  };
  /**
   * Gets the high 32 bits as an unsigned integer.
   * @this {!Long}
   * @returns {number} Unsigned high bits
   */
  
  
  LongPrototype.getHighBitsUnsigned = function getHighBitsUnsigned() {
    return this.high >>> 0;
  };
  /**
   * Gets the low 32 bits as a signed integer.
   * @this {!Long}
   * @returns {number} Signed low bits
   */
  
  
  LongPrototype.getLowBits = function getLowBits() {
    return this.low;
  };
  /**
   * Gets the low 32 bits as an unsigned integer.
   * @this {!Long}
   * @returns {number} Unsigned low bits
   */
  
  
  LongPrototype.getLowBitsUnsigned = function getLowBitsUnsigned() {
    return this.low >>> 0;
  };
  /**
   * Gets the number of bits needed to represent the absolute value of this Long.
   * @this {!Long}
   * @returns {number}
   */
  
  
  LongPrototype.getNumBitsAbs = function getNumBitsAbs() {
    if (this.isNegative()) // Unsigned Longs are never negative
      return this.eq(MIN_VALUE) ? 64 : this.neg().getNumBitsAbs();
    var val = this.high != 0 ? this.high : this.low;
  
    for (var bit = 31; bit > 0; bit--) if ((val & 1 << bit) != 0) break;
  
    return this.high != 0 ? bit + 33 : bit + 1;
  };
  /**
   * Tests if this Long's value equals zero.
   * @this {!Long}
   * @returns {boolean}
   */
  
  
  LongPrototype.isZero = function isZero() {
    return this.high === 0 && this.low === 0;
  };
  /**
   * Tests if this Long's value equals zero. This is an alias of {@link Long#isZero}.
   * @returns {boolean}
   */
  
  
  LongPrototype.eqz = LongPrototype.isZero;
  /**
   * Tests if this Long's value is negative.
   * @this {!Long}
   * @returns {boolean}
   */
  
  LongPrototype.isNegative = function isNegative() {
    return !this.unsigned && this.high < 0;
  };
  /**
   * Tests if this Long's value is positive or zero.
   * @this {!Long}
   * @returns {boolean}
   */
  
  
  LongPrototype.isPositive = function isPositive() {
    return this.unsigned || this.high >= 0;
  };
  /**
   * Tests if this Long's value is odd.
   * @this {!Long}
   * @returns {boolean}
   */
  
  
  LongPrototype.isOdd = function isOdd() {
    return (this.low & 1) === 1;
  };
  /**
   * Tests if this Long's value is even.
   * @this {!Long}
   * @returns {boolean}
   */
  
  
  LongPrototype.isEven = function isEven() {
    return (this.low & 1) === 0;
  };
  /**
   * Tests if this Long's value equals the specified's.
   * @this {!Long}
   * @param {!Long|number|string} other Other value
   * @returns {boolean}
   */
  
  
  LongPrototype.equals = function equals(other) {
    if (!isLong(other)) other = fromValue(other);
    if (this.unsigned !== other.unsigned && this.high >>> 31 === 1 && other.high >>> 31 === 1) return false;
    return this.high === other.high && this.low === other.low;
  };
  /**
   * Tests if this Long's value equals the specified's. This is an alias of {@link Long#equals}.
   * @function
   * @param {!Long|number|string} other Other value
   * @returns {boolean}
   */
  
  
  LongPrototype.eq = LongPrototype.equals;
  /**
   * Tests if this Long's value differs from the specified's.
   * @this {!Long}
   * @param {!Long|number|string} other Other value
   * @returns {boolean}
   */
  
  LongPrototype.notEquals = function notEquals(other) {
    return !this.eq(
    /* validates */
    other);
  };
  /**
   * Tests if this Long's value differs from the specified's. This is an alias of {@link Long#notEquals}.
   * @function
   * @param {!Long|number|string} other Other value
   * @returns {boolean}
   */
  
  
  LongPrototype.neq = LongPrototype.notEquals;
  /**
   * Tests if this Long's value differs from the specified's. This is an alias of {@link Long#notEquals}.
   * @function
   * @param {!Long|number|string} other Other value
   * @returns {boolean}
   */
  
  LongPrototype.ne = LongPrototype.notEquals;
  /**
   * Tests if this Long's value is less than the specified's.
   * @this {!Long}
   * @param {!Long|number|string} other Other value
   * @returns {boolean}
   */
  
  LongPrototype.lessThan = function lessThan(other) {
    return this.comp(
    /* validates */
    other) < 0;
  };
  /**
   * Tests if this Long's value is less than the specified's. This is an alias of {@link Long#lessThan}.
   * @function
   * @param {!Long|number|string} other Other value
   * @returns {boolean}
   */
  
  
  LongPrototype.lt = LongPrototype.lessThan;
  /**
   * Tests if this Long's value is less than or equal the specified's.
   * @this {!Long}
   * @param {!Long|number|string} other Other value
   * @returns {boolean}
   */
  
  LongPrototype.lessThanOrEqual = function lessThanOrEqual(other) {
    return this.comp(
    /* validates */
    other) <= 0;
  };
  /**
   * Tests if this Long's value is less than or equal the specified's. This is an alias of {@link Long#lessThanOrEqual}.
   * @function
   * @param {!Long|number|string} other Other value
   * @returns {boolean}
   */
  
  
  LongPrototype.lte = LongPrototype.lessThanOrEqual;
  /**
   * Tests if this Long's value is less than or equal the specified's. This is an alias of {@link Long#lessThanOrEqual}.
   * @function
   * @param {!Long|number|string} other Other value
   * @returns {boolean}
   */
  
  LongPrototype.le = LongPrototype.lessThanOrEqual;
  /**
   * Tests if this Long's value is greater than the specified's.
   * @this {!Long}
   * @param {!Long|number|string} other Other value
   * @returns {boolean}
   */
  
  LongPrototype.greaterThan = function greaterThan(other) {
    return this.comp(
    /* validates */
    other) > 0;
  };
  /**
   * Tests if this Long's value is greater than the specified's. This is an alias of {@link Long#greaterThan}.
   * @function
   * @param {!Long|number|string} other Other value
   * @returns {boolean}
   */
  
  
  LongPrototype.gt = LongPrototype.greaterThan;
  /**
   * Tests if this Long's value is greater than or equal the specified's.
   * @this {!Long}
   * @param {!Long|number|string} other Other value
   * @returns {boolean}
   */
  
  LongPrototype.greaterThanOrEqual = function greaterThanOrEqual(other) {
    return this.comp(
    /* validates */
    other) >= 0;
  };
  /**
   * Tests if this Long's value is greater than or equal the specified's. This is an alias of {@link Long#greaterThanOrEqual}.
   * @function
   * @param {!Long|number|string} other Other value
   * @returns {boolean}
   */
  
  
  LongPrototype.gte = LongPrototype.greaterThanOrEqual;
  /**
   * Tests if this Long's value is greater than or equal the specified's. This is an alias of {@link Long#greaterThanOrEqual}.
   * @function
   * @param {!Long|number|string} other Other value
   * @returns {boolean}
   */
  
  LongPrototype.ge = LongPrototype.greaterThanOrEqual;
  /**
   * Compares this Long's value with the specified's.
   * @this {!Long}
   * @param {!Long|number|string} other Other value
   * @returns {number} 0 if they are the same, 1 if the this is greater and -1
   *  if the given one is greater
   */
  
  LongPrototype.compare = function compare(other) {
    if (!isLong(other)) other = fromValue(other);
    if (this.eq(other)) return 0;
    var thisNeg = this.isNegative(),
        otherNeg = other.isNegative();
    if (thisNeg && !otherNeg) return -1;
    if (!thisNeg && otherNeg) return 1; // At this point the sign bits are the same
  
    if (!this.unsigned) return this.sub(other).isNegative() ? -1 : 1; // Both are positive if at least one is unsigned
  
    return other.high >>> 0 > this.high >>> 0 || other.high === this.high && other.low >>> 0 > this.low >>> 0 ? -1 : 1;
  };
  /**
   * Compares this Long's value with the specified's. This is an alias of {@link Long#compare}.
   * @function
   * @param {!Long|number|string} other Other value
   * @returns {number} 0 if they are the same, 1 if the this is greater and -1
   *  if the given one is greater
   */
  
  
  LongPrototype.comp = LongPrototype.compare;
  /**
   * Negates this Long's value.
   * @this {!Long}
   * @returns {!Long} Negated Long
   */
  
  LongPrototype.negate = function negate() {
    if (!this.unsigned && this.eq(MIN_VALUE)) return MIN_VALUE;
    return this.not().add(ONE);
  };
  /**
   * Negates this Long's value. This is an alias of {@link Long#negate}.
   * @function
   * @returns {!Long} Negated Long
   */
  
  
  LongPrototype.neg = LongPrototype.negate;
  /**
   * Returns the sum of this and the specified Long.
   * @this {!Long}
   * @param {!Long|number|string} addend Addend
   * @returns {!Long} Sum
   */
  
  LongPrototype.add = function add(addend) {
    if (!isLong(addend)) addend = fromValue(addend); // Divide each number into 4 chunks of 16 bits, and then sum the chunks.
  
    var a48 = this.high >>> 16;
    var a32 = this.high & 0xFFFF;
    var a16 = this.low >>> 16;
    var a00 = this.low & 0xFFFF;
    var b48 = addend.high >>> 16;
    var b32 = addend.high & 0xFFFF;
    var b16 = addend.low >>> 16;
    var b00 = addend.low & 0xFFFF;
    var c48 = 0,
        c32 = 0,
        c16 = 0,
        c00 = 0;
    c00 += a00 + b00;
    c16 += c00 >>> 16;
    c00 &= 0xFFFF;
    c16 += a16 + b16;
    c32 += c16 >>> 16;
    c16 &= 0xFFFF;
    c32 += a32 + b32;
    c48 += c32 >>> 16;
    c32 &= 0xFFFF;
    c48 += a48 + b48;
    c48 &= 0xFFFF;
    return fromBits(c16 << 16 | c00, c48 << 16 | c32, this.unsigned);
  };
  /**
   * Returns the difference of this and the specified Long.
   * @this {!Long}
   * @param {!Long|number|string} subtrahend Subtrahend
   * @returns {!Long} Difference
   */
  
  
  LongPrototype.subtract = function subtract(subtrahend) {
    if (!isLong(subtrahend)) subtrahend = fromValue(subtrahend);
    return this.add(subtrahend.neg());
  };
  /**
   * Returns the difference of this and the specified Long. This is an alias of {@link Long#subtract}.
   * @function
   * @param {!Long|number|string} subtrahend Subtrahend
   * @returns {!Long} Difference
   */
  
  
  LongPrototype.sub = LongPrototype.subtract;
  /**
   * Returns the product of this and the specified Long.
   * @this {!Long}
   * @param {!Long|number|string} multiplier Multiplier
   * @returns {!Long} Product
   */
  
  LongPrototype.multiply = function multiply(multiplier) {
    if (this.isZero()) return this;
    if (!isLong(multiplier)) multiplier = fromValue(multiplier); // use wasm support if present
  
    if (wasm) {
      var low = wasm["mul"](this.low, this.high, multiplier.low, multiplier.high);
      return fromBits(low, wasm["get_high"](), this.unsigned);
    }
  
    if (multiplier.isZero()) return this.unsigned ? UZERO : ZERO;
    if (this.eq(MIN_VALUE)) return multiplier.isOdd() ? MIN_VALUE : ZERO;
    if (multiplier.eq(MIN_VALUE)) return this.isOdd() ? MIN_VALUE : ZERO;
  
    if (this.isNegative()) {
      if (multiplier.isNegative()) return this.neg().mul(multiplier.neg());else return this.neg().mul(multiplier).neg();
    } else if (multiplier.isNegative()) return this.mul(multiplier.neg()).neg(); // If both longs are small, use float multiplication
  
  
    if (this.lt(TWO_PWR_24) && multiplier.lt(TWO_PWR_24)) return fromNumber(this.toNumber() * multiplier.toNumber(), this.unsigned); // Divide each long into 4 chunks of 16 bits, and then add up 4x4 products.
    // We can skip products that would overflow.
  
    var a48 = this.high >>> 16;
    var a32 = this.high & 0xFFFF;
    var a16 = this.low >>> 16;
    var a00 = this.low & 0xFFFF;
    var b48 = multiplier.high >>> 16;
    var b32 = multiplier.high & 0xFFFF;
    var b16 = multiplier.low >>> 16;
    var b00 = multiplier.low & 0xFFFF;
    var c48 = 0,
        c32 = 0,
        c16 = 0,
        c00 = 0;
    c00 += a00 * b00;
    c16 += c00 >>> 16;
    c00 &= 0xFFFF;
    c16 += a16 * b00;
    c32 += c16 >>> 16;
    c16 &= 0xFFFF;
    c16 += a00 * b16;
    c32 += c16 >>> 16;
    c16 &= 0xFFFF;
    c32 += a32 * b00;
    c48 += c32 >>> 16;
    c32 &= 0xFFFF;
    c32 += a16 * b16;
    c48 += c32 >>> 16;
    c32 &= 0xFFFF;
    c32 += a00 * b32;
    c48 += c32 >>> 16;
    c32 &= 0xFFFF;
    c48 += a48 * b00 + a32 * b16 + a16 * b32 + a00 * b48;
    c48 &= 0xFFFF;
    return fromBits(c16 << 16 | c00, c48 << 16 | c32, this.unsigned);
  };
  /**
   * Returns the product of this and the specified Long. This is an alias of {@link Long#multiply}.
   * @function
   * @param {!Long|number|string} multiplier Multiplier
   * @returns {!Long} Product
   */
  
  
  LongPrototype.mul = LongPrototype.multiply;
  /**
   * Returns this Long divided by the specified. The result is signed if this Long is signed or
   *  unsigned if this Long is unsigned.
   * @this {!Long}
   * @param {!Long|number|string} divisor Divisor
   * @returns {!Long} Quotient
   */
  
  LongPrototype.divide = function divide(divisor) {
    if (!isLong(divisor)) divisor = fromValue(divisor);
    if (divisor.isZero()) throw Error('division by zero'); // use wasm support if present
  
    if (wasm) {
      // guard against signed division overflow: the largest
      // negative number / -1 would be 1 larger than the largest
      // positive number, due to two's complement.
      if (!this.unsigned && this.high === -0x80000000 && divisor.low === -1 && divisor.high === -1) {
        // be consistent with non-wasm code path
        return this;
      }
  
      var low = (this.unsigned ? wasm["div_u"] : wasm["div_s"])(this.low, this.high, divisor.low, divisor.high);
      return fromBits(low, wasm["get_high"](), this.unsigned);
    }
  
    if (this.isZero()) return this.unsigned ? UZERO : ZERO;
    var approx, rem, res;
  
    if (!this.unsigned) {
      // This section is only relevant for signed longs and is derived from the
      // closure library as a whole.
      if (this.eq(MIN_VALUE)) {
        if (divisor.eq(ONE) || divisor.eq(NEG_ONE)) return MIN_VALUE; // recall that -MIN_VALUE == MIN_VALUE
        else if (divisor.eq(MIN_VALUE)) return ONE;else {
          // At this point, we have |other| >= 2, so |this/other| < |MIN_VALUE|.
          var halfThis = this.shr(1);
          approx = halfThis.div(divisor).shl(1);
  
          if (approx.eq(ZERO)) {
            return divisor.isNegative() ? ONE : NEG_ONE;
          } else {
            rem = this.sub(divisor.mul(approx));
            res = approx.add(rem.div(divisor));
            return res;
          }
        }
      } else if (divisor.eq(MIN_VALUE)) return this.unsigned ? UZERO : ZERO;
  
      if (this.isNegative()) {
        if (divisor.isNegative()) return this.neg().div(divisor.neg());
        return this.neg().div(divisor).neg();
      } else if (divisor.isNegative()) return this.div(divisor.neg()).neg();
  
      res = ZERO;
    } else {
      // The algorithm below has not been made for unsigned longs. It's therefore
      // required to take special care of the MSB prior to running it.
      if (!divisor.unsigned) divisor = divisor.toUnsigned();
      if (divisor.gt(this)) return UZERO;
      if (divisor.gt(this.shru(1))) // 15 >>> 1 = 7 ; with divisor = 8 ; true
        return UONE;
      res = UZERO;
    } // Repeat the following until the remainder is less than other:  find a
    // floating-point that approximates remainder / other *from below*, add this
    // into the result, and subtract it from the remainder.  It is critical that
    // the approximate value is less than or equal to the real value so that the
    // remainder never becomes negative.
  
  
    rem = this;
  
    while (rem.gte(divisor)) {
      // Approximate the result of division. This may be a little greater or
      // smaller than the actual value.
      approx = Math.max(1, Math.floor(rem.toNumber() / divisor.toNumber())); // We will tweak the approximate result by changing it in the 48-th digit or
      // the smallest non-fractional digit, whichever is larger.
  
      var log2 = Math.ceil(Math.log(approx) / Math.LN2),
          delta = log2 <= 48 ? 1 : pow_dbl(2, log2 - 48),
          // Decrease the approximation until it is smaller than the remainder.  Note
      // that if it is too large, the product overflows and is negative.
      approxRes = fromNumber(approx),
          approxRem = approxRes.mul(divisor);
  
      while (approxRem.isNegative() || approxRem.gt(rem)) {
        approx -= delta;
        approxRes = fromNumber(approx, this.unsigned);
        approxRem = approxRes.mul(divisor);
      } // We know the answer can't be zero... and actually, zero would cause
      // infinite recursion since we would make no progress.
  
  
      if (approxRes.isZero()) approxRes = ONE;
      res = res.add(approxRes);
      rem = rem.sub(approxRem);
    }
  
    return res;
  };
  /**
   * Returns this Long divided by the specified. This is an alias of {@link Long#divide}.
   * @function
   * @param {!Long|number|string} divisor Divisor
   * @returns {!Long} Quotient
   */
  
  
  LongPrototype.div = LongPrototype.divide;
  /**
   * Returns this Long modulo the specified.
   * @this {!Long}
   * @param {!Long|number|string} divisor Divisor
   * @returns {!Long} Remainder
   */
  
  LongPrototype.modulo = function modulo(divisor) {
    if (!isLong(divisor)) divisor = fromValue(divisor); // use wasm support if present
  
    if (wasm) {
      var low = (this.unsigned ? wasm["rem_u"] : wasm["rem_s"])(this.low, this.high, divisor.low, divisor.high);
      return fromBits(low, wasm["get_high"](), this.unsigned);
    }
  
    return this.sub(this.div(divisor).mul(divisor));
  };
  /**
   * Returns this Long modulo the specified. This is an alias of {@link Long#modulo}.
   * @function
   * @param {!Long|number|string} divisor Divisor
   * @returns {!Long} Remainder
   */
  
  
  LongPrototype.mod = LongPrototype.modulo;
  /**
   * Returns this Long modulo the specified. This is an alias of {@link Long#modulo}.
   * @function
   * @param {!Long|number|string} divisor Divisor
   * @returns {!Long} Remainder
   */
  
  LongPrototype.rem = LongPrototype.modulo;
  /**
   * Returns the bitwise NOT of this Long.
   * @this {!Long}
   * @returns {!Long}
   */
  
  LongPrototype.not = function not() {
    return fromBits(~this.low, ~this.high, this.unsigned);
  };
  /**
   * Returns count leading zeros of this Long.
   * @this {!Long}
   * @returns {!number}
   */
  
  
  LongPrototype.countLeadingZeros = function countLeadingZeros() {
    return this.high ? Math.clz32(this.high) : Math.clz32(this.low) + 32;
  };
  /**
   * Returns count leading zeros. This is an alias of {@link Long#countLeadingZeros}.
   * @function
   * @param {!Long}
   * @returns {!number}
   */
  
  
  LongPrototype.clz = LongPrototype.countLeadingZeros;
  /**
   * Returns count trailing zeros of this Long.
   * @this {!Long}
   * @returns {!number}
   */
  
  LongPrototype.countTrailingZeros = function countTrailingZeros() {
    return this.low ? ctz32(this.low) : ctz32(this.high) + 32;
  };
  /**
   * Returns count trailing zeros. This is an alias of {@link Long#countTrailingZeros}.
   * @function
   * @param {!Long}
   * @returns {!number}
   */
  
  
  LongPrototype.ctz = LongPrototype.countTrailingZeros;
  /**
   * Returns the bitwise AND of this Long and the specified.
   * @this {!Long}
   * @param {!Long|number|string} other Other Long
   * @returns {!Long}
   */
  
  LongPrototype.and = function and(other) {
    if (!isLong(other)) other = fromValue(other);
    return fromBits(this.low & other.low, this.high & other.high, this.unsigned);
  };
  /**
   * Returns the bitwise OR of this Long and the specified.
   * @this {!Long}
   * @param {!Long|number|string} other Other Long
   * @returns {!Long}
   */
  
  
  LongPrototype.or = function or(other) {
    if (!isLong(other)) other = fromValue(other);
    return fromBits(this.low | other.low, this.high | other.high, this.unsigned);
  };
  /**
   * Returns the bitwise XOR of this Long and the given one.
   * @this {!Long}
   * @param {!Long|number|string} other Other Long
   * @returns {!Long}
   */
  
  
  LongPrototype.xor = function xor(other) {
    if (!isLong(other)) other = fromValue(other);
    return fromBits(this.low ^ other.low, this.high ^ other.high, this.unsigned);
  };
  /**
   * Returns this Long with bits shifted to the left by the given amount.
   * @this {!Long}
   * @param {number|!Long} numBits Number of bits
   * @returns {!Long} Shifted Long
   */
  
  
  LongPrototype.shiftLeft = function shiftLeft(numBits) {
    if (isLong(numBits)) numBits = numBits.toInt();
    if ((numBits &= 63) === 0) return this;else if (numBits < 32) return fromBits(this.low << numBits, this.high << numBits | this.low >>> 32 - numBits, this.unsigned);else return fromBits(0, this.low << numBits - 32, this.unsigned);
  };
  /**
   * Returns this Long with bits shifted to the left by the given amount. This is an alias of {@link Long#shiftLeft}.
   * @function
   * @param {number|!Long} numBits Number of bits
   * @returns {!Long} Shifted Long
   */
  
  
  LongPrototype.shl = LongPrototype.shiftLeft;
  /**
   * Returns this Long with bits arithmetically shifted to the right by the given amount.
   * @this {!Long}
   * @param {number|!Long} numBits Number of bits
   * @returns {!Long} Shifted Long
   */
  
  LongPrototype.shiftRight = function shiftRight(numBits) {
    if (isLong(numBits)) numBits = numBits.toInt();
    if ((numBits &= 63) === 0) return this;else if (numBits < 32) return fromBits(this.low >>> numBits | this.high << 32 - numBits, this.high >> numBits, this.unsigned);else return fromBits(this.high >> numBits - 32, this.high >= 0 ? 0 : -1, this.unsigned);
  };
  /**
   * Returns this Long with bits arithmetically shifted to the right by the given amount. This is an alias of {@link Long#shiftRight}.
   * @function
   * @param {number|!Long} numBits Number of bits
   * @returns {!Long} Shifted Long
   */
  
  
  LongPrototype.shr = LongPrototype.shiftRight;
  /**
   * Returns this Long with bits logically shifted to the right by the given amount.
   * @this {!Long}
   * @param {number|!Long} numBits Number of bits
   * @returns {!Long} Shifted Long
   */
  
  LongPrototype.shiftRightUnsigned = function shiftRightUnsigned(numBits) {
    if (isLong(numBits)) numBits = numBits.toInt();
    if ((numBits &= 63) === 0) return this;
    if (numBits < 32) return fromBits(this.low >>> numBits | this.high << 32 - numBits, this.high >>> numBits, this.unsigned);
    if (numBits === 32) return fromBits(this.high, 0, this.unsigned);
    return fromBits(this.high >>> numBits - 32, 0, this.unsigned);
  };
  /**
   * Returns this Long with bits logically shifted to the right by the given amount. This is an alias of {@link Long#shiftRightUnsigned}.
   * @function
   * @param {number|!Long} numBits Number of bits
   * @returns {!Long} Shifted Long
   */
  
  
  LongPrototype.shru = LongPrototype.shiftRightUnsigned;
  /**
   * Returns this Long with bits logically shifted to the right by the given amount. This is an alias of {@link Long#shiftRightUnsigned}.
   * @function
   * @param {number|!Long} numBits Number of bits
   * @returns {!Long} Shifted Long
   */
  
  LongPrototype.shr_u = LongPrototype.shiftRightUnsigned;
  /**
   * Returns this Long with bits rotated to the left by the given amount.
   * @this {!Long}
   * @param {number|!Long} numBits Number of bits
   * @returns {!Long} Rotated Long
   */
  
  LongPrototype.rotateLeft = function rotateLeft(numBits) {
    var b;
    if (isLong(numBits)) numBits = numBits.toInt();
    if ((numBits &= 63) === 0) return this;
    if (numBits === 32) return fromBits(this.high, this.low, this.unsigned);
  
    if (numBits < 32) {
      b = 32 - numBits;
      return fromBits(this.low << numBits | this.high >>> b, this.high << numBits | this.low >>> b, this.unsigned);
    }
  
    numBits -= 32;
    b = 32 - numBits;
    return fromBits(this.high << numBits | this.low >>> b, this.low << numBits | this.high >>> b, this.unsigned);
  };
  /**
   * Returns this Long with bits rotated to the left by the given amount. This is an alias of {@link Long#rotateLeft}.
   * @function
   * @param {number|!Long} numBits Number of bits
   * @returns {!Long} Rotated Long
   */
  
  
  LongPrototype.rotl = LongPrototype.rotateLeft;
  /**
   * Returns this Long with bits rotated to the right by the given amount.
   * @this {!Long}
   * @param {number|!Long} numBits Number of bits
   * @returns {!Long} Rotated Long
   */
  
  LongPrototype.rotateRight = function rotateRight(numBits) {
    var b;
    if (isLong(numBits)) numBits = numBits.toInt();
    if ((numBits &= 63) === 0) return this;
    if (numBits === 32) return fromBits(this.high, this.low, this.unsigned);
  
    if (numBits < 32) {
      b = 32 - numBits;
      return fromBits(this.high << b | this.low >>> numBits, this.low << b | this.high >>> numBits, this.unsigned);
    }
  
    numBits -= 32;
    b = 32 - numBits;
    return fromBits(this.low << b | this.high >>> numBits, this.high << b | this.low >>> numBits, this.unsigned);
  };
  /**
   * Returns this Long with bits rotated to the right by the given amount. This is an alias of {@link Long#rotateRight}.
   * @function
   * @param {number|!Long} numBits Number of bits
   * @returns {!Long} Rotated Long
   */
  
  
  LongPrototype.rotr = LongPrototype.rotateRight;
  /**
   * Converts this Long to signed.
   * @this {!Long}
   * @returns {!Long} Signed long
   */
  
  LongPrototype.toSigned = function toSigned() {
    if (!this.unsigned) return this;
    return fromBits(this.low, this.high, false);
  };
  /**
   * Converts this Long to unsigned.
   * @this {!Long}
   * @returns {!Long} Unsigned long
   */
  
  
  LongPrototype.toUnsigned = function toUnsigned() {
    if (this.unsigned) return this;
    return fromBits(this.low, this.high, true);
  };
  /**
   * Converts this Long to its byte representation.
   * @param {boolean=} le Whether little or big endian, defaults to big endian
   * @this {!Long}
   * @returns {!Array.<number>} Byte representation
   */
  
  
  LongPrototype.toBytes = function toBytes(le) {
    return le ? this.toBytesLE() : this.toBytesBE();
  };
  /**
   * Converts this Long to its little endian byte representation.
   * @this {!Long}
   * @returns {!Array.<number>} Little endian byte representation
   */
  
  
  LongPrototype.toBytesLE = function toBytesLE() {
    var hi = this.high,
        lo = this.low;
    return [lo & 0xff, lo >>> 8 & 0xff, lo >>> 16 & 0xff, lo >>> 24, hi & 0xff, hi >>> 8 & 0xff, hi >>> 16 & 0xff, hi >>> 24];
  };
  /**
   * Converts this Long to its big endian byte representation.
   * @this {!Long}
   * @returns {!Array.<number>} Big endian byte representation
   */
  
  
  LongPrototype.toBytesBE = function toBytesBE() {
    var hi = this.high,
        lo = this.low;
    return [hi >>> 24, hi >>> 16 & 0xff, hi >>> 8 & 0xff, hi & 0xff, lo >>> 24, lo >>> 16 & 0xff, lo >>> 8 & 0xff, lo & 0xff];
  };
  /**
   * Creates a Long from its byte representation.
   * @param {!Array.<number>} bytes Byte representation
   * @param {boolean=} unsigned Whether unsigned or not, defaults to signed
   * @param {boolean=} le Whether little or big endian, defaults to big endian
   * @returns {Long} The corresponding Long value
   */
  
  
  Long.fromBytes = function fromBytes(bytes, unsigned, le) {
    return le ? Long.fromBytesLE(bytes, unsigned) : Long.fromBytesBE(bytes, unsigned);
  };
  /**
   * Creates a Long from its little endian byte representation.
   * @param {!Array.<number>} bytes Little endian byte representation
   * @param {boolean=} unsigned Whether unsigned or not, defaults to signed
   * @returns {Long} The corresponding Long value
   */
  
  
  Long.fromBytesLE = function fromBytesLE(bytes, unsigned) {
    return new Long(bytes[0] | bytes[1] << 8 | bytes[2] << 16 | bytes[3] << 24, bytes[4] | bytes[5] << 8 | bytes[6] << 16 | bytes[7] << 24, unsigned);
  };
  /**
   * Creates a Long from its big endian byte representation.
   * @param {!Array.<number>} bytes Big endian byte representation
   * @param {boolean=} unsigned Whether unsigned or not, defaults to signed
   * @returns {Long} The corresponding Long value
   */
  
  
  Long.fromBytesBE = function fromBytesBE(bytes, unsigned) {
    return new Long(bytes[4] << 24 | bytes[5] << 16 | bytes[6] << 8 | bytes[7], bytes[0] << 24 | bytes[1] << 16 | bytes[2] << 8 | bytes[3], unsigned);
  };
  
  var _default = Long;
  exports.default = _default;
  return "default" in exports ? exports.default : exports;
})({});
if (true) !(__WEBPACK_AMD_DEFINE_ARRAY__ = [], __WEBPACK_AMD_DEFINE_RESULT__ = (function() { return Long; }).apply(exports, __WEBPACK_AMD_DEFINE_ARRAY__),
		__WEBPACK_AMD_DEFINE_RESULT__ !== undefined && (module.exports = __WEBPACK_AMD_DEFINE_RESULT__));
else {}


/***/ }),

/***/ "../temporal/build/payload-converter.cjs":
/*!***********************************************!*\
  !*** ../temporal/build/payload-converter.cjs ***!
  \***********************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";
var _=Object.defineProperty;var Pe=Object.getOwnPropertyDescriptor;var Re=Object.getOwnPropertyNames;var Se=Object.prototype.hasOwnProperty;var Ae=(e,t)=>{for(var r in t)_(e,r,{get:t[r],enumerable:!0})},Ne=(e,t,r,n)=>{if(t&&typeof t=="object"||typeof t=="function")for(let s of Re(t))!Se.call(e,s)&&s!==r&&_(e,s,{get:()=>t[s],enumerable:!(n=Pe(t,s))||n.enumerable});return e};var ke=e=>Ne(_({},"__esModule",{value:!0}),e);var $e={};Ae($e,{payloadConverter:()=>Fe});module.exports=ke($e);var j=__webpack_require__(/*! @temporalio/common */ "../../node_modules/@temporalio/common/lib/index.js");var M=__webpack_require__(/*! @temporalio/common */ "../../node_modules/@temporalio/common/lib/index.js");var k=class{constructor(){this.keyToValue=new Map,this.valueToKey=new Map}set(t,r){this.keyToValue.set(t,r),this.valueToKey.set(r,t)}getByKey(t){return this.keyToValue.get(t)}getByValue(t){return this.valueToKey.get(t)}clear(){this.keyToValue.clear(),this.valueToKey.clear()}};var b=class{constructor(t){this.generateIdentifier=t,this.kv=new k}register(t,r){this.kv.getByValue(t)||(r||(r=this.generateIdentifier(t)),this.kv.set(r,t))}clear(){this.kv.clear()}getIdentifier(t){return this.kv.getByValue(t)}getValue(t){return this.kv.getByKey(t)}};var I=class extends b{constructor(){super(t=>t.name),this.classToAllowedProps=new Map}register(t,r){typeof r=="object"?(r.allowProps&&this.classToAllowedProps.set(t,r.allowProps),super.register(t,r.identifier)):super.register(t,r)}getAllowedProps(t){return this.classToAllowedProps.get(t)}};function Ie(e){if("values"in Object)return Object.values(e);let t=[];for(let r in e)e.hasOwnProperty(r)&&t.push(e[r]);return t}function Z(e,t){let r=Ie(e);if("find"in r)return r.find(t);let n=r;for(let s=0;s<n.length;s++){let o=n[s];if(t(o))return o}}function g(e,t){Object.entries(e).forEach(([r,n])=>t(n,r))}function E(e,t){return e.indexOf(t)!==-1}function q(e,t){for(let r=0;r<e.length;r++){let n=e[r];if(t(n))return n}}var T=class{constructor(){this.transfomers={}}register(t){this.transfomers[t.name]=t}findApplicable(t){return Z(this.transfomers,r=>r.isApplicable(t))}findByName(t){return this.transfomers[t]}};var Te=e=>Object.prototype.toString.call(e).slice(8,-1),K=e=>typeof e>"u",ve=e=>e===null,h=e=>typeof e!="object"||e===null||e===Object.prototype?!1:Object.getPrototypeOf(e)===null?!0:Object.getPrototypeOf(e)===Object.prototype,v=e=>h(e)&&Object.keys(e).length===0,l=e=>Array.isArray(e),Ve=e=>typeof e=="string",Ue=e=>typeof e=="number"&&!isNaN(e),Ce=e=>typeof e=="boolean",J=e=>e instanceof RegExp,y=e=>e instanceof Map,d=e=>e instanceof Set,F=e=>Te(e)==="Symbol",ee=e=>e instanceof Date&&!isNaN(e.valueOf()),te=e=>e instanceof Error,$=e=>typeof e=="number"&&isNaN(e),re=e=>Ce(e)||ve(e)||K(e)||Ue(e)||Ve(e)||F(e),ne=e=>typeof e=="bigint",se=e=>e===1/0||e===-1/0,oe=e=>ArrayBuffer.isView(e)&&!(e instanceof DataView),ie=e=>e instanceof URL;var L=e=>e.replace(/\./g,"\\."),V=e=>e.map(String).map(L).join("."),O=e=>{let t=[],r="";for(let s=0;s<e.length;s++){let o=e.charAt(s);if(o==="\\"&&e.charAt(s+1)==="."){r+=".",s++;continue}if(o==="."){t.push(r),r="";continue}r+=o}let n=r;return t.push(n),t};function p(e,t,r,n){return{isApplicable:e,annotation:t,transform:r,untransform:n}}var ae=[p(K,"undefined",()=>null,()=>{}),p(ne,"bigint",e=>e.toString(),e=>typeof BigInt<"u"?BigInt(e):(console.error("Please add a BigInt polyfill."),e)),p(ee,"Date",e=>e.toISOString(),e=>new Date(e)),p(te,"Error",(e,t)=>{let r={name:e.name,message:e.message};return t.allowedErrorProps.forEach(n=>{r[n]=e[n]}),r},(e,t)=>{let r=new Error(e.message);return r.name=e.name,r.stack=e.stack,t.allowedErrorProps.forEach(n=>{r[n]=e[n]}),r}),p(J,"regexp",e=>""+e,e=>{let t=e.slice(1,e.lastIndexOf("/")),r=e.slice(e.lastIndexOf("/")+1);return new RegExp(t,r)}),p(d,"set",e=>[...e.values()],e=>new Set(e)),p(y,"map",e=>[...e.entries()],e=>new Map(e)),p(e=>$(e)||se(e),"number",e=>$(e)?"NaN":e>0?"Infinity":"-Infinity",Number),p(e=>e===0&&1/e===-1/0,"number",()=>"-0",Number),p(ie,"URL",e=>e.toString(),e=>new URL(e))];function U(e,t,r,n){return{isApplicable:e,annotation:t,transform:r,untransform:n}}var ue=U((e,t)=>F(e)?!!t.symbolRegistry.getIdentifier(e):!1,(e,t)=>["symbol",t.symbolRegistry.getIdentifier(e)],e=>e.description,(e,t,r)=>{let n=r.symbolRegistry.getValue(t[1]);if(!n)throw new Error("Trying to deserialize unknown symbol");return n}),ze=[Int8Array,Uint8Array,Int16Array,Uint16Array,Int32Array,Uint32Array,Float32Array,Float64Array,Uint8ClampedArray].reduce((e,t)=>(e[t.name]=t,e),{}),ce=U(oe,e=>["typed-array",e.constructor.name],e=>[...e],(e,t)=>{let r=ze[t[1]];if(!r)throw new Error("Trying to deserialize unknown typed array");return new r(e)});function W(e,t){return e?.constructor?!!t.classRegistry.getIdentifier(e.constructor):!1}var fe=U(W,(e,t)=>["class",t.classRegistry.getIdentifier(e.constructor)],(e,t)=>{let r=t.classRegistry.getAllowedProps(e.constructor);if(!r)return{...e};let n={};return r.forEach(s=>{n[s]=e[s]}),n},(e,t,r)=>{let n=r.classRegistry.getValue(t[1]);if(!n)throw new Error(`Trying to deserialize unknown class '${t[1]}' - check https://github.com/blitz-js/superjson/issues/116#issuecomment-773996564`);return Object.assign(Object.create(n.prototype),e)}),le=U((e,t)=>!!t.customTransformerRegistry.findApplicable(e),(e,t)=>["custom",t.customTransformerRegistry.findApplicable(e).name],(e,t)=>t.customTransformerRegistry.findApplicable(e).serialize(e),(e,t,r)=>{let n=r.customTransformerRegistry.findByName(t[1]);if(!n)throw new Error("Trying to deserialize unknown custom value");return n.deserialize(e)}),Be=[fe,ue,le,ce],G=(e,t)=>{let r=q(Be,s=>s.isApplicable(e,t));if(r)return{value:r.transform(e,t),type:r.annotation(e,t)};let n=q(ae,s=>s.isApplicable(e,t));if(n)return{value:n.transform(e,t),type:n.annotation}},pe={};ae.forEach(e=>{pe[e.annotation]=e});var me=(e,t,r)=>{if(l(t))switch(t[0]){case"symbol":return ue.untransform(e,t,r);case"class":return fe.untransform(e,t,r);case"custom":return le.untransform(e,t,r);case"typed-array":return ce.untransform(e,t,r);default:throw new Error("Unknown transformation: "+t)}else{let n=pe[t];if(!n)throw new Error("Unknown transformation: "+t);return n.untransform(e,r)}};var x=(e,t)=>{if(t>e.size)throw new Error("index out of bounds");let r=e.keys();for(;t>0;)r.next(),t--;return r.next().value};function ye(e){if(E(e,"__proto__"))throw new Error("__proto__ is not allowed as a property");if(E(e,"prototype"))throw new Error("prototype is not allowed as a property");if(E(e,"constructor"))throw new Error("constructor is not allowed as a property")}var de=(e,t)=>{ye(t);for(let r=0;r<t.length;r++){let n=t[r];if(d(e))e=x(e,+n);else if(y(e)){let s=+n,o=+t[++r]==0?"key":"value",a=x(e,s);switch(o){case"key":e=a;break;case"value":e=e.get(a);break}}else e=e[n]}return e},C=(e,t,r)=>{if(ye(t),t.length===0)return r(e);let n=e;for(let o=0;o<t.length-1;o++){let a=t[o];if(l(n)){let u=+a;n=n[u]}else if(h(n))n=n[a];else if(d(n)){let u=+a;n=x(n,u)}else if(y(n)){if(o===t.length-2)break;let c=+a,N=+t[++o]==0?"key":"value",w=x(n,c);switch(N){case"key":n=w;break;case"value":n=n.get(w);break}}}let s=t[t.length-1];if(l(n)?n[+s]=r(n[+s]):h(n)&&(n[s]=r(n[s])),d(n)){let o=x(n,+s),a=r(o);o!==a&&(n.delete(o),n.add(a))}if(y(n)){let o=+t[t.length-2],a=x(n,o);switch(+s==0?"key":"value"){case"key":{let c=r(a);n.set(c,n.get(a)),c!==a&&n.delete(a);break}case"value":{n.set(a,r(n.get(a)));break}}}return e};function Y(e,t,r=[]){if(!e)return;if(!l(e)){g(e,(o,a)=>Y(o,t,[...r,...O(a)]));return}let[n,s]=e;s&&g(s,(o,a)=>{Y(o,t,[...r,...O(a)])}),t(n,r)}function ge(e,t,r){return Y(t,(n,s)=>{e=C(e,s,o=>me(o,n,r))}),e}function he(e,t){function r(n,s){let o=de(e,O(s));n.map(O).forEach(a=>{e=C(e,a,()=>o)})}if(l(t)){let[n,s]=t;n.forEach(o=>{e=C(e,O(o),()=>e)}),s&&g(s,r)}else g(t,r);return e}var De=(e,t)=>h(e)||l(e)||y(e)||d(e)||W(e,t);function Me(e,t,r){let n=r.get(e);n?n.push(t):r.set(e,[t])}function we(e,t){let r={},n;return e.forEach(s=>{if(s.length<=1)return;t||(s=s.map(u=>u.map(String)).sort((u,c)=>u.length-c.length));let[o,...a]=s;o.length===0?n=a.map(V):r[V(o)]=a.map(V)}),n?v(r)?[n]:[n,r]:v(r)?void 0:r}var H=(e,t,r,n,s=[],o=[],a=new Map)=>{let u=re(e);if(!u){Me(e,s,t);let m=a.get(e);if(m)return n?{transformedValue:null}:m}if(!De(e,r)){let m=G(e,r),f=m?{transformedValue:m.value,annotations:[m.type]}:{transformedValue:e};return u||a.set(e,f),f}if(E(o,e))return{transformedValue:null};let c=G(e,r),N=c?.value??e,w=l(N)?[]:{},R={};g(N,(m,f)=>{if(f==="__proto__"||f==="constructor"||f==="prototype")throw new Error(`Detected property ${f}. This is a prototype pollution risk, please remove it from your object.`);let S=H(m,t,r,n,[...s,f],[...o,e],a);w[f]=S.transformedValue,l(S.annotations)?R[f]=S.annotations:h(S.annotations)&&g(S.annotations,(Oe,xe)=>{R[L(f)+"."+xe]=Oe})});let X=v(R)?{transformedValue:w,annotations:c?[c.type]:void 0}:{transformedValue:w,annotations:c?[c.type,R]:R};return u||a.set(e,X),X};function z(e){return Object.prototype.toString.call(e).slice(8,-1)}function Q(e){return z(e)==="Array"}function be(e){if(z(e)!=="Object")return!1;let t=Object.getPrototypeOf(e);return!!t&&t.constructor===Object&&t===Object.prototype}function je(e){return z(e)==="Null"}function _e(e,t,r,n,s){return o=>e(o)||t(o)||!!r&&r(o)||!!n&&n(o)||!!s&&s(o)}function qe(e){return z(e)==="Undefined"}var dt=_e(je,qe);function Ke(e,t,r,n,s){let o={}.propertyIsEnumerable.call(n,t)?"enumerable":"nonenumerable";o==="enumerable"&&(e[t]=r),s&&o==="nonenumerable"&&Object.defineProperty(e,t,{value:r,enumerable:!1,writable:!0,configurable:!0})}function B(e,t={}){if(Q(e))return e.map(s=>B(s,t));if(!be(e))return e;let r=Object.getOwnPropertyNames(e),n=Object.getOwnPropertySymbols(e);return[...r,...n].reduce((s,o)=>{if(Q(t.props)&&!t.props.includes(o))return s;let a=e[o],u=B(a,t);return Ke(s,o,u,e,t.nonenumerable),s},{})}var i=class{constructor({dedupe:t=!1}={}){this.classRegistry=new I,this.symbolRegistry=new b(r=>r.description??""),this.customTransformerRegistry=new T,this.allowedErrorProps=[],this.dedupe=t}serialize(t){let r=new Map,n=H(t,r,this,this.dedupe),s={json:n.transformedValue};n.annotations&&(s.meta={...s.meta,values:n.annotations});let o=we(r,this.dedupe);return o&&(s.meta={...s.meta,referentialEqualities:o}),s}deserialize(t){let{json:r,meta:n}=t,s=B(r);return n?.values&&(s=ge(s,n.values,this)),n?.referentialEqualities&&(s=he(s,n.referentialEqualities)),s}stringify(t){return JSON.stringify(this.serialize(t))}parse(t){return this.deserialize(JSON.parse(t))}registerClass(t,r){this.classRegistry.register(t,r)}registerSymbol(t,r){this.symbolRegistry.register(t,r)}registerCustom(t,r){this.customTransformerRegistry.register({name:r,...t})}allowErrorProps(...t){this.allowedErrorProps.push(...t)}};i.defaultInstance=new i;i.serialize=i.defaultInstance.serialize.bind(i.defaultInstance);i.deserialize=i.defaultInstance.deserialize.bind(i.defaultInstance);i.stringify=i.defaultInstance.stringify.bind(i.defaultInstance);i.parse=i.defaultInstance.parse.bind(i.defaultInstance);i.registerClass=i.defaultInstance.registerClass.bind(i.defaultInstance);i.registerSymbol=i.defaultInstance.registerSymbol.bind(i.defaultInstance);i.registerCustom=i.defaultInstance.registerCustom.bind(i.defaultInstance);i.allowErrorProps=i.defaultInstance.allowErrorProps.bind(i.defaultInstance);var Rt=i.serialize,St=i.deserialize,At=i.stringify,Nt=i.parse,kt=i.registerClass,It=i.registerCustom,Tt=i.registerSymbol,vt=i.allowErrorProps;var P=__webpack_require__(/*! @temporalio/common/lib/encoding */ "../../node_modules/@temporalio/common/lib/encoding.js"),D=class{encodingType="json/plain";toPayload(t){if(t===void 0)return;let r="";try{r=i.stringify(t)}catch(n){throw new A(`Can't run SUPERJSON.stringify on this value: ${t}. Either convert it (or its properties) to SUPERJSON-serializable values (see https://github.com/flightcontrolhq/superjson#readme ), or create a custom data converter. SJSON.stringify error message: ${Ee(n)}`,n)}return{metadata:{[M.METADATA_ENCODING_KEY]:(0,P.encode)("json/plain"),format:(0,P.encode)("extended")},data:(0,P.encode)(r)}}fromPayload(t){try{if(!t.data)throw new A(`Can't run SUPERJSON.parse on this value: ${t.data}. Either convert it (or its properties) to SUPERJSON-serializable values (see https://github.com/flightcontrolhq/superjson#readme ), or create a custom data converter. No data found in payload.`);return i.parse((0,P.decode)(t.data))}catch(r){throw new A(`Can't run SUPERJSON.parse on this value: ${t.data}. Either convert it (or its properties) to SUPERJSON-serializable values (see https://github.com/flightcontrolhq/superjson#readme ), or create a custom data converter. SJSON.parse error message: ${Ee(r)}`,r)}}},A=class extends M.PayloadConverterError{constructor(r,n){super(r??void 0);this.cause=n}name="UnsupportedJsonTypeError"};function Ee(e){if(typeof e=="string")return e;if(e instanceof Error)return e.message}var Fe=new j.CompositePayloadConverter(new j.UndefinedPayloadConverter,new D);0&&(0);


/***/ }),

/***/ "../../node_modules/copy-anything/dist/index.js":
/*!******************************************************!*\
  !*** ../../node_modules/copy-anything/dist/index.js ***!
  \******************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   copy: () => (/* binding */ copy)
/* harmony export */ });
/* harmony import */ var is_what__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! is-what */ "../../node_modules/is-what/dist/index.js");


function assignProp(carry, key, newVal, originalObject, includeNonenumerable) {
  const propType = {}.propertyIsEnumerable.call(originalObject, key) ? "enumerable" : "nonenumerable";
  if (propType === "enumerable")
    carry[key] = newVal;
  if (includeNonenumerable && propType === "nonenumerable") {
    Object.defineProperty(carry, key, {
      value: newVal,
      enumerable: false,
      writable: true,
      configurable: true
    });
  }
}
function copy(target, options = {}) {
  if ((0,is_what__WEBPACK_IMPORTED_MODULE_0__.isArray)(target)) {
    return target.map((item) => copy(item, options));
  }
  if (!(0,is_what__WEBPACK_IMPORTED_MODULE_0__.isPlainObject)(target)) {
    return target;
  }
  const props = Object.getOwnPropertyNames(target);
  const symbols = Object.getOwnPropertySymbols(target);
  return [...props, ...symbols].reduce((carry, key) => {
    if ((0,is_what__WEBPACK_IMPORTED_MODULE_0__.isArray)(options.props) && !options.props.includes(key)) {
      return carry;
    }
    const val = target[key];
    const newVal = copy(val, options);
    assignProp(carry, key, newVal, target, options.nonenumerable);
    return carry;
  }, {});
}




/***/ }),

/***/ "../../node_modules/is-what/dist/index.js":
/*!************************************************!*\
  !*** ../../node_modules/is-what/dist/index.js ***!
  \************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   getType: () => (/* binding */ getType),
/* harmony export */   isAnyObject: () => (/* binding */ isAnyObject),
/* harmony export */   isArray: () => (/* binding */ isArray),
/* harmony export */   isBlob: () => (/* binding */ isBlob),
/* harmony export */   isBoolean: () => (/* binding */ isBoolean),
/* harmony export */   isDate: () => (/* binding */ isDate),
/* harmony export */   isEmptyArray: () => (/* binding */ isEmptyArray),
/* harmony export */   isEmptyObject: () => (/* binding */ isEmptyObject),
/* harmony export */   isEmptyString: () => (/* binding */ isEmptyString),
/* harmony export */   isError: () => (/* binding */ isError),
/* harmony export */   isFile: () => (/* binding */ isFile),
/* harmony export */   isFullArray: () => (/* binding */ isFullArray),
/* harmony export */   isFullObject: () => (/* binding */ isFullObject),
/* harmony export */   isFullString: () => (/* binding */ isFullString),
/* harmony export */   isFunction: () => (/* binding */ isFunction),
/* harmony export */   isInstanceOf: () => (/* binding */ isInstanceOf),
/* harmony export */   isMap: () => (/* binding */ isMap),
/* harmony export */   isNaNValue: () => (/* binding */ isNaNValue),
/* harmony export */   isNegativeNumber: () => (/* binding */ isNegativeNumber),
/* harmony export */   isNull: () => (/* binding */ isNull),
/* harmony export */   isNullOrUndefined: () => (/* binding */ isNullOrUndefined),
/* harmony export */   isNumber: () => (/* binding */ isNumber),
/* harmony export */   isObject: () => (/* binding */ isObject),
/* harmony export */   isObjectLike: () => (/* binding */ isObjectLike),
/* harmony export */   isOneOf: () => (/* binding */ isOneOf),
/* harmony export */   isPlainObject: () => (/* binding */ isPlainObject),
/* harmony export */   isPositiveNumber: () => (/* binding */ isPositiveNumber),
/* harmony export */   isPrimitive: () => (/* binding */ isPrimitive),
/* harmony export */   isPromise: () => (/* binding */ isPromise),
/* harmony export */   isRegExp: () => (/* binding */ isRegExp),
/* harmony export */   isSet: () => (/* binding */ isSet),
/* harmony export */   isString: () => (/* binding */ isString),
/* harmony export */   isSymbol: () => (/* binding */ isSymbol),
/* harmony export */   isType: () => (/* binding */ isType),
/* harmony export */   isUndefined: () => (/* binding */ isUndefined),
/* harmony export */   isWeakMap: () => (/* binding */ isWeakMap),
/* harmony export */   isWeakSet: () => (/* binding */ isWeakSet)
/* harmony export */ });
function getType(payload) {
  return Object.prototype.toString.call(payload).slice(8, -1);
}

function isAnyObject(payload) {
  return getType(payload) === "Object";
}

function isArray(payload) {
  return getType(payload) === "Array";
}

function isBlob(payload) {
  return getType(payload) === "Blob";
}

function isBoolean(payload) {
  return getType(payload) === "Boolean";
}

function isDate(payload) {
  return getType(payload) === "Date" && !isNaN(payload);
}

function isEmptyArray(payload) {
  return isArray(payload) && payload.length === 0;
}

function isPlainObject(payload) {
  if (getType(payload) !== "Object")
    return false;
  const prototype = Object.getPrototypeOf(payload);
  return !!prototype && prototype.constructor === Object && prototype === Object.prototype;
}

function isEmptyObject(payload) {
  return isPlainObject(payload) && Object.keys(payload).length === 0;
}

function isEmptyString(payload) {
  return payload === "";
}

function isError(payload) {
  return getType(payload) === "Error" || payload instanceof Error;
}

function isFile(payload) {
  return getType(payload) === "File";
}

function isFullArray(payload) {
  return isArray(payload) && payload.length > 0;
}

function isFullObject(payload) {
  return isPlainObject(payload) && Object.keys(payload).length > 0;
}

function isString(payload) {
  return getType(payload) === "String";
}

function isFullString(payload) {
  return isString(payload) && payload !== "";
}

function isFunction(payload) {
  return typeof payload === "function";
}

function isType(payload, type) {
  if (!(type instanceof Function)) {
    throw new TypeError("Type must be a function");
  }
  if (!Object.prototype.hasOwnProperty.call(type, "prototype")) {
    throw new TypeError("Type is not a class");
  }
  const name = type.name;
  return getType(payload) === name || Boolean(payload && payload.constructor === type);
}

function isInstanceOf(value, classOrClassName) {
  if (typeof classOrClassName === "function") {
    for (let p = value; p; p = Object.getPrototypeOf(p)) {
      if (isType(p, classOrClassName)) {
        return true;
      }
    }
    return false;
  } else {
    for (let p = value; p; p = Object.getPrototypeOf(p)) {
      if (getType(p) === classOrClassName) {
        return true;
      }
    }
    return false;
  }
}

function isMap(payload) {
  return getType(payload) === "Map";
}

function isNaNValue(payload) {
  return getType(payload) === "Number" && isNaN(payload);
}

function isNumber(payload) {
  return getType(payload) === "Number" && !isNaN(payload);
}

function isNegativeNumber(payload) {
  return isNumber(payload) && payload < 0;
}

function isNull(payload) {
  return getType(payload) === "Null";
}

function isOneOf(a, b, c, d, e) {
  return (value) => a(value) || b(value) || !!c && c(value) || !!d && d(value) || !!e && e(value);
}

function isUndefined(payload) {
  return getType(payload) === "Undefined";
}

const isNullOrUndefined = isOneOf(isNull, isUndefined);

function isObject(payload) {
  return isPlainObject(payload);
}

function isObjectLike(payload) {
  return isAnyObject(payload);
}

function isPositiveNumber(payload) {
  return isNumber(payload) && payload > 0;
}

function isSymbol(payload) {
  return getType(payload) === "Symbol";
}

function isPrimitive(payload) {
  return isBoolean(payload) || isNull(payload) || isUndefined(payload) || isNumber(payload) || isString(payload) || isSymbol(payload);
}

function isPromise(payload) {
  return getType(payload) === "Promise";
}

function isRegExp(payload) {
  return getType(payload) === "RegExp";
}

function isSet(payload) {
  return getType(payload) === "Set";
}

function isWeakMap(payload) {
  return getType(payload) === "WeakMap";
}

function isWeakSet(payload) {
  return getType(payload) === "WeakSet";
}




/***/ }),

/***/ "../../node_modules/superjson/dist/accessDeep.js":
/*!*******************************************************!*\
  !*** ../../node_modules/superjson/dist/accessDeep.js ***!
  \*******************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   getDeep: () => (/* binding */ getDeep),
/* harmony export */   setDeep: () => (/* binding */ setDeep)
/* harmony export */ });
/* harmony import */ var _is_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./is.js */ "../../node_modules/superjson/dist/is.js");
/* harmony import */ var _util_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./util.js */ "../../node_modules/superjson/dist/util.js");


const getNthKey = (value, n) => {
    if (n > value.size)
        throw new Error('index out of bounds');
    const keys = value.keys();
    while (n > 0) {
        keys.next();
        n--;
    }
    return keys.next().value;
};
function validatePath(path) {
    if ((0,_util_js__WEBPACK_IMPORTED_MODULE_1__.includes)(path, '__proto__')) {
        throw new Error('__proto__ is not allowed as a property');
    }
    if ((0,_util_js__WEBPACK_IMPORTED_MODULE_1__.includes)(path, 'prototype')) {
        throw new Error('prototype is not allowed as a property');
    }
    if ((0,_util_js__WEBPACK_IMPORTED_MODULE_1__.includes)(path, 'constructor')) {
        throw new Error('constructor is not allowed as a property');
    }
}
const getDeep = (object, path) => {
    validatePath(path);
    for (let i = 0; i < path.length; i++) {
        const key = path[i];
        if ((0,_is_js__WEBPACK_IMPORTED_MODULE_0__.isSet)(object)) {
            object = getNthKey(object, +key);
        }
        else if ((0,_is_js__WEBPACK_IMPORTED_MODULE_0__.isMap)(object)) {
            const row = +key;
            const type = +path[++i] === 0 ? 'key' : 'value';
            const keyOfRow = getNthKey(object, row);
            switch (type) {
                case 'key':
                    object = keyOfRow;
                    break;
                case 'value':
                    object = object.get(keyOfRow);
                    break;
            }
        }
        else {
            object = object[key];
        }
    }
    return object;
};
const setDeep = (object, path, mapper) => {
    validatePath(path);
    if (path.length === 0) {
        return mapper(object);
    }
    let parent = object;
    for (let i = 0; i < path.length - 1; i++) {
        const key = path[i];
        if ((0,_is_js__WEBPACK_IMPORTED_MODULE_0__.isArray)(parent)) {
            const index = +key;
            parent = parent[index];
        }
        else if ((0,_is_js__WEBPACK_IMPORTED_MODULE_0__.isPlainObject)(parent)) {
            parent = parent[key];
        }
        else if ((0,_is_js__WEBPACK_IMPORTED_MODULE_0__.isSet)(parent)) {
            const row = +key;
            parent = getNthKey(parent, row);
        }
        else if ((0,_is_js__WEBPACK_IMPORTED_MODULE_0__.isMap)(parent)) {
            const isEnd = i === path.length - 2;
            if (isEnd) {
                break;
            }
            const row = +key;
            const type = +path[++i] === 0 ? 'key' : 'value';
            const keyOfRow = getNthKey(parent, row);
            switch (type) {
                case 'key':
                    parent = keyOfRow;
                    break;
                case 'value':
                    parent = parent.get(keyOfRow);
                    break;
            }
        }
    }
    const lastKey = path[path.length - 1];
    if ((0,_is_js__WEBPACK_IMPORTED_MODULE_0__.isArray)(parent)) {
        parent[+lastKey] = mapper(parent[+lastKey]);
    }
    else if ((0,_is_js__WEBPACK_IMPORTED_MODULE_0__.isPlainObject)(parent)) {
        parent[lastKey] = mapper(parent[lastKey]);
    }
    if ((0,_is_js__WEBPACK_IMPORTED_MODULE_0__.isSet)(parent)) {
        const oldValue = getNthKey(parent, +lastKey);
        const newValue = mapper(oldValue);
        if (oldValue !== newValue) {
            parent.delete(oldValue);
            parent.add(newValue);
        }
    }
    if ((0,_is_js__WEBPACK_IMPORTED_MODULE_0__.isMap)(parent)) {
        const row = +path[path.length - 2];
        const keyToRow = getNthKey(parent, row);
        const type = +lastKey === 0 ? 'key' : 'value';
        switch (type) {
            case 'key': {
                const newKey = mapper(keyToRow);
                parent.set(newKey, parent.get(keyToRow));
                if (newKey !== keyToRow) {
                    parent.delete(keyToRow);
                }
                break;
            }
            case 'value': {
                parent.set(keyToRow, mapper(parent.get(keyToRow)));
                break;
            }
        }
    }
    return object;
};


/***/ }),

/***/ "../../node_modules/superjson/dist/class-registry.js":
/*!***********************************************************!*\
  !*** ../../node_modules/superjson/dist/class-registry.js ***!
  \***********************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   ClassRegistry: () => (/* binding */ ClassRegistry)
/* harmony export */ });
/* harmony import */ var _registry_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./registry.js */ "../../node_modules/superjson/dist/registry.js");

class ClassRegistry extends _registry_js__WEBPACK_IMPORTED_MODULE_0__.Registry {
    constructor() {
        super(c => c.name);
        this.classToAllowedProps = new Map();
    }
    register(value, options) {
        if (typeof options === 'object') {
            if (options.allowProps) {
                this.classToAllowedProps.set(value, options.allowProps);
            }
            super.register(value, options.identifier);
        }
        else {
            super.register(value, options);
        }
    }
    getAllowedProps(value) {
        return this.classToAllowedProps.get(value);
    }
}


/***/ }),

/***/ "../../node_modules/superjson/dist/custom-transformer-registry.js":
/*!************************************************************************!*\
  !*** ../../node_modules/superjson/dist/custom-transformer-registry.js ***!
  \************************************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   CustomTransformerRegistry: () => (/* binding */ CustomTransformerRegistry)
/* harmony export */ });
/* harmony import */ var _util_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./util.js */ "../../node_modules/superjson/dist/util.js");

class CustomTransformerRegistry {
    constructor() {
        this.transfomers = {};
    }
    register(transformer) {
        this.transfomers[transformer.name] = transformer;
    }
    findApplicable(v) {
        return (0,_util_js__WEBPACK_IMPORTED_MODULE_0__.find)(this.transfomers, transformer => transformer.isApplicable(v));
    }
    findByName(name) {
        return this.transfomers[name];
    }
}


/***/ }),

/***/ "../../node_modules/superjson/dist/double-indexed-kv.js":
/*!**************************************************************!*\
  !*** ../../node_modules/superjson/dist/double-indexed-kv.js ***!
  \**************************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   DoubleIndexedKV: () => (/* binding */ DoubleIndexedKV)
/* harmony export */ });
class DoubleIndexedKV {
    constructor() {
        this.keyToValue = new Map();
        this.valueToKey = new Map();
    }
    set(key, value) {
        this.keyToValue.set(key, value);
        this.valueToKey.set(value, key);
    }
    getByKey(key) {
        return this.keyToValue.get(key);
    }
    getByValue(value) {
        return this.valueToKey.get(value);
    }
    clear() {
        this.keyToValue.clear();
        this.valueToKey.clear();
    }
}


/***/ }),

/***/ "../../node_modules/superjson/dist/index.js":
/*!**************************************************!*\
  !*** ../../node_modules/superjson/dist/index.js ***!
  \**************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   SuperJSON: () => (/* binding */ SuperJSON),
/* harmony export */   allowErrorProps: () => (/* binding */ allowErrorProps),
/* harmony export */   "default": () => (/* binding */ SuperJSON),
/* harmony export */   deserialize: () => (/* binding */ deserialize),
/* harmony export */   parse: () => (/* binding */ parse),
/* harmony export */   registerClass: () => (/* binding */ registerClass),
/* harmony export */   registerCustom: () => (/* binding */ registerCustom),
/* harmony export */   registerSymbol: () => (/* binding */ registerSymbol),
/* harmony export */   serialize: () => (/* binding */ serialize),
/* harmony export */   stringify: () => (/* binding */ stringify)
/* harmony export */ });
/* harmony import */ var _class_registry_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./class-registry.js */ "../../node_modules/superjson/dist/class-registry.js");
/* harmony import */ var _registry_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./registry.js */ "../../node_modules/superjson/dist/registry.js");
/* harmony import */ var _custom_transformer_registry_js__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./custom-transformer-registry.js */ "../../node_modules/superjson/dist/custom-transformer-registry.js");
/* harmony import */ var _plainer_js__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ./plainer.js */ "../../node_modules/superjson/dist/plainer.js");
/* harmony import */ var copy_anything__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! copy-anything */ "../../node_modules/copy-anything/dist/index.js");





class SuperJSON {
    /**
     * @param dedupeReferentialEqualities  If true, SuperJSON will make sure only one instance of referentially equal objects are serialized and the rest are replaced with `null`.
     */
    constructor({ dedupe = false, } = {}) {
        this.classRegistry = new _class_registry_js__WEBPACK_IMPORTED_MODULE_0__.ClassRegistry();
        this.symbolRegistry = new _registry_js__WEBPACK_IMPORTED_MODULE_1__.Registry(s => s.description ?? '');
        this.customTransformerRegistry = new _custom_transformer_registry_js__WEBPACK_IMPORTED_MODULE_2__.CustomTransformerRegistry();
        this.allowedErrorProps = [];
        this.dedupe = dedupe;
    }
    serialize(object) {
        const identities = new Map();
        const output = (0,_plainer_js__WEBPACK_IMPORTED_MODULE_3__.walker)(object, identities, this, this.dedupe);
        const res = {
            json: output.transformedValue,
        };
        if (output.annotations) {
            res.meta = {
                ...res.meta,
                values: output.annotations,
            };
        }
        const equalityAnnotations = (0,_plainer_js__WEBPACK_IMPORTED_MODULE_3__.generateReferentialEqualityAnnotations)(identities, this.dedupe);
        if (equalityAnnotations) {
            res.meta = {
                ...res.meta,
                referentialEqualities: equalityAnnotations,
            };
        }
        return res;
    }
    deserialize(payload) {
        const { json, meta } = payload;
        let result = (0,copy_anything__WEBPACK_IMPORTED_MODULE_4__.copy)(json);
        if (meta?.values) {
            result = (0,_plainer_js__WEBPACK_IMPORTED_MODULE_3__.applyValueAnnotations)(result, meta.values, this);
        }
        if (meta?.referentialEqualities) {
            result = (0,_plainer_js__WEBPACK_IMPORTED_MODULE_3__.applyReferentialEqualityAnnotations)(result, meta.referentialEqualities);
        }
        return result;
    }
    stringify(object) {
        return JSON.stringify(this.serialize(object));
    }
    parse(string) {
        return this.deserialize(JSON.parse(string));
    }
    registerClass(v, options) {
        this.classRegistry.register(v, options);
    }
    registerSymbol(v, identifier) {
        this.symbolRegistry.register(v, identifier);
    }
    registerCustom(transformer, name) {
        this.customTransformerRegistry.register({
            name,
            ...transformer,
        });
    }
    allowErrorProps(...props) {
        this.allowedErrorProps.push(...props);
    }
}
SuperJSON.defaultInstance = new SuperJSON();
SuperJSON.serialize = SuperJSON.defaultInstance.serialize.bind(SuperJSON.defaultInstance);
SuperJSON.deserialize = SuperJSON.defaultInstance.deserialize.bind(SuperJSON.defaultInstance);
SuperJSON.stringify = SuperJSON.defaultInstance.stringify.bind(SuperJSON.defaultInstance);
SuperJSON.parse = SuperJSON.defaultInstance.parse.bind(SuperJSON.defaultInstance);
SuperJSON.registerClass = SuperJSON.defaultInstance.registerClass.bind(SuperJSON.defaultInstance);
SuperJSON.registerSymbol = SuperJSON.defaultInstance.registerSymbol.bind(SuperJSON.defaultInstance);
SuperJSON.registerCustom = SuperJSON.defaultInstance.registerCustom.bind(SuperJSON.defaultInstance);
SuperJSON.allowErrorProps = SuperJSON.defaultInstance.allowErrorProps.bind(SuperJSON.defaultInstance);

const serialize = SuperJSON.serialize;
const deserialize = SuperJSON.deserialize;
const stringify = SuperJSON.stringify;
const parse = SuperJSON.parse;
const registerClass = SuperJSON.registerClass;
const registerCustom = SuperJSON.registerCustom;
const registerSymbol = SuperJSON.registerSymbol;
const allowErrorProps = SuperJSON.allowErrorProps;


/***/ }),

/***/ "../../node_modules/superjson/dist/is.js":
/*!***********************************************!*\
  !*** ../../node_modules/superjson/dist/is.js ***!
  \***********************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   isArray: () => (/* binding */ isArray),
/* harmony export */   isBigint: () => (/* binding */ isBigint),
/* harmony export */   isBoolean: () => (/* binding */ isBoolean),
/* harmony export */   isDate: () => (/* binding */ isDate),
/* harmony export */   isEmptyObject: () => (/* binding */ isEmptyObject),
/* harmony export */   isError: () => (/* binding */ isError),
/* harmony export */   isInfinite: () => (/* binding */ isInfinite),
/* harmony export */   isMap: () => (/* binding */ isMap),
/* harmony export */   isNaNValue: () => (/* binding */ isNaNValue),
/* harmony export */   isNull: () => (/* binding */ isNull),
/* harmony export */   isNumber: () => (/* binding */ isNumber),
/* harmony export */   isPlainObject: () => (/* binding */ isPlainObject),
/* harmony export */   isPrimitive: () => (/* binding */ isPrimitive),
/* harmony export */   isRegExp: () => (/* binding */ isRegExp),
/* harmony export */   isSet: () => (/* binding */ isSet),
/* harmony export */   isString: () => (/* binding */ isString),
/* harmony export */   isSymbol: () => (/* binding */ isSymbol),
/* harmony export */   isTypedArray: () => (/* binding */ isTypedArray),
/* harmony export */   isURL: () => (/* binding */ isURL),
/* harmony export */   isUndefined: () => (/* binding */ isUndefined)
/* harmony export */ });
const getType = (payload) => Object.prototype.toString.call(payload).slice(8, -1);
const isUndefined = (payload) => typeof payload === 'undefined';
const isNull = (payload) => payload === null;
const isPlainObject = (payload) => {
    if (typeof payload !== 'object' || payload === null)
        return false;
    if (payload === Object.prototype)
        return false;
    if (Object.getPrototypeOf(payload) === null)
        return true;
    return Object.getPrototypeOf(payload) === Object.prototype;
};
const isEmptyObject = (payload) => isPlainObject(payload) && Object.keys(payload).length === 0;
const isArray = (payload) => Array.isArray(payload);
const isString = (payload) => typeof payload === 'string';
const isNumber = (payload) => typeof payload === 'number' && !isNaN(payload);
const isBoolean = (payload) => typeof payload === 'boolean';
const isRegExp = (payload) => payload instanceof RegExp;
const isMap = (payload) => payload instanceof Map;
const isSet = (payload) => payload instanceof Set;
const isSymbol = (payload) => getType(payload) === 'Symbol';
const isDate = (payload) => payload instanceof Date && !isNaN(payload.valueOf());
const isError = (payload) => payload instanceof Error;
const isNaNValue = (payload) => typeof payload === 'number' && isNaN(payload);
const isPrimitive = (payload) => isBoolean(payload) ||
    isNull(payload) ||
    isUndefined(payload) ||
    isNumber(payload) ||
    isString(payload) ||
    isSymbol(payload);
const isBigint = (payload) => typeof payload === 'bigint';
const isInfinite = (payload) => payload === Infinity || payload === -Infinity;
const isTypedArray = (payload) => ArrayBuffer.isView(payload) && !(payload instanceof DataView);
const isURL = (payload) => payload instanceof URL;


/***/ }),

/***/ "../../node_modules/superjson/dist/pathstringifier.js":
/*!************************************************************!*\
  !*** ../../node_modules/superjson/dist/pathstringifier.js ***!
  \************************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   escapeKey: () => (/* binding */ escapeKey),
/* harmony export */   parsePath: () => (/* binding */ parsePath),
/* harmony export */   stringifyPath: () => (/* binding */ stringifyPath)
/* harmony export */ });
const escapeKey = (key) => key.replace(/\./g, '\\.');
const stringifyPath = (path) => path
    .map(String)
    .map(escapeKey)
    .join('.');
const parsePath = (string) => {
    const result = [];
    let segment = '';
    for (let i = 0; i < string.length; i++) {
        let char = string.charAt(i);
        const isEscapedDot = char === '\\' && string.charAt(i + 1) === '.';
        if (isEscapedDot) {
            segment += '.';
            i++;
            continue;
        }
        const isEndOfSegment = char === '.';
        if (isEndOfSegment) {
            result.push(segment);
            segment = '';
            continue;
        }
        segment += char;
    }
    const lastSegment = segment;
    result.push(lastSegment);
    return result;
};


/***/ }),

/***/ "../../node_modules/superjson/dist/plainer.js":
/*!****************************************************!*\
  !*** ../../node_modules/superjson/dist/plainer.js ***!
  \****************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   applyReferentialEqualityAnnotations: () => (/* binding */ applyReferentialEqualityAnnotations),
/* harmony export */   applyValueAnnotations: () => (/* binding */ applyValueAnnotations),
/* harmony export */   generateReferentialEqualityAnnotations: () => (/* binding */ generateReferentialEqualityAnnotations),
/* harmony export */   walker: () => (/* binding */ walker)
/* harmony export */ });
/* harmony import */ var _is_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./is.js */ "../../node_modules/superjson/dist/is.js");
/* harmony import */ var _pathstringifier_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./pathstringifier.js */ "../../node_modules/superjson/dist/pathstringifier.js");
/* harmony import */ var _transformer_js__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./transformer.js */ "../../node_modules/superjson/dist/transformer.js");
/* harmony import */ var _util_js__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ./util.js */ "../../node_modules/superjson/dist/util.js");
/* harmony import */ var _accessDeep_js__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! ./accessDeep.js */ "../../node_modules/superjson/dist/accessDeep.js");






function traverse(tree, walker, origin = []) {
    if (!tree) {
        return;
    }
    if (!(0,_is_js__WEBPACK_IMPORTED_MODULE_0__.isArray)(tree)) {
        (0,_util_js__WEBPACK_IMPORTED_MODULE_3__.forEach)(tree, (subtree, key) => traverse(subtree, walker, [...origin, ...(0,_pathstringifier_js__WEBPACK_IMPORTED_MODULE_1__.parsePath)(key)]));
        return;
    }
    const [nodeValue, children] = tree;
    if (children) {
        (0,_util_js__WEBPACK_IMPORTED_MODULE_3__.forEach)(children, (child, key) => {
            traverse(child, walker, [...origin, ...(0,_pathstringifier_js__WEBPACK_IMPORTED_MODULE_1__.parsePath)(key)]);
        });
    }
    walker(nodeValue, origin);
}
function applyValueAnnotations(plain, annotations, superJson) {
    traverse(annotations, (type, path) => {
        plain = (0,_accessDeep_js__WEBPACK_IMPORTED_MODULE_4__.setDeep)(plain, path, v => (0,_transformer_js__WEBPACK_IMPORTED_MODULE_2__.untransformValue)(v, type, superJson));
    });
    return plain;
}
function applyReferentialEqualityAnnotations(plain, annotations) {
    function apply(identicalPaths, path) {
        const object = (0,_accessDeep_js__WEBPACK_IMPORTED_MODULE_4__.getDeep)(plain, (0,_pathstringifier_js__WEBPACK_IMPORTED_MODULE_1__.parsePath)(path));
        identicalPaths.map(_pathstringifier_js__WEBPACK_IMPORTED_MODULE_1__.parsePath).forEach(identicalObjectPath => {
            plain = (0,_accessDeep_js__WEBPACK_IMPORTED_MODULE_4__.setDeep)(plain, identicalObjectPath, () => object);
        });
    }
    if ((0,_is_js__WEBPACK_IMPORTED_MODULE_0__.isArray)(annotations)) {
        const [root, other] = annotations;
        root.forEach(identicalPath => {
            plain = (0,_accessDeep_js__WEBPACK_IMPORTED_MODULE_4__.setDeep)(plain, (0,_pathstringifier_js__WEBPACK_IMPORTED_MODULE_1__.parsePath)(identicalPath), () => plain);
        });
        if (other) {
            (0,_util_js__WEBPACK_IMPORTED_MODULE_3__.forEach)(other, apply);
        }
    }
    else {
        (0,_util_js__WEBPACK_IMPORTED_MODULE_3__.forEach)(annotations, apply);
    }
    return plain;
}
const isDeep = (object, superJson) => (0,_is_js__WEBPACK_IMPORTED_MODULE_0__.isPlainObject)(object) ||
    (0,_is_js__WEBPACK_IMPORTED_MODULE_0__.isArray)(object) ||
    (0,_is_js__WEBPACK_IMPORTED_MODULE_0__.isMap)(object) ||
    (0,_is_js__WEBPACK_IMPORTED_MODULE_0__.isSet)(object) ||
    (0,_transformer_js__WEBPACK_IMPORTED_MODULE_2__.isInstanceOfRegisteredClass)(object, superJson);
function addIdentity(object, path, identities) {
    const existingSet = identities.get(object);
    if (existingSet) {
        existingSet.push(path);
    }
    else {
        identities.set(object, [path]);
    }
}
function generateReferentialEqualityAnnotations(identitites, dedupe) {
    const result = {};
    let rootEqualityPaths = undefined;
    identitites.forEach(paths => {
        if (paths.length <= 1) {
            return;
        }
        // if we're not deduping, all of these objects continue existing.
        // putting the shortest path first makes it easier to parse for humans
        // if we're deduping though, only the first entry will still exist, so we can't do this optimisation.
        if (!dedupe) {
            paths = paths
                .map(path => path.map(String))
                .sort((a, b) => a.length - b.length);
        }
        const [representativePath, ...identicalPaths] = paths;
        if (representativePath.length === 0) {
            rootEqualityPaths = identicalPaths.map(_pathstringifier_js__WEBPACK_IMPORTED_MODULE_1__.stringifyPath);
        }
        else {
            result[(0,_pathstringifier_js__WEBPACK_IMPORTED_MODULE_1__.stringifyPath)(representativePath)] = identicalPaths.map(_pathstringifier_js__WEBPACK_IMPORTED_MODULE_1__.stringifyPath);
        }
    });
    if (rootEqualityPaths) {
        if ((0,_is_js__WEBPACK_IMPORTED_MODULE_0__.isEmptyObject)(result)) {
            return [rootEqualityPaths];
        }
        else {
            return [rootEqualityPaths, result];
        }
    }
    else {
        return (0,_is_js__WEBPACK_IMPORTED_MODULE_0__.isEmptyObject)(result) ? undefined : result;
    }
}
const walker = (object, identities, superJson, dedupe, path = [], objectsInThisPath = [], seenObjects = new Map()) => {
    const primitive = (0,_is_js__WEBPACK_IMPORTED_MODULE_0__.isPrimitive)(object);
    if (!primitive) {
        addIdentity(object, path, identities);
        const seen = seenObjects.get(object);
        if (seen) {
            // short-circuit result if we've seen this object before
            return dedupe
                ? {
                    transformedValue: null,
                }
                : seen;
        }
    }
    if (!isDeep(object, superJson)) {
        const transformed = (0,_transformer_js__WEBPACK_IMPORTED_MODULE_2__.transformValue)(object, superJson);
        const result = transformed
            ? {
                transformedValue: transformed.value,
                annotations: [transformed.type],
            }
            : {
                transformedValue: object,
            };
        if (!primitive) {
            seenObjects.set(object, result);
        }
        return result;
    }
    if ((0,_util_js__WEBPACK_IMPORTED_MODULE_3__.includes)(objectsInThisPath, object)) {
        // prevent circular references
        return {
            transformedValue: null,
        };
    }
    const transformationResult = (0,_transformer_js__WEBPACK_IMPORTED_MODULE_2__.transformValue)(object, superJson);
    const transformed = transformationResult?.value ?? object;
    const transformedValue = (0,_is_js__WEBPACK_IMPORTED_MODULE_0__.isArray)(transformed) ? [] : {};
    const innerAnnotations = {};
    (0,_util_js__WEBPACK_IMPORTED_MODULE_3__.forEach)(transformed, (value, index) => {
        if (index === '__proto__' ||
            index === 'constructor' ||
            index === 'prototype') {
            throw new Error(`Detected property ${index}. This is a prototype pollution risk, please remove it from your object.`);
        }
        const recursiveResult = walker(value, identities, superJson, dedupe, [...path, index], [...objectsInThisPath, object], seenObjects);
        transformedValue[index] = recursiveResult.transformedValue;
        if ((0,_is_js__WEBPACK_IMPORTED_MODULE_0__.isArray)(recursiveResult.annotations)) {
            innerAnnotations[index] = recursiveResult.annotations;
        }
        else if ((0,_is_js__WEBPACK_IMPORTED_MODULE_0__.isPlainObject)(recursiveResult.annotations)) {
            (0,_util_js__WEBPACK_IMPORTED_MODULE_3__.forEach)(recursiveResult.annotations, (tree, key) => {
                innerAnnotations[(0,_pathstringifier_js__WEBPACK_IMPORTED_MODULE_1__.escapeKey)(index) + '.' + key] = tree;
            });
        }
    });
    const result = (0,_is_js__WEBPACK_IMPORTED_MODULE_0__.isEmptyObject)(innerAnnotations)
        ? {
            transformedValue,
            annotations: !!transformationResult
                ? [transformationResult.type]
                : undefined,
        }
        : {
            transformedValue,
            annotations: !!transformationResult
                ? [transformationResult.type, innerAnnotations]
                : innerAnnotations,
        };
    if (!primitive) {
        seenObjects.set(object, result);
    }
    return result;
};


/***/ }),

/***/ "../../node_modules/superjson/dist/registry.js":
/*!*****************************************************!*\
  !*** ../../node_modules/superjson/dist/registry.js ***!
  \*****************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   Registry: () => (/* binding */ Registry)
/* harmony export */ });
/* harmony import */ var _double_indexed_kv_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./double-indexed-kv.js */ "../../node_modules/superjson/dist/double-indexed-kv.js");

class Registry {
    constructor(generateIdentifier) {
        this.generateIdentifier = generateIdentifier;
        this.kv = new _double_indexed_kv_js__WEBPACK_IMPORTED_MODULE_0__.DoubleIndexedKV();
    }
    register(value, identifier) {
        if (this.kv.getByValue(value)) {
            return;
        }
        if (!identifier) {
            identifier = this.generateIdentifier(value);
        }
        this.kv.set(identifier, value);
    }
    clear() {
        this.kv.clear();
    }
    getIdentifier(value) {
        return this.kv.getByValue(value);
    }
    getValue(identifier) {
        return this.kv.getByKey(identifier);
    }
}


/***/ }),

/***/ "../../node_modules/superjson/dist/transformer.js":
/*!********************************************************!*\
  !*** ../../node_modules/superjson/dist/transformer.js ***!
  \********************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   isInstanceOfRegisteredClass: () => (/* binding */ isInstanceOfRegisteredClass),
/* harmony export */   transformValue: () => (/* binding */ transformValue),
/* harmony export */   untransformValue: () => (/* binding */ untransformValue)
/* harmony export */ });
/* harmony import */ var _is_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./is.js */ "../../node_modules/superjson/dist/is.js");
/* harmony import */ var _util_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./util.js */ "../../node_modules/superjson/dist/util.js");


function simpleTransformation(isApplicable, annotation, transform, untransform) {
    return {
        isApplicable,
        annotation,
        transform,
        untransform,
    };
}
const simpleRules = [
    simpleTransformation(_is_js__WEBPACK_IMPORTED_MODULE_0__.isUndefined, 'undefined', () => null, () => undefined),
    simpleTransformation(_is_js__WEBPACK_IMPORTED_MODULE_0__.isBigint, 'bigint', v => v.toString(), v => {
        if (typeof BigInt !== 'undefined') {
            return BigInt(v);
        }
        console.error('Please add a BigInt polyfill.');
        return v;
    }),
    simpleTransformation(_is_js__WEBPACK_IMPORTED_MODULE_0__.isDate, 'Date', v => v.toISOString(), v => new Date(v)),
    simpleTransformation(_is_js__WEBPACK_IMPORTED_MODULE_0__.isError, 'Error', (v, superJson) => {
        const baseError = {
            name: v.name,
            message: v.message,
        };
        superJson.allowedErrorProps.forEach(prop => {
            baseError[prop] = v[prop];
        });
        return baseError;
    }, (v, superJson) => {
        const e = new Error(v.message);
        e.name = v.name;
        e.stack = v.stack;
        superJson.allowedErrorProps.forEach(prop => {
            e[prop] = v[prop];
        });
        return e;
    }),
    simpleTransformation(_is_js__WEBPACK_IMPORTED_MODULE_0__.isRegExp, 'regexp', v => '' + v, regex => {
        const body = regex.slice(1, regex.lastIndexOf('/'));
        const flags = regex.slice(regex.lastIndexOf('/') + 1);
        return new RegExp(body, flags);
    }),
    simpleTransformation(_is_js__WEBPACK_IMPORTED_MODULE_0__.isSet, 'set', 
    // (sets only exist in es6+)
    // eslint-disable-next-line es5/no-es6-methods
    v => [...v.values()], v => new Set(v)),
    simpleTransformation(_is_js__WEBPACK_IMPORTED_MODULE_0__.isMap, 'map', v => [...v.entries()], v => new Map(v)),
    simpleTransformation((v) => (0,_is_js__WEBPACK_IMPORTED_MODULE_0__.isNaNValue)(v) || (0,_is_js__WEBPACK_IMPORTED_MODULE_0__.isInfinite)(v), 'number', v => {
        if ((0,_is_js__WEBPACK_IMPORTED_MODULE_0__.isNaNValue)(v)) {
            return 'NaN';
        }
        if (v > 0) {
            return 'Infinity';
        }
        else {
            return '-Infinity';
        }
    }, Number),
    simpleTransformation((v) => v === 0 && 1 / v === -Infinity, 'number', () => {
        return '-0';
    }, Number),
    simpleTransformation(_is_js__WEBPACK_IMPORTED_MODULE_0__.isURL, 'URL', v => v.toString(), v => new URL(v)),
];
function compositeTransformation(isApplicable, annotation, transform, untransform) {
    return {
        isApplicable,
        annotation,
        transform,
        untransform,
    };
}
const symbolRule = compositeTransformation((s, superJson) => {
    if ((0,_is_js__WEBPACK_IMPORTED_MODULE_0__.isSymbol)(s)) {
        const isRegistered = !!superJson.symbolRegistry.getIdentifier(s);
        return isRegistered;
    }
    return false;
}, (s, superJson) => {
    const identifier = superJson.symbolRegistry.getIdentifier(s);
    return ['symbol', identifier];
}, v => v.description, (_, a, superJson) => {
    const value = superJson.symbolRegistry.getValue(a[1]);
    if (!value) {
        throw new Error('Trying to deserialize unknown symbol');
    }
    return value;
});
const constructorToName = [
    Int8Array,
    Uint8Array,
    Int16Array,
    Uint16Array,
    Int32Array,
    Uint32Array,
    Float32Array,
    Float64Array,
    Uint8ClampedArray,
].reduce((obj, ctor) => {
    obj[ctor.name] = ctor;
    return obj;
}, {});
const typedArrayRule = compositeTransformation(_is_js__WEBPACK_IMPORTED_MODULE_0__.isTypedArray, v => ['typed-array', v.constructor.name], v => [...v], (v, a) => {
    const ctor = constructorToName[a[1]];
    if (!ctor) {
        throw new Error('Trying to deserialize unknown typed array');
    }
    return new ctor(v);
});
function isInstanceOfRegisteredClass(potentialClass, superJson) {
    if (potentialClass?.constructor) {
        const isRegistered = !!superJson.classRegistry.getIdentifier(potentialClass.constructor);
        return isRegistered;
    }
    return false;
}
const classRule = compositeTransformation(isInstanceOfRegisteredClass, (clazz, superJson) => {
    const identifier = superJson.classRegistry.getIdentifier(clazz.constructor);
    return ['class', identifier];
}, (clazz, superJson) => {
    const allowedProps = superJson.classRegistry.getAllowedProps(clazz.constructor);
    if (!allowedProps) {
        return { ...clazz };
    }
    const result = {};
    allowedProps.forEach(prop => {
        result[prop] = clazz[prop];
    });
    return result;
}, (v, a, superJson) => {
    const clazz = superJson.classRegistry.getValue(a[1]);
    if (!clazz) {
        throw new Error(`Trying to deserialize unknown class '${a[1]}' - check https://github.com/blitz-js/superjson/issues/116#issuecomment-773996564`);
    }
    return Object.assign(Object.create(clazz.prototype), v);
});
const customRule = compositeTransformation((value, superJson) => {
    return !!superJson.customTransformerRegistry.findApplicable(value);
}, (value, superJson) => {
    const transformer = superJson.customTransformerRegistry.findApplicable(value);
    return ['custom', transformer.name];
}, (value, superJson) => {
    const transformer = superJson.customTransformerRegistry.findApplicable(value);
    return transformer.serialize(value);
}, (v, a, superJson) => {
    const transformer = superJson.customTransformerRegistry.findByName(a[1]);
    if (!transformer) {
        throw new Error('Trying to deserialize unknown custom value');
    }
    return transformer.deserialize(v);
});
const compositeRules = [classRule, symbolRule, customRule, typedArrayRule];
const transformValue = (value, superJson) => {
    const applicableCompositeRule = (0,_util_js__WEBPACK_IMPORTED_MODULE_1__.findArr)(compositeRules, rule => rule.isApplicable(value, superJson));
    if (applicableCompositeRule) {
        return {
            value: applicableCompositeRule.transform(value, superJson),
            type: applicableCompositeRule.annotation(value, superJson),
        };
    }
    const applicableSimpleRule = (0,_util_js__WEBPACK_IMPORTED_MODULE_1__.findArr)(simpleRules, rule => rule.isApplicable(value, superJson));
    if (applicableSimpleRule) {
        return {
            value: applicableSimpleRule.transform(value, superJson),
            type: applicableSimpleRule.annotation,
        };
    }
    return undefined;
};
const simpleRulesByAnnotation = {};
simpleRules.forEach(rule => {
    simpleRulesByAnnotation[rule.annotation] = rule;
});
const untransformValue = (json, type, superJson) => {
    if ((0,_is_js__WEBPACK_IMPORTED_MODULE_0__.isArray)(type)) {
        switch (type[0]) {
            case 'symbol':
                return symbolRule.untransform(json, type, superJson);
            case 'class':
                return classRule.untransform(json, type, superJson);
            case 'custom':
                return customRule.untransform(json, type, superJson);
            case 'typed-array':
                return typedArrayRule.untransform(json, type, superJson);
            default:
                throw new Error('Unknown transformation: ' + type);
        }
    }
    else {
        const transformation = simpleRulesByAnnotation[type];
        if (!transformation) {
            throw new Error('Unknown transformation: ' + type);
        }
        return transformation.untransform(json, superJson);
    }
};


/***/ }),

/***/ "../../node_modules/superjson/dist/util.js":
/*!*************************************************!*\
  !*** ../../node_modules/superjson/dist/util.js ***!
  \*************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   find: () => (/* binding */ find),
/* harmony export */   findArr: () => (/* binding */ findArr),
/* harmony export */   forEach: () => (/* binding */ forEach),
/* harmony export */   includes: () => (/* binding */ includes)
/* harmony export */ });
function valuesOfObj(record) {
    if ('values' in Object) {
        // eslint-disable-next-line es5/no-es6-methods
        return Object.values(record);
    }
    const values = [];
    // eslint-disable-next-line no-restricted-syntax
    for (const key in record) {
        if (record.hasOwnProperty(key)) {
            values.push(record[key]);
        }
    }
    return values;
}
function find(record, predicate) {
    const values = valuesOfObj(record);
    if ('find' in values) {
        // eslint-disable-next-line es5/no-es6-methods
        return values.find(predicate);
    }
    const valuesNotNever = values;
    for (let i = 0; i < valuesNotNever.length; i++) {
        const value = valuesNotNever[i];
        if (predicate(value)) {
            return value;
        }
    }
    return undefined;
}
function forEach(record, run) {
    Object.entries(record).forEach(([key, value]) => run(value, key));
}
function includes(arr, value) {
    return arr.indexOf(value) !== -1;
}
function findArr(record, predicate) {
    for (let i = 0; i < record.length; i++) {
        const value = record[i];
        if (predicate(value)) {
            return value;
        }
    }
    return undefined;
}


/***/ }),

/***/ "../../node_modules/viem/_esm/utils/data/isHex.js":
/*!********************************************************!*\
  !*** ../../node_modules/viem/_esm/utils/data/isHex.js ***!
  \********************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   isHex: () => (/* binding */ isHex)
/* harmony export */ });
function isHex(value, { strict = true } = {}) {
    if (!value)
        return false;
    if (typeof value !== 'string')
        return false;
    return strict ? /^0x[0-9a-fA-F]*$/.test(value) : value.startsWith('0x');
}


/***/ }),

/***/ "../../node_modules/@temporalio/workflow/package.json":
/*!************************************************************!*\
  !*** ../../node_modules/@temporalio/workflow/package.json ***!
  \************************************************************/
/***/ ((module) => {

"use strict";
module.exports = /*#__PURE__*/JSON.parse('{"name":"@temporalio/workflow","version":"1.10.1","description":"Temporal.io SDK Workflow sub-package","keywords":["temporal","workflow","isolate"],"bugs":{"url":"https://github.com/temporalio/sdk-typescript/issues"},"repository":{"type":"git","url":"git+https://github.com/temporalio/sdk-typescript.git","directory":"packages/workflow"},"homepage":"https://github.com/temporalio/sdk-typescript/tree/main/packages/workflow","license":"MIT","author":"Temporal Technologies Inc. <sdk@temporal.io>","main":"lib/index.js","types":"lib/index.d.ts","scripts":{},"dependencies":{"@temporalio/common":"1.10.1","@temporalio/proto":"1.10.1"},"devDependencies":{"source-map":"^0.7.4"},"publishConfig":{"access":"public"},"files":["src","lib"],"gitHead":"a39419f4f9398bd69cc313700af75aea268f80b1"}');

/***/ })

/******/ 	});
/************************************************************************/
/******/ 	// The module cache
/******/ 	var __webpack_module_cache__ = globalThis.__webpack_module_cache__;
/******/ 	
/******/ 	// The require function
/******/ 	function __webpack_require__(moduleId) {
/******/ 		// Check if module is in cache
/******/ 		var cachedModule = __webpack_module_cache__[moduleId];
/******/ 		if (cachedModule !== undefined) {
/******/ 			return cachedModule.exports;
/******/ 		}
/******/ 		// Create a new module (and put it into the cache)
/******/ 		var module = __webpack_module_cache__[moduleId] = {
/******/ 			// no module.id needed
/******/ 			// no module.loaded needed
/******/ 			exports: {}
/******/ 		};
/******/ 	
/******/ 		// Execute the module function
/******/ 		__webpack_modules__[moduleId].call(module.exports, module, module.exports, __webpack_require__);
/******/ 	
/******/ 		// Return the exports of the module
/******/ 		return module.exports;
/******/ 	}
/******/ 	
/************************************************************************/
/******/ 	/* webpack/runtime/compat get default export */
/******/ 	(() => {
/******/ 		// getDefaultExport function for compatibility with non-harmony modules
/******/ 		__webpack_require__.n = (module) => {
/******/ 			var getter = module && module.__esModule ?
/******/ 				() => (module['default']) :
/******/ 				() => (module);
/******/ 			__webpack_require__.d(getter, { a: getter });
/******/ 			return getter;
/******/ 		};
/******/ 	})();
/******/ 	
/******/ 	/* webpack/runtime/define property getters */
/******/ 	(() => {
/******/ 		// define getter functions for harmony exports
/******/ 		__webpack_require__.d = (exports, definition) => {
/******/ 			for(var key in definition) {
/******/ 				if(__webpack_require__.o(definition, key) && !__webpack_require__.o(exports, key)) {
/******/ 					Object.defineProperty(exports, key, { enumerable: true, get: definition[key] });
/******/ 				}
/******/ 			}
/******/ 		};
/******/ 	})();
/******/ 	
/******/ 	/* webpack/runtime/hasOwnProperty shorthand */
/******/ 	(() => {
/******/ 		__webpack_require__.o = (obj, prop) => (Object.prototype.hasOwnProperty.call(obj, prop))
/******/ 	})();
/******/ 	
/******/ 	/* webpack/runtime/make namespace object */
/******/ 	(() => {
/******/ 		// define __esModule on exports
/******/ 		__webpack_require__.r = (exports) => {
/******/ 			if(typeof Symbol !== 'undefined' && Symbol.toStringTag) {
/******/ 				Object.defineProperty(exports, Symbol.toStringTag, { value: 'Module' });
/******/ 			}
/******/ 			Object.defineProperty(exports, '__esModule', { value: true });
/******/ 		};
/******/ 	})();
/******/ 	
/************************************************************************/
var __webpack_exports__ = {};
// This entry need to be wrapped in an IIFE because it uses a non-standard name for the exports (exports).
(() => {
var exports = __webpack_exports__;
/*!********************************************************!*\
  !*** ./src/all-workflows-autogenerated-entrypoint.cjs ***!
  \********************************************************/

const api = __webpack_require__(/*! @temporalio/workflow/lib/worker-interface.js */ "../../node_modules/@temporalio/workflow/lib/worker-interface.js");

api.overrideGlobals();

exports.api = api;

exports.importWorkflows = function importWorkflows() {
  return __webpack_require__(/* webpackMode: "eager" */ /*! ./src/all-workflows.ts */ "./src/all-workflows.ts");
}

exports.importInterceptors = function importInterceptors() {
  return [
    
  ];
}

})();

__TEMPORAL__ = __webpack_exports__;
/******/ })()
;
//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoid29ya2Zsb3ctYnVuZGxlLTI0ODViMTVkZjE4ZTRjNThkNzYxLmpzIiwibWFwcGluZ3MiOiI7Ozs7Ozs7Ozs7Ozs7OztBQUlBLG1KQUE4RDtBQUVqRCxnQ0FBd0IsR0FBRztJQUN0QyxVQUFVLEVBQUUsWUFBWTtJQUN4QiwyQkFBMkIsRUFBRSw2QkFBNkI7SUFDMUQsT0FBTyxFQUFFLFNBQVM7Q0FDVixDQUFDO0FBR0UsS0FBbUUsK0NBQXVCLEVBT3JHO0lBQ0UsQ0FBQyxnQ0FBd0IsQ0FBQyxVQUFVLENBQUMsRUFBRSxDQUFDO0lBQ3hDLENBQUMsZ0NBQXdCLENBQUMsMkJBQTJCLENBQUMsRUFBRSxDQUFDO0lBQ3pELENBQUMsZ0NBQXdCLENBQUMsT0FBTyxDQUFDLEVBQUUsQ0FBQztDQUM3QixFQUNWLEVBQUUsQ0FDSCxFQWJhLHNDQUE4QixVQUFFLHNDQUE4QixTQWExRTs7Ozs7Ozs7Ozs7Ozs7O0FDMUJGLHVKQUFnRjtBQUVoRix1SkFBZ0Y7QUE0RGhGOzs7O0dBSUc7QUFDVSwrQkFBdUIsR0FBcUIsSUFBSSwyQ0FBdUIsRUFBRSxDQUFDO0FBRXZGOztHQUVHO0FBQ1UsNEJBQW9CLEdBQXdCO0lBQ3ZELGdCQUFnQixFQUFFLDJDQUF1QjtJQUN6QyxnQkFBZ0IsRUFBRSwrQkFBdUI7SUFDekMsYUFBYSxFQUFFLEVBQUU7Q0FDbEIsQ0FBQzs7Ozs7Ozs7Ozs7Ozs7O0FDMUJGLDRDQVFDO0FBMURELGdIQWVvQjtBQUNwQiwrSEFBMEM7QUFDMUMsdUdBQXlDO0FBQ3pDLHVKQUEyRztBQUUzRyxTQUFTLGFBQWEsQ0FBQyxHQUFHLE9BQWlCO0lBQ3pDLE9BQU8sSUFBSSxNQUFNLENBQUMsT0FBTyxDQUFDLEdBQUcsQ0FBQyxDQUFDLENBQUMsRUFBRSxFQUFFLENBQUMsTUFBTSxDQUFDLENBQUMsTUFBTSxHQUFHLENBQUMsQ0FBQyxJQUFJLENBQUMsR0FBRyxDQUFDLENBQUMsQ0FBQztBQUNyRSxDQUFDO0FBRUQ7O0dBRUc7QUFDSCxNQUFNLHFCQUFxQixHQUFHLGFB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QTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxFQUFFOztBQUVGO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFdBQVcsNENBQTRDOztBQUV2RDtBQUNBO0FBQ0E7QUFDQSxXQUFXLFFBQVE7QUFDbkI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsSUFBSTtBQUNKO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0Es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QUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxZQUFZO0FBQ1o7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0EsYUFBYSxHQUFHO0FBQ2hCLGVBQWU7QUFDZjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsYUFBYSxHQUFHO0FBQ2hCLGVBQWU7QUFDZjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsYUFBYSxHQUFHO0FBQ2hCLGVBQWU7QUFDZjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxZQUFZO0FBQ1o7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsWUFBWTtBQUNaO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxhQUFhLFFBQVE7QUFDckIsYUFBYSxVQUFVO0FBQ3ZCLGVBQWU7QUFDZjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsTUFBTTtBQUNOO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGFBQWEsUUFBUTtBQUNyQixhQUFhLFVBQVU7QUFDdkIsZUFBZSxPQUFPO0FBQ3RCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxhQUFhLFFBQVE7QUFDckIsYUFBYSxVQUFVO0FBQ3ZCLGVBQWU7QUFDZjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxNQUFNO0FBQ047QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxhQUFhLFFBQVE7QUFDckIsYUFBYSxVQUFVO0FBQ3ZCLGVBQWUsT0FBTztBQUN0QjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsYUFBYSxRQUFRO0FBQ3JCLGFBQWEsUUFBUTtBQUNyQixhQUFhLFVBQVU7QUFDdkIsZUFBZTtBQUNmO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsYUFBYSxRQUFRO0FBQ3JCLGFBQWEsUUFBUTtBQUNyQixhQUFhLFVBQVU7QUFDdkIsZUFBZSxPQUFPO0FBQ3RCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGFBQWEsUUFBUTtBQUNyQixhQUFhLFFBQVE7QUFDckIsZUFBZTtBQUNmO0FBQ0E7QUFDQTtBQUNBLDBCQUEwQjtBQUMxQjtBQUNBO0FBQ0EsYUFBYSxRQUFRO0FBQ3JCLGFBQWEsbUJBQW1CO0FBQ2hDLGFBQWEsU0FBUztBQUN0QixlQUFlO0FBQ2Y7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxNQUFNO0FBQ047QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxtRUFBbUU7QUFDbkU7QUFDQSxNQUFNO0FBQ047QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLG9CQUFvQixnQkFBZ0I7QUFDcEM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsUUFBUTtBQUNSO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxhQUFhLFFBQVE7QUFDckIsYUFBYSxtQkFBbUI7QUFDaEMsYUFBYSxTQUFTO0FBQ3RCLGVBQWUsT0FBTztBQUN0QjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxhQUFhLHNCQUFzQiwrQ0FBK0M7QUFDbEYsYUFBYSxVQUFVO0FBQ3ZCLGVBQWU7QUFDZjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsbUVBQW1FO0FBQ25FO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGFBQWEsc0JBQXNCLCtDQUErQztBQUNsRixhQUFhLFVBQVU7QUFDdkIsZUFBZTtBQUNmO0FBQ0E7QUFDQTtBQUNBLDhCQUE4QjtBQUM5QjtBQUNBO0FBQ0E7QUFDQSxZQUFZO0FBQ1o7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsWUFBWTtBQUNaO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFlBQVk7QUFDWjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxZQUFZO0FBQ1o7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsWUFBWTtBQUNaO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFlBQVk7QUFDWjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxZQUFZO0FBQ1o7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsWUFBWTtBQUNaO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsWUFBWTtBQUNaO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFlBQVk7QUFDWjtBQUNBO0FBQ0E7QUFDQTtBQUNBLFlBQVk7QUFDWjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxZQUFZO0FBQ1o7QUFDQTtBQUNBO0FBQ0E7QUFDQSxZQUFZO0FBQ1o7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsWUFBWTtBQUNaO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsWUFBWTtBQUNaO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFlBQVk7QUFDWjtBQUNBO0FBQ0E7QUFDQTtBQUNBLFlBQVk7QUFDWjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxZQUFZO0FBQ1o7QUFDQTtBQUNBO0FBQ0E7QUFDQSxZQUFZO0FBQ1o7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsWUFBWTtBQUNaO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsWUFBWTtBQUNaO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFlBQVk7QUFDWjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsWUFBWTtBQUNa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O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSx3QkFBd0IsR0FBRztBQUMzQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsSUFBSTtBQUNKLHdCQUF3QixHQUFHO0FBQzNCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRXdiOzs7Ozs7Ozs7Ozs7Ozs7Ozs7O0FDMUt6WDtBQUMxQjtBQUVyQyxNQUFNLFNBQVMsR0FBRyxDQUFDLEtBQStCLEVBQUUsQ0FBUyxFQUFPLEVBQUU7SUFDcEUsSUFBSSxDQUFDLEdBQUcsS0FBSyxDQUFDLElBQUk7UUFBRSxNQUFNLElBQUksS0FBSyxDQUFDLHFCQUFxQixDQUFDLENBQUM7SUFDM0QsTUFBTSxJQUFJLEdBQUcsS0FBSyxDQUFDLElBQUksRUFBRSxDQUFDO0lBQzFCLE9BQU8sQ0FBQyxH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bUJBQU8sNEJBQTRCLHNEQUErRTtBQUMzSDs7QUFFQSwwQkFBMEI7QUFDMUI7QUFDQTtBQUNBO0FBQ0EiLCJzb3VyY2VzIjpbIi9Vc2Vycy92aWN0MHhyL0RvY3VtZW50cy9TZW5kL3NlbmRhcHAvbm9kZV9tb2R1bGVzL0B0ZW1wb3JhbGlvL2NvbW1vbi9zcmMvYWN0aXZpdHktb3B0aW9ucy50cyIsIi9Vc2Vycy92aWN0MHhyL0RvY3VtZW50cy9TZW5kL3NlbmRhcHAvbm9kZV9tb2R1bGVzL0B0ZW1wb3JhbGlvL2NvbW1vbi9zcmMvY29udmVydGVyL2RhdGEtY29udmVydGVyLnRzIiwiL1VzZXJzL3ZpY3QweHIvRG9jdW1lbnRzL1NlbmQvc2VuZGFwcC9ub2RlX21vZHVsZXMvQHRlbXBvcmFsaW8vY29tbW9uL3NyYy9jb252ZXJ0ZXIvZmFpbHVyZS1jb252ZXJ0ZXIudHMiLCIvVXNlcnMvdmljdDB4ci9Eb2N1bWVudHMvU2VuZC9zZW5kYXBwL25vZGVfbW9kdWxlcy9AdGVtcG9yYWxpby9jb21tb24vc3JjL2NvbnZlcnRlci9wYXlsb2FkLWNvZGVjLnRzIiwiL1VzZXJzL3ZpY3QweHIvRG9jdW1lbnRzL1NlbmQvc2VuZGFwcC9ub2RlX21vZHVsZXMvQHRlbXBvcmFsaW8vY29tbW9uL3NyYy9jb252ZXJ0ZXIvcGF5bG9hZC1jb252ZXJ0ZXIudHMiLCIvVXNlcnMvdmljdDB4ci9Eb2N1bWVudHMvU2VuZC9zZW5kYXBwL25vZGVfbW9kdWxlcy9AdGVtcG9yYWxpby9jb21tb24vc3JjL2NvbnZlcnRlci90eXBlcy50cyIsIi9Vc2Vycy92aWN0MHhyL0RvY3VtZW50cy9TZW5kL3NlbmRhcHAvbm9kZV9tb2R1bGVzL0B0ZW1wb3JhbGlvL2NvbW1vbi9zcmMvZGVwcmVjYXRlZC10aW1lLnRzIiwiL1VzZXJzL3ZpY3QweHIvRG9jdW1lbnRzL1NlbmQvc2VuZGFwcC9ub2RlX21vZHVsZXMvQHRlbXBvcmFsaW8vY29tbW9uL3NyYy9lbmNvZGluZy50cyIsIi9Vc2Vycy92aWN0MHhyL0RvY3VtZW50cy9TZW5kL3NlbmRhcHAvbm9kZV9tb2R1bGVzL0B0ZW1wb3JhbGlvL2NvbW1vbi9zcmMvZXJyb3JzLnRzIiwiL1VzZXJzL3ZpY3QweHIvRG9jdW1lbnRzL1NlbmQvc2VuZGFwcC9ub2RlX21vZHVsZXMvQHRlbXBvcmFsaW8vY29tbW9uL3NyYy9mYWlsdXJlLnRzIiwiL1VzZXJzL3ZpY3QweHIvRG9jdW1lbnRzL1NlbmQvc2VuZGFwcC9ub2RlX21vZHVsZXMvQHRlbXBvcmFsaW8vY29tbW9uL3NyYy9pbmRleC50cyIsIi9Vc2Vycy92aWN0MHhyL0RvY3VtZW50cy9TZW5kL3NlbmRhcHAvbm9kZV9tb2R1bGVzL0B0ZW1wb3JhbGlvL2NvbW1vbi9zcmMvaW50ZXJmYWNlcy50cyIsIi9Vc2Vycy92aWN0MHhyL0RvY3VtZW50cy9TZW5kL3NlbmRhcHAvbm9kZV9tb2R1bGVzL0B0ZW1wb3JhbGlvL2NvbW1vbi9zcmMvaW50ZXJuYWwtd29ya2Zsb3cvZW51bXMtaGVscGVycy50cyIsIi9Vc2Vycy92aWN0MHhyL0RvY3VtZW50cy9TZW5kL3NlbmRhcHAvbm9kZV9tb2R1bGVzL0B0ZW1wb3JhbGlvL2NvbW1vbi9zcmMvaW50ZXJuYWwtd29ya2Zsb3cvaW5kZXgudHMiLCIvVXNlcnMvdmljdDB4ci9Eb2N1bWVudHMvU2VuZC9zZW5kYXBwL25vZGVfbW9kdWxlcy9AdGVtcG9yYWxpby9jb21tb24vc3JjL2xvZ2dlci50cyIsIi9Vc2Vycy92aWN0MHhyL0RvY3VtZW50cy9TZW5kL3NlbmRhcHAvbm9kZV9tb2R1bGVzL0B0ZW1wb3JhbGlvL2NvbW1vbi9zcmMvcmV0cnktcG9saWN5LnRzIiwiL1VzZXJzL3ZpY3QweHIvRG9jdW1lbnRzL1NlbmQvc2VuZGFwcC9ub2RlX21vZHVsZXMvQHRlbXBvcmFsaW8vY29tbW9uL3NyYy90aW1lLnRzIiwiL1VzZXJzL3ZpY3QweHIvRG9jdW1lbnRzL1NlbmQvc2VuZGFwcC9ub2RlX21vZHVsZXMvQHRlbXBvcmFsaW8vY29tbW9uL3NyYy90eXBlLWhlbHBlcnMudHMiLCIvVXNlcnMvdmljdDB4ci9Eb2N1bWVudHMvU2VuZC9zZW5kYXBwL25vZGVfbW9kdWxlcy9AdGVtcG9yYWxpby9jb21tb24vc3JjL3ZlcnNpb25pbmctaW50ZW50LnRzIiwiL1VzZXJzL3ZpY3QweHIvRG9jdW1lbnRzL1NlbmQvc2VuZGFwcC9ub2RlX21vZHVsZXMvQHRlbXBvcmFsaW8vY29tbW9uL3NyYy93b3JrZmxvdy1oYW5kbGUudHMiLCIvVXNlcnMvdmljdDB4ci9Eb2N1bWVudHMvU2VuZC9zZW5kYXBwL25vZGVfbW9kdWxlcy9AdGVtcG9yYWxpby9jb21tb24vc3JjL3dvcmtmbG93LW9wdGlvbnMudHMiLCIvVXNlcnMvdmljdDB4ci9Eb2N1bWVudHMvU2VuZC9zZW5kYXBwL25vZGVfbW9kdWxlcy9AdGVtcG9yYWxpby93b3JrZmxvdy9zcmMvYWxlYS50cyIsIi9Vc2Vycy92aWN0MHhyL0RvY3VtZW50cy9TZW5kL3NlbmRhcHAvbm9kZV9tb2R1bGVzL0B0ZW1wb3JhbGlvL3dvcmtmbG93L3NyYy9jYW5jZWxsYXRpb24tc2NvcGUudHMiLCIvVXNlcnMvdmljdDB4ci9Eb2N1bWVudHMvU2VuZC9zZW5kYXBwL25vZGVfbW9kdWxlcy9AdGVtcG9yYWxpby93b3JrZmxvdy9zcmMvZXJyb3JzLnRzIiwiL1VzZXJzL3ZpY3QweHIvRG9jdW1lbnRzL1NlbmQvc2VuZGFwcC9ub2RlX21vZHVsZXMvQHRlbXBvcmFsaW8vd29ya2Zsb3cvc3JjL2dsb2JhbC1hdHRyaWJ1dGVzLnRzIiwiL1VzZXJzL3ZpY3QweHIvRG9jdW1lbnRzL1NlbmQvc2VuZGFwcC9ub2RlX21vZHVsZXMvQHRlbXBvcmFsaW8vd29ya2Zsb3cvc3JjL2luZGV4LnRzIiwiL1VzZXJzL3ZpY3QweHIvRG9jdW1lbnRzL1NlbmQvc2VuZGFwcC9ub2RlX21vZHVsZXMvQHRlbXBvcmFsaW8vd29ya2Zsb3cvc3JjL2ludGVyY2VwdG9ycy50cyIsIi9Vc2Vycy92aWN0MHhyL0RvY3VtZW50cy9TZW5kL3NlbmRhcHAvbm9kZV9tb2R1bGVzL0B0ZW1wb3JhbGlvL3dvcmtmbG93L3NyYy9pbnRlcmZhY2VzLnRzIiwiL1VzZXJzL3ZpY3QweHIvRG9jdW1lbnRzL1NlbmQvc2VuZGFwcC9ub2RlX21vZHVsZXMvQHRlbXBvcmFsaW8vd29ya2Zsb3cvc3JjL2ludGVybmFscy50cyIsIi9Vc2Vycy92aWN0MHhyL0RvY3VtZW50cy9TZW5kL3NlbmRhcHAvbm9kZV9tb2R1bGVzL0B0ZW1wb3JhbGlvL3dvcmtmbG93L3NyYy9sb2dzLnRzIiwiL1VzZXJzL3ZpY3QweHIvRG9jdW1lbnRzL1NlbmQvc2VuZGFwcC9ub2RlX21vZHVsZXMvQHRlbXBvcmFsaW8vd29ya2Zsb3cvc3JjL3BrZy50cyIsIi9Vc2Vycy92aWN0MHhyL0RvY3VtZW50cy9TZW5kL3NlbmRhcHAvbm9kZV9tb2R1bGVzL0B0ZW1wb3JhbGlvL3dvcmtmbG93L3NyYy9zaW5rcy50cyIsIi9Vc2Vycy92aWN0MHhyL0RvY3VtZW50cy9TZW5kL3NlbmRhcHAvbm9kZV9tb2R1bGVzL0B0ZW1wb3JhbGlvL3dvcmtmbG93L3NyYy9zdGFjay1oZWxwZXJzLnRzIiwiL1VzZXJzL3ZpY3QweHIvRG9jdW1lbnRzL1NlbmQvc2VuZGFwcC9ub2RlX21vZHVsZXMvQHRlbXBvcmFsaW8vd29ya2Zsb3cvc3JjL3RyaWdnZXIudHMiLCIvVXNlcnMvdmljdDB4ci9Eb2N1bWVudHMvU2VuZC9zZW5kYXBwL25vZGVfbW9kdWxlcy9AdGVtcG9yYWxpby93b3JrZmxvdy9zcmMvd29ya2VyLWludGVyZmFjZS50cyIsIi9Vc2Vycy92aWN0MHhyL0RvY3VtZW50cy9TZW5kL3NlbmRhcHAvbm9kZV9tb2R1bGVzL0B0ZW1wb3JhbGlvL3dvcmtmbG93L3NyYy93b3JrZmxvdy50cyIsIi9Vc2Vycy92aWN0MHhyL0RvY3VtZW50cy9TZW5kL3NlbmRhcHAvbm9kZV9tb2R1bGVzL0B0ZW1wb3JhbGlvL3dvcmtmbG93L25vZGVfbW9kdWxlcy9AdGVtcG9yYWxpby9jb21tb24vc3JjL2FjdGl2aXR5LW9wdGlvbnMudHMiLCIvVXNlcnMvdmljdDB4ci9Eb2N1bWVudHMvU2VuZC9zZW5kYXBwL25vZGVfbW9kdWxlcy9AdGVtcG9yYWxpby93b3JrZmxvdy9ub2RlX21vZHVsZXMvQHRlbXBvcmFsaW8vY29tbW9uL3NyYy9jb252ZXJ0ZXIvZGF0YS1jb252ZXJ0ZXIudHMiLCIvVXNlcnMvdmljdDB4ci9Eb2N1bWVudHMvU2VuZC9zZW5kYXBwL25vZGVfbW9kdWxlcy9AdGVtcG9yYWxpby93b3JrZmxvdy9ub2RlX21vZHVsZXMvQHRlbXBvcmFsaW8vY29tbW9uL3NyYy9jb252ZXJ0ZXIvZmFpbHVyZS1jb252ZXJ0ZXIudHMiLCIvVXNlcnMvdmljdDB4ci9Eb2N1bWVudHMvU2VuZC9zZW5kYXBwL25vZGVfbW9kdWxlcy9AdGVtcG9yYWxpby93b3JrZmxvdy9ub2RlX21vZHVsZXMvQHRlbXBvcmFsaW8vY29tbW9uL3NyYy9jb252ZXJ0ZXIvcGF5bG9hZC1jb2RlYy50cyIsIi9Vc2Vycy92aWN0MHhyL0RvY3VtZW50cy9TZW5kL3NlbmRhcHAvbm9kZV9tb2R1bGVzL0B0ZW1wb3JhbGlvL3dvcmtmbG93L25vZGVfbW9kdWxlcy9AdGVtcG9yYWxpby9jb21tb24vc3JjL2NvbnZlcnRlci9wYXlsb2FkLWNvbnZlcnRlci50cyIsIi9Vc2Vycy92aWN0MHhyL0RvY3VtZW50cy9TZW5kL3NlbmRhcHAvbm9kZV9tb2R1bGVzL0B0ZW1wb3JhbGlvL3dvcmtmbG93L25vZGVfbW9kdWxlcy9AdGVtcG9yYWxpby9jb21tb24vc3JjL2NvbnZlcnRlci90eXBlcy50cyIsIi9Vc2Vycy92aWN0MHhyL0RvY3VtZW50cy9TZW5kL3NlbmRhcHAvbm9kZV9tb2R1bGVzL0B0ZW1wb3JhbGlvL3dvcmtmbG93L25vZGVfbW9kdWxlcy9AdGVtcG9yYWxpby9jb21tb24vc3JjL2RlcHJlY2F0ZWQtdGltZS50cyIsIi9Vc2Vycy92aWN0MHhyL0RvY3VtZW50cy9TZW5kL3NlbmRhcHAvbm9kZV9tb2R1bGVzL0B0ZW1wb3JhbGlvL3dvcmtmbG93L25vZGVfbW9kdWxlcy9AdGVtcG9yYWxpby9jb21tb24vc3JjL2VuY29kaW5nLnRzIiwiL1VzZXJzL3ZpY3QweHIvRG9jdW1lbnRzL1NlbmQvc2VuZGFwcC9ub2RlX21vZHVsZXMvQHRlbXBvcmFsaW8vd29ya2Zsb3cvbm9kZV9tb2R1bGVzL0B0ZW1wb3JhbGlvL2NvbW1vbi9zcmMvZXJyb3JzLnRzIiwiL1VzZXJzL3ZpY3QweHIvRG9jdW1lbnRzL1NlbmQvc2VuZGFwcC9ub2RlX21vZHVsZXMvQHRlbXBvcmFsaW8vd29ya2Zsb3cvbm9kZV9tb2R1bGVzL0B0ZW1wb3JhbGlvL2NvbW1vbi9zcmMvZmFpbHVyZS50cyIsIi9Vc2Vycy92aWN0MHhyL0RvY3VtZW50cy9TZW5kL3NlbmRhcHAvbm9kZV9tb2R1bGVzL0B0ZW1wb3JhbGlvL3dvcmtmbG93L25vZGVfbW9kdWxlcy9AdGVtcG9yYWxpby9jb21tb24vc3JjL2luZGV4LnRzIiwiL1VzZXJzL3ZpY3QweHIvRG9jdW1lbnRzL1NlbmQvc2VuZGFwcC9ub2RlX21vZHVsZXMvQHRlbXBvcmFsaW8vd29ya2Zsb3cvbm9kZV9tb2R1bGVzL0B0ZW1wb3JhbGlvL2NvbW1vbi9zcmMvaW50ZXJjZXB0b3JzLnRzIiwiL1VzZXJzL3ZpY3QweHIvRG9jdW1lbnRzL1NlbmQvc2VuZGFwcC9ub2RlX21vZHVsZXMvQHRlbXBvcmFsaW8vd29ya2Zsb3cvbm9kZV9tb2R1bGVzL0B0ZW1wb3JhbGlvL2NvbW1vbi9zcmMvaW50ZXJmYWNlcy50cyIsIi9Vc2Vycy92aWN0MHhyL0RvY3VtZW50cy9TZW5kL3NlbmRhcHAvbm9kZV9tb2R1bGVzL0B0ZW1wb3JhbGlvL3dvcmtmbG93L25vZGVfbW9kdWxlcy9AdGVtcG9yYWxpby9jb21tb24vc3JjL2xvZ2dlci50cyIsIi9Vc2Vycy92aWN0MHhyL0RvY3VtZW50cy9TZW5kL3NlbmRhcHAvbm9kZV9tb2R1bGVzL0B0ZW1wb3JhbGlvL3dvcmtmbG93L25vZGVfbW9kdWxlcy9AdGVtcG9yYWxpby9jb21tb24vc3JjL3JldHJ5LXBvbGljeS50cyIsIi9Vc2Vycy92aWN0MHhyL0RvY3VtZW50cy9TZW5kL3NlbmRhcHAvbm9kZV9tb2R1bGVzL0B0ZW1wb3JhbGlvL3dvcmtmbG93L25vZGVfbW9kdWxlcy9AdGVtcG9yYWxpby9jb21tb24vc3JjL3RpbWUudHMiLCIvVXNlcnMvdmljdDB4ci9Eb2N1bWVudHMvU2VuZC9zZW5kYXBwL25vZGVfbW9kdWxlcy9AdGVtcG9yYWxpby93b3JrZmxvdy9ub2RlX21vZHVsZXMvQHRlbXBvcmFsaW8vY29tbW9uL3NyYy90eXBlLWhlbHBlcnMudHMiLCIvVXNlcnMvdmljdDB4ci9Eb2N1bWVudHMvU2VuZC9zZW5kYXBwL25vZGVfbW9kdWxlcy9AdGVtcG9yYWxpby93b3JrZmxvdy9ub2RlX21vZHVsZXMvQHRlbXBvcmFsaW8vY29tbW9uL3NyYy92ZXJzaW9uaW5nLWludGVudC1lbnVtLnRzIiwiL1VzZXJzL3ZpY3QweHIvRG9jdW1lbnRzL1NlbmQvc2VuZGFwcC9ub2RlX21vZHVsZXMvQHRlbXBvcmFsaW8vd29ya2Zsb3cvbm9kZV9tb2R1bGVzL0B0ZW1wb3JhbGlvL2NvbW1vbi9zcmMvdmVyc2lvbmluZy1pbnRlbnQudHMiLCIvVXNlcnMvdmljdDB4ci9Eb2N1bWVudHMvU2VuZC9zZW5kYXBwL25vZGVfbW9kdWxlcy9AdGVtcG9yYWxpby93b3JrZmxvdy9ub2RlX21vZHVsZXMvQHRlbXBvcmFsaW8vY29tbW9uL3NyYy93b3JrZmxvdy1oYW5kbGUudHMiLCIvVXNlcnMvdmljdDB4ci9Eb2N1bWVudHMvU2VuZC9zZW5kYXBwL25vZGVfbW9kdWxlcy9AdGVtcG9yYWxpby93b3JrZmxvdy9ub2RlX21vZHVsZXMvQHRlbXBvcmFsaW8vY29tbW9uL3NyYy93b3JrZmxvdy1vcHRpb25zLnRzIiwiL1VzZXJzL3ZpY3QweHIvRG9jdW1lbnRzL1NlbmQvc2VuZGFwcC9ub2RlX21vZHVsZXMvZGVidWcvbm9kZV9tb2R1bGVzL21zL2luZGV4LmpzIiwiL1VzZXJzL3ZpY3QweHIvRG9jdW1lbnRzL1NlbmQvc2VuZGFwcC9ub2RlX21vZHVsZXMvZGVidWcvc3JjL2Jyb3dzZXIuanMiLCIvVXNlcnMvdmljdDB4ci9Eb2N1bWVudHMvU2VuZC9zZW5kYXBwL25vZGVfbW9kdWxlcy9kZWJ1Zy9zcmMvY29tbW9uLmpzIiwiL1VzZXJzL3ZpY3QweHIvRG9jdW1lbnRzL1NlbmQvc2VuZGFwcC9wYWNrYWdlcy9hcHAvdXRpbHMvYXNzZXJ0LnRzIiwiL1VzZXJzL3ZpY3QweHIvRG9jdW1lbnRzL1NlbmQvc2VuZGFwcC9wYWNrYWdlcy9hcHAvdXRpbHMvaGV4VG9CeXRlYS50cyIsIi9Vc2Vycy92aWN0MHhyL0RvY3VtZW50cy9TZW5kL3NlbmRhcHAvcGFja2FnZXMvd29ya2Zsb3dzL3NyYy9hbGwtd29ya2Zsb3dzLnRzIiwiL1VzZXJzL3ZpY3QweHIvRG9jdW1lbnRzL1NlbmQvc2VuZGFwcC9wYWNrYWdlcy93b3JrZmxvd3Mvc3JjL2Rpc3RyaWJ1dGlvbi13b3JrZmxvdy93b3JrZmxvdy50cyIsIi9Vc2Vycy92aWN0MHhyL0RvY3VtZW50cy9TZW5kL3NlbmRhcHAvcGFja2FnZXMvd29ya2Zsb3dzL3NyYy90cmFuc2Zlci13b3JrZmxvdy93b3JrZmxvdy50cyIsImlnbm9yZWR8L1VzZXJzL3ZpY3QweHIvRG9jdW1lbnRzL1NlbmQvc2VuZGFwcC9ub2RlX21vZHVsZXMvQHRlbXBvcmFsaW8vd29ya2Zsb3cvbGlifF9fdGVtcG9yYWxfY3VzdG9tX2ZhaWx1cmVfY29udmVydGVyIiwiL1VzZXJzL3ZpY3QweHIvRG9jdW1lbnRzL1NlbmQvc2VuZGFwcC9ub2RlX21vZHVsZXMvQHRlbXBvcmFsaW8vY29tbW9uL25vZGVfbW9kdWxlcy9tcy9kaXN0L2luZGV4LmNqcyIsIi9Vc2Vycy92aWN0MHhyL0RvY3VtZW50cy9TZW5kL3NlbmRhcHAvbm9kZV9tb2R1bGVzL0B0ZW1wb3JhbGlvL3dvcmtmbG93L25vZGVfbW9kdWxlcy9tcy9kaXN0L2luZGV4LmNqcyIsIi9Vc2Vycy92aWN0MHhyL0RvY3VtZW50cy9TZW5kL3NlbmRhcHAvbm9kZV9tb2R1bGVzL2xvbmcvdW1kL2luZGV4LmpzIiwiL1VzZXJzL3ZpY3QweHIvRG9jdW1lbnRzL1NlbmQvc2VuZGFwcC9wYWNrYWdlcy90ZW1wb3JhbC9idWlsZC9wYXlsb2FkLWNvbnZlcnRlci5janMiLCIvVXNlcnMvdmljdDB4ci9Eb2N1bWVudHMvU2VuZC9zZW5kYXBwL25vZGVfbW9kdWxlcy9jb3B5LWFueXRoaW5nL2Rpc3QvaW5kZXguanMiLCIvVXNlcnMvdmljdDB4ci9Eb2N1bWVudHMvU2VuZC9zZW5kYXBwL25vZGVfbW9kdWxlcy9pcy13aGF0L2Rpc3QvaW5kZXguanMiLCIvVXNlcnMvdmljdDB4ci9Eb2N1bWVudHMvU2VuZC9zZW5kYXBwL3BhY2thZ2VzL3NyYy9hY2Nlc3NEZWVwLnRzIiwiL1VzZXJzL3ZpY3QweHIvRG9jdW1lbnRzL1NlbmQvc2VuZGFwcC9wYWNrYWdlcy9zcmMvY2xhc3MtcmVnaXN0cnkudHMiLCIvVXNlcnMvdmljdDB4ci9Eb2N1bWVudHMvU2VuZC9zZW5kYXBwL3BhY2thZ2VzL3NyYy9jdXN0b20tdHJhbnNmb3JtZXItcmVnaXN0cnkudHMiLCIvVXNlcnMvdmljdDB4ci9Eb2N1bWVudHMvU2VuZC9zZW5kYXBwL3BhY2thZ2VzL3NyYy9kb3VibGUtaW5kZXhlZC1rdi50cyIsIi9Vc2Vycy92aWN0MHhyL0RvY3VtZW50cy9TZW5kL3NlbmRhcHAvcGFja2FnZXMvc3JjL2luZGV4LnRzIiwiL1VzZXJzL3ZpY3QweHIvRG9jdW1lbnRzL1NlbmQvc2VuZGFwcC9wYWNrYWdlcy9zcmMvaXMudHMiLCIvVXNlcnMvdmljdDB4ci9Eb2N1bWVudHMvU2VuZC9zZW5kYXBwL3BhY2thZ2VzL3NyYy9wYXRoc3RyaW5naWZpZXIudHMiLCIvVXNlcnMvdmljdDB4ci9Eb2N1bWVudHMvU2VuZC9zZW5kYXBwL3BhY2thZ2VzL3NyYy9wbGFpbmVyLnRzIiwiL1VzZXJzL3ZpY3QweHIvRG9jdW1lbnRzL1NlbmQvc2VuZGFwcC9wYWNrYWdlcy9zcmMvcmVnaXN0cnkudHMiLCIvVXNlcnMvdmljdDB4ci9Eb2N1bWVudHMvU2VuZC9zZW5kYXBwL3BhY2thZ2VzL3NyYy90cmFuc2Zvcm1lci50cyIsIi9Vc2Vycy92aWN0MHhyL0RvY3VtZW50cy9TZW5kL3NlbmRhcHAvcGFja2FnZXMvc3JjL3V0aWwudHMiLCIvVXNlcnMvdmljdDB4ci9Eb2N1bWVudHMvU2VuZC9zZW5kYXBwL25vZGVfbW9kdWxlcy92aWVtL3V0aWxzL2RhdGEvaXNIZXgudHMiLCJ3ZWJwYWNrL2Jvb3RzdHJhcCIsIndlYnBhY2svcnVudGltZS9jb21wYXQgZ2V0IGRlZmF1bHQgZXhwb3J0Iiwid2VicGFjay9ydW50aW1lL2RlZmluZSBwcm9wZXJ0eSBnZXR0ZXJzIiwid2VicGFjay9ydW50aW1lL2hhc093blByb3BlcnR5IHNob3J0aGFuZCIsIndlYnBhY2svcnVudGltZS9tYWtlIG5hbWVzcGFjZSBvYmplY3QiLCIvVXNlcnMvdmljdDB4ci9Eb2N1bWVudHMvU2VuZC9zZW5kYXBwL3BhY2thZ2VzL3dvcmtmbG93cy9zcmMvYWxsLXdvcmtmbG93cy1hdXRvZ2VuZXJhdGVkLWVudHJ5cG9pbnQuY2pzIl0sInNvdXJjZXNDb250ZW50IjpbImltcG9ydCB0eXBlIHsgY29yZXNkayB9IGZyb20gJ0B0ZW1wb3JhbGlvL3Byb3RvJztcbmltcG9ydCB7IFJldHJ5UG9saWN5IH0gZnJvbSAnLi9yZXRyeS1wb2xpY3knO1xuaW1wb3J0IHsgRHVyYXRpb24gfSBmcm9tICcuL3RpbWUnO1xuaW1wb3J0IHsgVmVyc2lvbmluZ0ludGVudCB9IGZyb20gJy4vdmVyc2lvbmluZy1pbnRlbnQnO1xuaW1wb3J0IHsgbWFrZVByb3RvRW51bUNvbnZlcnRlcnMgfSBmcm9tICcuL2ludGVybmFsLXdvcmtmbG93JztcblxuZXhwb3J0IGNvbnN0IEFjdGl2aXR5Q2FuY2VsbGF0aW9uVHlwZSA9IHtcbiAgVFJZX0NBTkNFTDogJ1RSWV9DQU5DRUwnLFxuICBXQUlUX0NBTkNFTExBVElPTl9DT01QTEVURUQ6ICdXQUlUX0NBTkNFTExBVElPTl9DT01QTEVURUQnLFxuICBBQkFORE9OOiAnQUJBTkRPTicsXG59IGFzIGNvbnN0O1xuZXhwb3J0IHR5cGUgQWN0aXZpdHlDYW5jZWxsYXRpb25UeXBlID0gKHR5cGVvZiBBY3Rpdml0eUNhbmNlbGxhdGlvblR5cGUpW2tleW9mIHR5cGVvZiBBY3Rpdml0eUNhbmNlbGxhdGlvblR5cGVdO1xuXG5leHBvcnQgY29uc3QgW2VuY29kZUFjdGl2aXR5Q2FuY2VsbGF0aW9uVHlwZSwgZGVjb2RlQWN0aXZpdHlDYW5jZWxsYXRpb25UeXBlXSA9IG1ha2VQcm90b0VudW1Db252ZXJ0ZXJzPFxuICBjb3Jlc2RrLndvcmtmbG93X2NvbW1hbmRzLkFjdGl2aXR5Q2FuY2VsbGF0aW9uVHlwZSxcbiAgdHlwZW9mIGNvcmVzZGsud29ya2Zsb3dfY29tbWFuZHMuQWN0aXZpdHlDYW5jZWxsYXRpb25UeXBlLFxuICBrZXlvZiB0eXBlb2YgY29yZXNkay53b3JrZmxvd19jb21tYW5kcy5BY3Rpdml0eUNhbmNlbGxhdGlvblR5cGUsXG4gIHR5cGVvZiBBY3Rpdml0eUNhbmNlbGxhdGlvblR5cGUsXG4gICcnXG4+KFxuICB7XG4gICAgW0FjdGl2aXR5Q2FuY2VsbGF0aW9uVHlwZS5UUllfQ0FOQ0VMXTogMCxcbiAgICBbQWN0aXZpdHlDYW5jZWxsYXRpb25UeXBlLldBSVRfQ0FOQ0VMTEFUSU9OX0NPTVBMRVRFRF06IDEsXG4gICAgW0FjdGl2aXR5Q2FuY2VsbGF0aW9uVHlwZS5BQkFORE9OXTogMixcbiAgfSBhcyBjb25zdCxcbiAgJydcbik7XG5cbi8qKlxuICogT3B0aW9ucyBmb3IgcmVtb3RlIGFjdGl2aXR5IGludm9jYXRpb25cbiAqL1xuZXhwb3J0IGludGVyZmFjZSBBY3Rpdml0eU9wdGlvbnMge1xuICAvKipcbiAgICogSWRlbnRpZmllciB0byB1c2UgZm9yIHRyYWNraW5nIHRoZSBhY3Rpdml0eSBpbiBXb3JrZmxvdyBoaXN0b3J5LlxuICAgKiBUaGUgYGFjdGl2aXR5SWRgIGNhbiBiZSBhY2Nlc3NlZCBieSB0aGUgYWN0aXZpdHkgZnVuY3Rpb24uXG4gICAqIERvZXMgbm90IG5lZWQgdG8gYmUgdW5pcXVlLlxuICAgKlxuICAgKiBAZGVmYXVsdCBhbiBpbmNyZW1lbnRhbCBzZXF1ZW5jZSBudW1iZXJcbiAgICovXG4gIGFjdGl2aXR5SWQ/OiBzdHJpbmc7XG5cbiAgLyoqXG4gICAqIFRhc2sgcXVldWUgbmFtZS5cbiAgICpcbiAgICogQGRlZmF1bHQgY3VycmVudCB3b3JrZXIgdGFzayBxdWV1ZVxuICAgKi9cbiAgdGFza1F1ZXVlPzogc3RyaW5nO1xuXG4gIC8qKlxuICAgKiBIZWFydGJlYXQgaW50ZXJ2YWwuIEFjdGl2aXR5IG11c3QgaGVhcnRiZWF0IGJlZm9yZSB0aGlzIGludGVydmFsIHBhc3NlcyBhZnRlciBhIGxhc3QgaGVhcnRiZWF0IG9yIGFjdGl2aXR5IHN0YXJ0LlxuICAgKiBAZm9ybWF0IG51bWJlciBvZiBtaWxsaXNlY29uZHMgb3Ige0BsaW5rIGh0dHBzOi8vd3d3Lm5wbWpzLmNvbS9wYWNrYWdlL21zIHwgbXMtZm9ybWF0dGVkIHN0cmluZ31cbiAgICovXG4gIGhlYXJ0YmVhdFRpbWVvdXQ/OiBEdXJhdGlvbjtcblxuICAvKipcbiAgICogUmV0cnlQb2xpY3kgdGhhdCBkZWZpbmUgaG93IGFjdGl2aXR5IGlzIHJldHJpZWQgaW4gY2FzZSBvZiBmYWlsdXJlLiBJZiB0aGlzIGlzIG5vdCBzZXQsIHRoZW4gdGhlIHNlcnZlci1kZWZpbmVkIGRlZmF1bHQgYWN0aXZpdHkgcmV0cnkgcG9saWN5IHdpbGwgYmUgdXNlZC4gVG8gZW5zdXJlIHplcm8gcmV0cmllcywgc2V0IG1heGltdW0gYXR0ZW1wdHMgdG8gMS5cbiAgICovXG4gIHJldHJ5PzogUmV0cnlQb2xpY3k7XG5cbiAgLyoqXG4gICAqIE1heGltdW0gdGltZSBvZiBhIHNpbmdsZSBBY3Rpdml0eSBleGVjdXRpb24gYXR0ZW1wdC4gTm90ZSB0aGF0IHRoZSBUZW1wb3JhbCBTZXJ2ZXIgZG9lc24ndCBkZXRlY3QgV29ya2VyIHByb2Nlc3NcbiAgICogZmFpbHVyZXMgZGlyZWN0bHk6IGluc3RlYWQsIGl0IHJlbGllcyBvbiB0aGlzIHRpbWVvdXQgdG8gZGV0ZWN0IHRoYXQgYW4gQWN0aXZpdHkgZGlkbid0IGNvbXBsZXRlIG9uIHRpbWUuIFRoZXJlZm9yZSwgdGhpc1xuICAgKiB0aW1lb3V0IHNob3VsZCBiZSBhcyBzaG9ydCBhcyB0aGUgbG9uZ2VzdCBwb3NzaWJsZSBleGVjdXRpb24gb2YgdGhlIEFjdGl2aXR5IGJvZHkuIFBvdGVudGlhbGx5IGxvbmctcnVubmluZ1xuICAgKiBBY3Rpdml0aWVzIG11c3Qgc3BlY2lmeSB7QGxpbmsgaGVhcnRiZWF0VGltZW91dH0gYW5kIGNhbGwge0BsaW5rIGFjdGl2aXR5LkNvbnRleHQuaGVhcnRiZWF0fSBwZXJpb2RpY2FsbHkgZm9yXG4gICAqIHRpbWVseSBmYWlsdXJlIGRldGVjdGlvbi5cbiAgICpcbiAgICogRWl0aGVyIHRoaXMgb3B0aW9uIG9yIHtAbGluayBzY2hlZHVsZVRvQ2xvc2VUaW1lb3V0fSBpcyByZXF1aXJlZC5cbiAgICpcbiAgICogQGRlZmF1bHQgYHNjaGVkdWxlVG9DbG9zZVRpbWVvdXRgIG9yIHVubGltaXRlZFxuICAgKiBAZm9ybWF0IG51bWJlciBvZiBtaWxsaXNlY29uZHMgb3Ige0BsaW5rIGh0dHBzOi8vd3d3Lm5wbWpzLmNvbS9wYWNrYWdlL21zIHwgbXMtZm9ybWF0dGVkIHN0cmluZ31cbiAgICovXG4gIHN0YXJ0VG9DbG9zZVRpbWVvdXQ/OiBEdXJhdGlvbjtcblxuICAvKipcbiAgICogVGltZSB0aGF0IHRoZSBBY3Rpdml0eSBUYXNrIGNhbiBzdGF5IGluIHRoZSBUYXNrIFF1ZXVlIGJlZm9yZSBpdCBpcyBwaWNrZWQgdXAgYnkgYSBXb3JrZXIuIERvIG5vdCBzcGVjaWZ5IHRoaXMgdGltZW91dCB1bmxlc3MgdXNpbmcgaG9zdC1zcGVjaWZpYyBUYXNrIFF1ZXVlcyBmb3IgQWN0aXZpdHkgVGFza3MgYXJlIGJlaW5nIHVzZWQgZm9yIHJvdXRpbmcuXG4gICAqIGBzY2hlZHVsZVRvU3RhcnRUaW1lb3V0YCBpcyBhbHdheXMgbm9uLXJldHJ5YWJsZS4gUmV0cnlpbmcgYWZ0ZXIgdGhpcyB0aW1lb3V0IGRvZXNuJ3QgbWFrZSBzZW5zZSBhcyBpdCB3b3VsZCBqdXN0IHB1dCB0aGUgQWN0aXZpdHkgVGFzayBiYWNrIGludG8gdGhlIHNhbWUgVGFzayBRdWV1ZS5cbiAgICpcbiAgICogQGRlZmF1bHQgYHNjaGVkdWxlVG9DbG9zZVRpbWVvdXRgIG9yIHVubGltaXRlZFxuICAgKiBAZm9ybWF0IG51bWJlciBvZiBtaWxsaXNlY29uZHMgb3Ige0BsaW5rIGh0dHBzOi8vd3d3Lm5wbWpzLmNvbS9wYWNrYWdlL21zIHwgbXMtZm9ybWF0dGVkIHN0cmluZ31cbiAgICovXG4gIHNjaGVkdWxlVG9TdGFydFRpbWVvdXQ/OiBEdXJhdGlvbjtcblxuICAvKipcbiAgICogVG90YWwgdGltZSB0aGF0IGEgd29ya2Zsb3cgaXMgd2lsbGluZyB0byB3YWl0IGZvciB0aGUgQWN0aXZpdHkgdG8gY29tcGxldGUuXG4gICAqIGBzY2hlZHVsZVRvQ2xvc2VUaW1lb3V0YCBsaW1pdHMgdGhlIHRvdGFsIHRpbWUgb2YgYW4gQWN0aXZpdHkncyBleGVjdXRpb24gaW5jbHVkaW5nIHJldHJpZXMgKHVzZSB7QGxpbmsgc3RhcnRUb0Nsb3NlVGltZW91dH0gdG8gbGltaXQgdGhlIHRpbWUgb2YgYSBzaW5nbGUgYXR0ZW1wdCkuXG4gICAqXG4gICAqIEVpdGhlciB0aGlzIG9wdGlvbiBvciB7QGxpbmsgc3RhcnRUb0Nsb3NlVGltZW91dH0gaXMgcmVxdWlyZWQuXG4gICAqXG4gICAqIEBkZWZhdWx0IHVubGltaXRlZFxuICAgKiBAZm9ybWF0IG51bWJlciBvZiBtaWxsaXNlY29uZHMgb3Ige0BsaW5rIGh0dHBzOi8vd3d3Lm5wbWpzLmNvbS9wYWNrYWdlL21zIHwgbXMtZm9ybWF0dGVkIHN0cmluZ31cbiAgICovXG4gIHNjaGVkdWxlVG9DbG9zZVRpbWVvdXQ/OiBEdXJhdGlvbjtcblxuICAvKipcbiAgICogRGV0ZXJtaW5lcyB3aGF0IHRoZSBTREsgZG9lcyB3aGVuIHRoZSBBY3Rpdml0eSBpcyBjYW5jZWxsZWQuXG4gICAqIC0gYFRSWV9DQU5DRUxgIC0gSW5pdGlhdGUgYSBjYW5jZWxsYXRpb24gcmVxdWVzdCBhbmQgaW1tZWRpYXRlbHkgcmVwb3J0IGNhbmNlbGxhdGlvbiB0byB0aGUgd29ya2Zsb3cuXG4gICAqIC0gYFdBSVRfQ0FOQ0VMTEFUSU9OX0NPTVBMRVRFRGAgLSBXYWl0IGZvciBhY3Rpdml0eSBjYW5jZWxsYXRpb24gY29tcGxldGlvbi4gTm90ZSB0aGF0IGFjdGl2aXR5IG11c3QgaGVhcnRiZWF0IHRvIHJlY2VpdmUgYVxuICAgKiAgIGNhbmNlbGxhdGlvbiBub3RpZmljYXRpb24uIFRoaXMgY2FuIGJsb2NrIHRoZSBjYW5jZWxsYXRpb24gZm9yIGEgbG9uZyB0aW1lIGlmIGFjdGl2aXR5IGRvZXNuJ3RcbiAgICogICBoZWFydGJlYXQgb3IgY2hvb3NlcyB0byBpZ25vcmUgdGhlIGNhbmNlbGxhdGlvbiByZXF1ZXN0LlxuICAgKiAtIGBBQkFORE9OYCAtIERvIG5vdCByZXF1ZXN0IGNhbmNlbGxhdGlvbiBvZiB0aGUgYWN0aXZpdHkgYW5kIGltbWVkaWF0ZWx5IHJlcG9ydCBjYW5jZWxsYXRpb24gdG8gdGhlIHdvcmtmbG93LlxuICAgKi9cbiAgY2FuY2VsbGF0aW9uVHlwZT86IEFjdGl2aXR5Q2FuY2VsbGF0aW9uVHlwZTtcblxuICAvKipcbiAgICogRWFnZXIgZGlzcGF0Y2ggaXMgYW4gb3B0aW1pemF0aW9uIHRoYXQgaW1wcm92ZXMgdGhlIHRocm91Z2hwdXQgYW5kIGxvYWQgb24gdGhlIHNlcnZlciBmb3Igc2NoZWR1bGluZyBBY3Rpdml0aWVzLlxuICAgKiBXaGVuIHVzZWQsIHRoZSBzZXJ2ZXIgd2lsbCBoYW5kIG91dCBBY3Rpdml0eSB0YXNrcyBiYWNrIHRvIHRoZSBXb3JrZXIgd2hlbiBpdCBjb21wbGV0ZXMgYSBXb3JrZmxvdyB0YXNrLlxuICAgKiBJdCBpcyBhdmFpbGFibGUgZnJvbSBzZXJ2ZXIgdmVyc2lvbiAxLjE3IGJlaGluZCB0aGUgYHN5c3RlbS5lbmFibGVBY3Rpdml0eUVhZ2VyRXhlY3V0aW9uYCBmZWF0dXJlIGZsYWcuXG4gICAqXG4gICAqIEVhZ2VyIGRpc3BhdGNoIHdpbGwgb25seSBiZSB1c2VkIGlmIGBhbGxvd0VhZ2VyRGlzcGF0Y2hgIGlzIGVuYWJsZWQgKHRoZSBkZWZhdWx0KSBhbmQge0BsaW5rIHRhc2tRdWV1ZX0gaXMgZWl0aGVyXG4gICAqIG9taXR0ZWQgb3IgdGhlIHNhbWUgYXMgdGhlIGN1cnJlbnQgV29ya2Zsb3cuXG4gICAqXG4gICAqIEBkZWZhdWx0IHRydWVcbiAgICovXG4gIGFsbG93RWFnZXJEaXNwYXRjaD86IGJvb2xlYW47XG5cbiAgLyoqXG4gICAqIFdoZW4gdXNpbmcgdGhlIFdvcmtlciBWZXJzaW9uaW5nIGZlYXR1cmUsIHNwZWNpZmllcyB3aGV0aGVyIHRoaXMgQWN0aXZpdHkgc2hvdWxkIHJ1biBvbiBhXG4gICAqIHdvcmtlciB3aXRoIGEgY29tcGF0aWJsZSBCdWlsZCBJZCBvciBub3QuIFNlZSB7QGxpbmsgVmVyc2lvbmluZ0ludGVudH0uXG4gICAqXG4gICAqIEBkZWZhdWx0ICdDT01QQVRJQkxFJ1xuICAgKlxuICAgKiBAZXhwZXJpbWVudGFsXG4gICAqL1xuICB2ZXJzaW9uaW5nSW50ZW50PzogVmVyc2lvbmluZ0ludGVudDtcbn1cblxuLyoqXG4gKiBPcHRpb25zIGZvciBsb2NhbCBhY3Rpdml0eSBpbnZvY2F0aW9uXG4gKi9cbmV4cG9ydCBpbnRlcmZhY2UgTG9jYWxBY3Rpdml0eU9wdGlvbnMge1xuICAvKipcbiAgICogUmV0cnlQb2xpY3kgdGhhdCBkZWZpbmVzIGhvdyBhbiBhY3Rpdml0eSBpcyByZXRyaWVkIGluIGNhc2Ugb2YgZmFpbHVyZS4gSWYgdGhpcyBpcyBub3Qgc2V0LCB0aGVuIHRoZSBTREstZGVmaW5lZCBkZWZhdWx0IGFjdGl2aXR5IHJldHJ5IHBvbGljeSB3aWxsIGJlIHVzZWQuXG4gICAqIE5vdGUgdGhhdCBsb2NhbCBhY3Rpdml0aWVzIGFyZSBhbHdheXMgZXhlY3V0ZWQgYXQgbGVhc3Qgb25jZSwgZXZlbiBpZiBtYXhpbXVtIGF0dGVtcHRzIGlzIHNldCB0byAxIGR1ZSB0byBXb3JrZmxvdyB0YXNrIHJldHJpZXMuXG4gICAqL1xuICByZXRyeT86IFJldHJ5UG9saWN5O1xuXG4gIC8qKlxuICAgKiBNYXhpbXVtIHRpbWUgdGhlIGxvY2FsIGFjdGl2aXR5IGlzIGFsbG93ZWQgdG8gZXhlY3V0ZSBhZnRlciB0aGUgdGFzayBpcyBkaXNwYXRjaGVkLiBUaGlzXG4gICAqIHRpbWVvdXQgaXMgYWx3YXlzIHJldHJ5YWJsZS5cbiAgICpcbiAgICogRWl0aGVyIHRoaXMgb3B0aW9uIG9yIHtAbGluayBzY2hlZHVsZVRvQ2xvc2VUaW1lb3V0fSBpcyByZXF1aXJlZC5cbiAgICogSWYgc2V0LCB0aGlzIG11c3QgYmUgPD0ge0BsaW5rIHNjaGVkdWxlVG9DbG9zZVRpbWVvdXR9LCBvdGhlcndpc2UsIGl0IHdpbGwgYmUgY2xhbXBlZCBkb3duLlxuICAgKlxuICAgKiBAZm9ybWF0IG51bWJlciBvZiBtaWxsaXNlY29uZHMgb3Ige0BsaW5rIGh0dHBzOi8vd3d3Lm5wbWpzLmNvbS9wYWNrYWdlL21zIHwgbXMtZm9ybWF0dGVkIHN0cmluZ31cbiAgICovXG4gIHN0YXJ0VG9DbG9zZVRpbWVvdXQ/OiBEdXJhdGlvbjtcblxuICAvKipcbiAgICogTGltaXRzIHRpbWUgdGhlIGxvY2FsIGFjdGl2aXR5IGNhbiBpZGxlIGludGVybmFsbHkgYmVmb3JlIGJlaW5nIGV4ZWN1dGVkLiBUaGF0IGNhbiBoYXBwZW4gaWZcbiAgICogdGhlIHdvcmtlciBpcyBjdXJyZW50bHkgYXQgbWF4IGNvbmN1cnJlbnQgbG9jYWwgYWN0aXZpdHkgZXhlY3V0aW9ucy4gVGhpcyB0aW1lb3V0IGlzIGFsd2F5c1xuICAgKiBub24gcmV0cnlhYmxlIGFzIGFsbCBhIHJldHJ5IHdvdWxkIGFjaGlldmUgaXMgdG8gcHV0IGl0IGJhY2sgaW50byB0aGUgc2FtZSBxdWV1ZS4gRGVmYXVsdHNcbiAgICogdG8ge0BsaW5rIHNjaGVkdWxlVG9DbG9zZVRpbWVvdXR9IGlmIG5vdCBzcGVjaWZpZWQgYW5kIHRoYXQgaXMgc2V0LiBNdXN0IGJlIDw9XG4gICAqIHtAbGluayBzY2hlZHVsZVRvQ2xvc2VUaW1lb3V0fSB3aGVuIHNldCwgb3RoZXJ3aXNlLCBpdCB3aWxsIGJlIGNsYW1wZWQgZG93bi5cbiAgICpcbiAgICogQGRlZmF1bHQgdW5saW1pdGVkXG4gICAqIEBmb3JtYXQgbnVtYmVyIG9mIG1pbGxpc2Vjb25kcyBvciB7QGxpbmsgaHR0cHM6Ly93d3cubnBtanMuY29tL3BhY2thZ2UvbXMgfCBtcy1mb3JtYXR0ZWQgc3RyaW5nfVxuICAgKi9cbiAgc2NoZWR1bGVUb1N0YXJ0VGltZW91dD86IER1cmF0aW9uO1xuXG4gIC8qKlxuICAgKiBJbmRpY2F0ZXMgaG93IGxvbmcgdGhlIGNhbGxlciBpcyB3aWxsaW5nIHRvIHdhaXQgZm9yIGxvY2FsIGFjdGl2aXR5IGNvbXBsZXRpb24uIExpbWl0cyBob3dcbiAgICogbG9uZyByZXRyaWVzIHdpbGwgYmUgYXR0ZW1wdGVkLlxuICAgKlxuICAgKiBFaXRoZXIgdGhpcyBvcHRpb24gb3Ige0BsaW5rIHN0YXJ0VG9DbG9zZVRpbWVvdXR9IGlzIHJlcXVpcmVkLlxuICAgKlxuICAgKiBAZGVmYXVsdCB1bmxpbWl0ZWRcbiAgICogQGZvcm1hdCBudW1iZXIgb2YgbWlsbGlzZWNvbmRzIG9yIHtAbGluayBodHRwczovL3d3dy5ucG1qcy5jb20vcGFja2FnZS9tcyB8IG1zLWZvcm1hdHRlZCBzdHJpbmd9XG4gICAqL1xuICBzY2hlZHVsZVRvQ2xvc2VUaW1lb3V0PzogRHVyYXRpb247XG5cbiAgLyoqXG4gICAqIElmIHRoZSBhY3Rpdml0eSBpcyByZXRyeWluZyBhbmQgYmFja29mZiB3b3VsZCBleGNlZWQgdGhpcyB2YWx1ZSwgYSBzZXJ2ZXIgc2lkZSB0aW1lciB3aWxsIGJlIHNjaGVkdWxlZCBmb3IgdGhlIG5leHQgYXR0ZW1wdC5cbiAgICogT3RoZXJ3aXNlLCBiYWNrb2ZmIHdpbGwgaGFwcGVuIGludGVybmFsbHkgaW4gdGhlIFNESy5cbiAgICpcbiAgICogQGRlZmF1bHQgMSBtaW51dGVcbiAgICogQGZvcm1hdCBudW1iZXIgb2YgbWlsbGlzZWNvbmRzIG9yIHtAbGluayBodHRwczovL3d3dy5ucG1qcy5jb20vcGFja2FnZS9tcyB8IG1zLWZvcm1hdHRlZCBzdHJpbmd9XG4gICAqKi9cbiAgbG9jYWxSZXRyeVRocmVzaG9sZD86IER1cmF0aW9uO1xuXG4gIC8qKlxuICAgKiBEZXRlcm1pbmVzIHdoYXQgdGhlIFNESyBkb2VzIHdoZW4gdGhlIEFjdGl2aXR5IGlzIGNhbmNlbGxlZC5cbiAgICogLSBgVFJZX0NBTkNFTGAgLSBJbml0aWF0ZSBhIGNhbmNlbGxhdGlvbiByZXF1ZXN0IGFuZCBpbW1lZGlhdGVseSByZXBvcnQgY2FuY2VsbGF0aW9uIHRvIHRoZSB3b3JrZmxvdy5cbiAgICogLSBgV0FJVF9DQU5DRUxMQVRJT05fQ09NUExFVEVEYCAtIFdhaXQgZm9yIGFjdGl2aXR5IGNhbmNlbGxhdGlvbiBjb21wbGV0aW9uLiBOb3RlIHRoYXQgYWN0aXZpdHkgbXVzdCBoZWFydGJlYXQgdG8gcmVjZWl2ZSBhXG4gICAqICAgY2FuY2VsbGF0aW9uIG5vdGlmaWNhdGlvbi4gVGhpcyBjYW4gYmxvY2sgdGhlIGNhbmNlbGxhdGlvbiBmb3IgYSBsb25nIHRpbWUgaWYgYWN0aXZpdHkgZG9lc24ndFxuICAgKiAgIGhlYXJ0YmVhdCBvciBjaG9vc2VzIHRvIGlnbm9yZSB0aGUgY2FuY2VsbGF0aW9uIHJlcXVlc3QuXG4gICAqIC0gYEFCQU5ET05gIC0gRG8gbm90IHJlcXVlc3QgY2FuY2VsbGF0aW9uIG9mIHRoZSBhY3Rpdml0eSBhbmQgaW1tZWRpYXRlbHkgcmVwb3J0IGNhbmNlbGxhdGlvbiB0byB0aGUgd29ya2Zsb3cuXG4gICAqL1xuICBjYW5jZWxsYXRpb25UeXBlPzogQWN0aXZpdHlDYW5jZWxsYXRpb25UeXBlO1xufVxuIiwiaW1wb3J0IHsgRGVmYXVsdEZhaWx1cmVDb252ZXJ0ZXIsIEZhaWx1cmVDb252ZXJ0ZXIgfSBmcm9tICcuL2ZhaWx1cmUtY29udmVydGVyJztcbmltcG9ydCB7IFBheWxvYWRDb2RlYyB9IGZyb20gJy4vcGF5bG9hZC1jb2RlYyc7XG5pbXBvcnQgeyBkZWZhdWx0UGF5bG9hZENvbnZlcnRlciwgUGF5bG9hZENvbnZlcnRlciB9IGZyb20gJy4vcGF5bG9hZC1jb252ZXJ0ZXInO1xuXG4vKipcbiAqIFdoZW4geW91ciBkYXRhIChhcmd1bWVudHMgYW5kIHJldHVybiB2YWx1ZXMpIGlzIHNlbnQgb3ZlciB0aGUgd2lyZSBhbmQgc3RvcmVkIGJ5IFRlbXBvcmFsIFNlcnZlciwgaXQgaXMgZW5jb2RlZCBpblxuICogYmluYXJ5IGluIGEge0BsaW5rIFBheWxvYWR9IFByb3RvYnVmIG1lc3NhZ2UuXG4gKlxuICogVGhlIGRlZmF1bHQgYERhdGFDb252ZXJ0ZXJgIHN1cHBvcnRzIGB1bmRlZmluZWRgLCBgVWludDhBcnJheWAsIGFuZCBKU09OIHNlcmlhbGl6YWJsZXMgKHNvIGlmXG4gKiB7QGxpbmsgaHR0cHM6Ly9kZXZlbG9wZXIubW96aWxsYS5vcmcvZW4tVVMvZG9jcy9XZWIvSmF2YVNjcmlwdC9SZWZlcmVuY2UvR2xvYmFsX09iamVjdHMvSlNPTi9zdHJpbmdpZnkjZGVzY3JpcHRpb24gfCBgSlNPTi5zdHJpbmdpZnkoeW91ckFyZ09yUmV0dmFsKWB9XG4gKiB3b3JrcywgdGhlIGRlZmF1bHQgZGF0YSBjb252ZXJ0ZXIgd2lsbCB3b3JrKS4gUHJvdG9idWZzIGFyZSBzdXBwb3J0ZWQgdmlhXG4gKiB7QGxpbmsgaHR0cHM6Ly9kb2NzLnRlbXBvcmFsLmlvL3R5cGVzY3JpcHQvZGF0YS1jb252ZXJ0ZXJzI3Byb3RvYnVmcyB8IHRoaXMgQVBJfS5cbiAqXG4gKiBVc2UgYSBjdXN0b20gYERhdGFDb252ZXJ0ZXJgIHRvIGNvbnRyb2wgdGhlIGNvbnRlbnRzIG9mIHlvdXIge0BsaW5rIFBheWxvYWR9cy4gQ29tbW9uIHJlYXNvbnMgZm9yIHVzaW5nIGEgY3VzdG9tXG4gKiBgRGF0YUNvbnZlcnRlcmAgYXJlOlxuICogLSBDb252ZXJ0aW5nIHZhbHVlcyB0aGF0IGFyZSBub3Qgc3VwcG9ydGVkIGJ5IHRoZSBkZWZhdWx0IGBEYXRhQ29udmVydGVyYCAoZm9yIGV4YW1wbGUsIGBKU09OLnN0cmluZ2lmeSgpYCBkb2Vzbid0XG4gKiAgIGhhbmRsZSBgQmlnSW50YHMsIHNvIGlmIHlvdSB3YW50IHRvIHJldHVybiBgeyB0b3RhbDogMTAwMG4gfWAgZnJvbSBhIFdvcmtmbG93LCBTaWduYWwsIG9yIEFjdGl2aXR5LCB5b3UgbmVlZCB5b3VyXG4gKiAgIG93biBgRGF0YUNvbnZlcnRlcmApLlxuICogLSBFbmNyeXB0aW5nIHZhbHVlcyB0aGF0IG1heSBjb250YWluIHByaXZhdGUgaW5mb3JtYXRpb24gdGhhdCB5b3UgZG9uJ3Qgd2FudCBzdG9yZWQgaW4gcGxhaW50ZXh0IGluIFRlbXBvcmFsIFNlcnZlcidzXG4gKiAgIGRhdGFiYXNlLlxuICogLSBDb21wcmVzc2luZyB2YWx1ZXMgdG8gcmVkdWNlIGRpc2sgb3IgbmV0d29yayB1c2FnZS5cbiAqXG4gKiBUbyB1c2UgeW91ciBjdXN0b20gYERhdGFDb252ZXJ0ZXJgLCBwcm92aWRlIGl0IHRvIHRoZSB7QGxpbmsgV29ya2Zsb3dDbGllbnR9LCB7QGxpbmsgV29ya2VyfSwgYW5kXG4gKiB7QGxpbmsgYnVuZGxlV29ya2Zsb3dDb2RlfSAoaWYgeW91IHVzZSBpdCk6XG4gKiAtIGBuZXcgV29ya2Zsb3dDbGllbnQoeyAuLi4sIGRhdGFDb252ZXJ0ZXIgfSlgXG4gKiAtIGBXb3JrZXIuY3JlYXRlKHsgLi4uLCBkYXRhQ29udmVydGVyIH0pYFxuICogLSBgYnVuZGxlV29ya2Zsb3dDb2RlKHsgLi4uLCBwYXlsb2FkQ29udmVydGVyUGF0aCB9KWBcbiAqL1xuZXhwb3J0IGludGVyZmFjZSBEYXRhQ29udmVydGVyIHtcbiAgLyoqXG4gICAqIFBhdGggb2YgYSBmaWxlIHRoYXQgaGFzIGEgYHBheWxvYWRDb252ZXJ0ZXJgIG5hbWVkIGV4cG9ydC5cbiAgICogYHBheWxvYWRDb252ZXJ0ZXJgIHNob3VsZCBiZSBhbiBvYmplY3QgdGhhdCBpbXBsZW1lbnRzIHtAbGluayBQYXlsb2FkQ29udmVydGVyfS5cbiAgICogSWYgbm8gcGF0aCBpcyBwcm92aWRlZCwge0BsaW5rIGRlZmF1bHRQYXlsb2FkQ29udmVydGVyfSBpcyB1c2VkLlxuICAgKi9cbiAgcGF5bG9hZENvbnZlcnRlclBhdGg/OiBzdHJpbmc7XG5cbiAgLyoqXG4gICAqIFBhdGggb2YgYSBmaWxlIHRoYXQgaGFzIGEgYGZhaWx1cmVDb252ZXJ0ZXJgIG5hbWVkIGV4cG9ydC5cbiAgICogYGZhaWx1cmVDb252ZXJ0ZXJgIHNob3VsZCBiZSBhbiBvYmplY3QgdGhhdCBpbXBsZW1lbnRzIHtAbGluayBGYWlsdXJlQ29udmVydGVyfS5cbiAgICogSWYgbm8gcGF0aCBpcyBwcm92aWRlZCwge0BsaW5rIGRlZmF1bHRGYWlsdXJlQ29udmVydGVyfSBpcyB1c2VkLlxuICAgKi9cbiAgZmFpbHVyZUNvbnZlcnRlclBhdGg/OiBzdHJpbmc7XG5cbiAgLyoqXG4gICAqIEFuIGFycmF5IG9mIHtAbGluayBQYXlsb2FkQ29kZWN9IGluc3RhbmNlcy5cbiAgICpcbiAgICogUGF5bG9hZHMgYXJlIGVuY29kZWQgaW4gdGhlIG9yZGVyIG9mIHRoZSBhcnJheSBhbmQgZGVjb2RlZCBpbiB0aGUgb3Bwb3NpdGUgb3JkZXIuIEZvciBleGFtcGxlLCBpZiB5b3UgaGF2ZSBhXG4gICAqIGNvbXByZXNzaW9uIGNvZGVjIGFuZCBhbiBlbmNyeXB0aW9uIGNvZGVjLCB0aGVuIHlvdSB3YW50IGRhdGEgdG8gYmUgZW5jb2RlZCB3aXRoIHRoZSBjb21wcmVzc2lvbiBjb2RlYyBmaXJzdCwgc29cbiAgICogeW91J2QgZG8gYHBheWxvYWRDb2RlY3M6IFtjb21wcmVzc2lvbkNvZGVjLCBlbmNyeXB0aW9uQ29kZWNdYC5cbiAgICovXG4gIHBheWxvYWRDb2RlY3M/OiBQYXlsb2FkQ29kZWNbXTtcbn1cblxuLyoqXG4gKiBBIHtAbGluayBEYXRhQ29udmVydGVyfSB0aGF0IGhhcyBiZWVuIGxvYWRlZCB2aWEge0BsaW5rIGxvYWREYXRhQ29udmVydGVyfS5cbiAqL1xuZXhwb3J0IGludGVyZmFjZSBMb2FkZWREYXRhQ29udmVydGVyIHtcbiAgcGF5bG9hZENvbnZlcnRlcjogUGF5bG9hZENvbnZlcnRlcjtcbiAgZmFpbHVyZUNvbnZlcnRlcjogRmFpbHVyZUNvbnZlcnRlcjtcbiAgcGF5bG9hZENvZGVjczogUGF5bG9hZENvZGVjW107XG59XG5cbi8qKlxuICogVGhlIGRlZmF1bHQge0BsaW5rIEZhaWx1cmVDb252ZXJ0ZXJ9IHVzZWQgYnkgdGhlIFNESy5cbiAqXG4gKiBFcnJvciBtZXNzYWdlcyBhbmQgc3RhY2sgdHJhY2VzIGFyZSBzZXJpemFsaXplZCBhcyBwbGFpbiB0ZXh0LlxuICovXG5leHBvcnQgY29uc3QgZGVmYXVsdEZhaWx1cmVDb252ZXJ0ZXI6IEZhaWx1cmVDb252ZXJ0ZXIgPSBuZXcgRGVmYXVsdEZhaWx1cmVDb252ZXJ0ZXIoKTtcblxuLyoqXG4gKiBBIFwibG9hZGVkXCIgZGF0YSBjb252ZXJ0ZXIgdGhhdCB1c2VzIHRoZSBkZWZhdWx0IHNldCBvZiBmYWlsdXJlIGFuZCBwYXlsb2FkIGNvbnZlcnRlcnMuXG4gKi9cbmV4cG9ydCBjb25zdCBkZWZhdWx0RGF0YUNvbnZlcnRlcjogTG9hZGVkRGF0YUNvbnZlcnRlciA9IHtcbiAgcGF5bG9hZENvbnZlcnRlcjogZGVmYXVsdFBheWxvYWRDb252ZXJ0ZXIsXG4gIGZhaWx1cmVDb252ZXJ0ZXI6IGRlZmF1bHRGYWlsdXJlQ29udmVydGVyLFxuICBwYXlsb2FkQ29kZWNzOiBbXSxcbn07XG4iLCJpbXBvcnQge1xuICBBY3Rpdml0eUZhaWx1cmUsXG4gIEFwcGxpY2F0aW9uRmFpbHVyZSxcbiAgQ2FuY2VsbGVkRmFpbHVyZSxcbiAgQ2hpbGRXb3JrZmxvd0ZhaWx1cmUsXG4gIGRlY29kZVJldHJ5U3RhdGUsXG4gIGRlY29kZVRpbWVvdXRUeXBlLFxuICBlbmNvZGVSZXRyeVN0YXRlLFxuICBlbmNvZGVUaW1lb3V0VHlwZSxcbiAgRkFJTFVSRV9TT1VSQ0UsXG4gIFByb3RvRmFpbHVyZSxcbiAgU2VydmVyRmFpbHVyZSxcbiAgVGVtcG9yYWxGYWlsdXJlLFxuICBUZXJtaW5hdGVkRmFpbHVyZSxcbiAgVGltZW91dEZhaWx1cmUsXG59IGZyb20gJy4uL2ZhaWx1cmUnO1xuaW1wb3J0IHsgaXNFcnJvciB9IGZyb20gJy4uL3R5cGUtaGVscGVycyc7XG5pbXBvcnQgeyBtc09wdGlvbmFsVG9UcyB9IGZyb20gJy4uL3RpbWUnO1xuaW1wb3J0IHsgYXJyYXlGcm9tUGF5bG9hZHMsIGZyb21QYXlsb2Fkc0F0SW5kZXgsIFBheWxvYWRDb252ZXJ0ZXIsIHRvUGF5bG9hZHMgfSBmcm9tICcuL3BheWxvYWQtY29udmVydGVyJztcblxuZnVuY3Rpb24gY29tYmluZVJlZ0V4cCguLi5yZWdleHBzOiBSZWdFeHBbXSk6IFJlZ0V4cCB7XG4gIHJldHVybiBuZXcgUmVnRXhwKHJlZ2V4cHMubWFwKCh4KSA9PiBgKD86JHt4LnNvdXJjZX0pYCkuam9pbignfCcpKTtcbn1cblxuLyoqXG4gKiBTdGFjayB0cmFjZXMgd2lsbCBiZSBjdXRvZmYgd2hlbiBvbiBvZiB0aGVzZSBwYXR0ZXJucyBpcyBtYXRjaGVkXG4gKi9cbmNvbnN0IENVVE9GRl9TVEFDS19QQVRURVJOUyA9IGNvbWJpbmVSZWdFeHAoXG4gIC8qKiBBY3Rpdml0eSBleGVjdXRpb24gKi9cbiAgL1xccythdCBBY3Rpdml0eVxcLmV4ZWN1dGUgXFwoLipbXFxcXC9dd29ya2VyW1xcXFwvXSg/OnNyY3xsaWIpW1xcXFwvXWFjdGl2aXR5XFwuW2p0XXM6XFxkKzpcXGQrXFwpLyxcbiAgLyoqIFdvcmtmbG93IGFjdGl2YXRpb24gKi9cbiAgL1xccythdCBBY3RpdmF0b3JcXC5cXFMrTmV4dEhhbmRsZXIgXFwoLipbXFxcXC9dd29ya2Zsb3dbXFxcXC9dKD86c3JjfGxpYilbXFxcXC9daW50ZXJuYWxzXFwuW2p0XXM6XFxkKzpcXGQrXFwpLyxcbiAgLyoqIFdvcmtmbG93IHJ1biBhbnl0aGluZyBpbiBjb250ZXh0ICovXG4gIC9cXHMrYXQgU2NyaXB0XFwucnVuSW5Db250ZXh0IFxcKCg/Om5vZGU6dm18dm1cXC5qcyk6XFxkKzpcXGQrXFwpL1xuKTtcblxuLyoqXG4gKiBBbnkgc3RhY2sgdHJhY2UgZnJhbWVzIHRoYXQgbWF0Y2ggYW55IG9mIHRob3NlIHdpbCBiZSBkb3BwZWQuXG4gKiBUaGUgXCJudWxsLlwiIHByZWZpeCBvbiBzb21lIGNhc2VzIGlzIHRvIGF2b2lkIGh0dHBzOi8vZ2l0aHViLmNvbS9ub2RlanMvbm9kZS9pc3N1ZXMvNDI0MTdcbiAqL1xuY29uc3QgRFJPUFBFRF9TVEFDS19GUkFNRVNfUEFUVEVSTlMgPSBjb21iaW5lUmVnRXhwKFxuICAvKiogSW50ZXJuYWwgZnVuY3Rpb25zIHVzZWQgdG8gcmVjdXJzaXZlbHkgY2hhaW4gaW50ZXJjZXB0b3JzICovXG4gIC9cXHMrYXQgKG51bGxcXC4pP25leHQgXFwoLipbXFxcXC9dY29tbW9uW1xcXFwvXSg/OnNyY3xsaWIpW1xcXFwvXWludGVyY2VwdG9yc1xcLltqdF1zOlxcZCs6XFxkK1xcKS8sXG4gIC8qKiBJbnRlcm5hbCBmdW5jdGlvbnMgdXNlZCB0byByZWN1cnNpdmVseSBjaGFpbiBpbnRlcmNlcHRvcnMgKi9cbiAgL1xccythdCAobnVsbFxcLik/ZXhlY3V0ZU5leHRIYW5kbGVyIFxcKC4qW1xcXFwvXXdvcmtlcltcXFxcL10oPzpzcmN8bGliKVtcXFxcL11hY3Rpdml0eVxcLltqdF1zOlxcZCs6XFxkK1xcKS9cbik7XG5cbi8qKlxuICogQ3V0cyBvdXQgdGhlIGZyYW1ld29yayBwYXJ0IG9mIGEgc3RhY2sgdHJhY2UsIGxlYXZpbmcgb25seSB1c2VyIGNvZGUgZW50cmllc1xuICovXG5leHBvcnQgZnVuY3Rpb24gY3V0b2ZmU3RhY2tUcmFjZShzdGFjaz86IHN0cmluZyk6IHN0cmluZyB7XG4gIGNvbnN0IGxpbmVzID0gKHN0YWNrID8/ICcnKS5zcGxpdCgvXFxyP1xcbi8pO1xuICBjb25zdCBhY2MgPSBBcnJheTxzdHJpbmc+KCk7XG4gIGZvciAoY29uc3QgbGluZSBvZiBsaW5lcykge1xuICAgIGlmIChDVVRPRkZfU1RBQ0tfUEFUVEVSTlMudGVzdChsaW5lKSkgYnJlYWs7XG4gICAgaWYgKCFEUk9QUEVEX1NUQUNLX0ZSQU1FU19QQVRURVJOUy50ZXN0KGxpbmUpKSBhY2MucHVzaChsaW5lKTtcbiAgfVxuICByZXR1cm4gYWNjLmpvaW4oJ1xcbicpO1xufVxuXG4vKipcbiAqIEEgYEZhaWx1cmVDb252ZXJ0ZXJgIGlzIHJlc3BvbnNpYmxlIGZvciBjb252ZXJ0aW5nIGZyb20gcHJvdG8gYEZhaWx1cmVgIGluc3RhbmNlcyB0byBKUyBgRXJyb3JzYCBhbmQgYmFjay5cbiAqXG4gKiBXZSByZWNvbW1lbmRlZCB1c2luZyB0aGUge0BsaW5rIERlZmF1bHRGYWlsdXJlQ29udmVydGVyfSBpbnN0ZWFkIG9mIGN1c3RvbWl6aW5nIHRoZSBkZWZhdWx0IGltcGxlbWVudGF0aW9uIGluIG9yZGVyXG4gKiB0byBtYWludGFpbiBjcm9zcy1sYW5ndWFnZSBGYWlsdXJlIHNlcmlhbGl6YXRpb24gY29tcGF0aWJpbGl0eS5cbiAqL1xuZXhwb3J0IGludGVyZmFjZSBGYWlsdXJlQ29udmVydGVyIHtcbiAgLyoqXG4gICAqIENvbnZlcnRzIGEgY2F1Z2h0IGVycm9yIHRvIGEgRmFpbHVyZSBwcm90byBtZXNzYWdlLlxuICAgKi9cbiAgZXJyb3JUb0ZhaWx1cmUoZXJyOiB1bmtub3duLCBwYXlsb2FkQ29udmVydGVyOiBQYXlsb2FkQ29udmVydGVyKTogUHJvdG9GYWlsdXJlO1xuXG4gIC8qKlxuICAgKiBDb252ZXJ0cyBhIEZhaWx1cmUgcHJvdG8gbWVzc2FnZSB0byBhIEpTIEVycm9yIG9iamVjdC5cbiAgICpcbiAgICogVGhlIHJldHVybmVkIGVycm9yIG11c3QgYmUgYW4gaW5zdGFuY2Ugb2YgYFRlbXBvcmFsRmFpbHVyZWAuXG4gICAqL1xuICBmYWlsdXJlVG9FcnJvcihlcnI6IFByb3RvRmFpbHVyZSwgcGF5bG9hZENvbnZlcnRlcjogUGF5bG9hZENvbnZlcnRlcik6IFRlbXBvcmFsRmFpbHVyZTtcbn1cblxuLyoqXG4gKiBUaGUgXCJzaGFwZVwiIG9mIHRoZSBhdHRyaWJ1dGVzIHNldCBhcyB0aGUge0BsaW5rIFByb3RvRmFpbHVyZS5lbmNvZGVkQXR0cmlidXRlc30gcGF5bG9hZCBpbiBjYXNlXG4gKiB7QGxpbmsgRGVmYXVsdEVuY29kZWRGYWlsdXJlQXR0cmlidXRlcy5lbmNvZGVDb21tb25BdHRyaWJ1dGVzfSBpcyBzZXQgdG8gYHRydWVgLlxuICovXG5leHBvcnQgaW50ZXJmYWNlIERlZmF1bHRFbmNvZGVkRmFpbHVyZUF0dHJpYnV0ZXMge1xuICBtZXNzYWdlOiBzdHJpbmc7XG4gIHN0YWNrX3RyYWNlOiBzdHJpbmc7XG59XG5cbi8qKlxuICogT3B0aW9ucyBmb3IgdGhlIHtAbGluayBEZWZhdWx0RmFpbHVyZUNvbnZlcnRlcn0gY29uc3RydWN0b3IuXG4gKi9cbmV4cG9ydCBpbnRlcmZhY2UgRGVmYXVsdEZhaWx1cmVDb252ZXJ0ZXJPcHRpb25zIHtcbiAgLyoqXG4gICAqIFdoZXRoZXIgdG8gZW5jb2RlIGVycm9yIG1lc3NhZ2VzIGFuZCBzdGFjayB0cmFjZXMgKGZvciBlbmNyeXB0aW5nIHRoZXNlIGF0dHJpYnV0ZXMgdXNlIGEge0BsaW5rIFBheWxvYWRDb2RlY30pLlxuICAgKi9cbiAgZW5jb2RlQ29tbW9uQXR0cmlidXRlczogYm9vbGVhbjtcbn1cblxuLyoqXG4gKiBEZWZhdWx0LCBjcm9zcy1sYW5ndWFnZS1jb21wYXRpYmxlIEZhaWx1cmUgY29udmVydGVyLlxuICpcbiAqIEJ5IGRlZmF1bHQsIGl0IHdpbGwgbGVhdmUgZXJyb3IgbWVzc2FnZXMgYW5kIHN0YWNrIHRyYWNlcyBhcyBwbGFpbiB0ZXh0LiBJbiBvcmRlciB0byBlbmNyeXB0IHRoZW0sIHNldFxuICogYGVuY29kZUNvbW1vbkF0dHJpYnV0ZXNgIHRvIGB0cnVlYCBpbiB0aGUgY29uc3RydWN0b3Igb3B0aW9ucyBhbmQgdXNlIGEge0BsaW5rIFBheWxvYWRDb2RlY30gdGhhdCBjYW4gZW5jcnlwdCAvXG4gKiBkZWNyeXB0IFBheWxvYWRzIGluIHlvdXIge0BsaW5rIFdvcmtlck9wdGlvbnMuZGF0YUNvbnZlcnRlciB8IFdvcmtlcn0gYW5kXG4gKiB7QGxpbmsgQ2xpZW50T3B0aW9ucy5kYXRhQ29udmVydGVyIHwgQ2xpZW50IG9wdGlvbnN9LlxuICovXG5leHBvcnQgY2xhc3MgRGVmYXVsdEZhaWx1cmVDb252ZXJ0ZXIgaW1wbGVtZW50cyBGYWlsdXJlQ29udmVydGVyIHtcbiAgcHVibGljIHJlYWRvbmx5IG9wdGlvbnM6IERlZmF1bHRGYWlsdXJlQ29udmVydGVyT3B0aW9ucztcblxuICBjb25zdHJ1Y3RvcihvcHRpb25zPzogUGFydGlhbDxEZWZhdWx0RmFpbHVyZUNvbnZlcnRlck9wdGlvbnM+KSB7XG4gICAgY29uc3QgeyBlbmNvZGVDb21tb25BdHRyaWJ1dGVzIH0gPSBvcHRpb25zID8/IHt9O1xuICAgIHRoaXMub3B0aW9ucyA9IHtcbiAgICAgIGVuY29kZUNvbW1vbkF0dHJpYnV0ZXM6IGVuY29kZUNvbW1vbkF0dHJpYnV0ZXMgPz8gZmFsc2UsXG4gICAgfTtcbiAgfVxuXG4gIC8qKlxuICAgKiBDb252ZXJ0cyBhIEZhaWx1cmUgcHJvdG8gbWVzc2FnZSB0byBhIEpTIEVycm9yIG9iamVjdC5cbiAgICpcbiAgICogRG9lcyBub3Qgc2V0IGNvbW1vbiBwcm9wZXJ0aWVzLCB0aGF0IGlzIGRvbmUgaW4ge0BsaW5rIGZhaWx1cmVUb0Vycm9yfS5cbiAgICovXG4gIGZhaWx1cmVUb0Vycm9ySW5uZXIoZmFpbHVyZTogUHJvdG9GYWlsdXJlLCBwYXlsb2FkQ29udmVydGVyOiBQYXlsb2FkQ29udmVydGVyKTogVGVtcG9yYWxGYWlsdXJlIHtcbiAgICBpZiAoZmFpbHVyZS5hcHBsaWNhdGlvbkZhaWx1cmVJbmZvKSB7XG4gICAgICByZXR1cm4gbmV3IEFwcGxpY2F0aW9uRmFpbHVyZShcbiAgICAgICAgZmFpbHVyZS5tZXNzYWdlID8/IHVuZGVmaW5lZCxcbiAgICAgICAgZmFpbHVyZS5hcHBsaWNhdGlvbkZhaWx1cmVJbmZvLnR5cGUsXG4gICAgICAgIEJvb2xlYW4oZmFpbHVyZS5hcHBsaWNhdGlvbkZhaWx1cmVJbmZvLm5vblJldHJ5YWJsZSksXG4gICAgICAgIGFycmF5RnJvbVBheWxvYWRzKHBheWxvYWRDb252ZXJ0ZXIsIGZhaWx1cmUuYXBwbGljYXRpb25GYWlsdXJlSW5mby5kZXRhaWxzPy5wYXlsb2FkcyksXG4gICAgICAgIHRoaXMub3B0aW9uYWxGYWlsdXJlVG9PcHRpb25hbEVycm9yKGZhaWx1cmUuY2F1c2UsIHBheWxvYWRDb252ZXJ0ZXIpXG4gICAgICApO1xuICAgIH1cbiAgICBpZiAoZmFpbHVyZS5zZXJ2ZXJGYWlsdXJlSW5mbykge1xuICAgICAgcmV0dXJuIG5ldyBTZXJ2ZXJGYWlsdXJlKFxuICAgICAgICBmYWlsdXJlLm1lc3NhZ2UgPz8gdW5kZWZpbmVkLFxuICAgICAgICBCb29sZWFuKGZhaWx1cmUuc2VydmVyRmFpbHVyZUluZm8ubm9uUmV0cnlhYmxlKSxcbiAgICAgICAgdGhpcy5vcHRpb25hbEZhaWx1cmVUb09wdGlvbmFsRXJyb3IoZmFpbHVyZS5jYXVzZSwgcGF5bG9hZENvbnZlcnRlcilcbiAgICAgICk7XG4gICAgfVxuICAgIGlmIChmYWlsdXJlLnRpbWVvdXRGYWlsdXJlSW5mbykge1xuICAgICAgcmV0dXJuIG5ldyBUaW1lb3V0RmFpbHVyZShcbiAgICAgICAgZmFpbHVyZS5tZXNzYWdlID8/IHVuZGVmaW5lZCxcbiAgICAgICAgZnJvbVBheWxvYWRzQXRJbmRleChwYXlsb2FkQ29udmVydGVyLCAwLCBmYWlsdXJlLnRpbWVvdXRGYWlsdXJlSW5mby5sYXN0SGVhcnRiZWF0RGV0YWlscz8ucGF5bG9hZHMpLFxuICAgICAgICBkZWNvZGVUaW1lb3V0VHlwZShmYWlsdXJlLnRpbWVvdXRGYWlsdXJlSW5mby50aW1lb3V0VHlwZSlcbiAgICAgICk7XG4gICAgfVxuICAgIGlmIChmYWlsdXJlLnRlcm1pbmF0ZWRGYWlsdXJlSW5mbykge1xuICAgICAgcmV0dXJuIG5ldyBUZXJtaW5hdGVkRmFpbHVyZShcbiAgICAgICAgZmFpbHVyZS5tZXNzYWdlID8/IHVuZGVmaW5lZCxcbiAgICAgICAgdGhpcy5vcHRpb25hbEZhaWx1cmVUb09wdGlvbmFsRXJyb3IoZmFpbHVyZS5jYXVzZSwgcGF5bG9hZENvbnZlcnRlcilcbiAgICAgICk7XG4gICAgfVxuICAgIGlmIChmYWlsdXJlLmNhbmNlbGVkRmFpbHVyZUluZm8pIHtcbiAgICAgIHJldHVybiBuZXcgQ2FuY2VsbGVkRmFpbHVyZShcbiAgICAgICAgZmFpbHVyZS5tZXNzYWdlID8/IHVuZGVmaW5lZCxcbiAgICAgICAgYXJyYXlGcm9tUGF5bG9hZHMocGF5bG9hZENvbnZlcnRlciwgZmFpbHVyZS5jYW5jZWxlZEZhaWx1cmVJbmZvLmRldGFpbHM/LnBheWxvYWRzKSxcbiAgICAgICAgdGhpcy5vcHRpb25hbEZhaWx1cmVUb09wdGlvbmFsRXJyb3IoZmFpbHVyZS5jYXVzZSwgcGF5bG9hZENvbnZlcnRlcilcbiAgICAgICk7XG4gICAgfVxuICAgIGlmIChmYWlsdXJlLnJlc2V0V29ya2Zsb3dGYWlsdXJlSW5mbykge1xuICAgICAgcmV0dXJuIG5ldyBBcHBsaWNhdGlvbkZhaWx1cmUoXG4gICAgICAgIGZhaWx1cmUubWVzc2FnZSA/PyB1bmRlZmluZWQsXG4gICAgICAgICdSZXNldFdvcmtmbG93JyxcbiAgICAgICAgZmFsc2UsXG4gICAgICAgIGFycmF5RnJvbVBheWxvYWRzKHBheWxvYWRDb252ZXJ0ZXIsIGZhaWx1cmUucmVzZXRXb3JrZmxvd0ZhaWx1cmVJbmZvLmxhc3RIZWFydGJlYXREZXRhaWxzPy5wYXlsb2FkcyksXG4gICAgICAgIHRoaXMub3B0aW9uYWxGYWlsdXJlVG9PcHRpb25hbEVycm9yKGZhaWx1cmUuY2F1c2UsIHBheWxvYWRDb252ZXJ0ZXIpXG4gICAgICApO1xuICAgIH1cbiAgICBpZiAoZmFpbHVyZS5jaGlsZFdvcmtmbG93RXhlY3V0aW9uRmFpbHVyZUluZm8pIHtcbiAgICAgIGNvbnN0IHsgbmFtZXNwYWNlLCB3b3JrZmxvd1R5cGUsIHdvcmtmbG93RXhlY3V0aW9uLCByZXRyeVN0YXRlIH0gPSBmYWlsdXJlLmNoaWxkV29ya2Zsb3dFeGVjdXRpb25GYWlsdXJlSW5mbztcbiAgICAgIGlmICghKHdvcmtmbG93VHlwZT8ubmFtZSAmJiB3b3JrZmxvd0V4ZWN1dGlvbikpIHtcbiAgICAgICAgdGhyb3cgbmV3IFR5cGVFcnJvcignTWlzc2luZyBhdHRyaWJ1dGVzIG9uIGNoaWxkV29ya2Zsb3dFeGVjdXRpb25GYWlsdXJlSW5mbycpO1xuICAgICAgfVxuICAgICAgcmV0dXJuIG5ldyBDaGlsZFdvcmtmbG93RmFpbHVyZShcbiAgICAgICAgbmFtZXNwYWNlID8/IHVuZGVmaW5lZCxcbiAgICAgICAgd29ya2Zsb3dFeGVjdXRpb24sXG4gICAgICAgIHdvcmtmbG93VHlwZS5uYW1lLFxuICAgICAgICBkZWNvZGVSZXRyeVN0YXRlKHJldHJ5U3RhdGUpLFxuICAgICAgICB0aGlzLm9wdGlvbmFsRmFpbHVyZVRvT3B0aW9uYWxFcnJvcihmYWlsdXJlLmNhdXNlLCBwYXlsb2FkQ29udmVydGVyKVxuICAgICAgKTtcbiAgICB9XG4gICAgaWYgKGZhaWx1cmUuYWN0aXZpdHlGYWlsdXJlSW5mbykge1xuICAgICAgaWYgKCFmYWlsdXJlLmFjdGl2aXR5RmFpbHVyZUluZm8uYWN0aXZpdHlUeXBlPy5uYW1lKSB7XG4gICAgICAgIHRocm93IG5ldyBUeXBlRXJyb3IoJ01pc3NpbmcgYWN0aXZpdHlUeXBlPy5uYW1lIG9uIGFjdGl2aXR5RmFpbHVyZUluZm8nKTtcbiAgICAgIH1cbiAgICAgIHJldHVybiBuZXcgQWN0aXZpdHlGYWlsdXJlKFxuICAgICAgICBmYWlsdXJlLm1lc3NhZ2UgPz8gdW5kZWZpbmVkLFxuICAgICAgICBmYWlsdXJlLmFjdGl2aXR5RmFpbHVyZUluZm8uYWN0aXZpdHlUeXBlLm5hbWUsXG4gICAgICAgIGZhaWx1cmUuYWN0aXZpdHlGYWlsdXJlSW5mby5hY3Rpdml0eUlkID8/IHVuZGVmaW5lZCxcbiAgICAgICAgZGVjb2RlUmV0cnlTdGF0ZShmYWlsdXJlLmFjdGl2aXR5RmFpbHVyZUluZm8ucmV0cnlTdGF0ZSksXG4gICAgICAgIGZhaWx1cmUuYWN0aXZpdHlGYWlsdXJlSW5mby5pZGVudGl0eSA/PyB1bmRlZmluZWQsXG4gICAgICAgIHRoaXMub3B0aW9uYWxGYWlsdXJlVG9PcHRpb25hbEVycm9yKGZhaWx1cmUuY2F1c2UsIHBheWxvYWRDb252ZXJ0ZXIpXG4gICAgICApO1xuICAgIH1cbiAgICByZXR1cm4gbmV3IFRlbXBvcmFsRmFpbHVyZShcbiAgICAgIGZhaWx1cmUubWVzc2FnZSA/PyB1bmRlZmluZWQsXG4gICAgICB0aGlzLm9wdGlvbmFsRmFpbHVyZVRvT3B0aW9uYWxFcnJvcihmYWlsdXJlLmNhdXNlLCBwYXlsb2FkQ29udmVydGVyKVxuICAgICk7XG4gIH1cblxuICBmYWlsdXJlVG9FcnJvcihmYWlsdXJlOiBQcm90b0ZhaWx1cmUsIHBheWxvYWRDb252ZXJ0ZXI6IFBheWxvYWRDb252ZXJ0ZXIpOiBUZW1wb3JhbEZhaWx1cmUge1xuICAgIGlmIChmYWlsdXJlLmVuY29kZWRBdHRyaWJ1dGVzKSB7XG4gICAgICBjb25zdCBhdHRycyA9IHBheWxvYWRDb252ZXJ0ZXIuZnJvbVBheWxvYWQ8RGVmYXVsdEVuY29kZWRGYWlsdXJlQXR0cmlidXRlcz4oZmFpbHVyZS5lbmNvZGVkQXR0cmlidXRlcyk7XG4gICAgICAvLyBEb24ndCBhcHBseSBlbmNvZGVkQXR0cmlidXRlcyB1bmxlc3MgdGhleSBjb25mb3JtIHRvIGFuIGV4cGVjdGVkIHNjaGVtYVxuICAgICAgaWYgKHR5cGVvZiBhdHRycyA9PT0gJ29iamVjdCcgJiYgYXR0cnMgIT09IG51bGwpIHtcbiAgICAgICAgY29uc3QgeyBtZXNzYWdlLCBzdGFja190cmFjZSB9ID0gYXR0cnM7XG4gICAgICAgIC8vIEF2b2lkIG11dGF0aW5nIHRoZSBhcmd1bWVudFxuICAgICAgICBmYWlsdXJlID0geyAuLi5mYWlsdXJlIH07XG4gICAgICAgIGlmICh0eXBlb2YgbWVzc2FnZSA9PT0gJ3N0cmluZycpIHtcbiAgICAgICAgICBmYWlsdXJlLm1lc3NhZ2UgPSBtZXNzYWdlO1xuICAgICAgICB9XG4gICAgICAgIGlmICh0eXBlb2Ygc3RhY2tfdHJhY2UgPT09ICdzdHJpbmcnKSB7XG4gICAgICAgICAgZmFpbHVyZS5zdGFja1RyYWNlID0gc3RhY2tfdHJhY2U7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9XG4gICAgY29uc3QgZXJyID0gdGhpcy5mYWlsdXJlVG9FcnJvcklubmVyKGZhaWx1cmUsIHBheWxvYWRDb252ZXJ0ZXIpO1xuICAgIGVyci5zdGFjayA9IGZhaWx1cmUuc3RhY2tUcmFjZSA/PyAnJztcbiAgICBlcnIuZmFpbHVyZSA9IGZhaWx1cmU7XG4gICAgcmV0dXJuIGVycjtcbiAgfVxuXG4gIGVycm9yVG9GYWlsdXJlKGVycjogdW5rbm93biwgcGF5bG9hZENvbnZlcnRlcjogUGF5bG9hZENvbnZlcnRlcik6IFByb3RvRmFpbHVyZSB7XG4gICAgY29uc3QgZmFpbHVyZSA9IHRoaXMuZXJyb3JUb0ZhaWx1cmVJbm5lcihlcnIsIHBheWxvYWRDb252ZXJ0ZXIpO1xuICAgIGlmICh0aGlzLm9wdGlvbnMuZW5jb2RlQ29tbW9uQXR0cmlidXRlcykge1xuICAgICAgY29uc3QgeyBtZXNzYWdlLCBzdGFja1RyYWNlIH0gPSBmYWlsdXJlO1xuICAgICAgZmFpbHVyZS5tZXNzYWdlID0gJ0VuY29kZWQgZmFpbHVyZSc7XG4gICAgICBmYWlsdXJlLnN0YWNrVHJhY2UgPSAnJztcbiAgICAgIGZhaWx1cmUuZW5jb2RlZEF0dHJpYnV0ZXMgPSBwYXlsb2FkQ29udmVydGVyLnRvUGF5bG9hZCh7IG1lc3NhZ2UsIHN0YWNrX3RyYWNlOiBzdGFja1RyYWNlIH0pO1xuICAgIH1cbiAgICByZXR1cm4gZmFpbHVyZTtcbiAgfVxuXG4gIGVycm9yVG9GYWlsdXJlSW5uZXIoZXJyOiB1bmtub3duLCBwYXlsb2FkQ29udmVydGVyOiBQYXlsb2FkQ29udmVydGVyKTogUHJvdG9GYWlsdXJlIHtcbiAgICBpZiAoZXJyIGluc3RhbmNlb2YgVGVtcG9yYWxGYWlsdXJlKSB7XG4gICAgICBpZiAoZXJyLmZhaWx1cmUpIHJldHVybiBlcnIuZmFpbHVyZTtcbiAgICAgIGNvbnN0IGJhc2UgPSB7XG4gICAgICAgIG1lc3NhZ2U6IGVyci5tZXNzYWdlLFxuICAgICAgICBzdGFja1RyYWNlOiBjdXRvZmZTdGFja1RyYWNlKGVyci5zdGFjayksXG4gICAgICAgIGNhdXNlOiB0aGlzLm9wdGlvbmFsRXJyb3JUb09wdGlvbmFsRmFpbHVyZShlcnIuY2F1c2UsIHBheWxvYWRDb252ZXJ0ZXIpLFxuICAgICAgICBzb3VyY2U6IEZBSUxVUkVfU09VUkNFLFxuICAgICAgfTtcblxuICAgICAgaWYgKGVyciBpbnN0YW5jZW9mIEFjdGl2aXR5RmFpbHVyZSkge1xuICAgICAgICByZXR1cm4ge1xuICAgICAgICAgIC4uLmJhc2UsXG4gICAgICAgICAgYWN0aXZpdHlGYWlsdXJlSW5mbzoge1xuICAgICAgICAgICAgLi4uZXJyLFxuICAgICAgICAgICAgcmV0cnlTdGF0ZTogZW5jb2RlUmV0cnlTdGF0ZShlcnIucmV0cnlTdGF0ZSksXG4gICAgICAgICAgICBhY3Rpdml0eVR5cGU6IHsgbmFtZTogZXJyLmFjdGl2aXR5VHlwZSB9LFxuICAgICAgICAgIH0sXG4gICAgICAgIH07XG4gICAgICB9XG4gICAgICBpZiAoZXJyIGluc3RhbmNlb2YgQ2hpbGRXb3JrZmxvd0ZhaWx1cmUpIHtcbiAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICAuLi5iYXNlLFxuICAgICAgICAgIGNoaWxkV29ya2Zsb3dFeGVjdXRpb25GYWlsdXJlSW5mbzoge1xuICAgICAgICAgICAgLi4uZXJyLFxuICAgICAgICAgICAgcmV0cnlTdGF0ZTogZW5jb2RlUmV0cnlTdGF0ZShlcnIucmV0cnlTdGF0ZSksXG4gICAgICAgICAgICB3b3JrZmxvd0V4ZWN1dGlvbjogZXJyLmV4ZWN1dGlvbixcbiAgICAgICAgICAgIHdvcmtmbG93VHlwZTogeyBuYW1lOiBlcnIud29ya2Zsb3dUeXBlIH0sXG4gICAgICAgICAgfSxcbiAgICAgICAgfTtcbiAgICAgIH1cbiAgICAgIGlmIChlcnIgaW5zdGFuY2VvZiBBcHBsaWNhdGlvbkZhaWx1cmUpIHtcbiAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICAuLi5iYXNlLFxuICAgICAgICAgIGFwcGxpY2F0aW9uRmFpbHVyZUluZm86IHtcbiAgICAgICAgICAgIHR5cGU6IGVyci50eXBlLFxuICAgICAgICAgICAgbm9uUmV0cnlhYmxlOiBlcnIubm9uUmV0cnlhYmxlLFxuICAgICAgICAgICAgZGV0YWlsczpcbiAgICAgICAgICAgICAgZXJyLmRldGFpbHMgJiYgZXJyLmRldGFpbHMubGVuZ3RoXG4gICAgICAgICAgICAgICAgPyB7IHBheWxvYWRzOiB0b1BheWxvYWRzKHBheWxvYWRDb252ZXJ0ZXIsIC4uLmVyci5kZXRhaWxzKSB9XG4gICAgICAgICAgICAgICAgOiB1bmRlZmluZWQsXG4gICAgICAgICAgICBuZXh0UmV0cnlEZWxheTogbXNPcHRpb25hbFRvVHMoZXJyLm5leHRSZXRyeURlbGF5KSxcbiAgICAgICAgICB9LFxuICAgICAgICB9O1xuICAgICAgfVxuICAgICAgaWYgKGVyciBpbnN0YW5jZW9mIENhbmNlbGxlZEZhaWx1cmUpIHtcbiAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICAuLi5iYXNlLFxuICAgICAgICAgIGNhbmNlbGVkRmFpbHVyZUluZm86IHtcbiAgICAgICAgICAgIGRldGFpbHM6XG4gICAgICAgICAgICAgIGVyci5kZXRhaWxzICYmIGVyci5kZXRhaWxzLmxlbmd0aFxuICAgICAgICAgICAgICAgID8geyBwYXlsb2FkczogdG9QYXlsb2FkcyhwYXlsb2FkQ29udmVydGVyLCAuLi5lcnIuZGV0YWlscykgfVxuICAgICAgICAgICAgICAgIDogdW5kZWZpbmVkLFxuICAgICAgICAgIH0sXG4gICAgICAgIH07XG4gICAgICB9XG4gICAgICBpZiAoZXJyIGluc3RhbmNlb2YgVGltZW91dEZhaWx1cmUpIHtcbiAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICAuLi5iYXNlLFxuICAgICAgICAgIHRpbWVvdXRGYWlsdXJlSW5mbzoge1xuICAgICAgICAgICAgdGltZW91dFR5cGU6IGVuY29kZVRpbWVvdXRUeXBlKGVyci50aW1lb3V0VHlwZSksXG4gICAgICAgICAgICBsYXN0SGVhcnRiZWF0RGV0YWlsczogZXJyLmxhc3RIZWFydGJlYXREZXRhaWxzXG4gICAgICAgICAgICAgID8geyBwYXlsb2FkczogdG9QYXlsb2FkcyhwYXlsb2FkQ29udmVydGVyLCBlcnIubGFzdEhlYXJ0YmVhdERldGFpbHMpIH1cbiAgICAgICAgICAgICAgOiB1bmRlZmluZWQsXG4gICAgICAgICAgfSxcbiAgICAgICAgfTtcbiAgICAgIH1cbiAgICAgIGlmIChlcnIgaW5zdGFuY2VvZiBTZXJ2ZXJGYWlsdXJlKSB7XG4gICAgICAgIHJldHVybiB7XG4gICAgICAgICAgLi4uYmFzZSxcbiAgICAgICAgICBzZXJ2ZXJGYWlsdXJlSW5mbzogeyBub25SZXRyeWFibGU6IGVyci5ub25SZXRyeWFibGUgfSxcbiAgICAgICAgfTtcbiAgICAgIH1cbiAgICAgIGlmIChlcnIgaW5zdGFuY2VvZiBUZXJtaW5hdGVkRmFpbHVyZSkge1xuICAgICAgICByZXR1cm4ge1xuICAgICAgICAgIC4uLmJhc2UsXG4gICAgICAgICAgdGVybWluYXRlZEZhaWx1cmVJbmZvOiB7fSxcbiAgICAgICAgfTtcbiAgICAgIH1cbiAgICAgIC8vIEp1c3QgYSBUZW1wb3JhbEZhaWx1cmVcbiAgICAgIHJldHVybiBiYXNlO1xuICAgIH1cblxuICAgIGNvbnN0IGJhc2UgPSB7XG4gICAgICBzb3VyY2U6IEZBSUxVUkVfU09VUkNFLFxuICAgIH07XG5cbiAgICBpZiAoaXNFcnJvcihlcnIpKSB7XG4gICAgICByZXR1cm4ge1xuICAgICAgICAuLi5iYXNlLFxuICAgICAgICBtZXNzYWdlOiBTdHJpbmcoZXJyLm1lc3NhZ2UpID8/ICcnLFxuICAgICAgICBzdGFja1RyYWNlOiBjdXRvZmZTdGFja1RyYWNlKGVyci5zdGFjayksXG4gICAgICAgIGNhdXNlOiB0aGlzLm9wdGlvbmFsRXJyb3JUb09wdGlvbmFsRmFpbHVyZSgoZXJyIGFzIGFueSkuY2F1c2UsIHBheWxvYWRDb252ZXJ0ZXIpLFxuICAgICAgfTtcbiAgICB9XG5cbiAgICBjb25zdCByZWNvbW1lbmRhdGlvbiA9IGAgW0Egbm9uLUVycm9yIHZhbHVlIHdhcyB0aHJvd24gZnJvbSB5b3VyIGNvZGUuIFdlIHJlY29tbWVuZCB0aHJvd2luZyBFcnJvciBvYmplY3RzIHNvIHRoYXQgd2UgY2FuIHByb3ZpZGUgYSBzdGFjayB0cmFjZV1gO1xuXG4gICAgaWYgKHR5cGVvZiBlcnIgPT09ICdzdHJpbmcnKSB7XG4gICAgICByZXR1cm4geyAuLi5iYXNlLCBtZXNzYWdlOiBlcnIgKyByZWNvbW1lbmRhdGlvbiB9O1xuICAgIH1cbiAgICBpZiAodHlwZW9mIGVyciA9PT0gJ29iamVjdCcpIHtcbiAgICAgIGxldCBtZXNzYWdlID0gJyc7XG4gICAgICB0cnkge1xuICAgICAgICBtZXNzYWdlID0gSlNPTi5zdHJpbmdpZnkoZXJyKTtcbiAgICAgIH0gY2F0Y2ggKF9lcnIpIHtcbiAgICAgICAgbWVzc2FnZSA9IFN0cmluZyhlcnIpO1xuICAgICAgfVxuICAgICAgcmV0dXJuIHsgLi4uYmFzZSwgbWVzc2FnZTogbWVzc2FnZSArIHJlY29tbWVuZGF0aW9uIH07XG4gICAgfVxuXG4gICAgcmV0dXJuIHsgLi4uYmFzZSwgbWVzc2FnZTogU3RyaW5nKGVycikgKyByZWNvbW1lbmRhdGlvbiB9O1xuICB9XG5cbiAgLyoqXG4gICAqIENvbnZlcnRzIGEgRmFpbHVyZSBwcm90byBtZXNzYWdlIHRvIGEgSlMgRXJyb3Igb2JqZWN0IGlmIGRlZmluZWQgb3IgcmV0dXJucyB1bmRlZmluZWQuXG4gICAqL1xuICBvcHRpb25hbEZhaWx1cmVUb09wdGlvbmFsRXJyb3IoXG4gICAgZmFpbHVyZTogUHJvdG9GYWlsdXJlIHwgdW5kZWZpbmVkIHwgbnVsbCxcbiAgICBwYXlsb2FkQ29udmVydGVyOiBQYXlsb2FkQ29udmVydGVyXG4gICk6IFRlbXBvcmFsRmFpbHVyZSB8IHVuZGVmaW5lZCB7XG4gICAgcmV0dXJuIGZhaWx1cmUgPyB0aGlzLmZhaWx1cmVUb0Vycm9yKGZhaWx1cmUsIHBheWxvYWRDb252ZXJ0ZXIpIDogdW5kZWZpbmVkO1xuICB9XG5cbiAgLyoqXG4gICAqIENvbnZlcnRzIGFuIGVycm9yIHRvIGEgRmFpbHVyZSBwcm90byBtZXNzYWdlIGlmIGRlZmluZWQgb3IgcmV0dXJucyB1bmRlZmluZWRcbiAgICovXG4gIG9wdGlvbmFsRXJyb3JUb09wdGlvbmFsRmFpbHVyZShlcnI6IHVua25vd24sIHBheWxvYWRDb252ZXJ0ZXI6IFBheWxvYWRDb252ZXJ0ZXIpOiBQcm90b0ZhaWx1cmUgfCB1bmRlZmluZWQge1xuICAgIHJldHVybiBlcnIgPyB0aGlzLmVycm9yVG9GYWlsdXJlKGVyciwgcGF5bG9hZENvbnZlcnRlcikgOiB1bmRlZmluZWQ7XG4gIH1cbn1cbiIsImltcG9ydCB7IFBheWxvYWQgfSBmcm9tICcuLi9pbnRlcmZhY2VzJztcblxuLyoqXG4gKiBgUGF5bG9hZENvZGVjYCBpcyBhbiBvcHRpb25hbCBzdGVwIHRoYXQgaGFwcGVucyBiZXR3ZWVuIHRoZSB3aXJlIGFuZCB0aGUge0BsaW5rIFBheWxvYWRDb252ZXJ0ZXJ9OlxuICpcbiAqIFRlbXBvcmFsIFNlcnZlciA8LS0+IFdpcmUgPC0tPiBgUGF5bG9hZENvZGVjYCA8LS0+IGBQYXlsb2FkQ29udmVydGVyYCA8LS0+IFVzZXIgY29kZVxuICpcbiAqIEltcGxlbWVudCB0aGlzIHRvIHRyYW5zZm9ybSBhbiBhcnJheSBvZiB7QGxpbmsgUGF5bG9hZH1zIHRvL2Zyb20gdGhlIGZvcm1hdCBzZW50IG92ZXIgdGhlIHdpcmUgYW5kIHN0b3JlZCBieSBUZW1wb3JhbCBTZXJ2ZXIuXG4gKiBDb21tb24gdHJhbnNmb3JtYXRpb25zIGFyZSBlbmNyeXB0aW9uIGFuZCBjb21wcmVzc2lvbi5cbiAqL1xuZXhwb3J0IGludGVyZmFjZSBQYXlsb2FkQ29kZWMge1xuICAvKipcbiAgICogRW5jb2RlIGFuIGFycmF5IG9mIHtAbGluayBQYXlsb2FkfXMgZm9yIHNlbmRpbmcgb3ZlciB0aGUgd2lyZS5cbiAgICogQHBhcmFtIHBheWxvYWRzIE1heSBoYXZlIGxlbmd0aCAwLlxuICAgKi9cbiAgZW5jb2RlKHBheWxvYWRzOiBQYXlsb2FkW10pOiBQcm9taXNlPFBheWxvYWRbXT47XG5cbiAgLyoqXG4gICAqIERlY29kZSBhbiBhcnJheSBvZiB7QGxpbmsgUGF5bG9hZH1zIHJlY2VpdmVkIGZyb20gdGhlIHdpcmUuXG4gICAqL1xuICBkZWNvZGUocGF5bG9hZHM6IFBheWxvYWRbXSk6IFByb21pc2U8UGF5bG9hZFtdPjtcbn1cbiIsImltcG9ydCB7IGRlY29kZSwgZW5jb2RlIH0gZnJvbSAnLi4vZW5jb2RpbmcnO1xuaW1wb3J0IHsgUGF5bG9hZENvbnZlcnRlckVycm9yLCBWYWx1ZUVycm9yIH0gZnJvbSAnLi4vZXJyb3JzJztcbmltcG9ydCB7IFBheWxvYWQgfSBmcm9tICcuLi9pbnRlcmZhY2VzJztcbmltcG9ydCB7IGVuY29kaW5nS2V5cywgZW5jb2RpbmdUeXBlcywgTUVUQURBVEFfRU5DT0RJTkdfS0VZIH0gZnJvbSAnLi90eXBlcyc7XG5cbi8qKlxuICogVXNlZCBieSB0aGUgZnJhbWV3b3JrIHRvIHNlcmlhbGl6ZS9kZXNlcmlhbGl6ZSBkYXRhIGxpa2UgcGFyYW1ldGVycyBhbmQgcmV0dXJuIHZhbHVlcy5cbiAqXG4gKiBUaGlzIGlzIGNhbGxlZCBpbnNpZGUgdGhlIHtAbGluayBodHRwczovL2RvY3MudGVtcG9yYWwuaW8vdHlwZXNjcmlwdC9kZXRlcm1pbmlzbSB8IFdvcmtmbG93IGlzb2xhdGV9LlxuICogVG8gd3JpdGUgYXN5bmMgY29kZSBvciB1c2UgTm9kZSBBUElzIChvciB1c2UgcGFja2FnZXMgdGhhdCB1c2UgTm9kZSBBUElzKSwgdXNlIGEge0BsaW5rIFBheWxvYWRDb2RlY30uXG4gKi9cbmV4cG9ydCBpbnRlcmZhY2UgUGF5bG9hZENvbnZlcnRlciB7XG4gIC8qKlxuICAgKiBDb252ZXJ0cyBhIHZhbHVlIHRvIGEge0BsaW5rIFBheWxvYWR9LlxuICAgKlxuICAgKiBAcGFyYW0gdmFsdWUgVGhlIHZhbHVlIHRvIGNvbnZlcnQuIEV4YW1wbGUgdmFsdWVzIGluY2x1ZGUgdGhlIFdvcmtmbG93IGFyZ3Mgc2VudCBmcm9tIHRoZSBDbGllbnQgYW5kIHRoZSB2YWx1ZXMgcmV0dXJuZWQgYnkgYSBXb3JrZmxvdyBvciBBY3Rpdml0eS5cbiAgICpcbiAgICogQHJldHVybnMgVGhlIHtAbGluayBQYXlsb2FkfS5cbiAgICpcbiAgICogU2hvdWxkIHRocm93IHtAbGluayBWYWx1ZUVycm9yfSBpZiB1bmFibGUgdG8gY29udmVydC5cbiAgICovXG4gIHRvUGF5bG9hZDxUPih2YWx1ZTogVCk6IFBheWxvYWQ7XG5cbiAgLyoqXG4gICAqIENvbnZlcnRzIGEge0BsaW5rIFBheWxvYWR9IGJhY2sgdG8gYSB2YWx1ZS5cbiAgICovXG4gIGZyb21QYXlsb2FkPFQ+KHBheWxvYWQ6IFBheWxvYWQpOiBUO1xufVxuXG4vKipcbiAqIEltcGxlbWVudHMgY29udmVyc2lvbiBvZiBhIGxpc3Qgb2YgdmFsdWVzLlxuICpcbiAqIEBwYXJhbSBjb252ZXJ0ZXJcbiAqIEBwYXJhbSB2YWx1ZXMgSlMgdmFsdWVzIHRvIGNvbnZlcnQgdG8gUGF5bG9hZHNcbiAqIEByZXR1cm4gbGlzdCBvZiB7QGxpbmsgUGF5bG9hZH1zXG4gKiBAdGhyb3dzIHtAbGluayBWYWx1ZUVycm9yfSBpZiBjb252ZXJzaW9uIG9mIHRoZSB2YWx1ZSBwYXNzZWQgYXMgcGFyYW1ldGVyIGZhaWxlZCBmb3IgYW55XG4gKiAgICAgcmVhc29uLlxuICovXG5leHBvcnQgZnVuY3Rpb24gdG9QYXlsb2Fkcyhjb252ZXJ0ZXI6IFBheWxvYWRDb252ZXJ0ZXIsIC4uLnZhbHVlczogdW5rbm93bltdKTogUGF5bG9hZFtdIHwgdW5kZWZpbmVkIHtcbiAgaWYgKHZhbHVlcy5sZW5ndGggPT09IDApIHtcbiAgICByZXR1cm4gdW5kZWZpbmVkO1xuICB9XG5cbiAgcmV0dXJuIHZhbHVlcy5tYXAoKHZhbHVlKSA9PiBjb252ZXJ0ZXIudG9QYXlsb2FkKHZhbHVlKSk7XG59XG5cbi8qKlxuICogUnVuIHtAbGluayBQYXlsb2FkQ29udmVydGVyLnRvUGF5bG9hZH0gb24gZWFjaCB2YWx1ZSBpbiB0aGUgbWFwLlxuICpcbiAqIEB0aHJvd3Mge0BsaW5rIFZhbHVlRXJyb3J9IGlmIGNvbnZlcnNpb24gb2YgYW55IHZhbHVlIGluIHRoZSBtYXAgZmFpbHNcbiAqL1xuZXhwb3J0IGZ1bmN0aW9uIG1hcFRvUGF5bG9hZHM8SyBleHRlbmRzIHN0cmluZz4oY29udmVydGVyOiBQYXlsb2FkQ29udmVydGVyLCBtYXA6IFJlY29yZDxLLCBhbnk+KTogUmVjb3JkPEssIFBheWxvYWQ+IHtcbiAgcmV0dXJuIE9iamVjdC5mcm9tRW50cmllcyhcbiAgICBPYmplY3QuZW50cmllcyhtYXApLm1hcCgoW2ssIHZdKTogW0ssIFBheWxvYWRdID0+IFtrIGFzIEssIGNvbnZlcnRlci50b1BheWxvYWQodildKVxuICApIGFzIFJlY29yZDxLLCBQYXlsb2FkPjtcbn1cblxuLyoqXG4gKiBJbXBsZW1lbnRzIGNvbnZlcnNpb24gb2YgYW4gYXJyYXkgb2YgdmFsdWVzIG9mIGRpZmZlcmVudCB0eXBlcy4gVXNlZnVsIGZvciBkZXNlcmlhbGl6aW5nXG4gKiBhcmd1bWVudHMgb2YgZnVuY3Rpb24gaW52b2NhdGlvbnMuXG4gKlxuICogQHBhcmFtIGNvbnZlcnRlclxuICogQHBhcmFtIGluZGV4IGluZGV4IG9mIHRoZSB2YWx1ZSBpbiB0aGUgcGF5bG9hZHNcbiAqIEBwYXJhbSBwYXlsb2FkcyBzZXJpYWxpemVkIHZhbHVlIHRvIGNvbnZlcnQgdG8gSlMgdmFsdWVzLlxuICogQHJldHVybiBjb252ZXJ0ZWQgSlMgdmFsdWVcbiAqIEB0aHJvd3Mge0BsaW5rIFBheWxvYWRDb252ZXJ0ZXJFcnJvcn0gaWYgY29udmVyc2lvbiBvZiB0aGUgZGF0YSBwYXNzZWQgYXMgcGFyYW1ldGVyIGZhaWxlZCBmb3IgYW55XG4gKiAgICAgcmVhc29uLlxuICovXG5leHBvcnQgZnVuY3Rpb24gZnJvbVBheWxvYWRzQXRJbmRleDxUPihjb252ZXJ0ZXI6IFBheWxvYWRDb252ZXJ0ZXIsIGluZGV4OiBudW1iZXIsIHBheWxvYWRzPzogUGF5bG9hZFtdIHwgbnVsbCk6IFQge1xuICAvLyBUbyBtYWtlIGFkZGluZyBhcmd1bWVudHMgYSBiYWNrd2FyZHMgY29tcGF0aWJsZSBjaGFuZ2VcbiAgaWYgKHBheWxvYWRzID09PSB1bmRlZmluZWQgfHwgcGF5bG9hZHMgPT09IG51bGwgfHwgaW5kZXggPj0gcGF5bG9hZHMubGVuZ3RoKSB7XG4gICAgcmV0dXJuIHVuZGVmaW5lZCBhcyBhbnk7XG4gIH1cbiAgcmV0dXJuIGNvbnZlcnRlci5mcm9tUGF5bG9hZChwYXlsb2Fkc1tpbmRleF0pO1xufVxuXG4vKipcbiAqIFJ1biB7QGxpbmsgUGF5bG9hZENvbnZlcnRlci5mcm9tUGF5bG9hZH0gb24gZWFjaCB2YWx1ZSBpbiB0aGUgYXJyYXkuXG4gKi9cbmV4cG9ydCBmdW5jdGlvbiBhcnJheUZyb21QYXlsb2Fkcyhjb252ZXJ0ZXI6IFBheWxvYWRDb252ZXJ0ZXIsIHBheWxvYWRzPzogUGF5bG9hZFtdIHwgbnVsbCk6IHVua25vd25bXSB7XG4gIGlmICghcGF5bG9hZHMpIHtcbiAgICByZXR1cm4gW107XG4gIH1cbiAgcmV0dXJuIHBheWxvYWRzLm1hcCgocGF5bG9hZDogUGF5bG9hZCkgPT4gY29udmVydGVyLmZyb21QYXlsb2FkKHBheWxvYWQpKTtcbn1cblxuZXhwb3J0IGZ1bmN0aW9uIG1hcEZyb21QYXlsb2FkczxLIGV4dGVuZHMgc3RyaW5nPihcbiAgY29udmVydGVyOiBQYXlsb2FkQ29udmVydGVyLFxuICBtYXA/OiBSZWNvcmQ8SywgUGF5bG9hZD4gfCBudWxsIHwgdW5kZWZpbmVkXG4pOiBSZWNvcmQ8SywgdW5rbm93bj4gfCB1bmRlZmluZWQge1xuICBpZiAobWFwID09IG51bGwpIHJldHVybiB1bmRlZmluZWQ7XG4gIHJldHVybiBPYmplY3QuZnJvbUVudHJpZXMoXG4gICAgT2JqZWN0LmVudHJpZXMobWFwKS5tYXAoKFtrLCBwYXlsb2FkXSk6IFtLLCB1bmtub3duXSA9PiB7XG4gICAgICBjb25zdCB2YWx1ZSA9IGNvbnZlcnRlci5mcm9tUGF5bG9hZChwYXlsb2FkIGFzIFBheWxvYWQpO1xuICAgICAgcmV0dXJuIFtrIGFzIEssIHZhbHVlXTtcbiAgICB9KVxuICApIGFzIFJlY29yZDxLLCB1bmtub3duPjtcbn1cblxuZXhwb3J0IGludGVyZmFjZSBQYXlsb2FkQ29udmVydGVyV2l0aEVuY29kaW5nIHtcbiAgLyoqXG4gICAqIENvbnZlcnRzIGEgdmFsdWUgdG8gYSB7QGxpbmsgUGF5bG9hZH0uXG4gICAqXG4gICAqIEBwYXJhbSB2YWx1ZSBUaGUgdmFsdWUgdG8gY29udmVydC4gRXhhbXBsZSB2YWx1ZXMgaW5jbHVkZSB0aGUgV29ya2Zsb3cgYXJncyBzZW50IGZyb20gdGhlIENsaWVudCBhbmQgdGhlIHZhbHVlcyByZXR1cm5lZCBieSBhIFdvcmtmbG93IG9yIEFjdGl2aXR5LlxuICAgKiBAcmV0dXJucyBUaGUge0BsaW5rIFBheWxvYWR9LCBvciBgdW5kZWZpbmVkYCBpZiB1bmFibGUgdG8gY29udmVydC5cbiAgICovXG4gIHRvUGF5bG9hZDxUPih2YWx1ZTogVCk6IFBheWxvYWQgfCB1bmRlZmluZWQ7XG5cbiAgLyoqXG4gICAqIENvbnZlcnRzIGEge0BsaW5rIFBheWxvYWR9IGJhY2sgdG8gYSB2YWx1ZS5cbiAgICovXG4gIGZyb21QYXlsb2FkPFQ+KHBheWxvYWQ6IFBheWxvYWQpOiBUO1xuXG4gIHJlYWRvbmx5IGVuY29kaW5nVHlwZTogc3RyaW5nO1xufVxuXG4vKipcbiAqIFRyaWVzIHRvIGNvbnZlcnQgdmFsdWVzIHRvIHtAbGluayBQYXlsb2FkfXMgdXNpbmcgdGhlIHtAbGluayBQYXlsb2FkQ29udmVydGVyV2l0aEVuY29kaW5nfXMgcHJvdmlkZWQgdG8gdGhlIGNvbnN0cnVjdG9yLCBpbiB0aGUgb3JkZXIgcHJvdmlkZWQuXG4gKlxuICogQ29udmVydHMgUGF5bG9hZHMgdG8gdmFsdWVzIGJhc2VkIG9uIHRoZSBgUGF5bG9hZC5tZXRhZGF0YS5lbmNvZGluZ2AgZmllbGQsIHdoaWNoIG1hdGNoZXMgdGhlIHtAbGluayBQYXlsb2FkQ29udmVydGVyV2l0aEVuY29kaW5nLmVuY29kaW5nVHlwZX1cbiAqIG9mIHRoZSBjb252ZXJ0ZXIgdGhhdCBjcmVhdGVkIHRoZSBQYXlsb2FkLlxuICovXG5leHBvcnQgY2xhc3MgQ29tcG9zaXRlUGF5bG9hZENvbnZlcnRlciBpbXBsZW1lbnRzIFBheWxvYWRDb252ZXJ0ZXIge1xuICByZWFkb25seSBjb252ZXJ0ZXJzOiBQYXlsb2FkQ29udmVydGVyV2l0aEVuY29kaW5nW107XG4gIHJlYWRvbmx5IGNvbnZlcnRlckJ5RW5jb2Rpbmc6IE1hcDxzdHJpbmcsIFBheWxvYWRDb252ZXJ0ZXJXaXRoRW5jb2Rpbmc+ID0gbmV3IE1hcCgpO1xuXG4gIGNvbnN0cnVjdG9yKC4uLmNvbnZlcnRlcnM6IFBheWxvYWRDb252ZXJ0ZXJXaXRoRW5jb2RpbmdbXSkge1xuICAgIGlmIChjb252ZXJ0ZXJzLmxlbmd0aCA9PT0gMCkge1xuICAgICAgdGhyb3cgbmV3IFBheWxvYWRDb252ZXJ0ZXJFcnJvcignTXVzdCBwcm92aWRlIGF0IGxlYXN0IG9uZSBQYXlsb2FkQ29udmVydGVyV2l0aEVuY29kaW5nJyk7XG4gICAgfVxuXG4gICAgdGhpcy5jb252ZXJ0ZXJzID0gY29udmVydGVycztcbiAgICBmb3IgKGNvbnN0IGNvbnZlcnRlciBvZiBjb252ZXJ0ZXJzKSB7XG4gICAgICB0aGlzLmNvbnZlcnRlckJ5RW5jb2Rpbmcuc2V0KGNvbnZlcnRlci5lbmNvZGluZ1R5cGUsIGNvbnZlcnRlcik7XG4gICAgfVxuICB9XG5cbiAgLyoqXG4gICAqIFRyaWVzIHRvIHJ1biBgLnRvUGF5bG9hZCh2YWx1ZSlgIG9uIGVhY2ggY29udmVydGVyIGluIHRoZSBvcmRlciBwcm92aWRlZCBhdCBjb25zdHJ1Y3Rpb24uXG4gICAqIFJldHVybnMgdGhlIGZpcnN0IHN1Y2Nlc3NmdWwgcmVzdWx0LCB0aHJvd3Mge0BsaW5rIFZhbHVlRXJyb3J9IGlmIHRoZXJlIGlzIG5vIGNvbnZlcnRlciB0aGF0IGNhbiBoYW5kbGUgdGhlIHZhbHVlLlxuICAgKi9cbiAgcHVibGljIHRvUGF5bG9hZDxUPih2YWx1ZTogVCk6IFBheWxvYWQge1xuICAgIGZvciAoY29uc3QgY29udmVydGVyIG9mIHRoaXMuY29udmVydGVycykge1xuICAgICAgY29uc3QgcmVzdWx0ID0gY29udmVydGVyLnRvUGF5bG9hZCh2YWx1ZSk7XG4gICAgICBpZiAocmVzdWx0ICE9PSB1bmRlZmluZWQpIHtcbiAgICAgICAgcmV0dXJuIHJlc3VsdDtcbiAgICAgIH1cbiAgICB9XG5cbiAgICB0aHJvdyBuZXcgVmFsdWVFcnJvcihgVW5hYmxlIHRvIGNvbnZlcnQgJHt2YWx1ZX0gdG8gcGF5bG9hZGApO1xuICB9XG5cbiAgLyoqXG4gICAqIFJ1biB7QGxpbmsgUGF5bG9hZENvbnZlcnRlcldpdGhFbmNvZGluZy5mcm9tUGF5bG9hZH0gYmFzZWQgb24gdGhlIGBlbmNvZGluZ2AgbWV0YWRhdGEgb2YgdGhlIHtAbGluayBQYXlsb2FkfS5cbiAgICovXG4gIHB1YmxpYyBmcm9tUGF5bG9hZDxUPihwYXlsb2FkOiBQYXlsb2FkKTogVCB7XG4gICAgaWYgKHBheWxvYWQubWV0YWRhdGEgPT09IHVuZGVmaW5lZCB8fCBwYXlsb2FkLm1ldGFkYXRhID09PSBudWxsKSB7XG4gICAgICB0aHJvdyBuZXcgVmFsdWVFcnJvcignTWlzc2luZyBwYXlsb2FkIG1ldGFkYXRhJyk7XG4gICAgfVxuICAgIGNvbnN0IGVuY29kaW5nID0gZGVjb2RlKHBheWxvYWQubWV0YWRhdGFbTUVUQURBVEFfRU5DT0RJTkdfS0VZXSk7XG4gICAgY29uc3QgY29udmVydGVyID0gdGhpcy5jb252ZXJ0ZXJCeUVuY29kaW5nLmdldChlbmNvZGluZyk7XG4gICAgaWYgKGNvbnZlcnRlciA9PT0gdW5kZWZpbmVkKSB7XG4gICAgICB0aHJvdyBuZXcgVmFsdWVFcnJvcihgVW5rbm93biBlbmNvZGluZzogJHtlbmNvZGluZ31gKTtcbiAgICB9XG4gICAgcmV0dXJuIGNvbnZlcnRlci5mcm9tUGF5bG9hZChwYXlsb2FkKTtcbiAgfVxufVxuXG4vKipcbiAqIENvbnZlcnRzIGJldHdlZW4gSlMgdW5kZWZpbmVkIGFuZCBOVUxMIFBheWxvYWRcbiAqL1xuZXhwb3J0IGNsYXNzIFVuZGVmaW5lZFBheWxvYWRDb252ZXJ0ZXIgaW1wbGVtZW50cyBQYXlsb2FkQ29udmVydGVyV2l0aEVuY29kaW5nIHtcbiAgcHVibGljIGVuY29kaW5nVHlwZSA9IGVuY29kaW5nVHlwZXMuTUVUQURBVEFfRU5DT0RJTkdfTlVMTDtcblxuICBwdWJsaWMgdG9QYXlsb2FkKHZhbHVlOiB1bmtub3duKTogUGF5bG9hZCB8IHVuZGVmaW5lZCB7XG4gICAgaWYgKHZhbHVlICE9PSB1bmRlZmluZWQpIHtcbiAgICAgIHJldHVybiB1bmRlZmluZWQ7XG4gICAgfVxuXG4gICAgcmV0dXJuIHtcbiAgICAgIG1ldGFkYXRhOiB7XG4gICAgICAgIFtNRVRBREFUQV9FTkNPRElOR19LRVldOiBlbmNvZGluZ0tleXMuTUVUQURBVEFfRU5DT0RJTkdfTlVMTCxcbiAgICAgIH0sXG4gICAgfTtcbiAgfVxuXG4gIHB1YmxpYyBmcm9tUGF5bG9hZDxUPihfY29udGVudDogUGF5bG9hZCk6IFQge1xuICAgIHJldHVybiB1bmRlZmluZWQgYXMgYW55OyAvLyBKdXN0IHJldHVybiB1bmRlZmluZWRcbiAgfVxufVxuXG4vKipcbiAqIENvbnZlcnRzIGJldHdlZW4gYmluYXJ5IGRhdGEgdHlwZXMgYW5kIFJBVyBQYXlsb2FkXG4gKi9cbmV4cG9ydCBjbGFzcyBCaW5hcnlQYXlsb2FkQ29udmVydGVyIGltcGxlbWVudHMgUGF5bG9hZENvbnZlcnRlcldpdGhFbmNvZGluZyB7XG4gIHB1YmxpYyBlbmNvZGluZ1R5cGUgPSBlbmNvZGluZ1R5cGVzLk1FVEFEQVRBX0VOQ09ESU5HX1JBVztcblxuICBwdWJsaWMgdG9QYXlsb2FkKHZhbHVlOiB1bmtub3duKTogUGF5bG9hZCB8IHVuZGVmaW5lZCB7XG4gICAgaWYgKCEodmFsdWUgaW5zdGFuY2VvZiBVaW50OEFycmF5KSkge1xuICAgICAgcmV0dXJuIHVuZGVmaW5lZDtcbiAgICB9XG5cbiAgICByZXR1cm4ge1xuICAgICAgbWV0YWRhdGE6IHtcbiAgICAgICAgW01FVEFEQVRBX0VOQ09ESU5HX0tFWV06IGVuY29kaW5nS2V5cy5NRVRBREFUQV9FTkNPRElOR19SQVcsXG4gICAgICB9LFxuICAgICAgZGF0YTogdmFsdWUsXG4gICAgfTtcbiAgfVxuXG4gIHB1YmxpYyBmcm9tUGF5bG9hZDxUPihjb250ZW50OiBQYXlsb2FkKTogVCB7XG4gICAgcmV0dXJuIChcbiAgICAgIC8vIFdyYXAgd2l0aCBVaW50OEFycmF5IGZyb20gdGhpcyBjb250ZXh0IHRvIGVuc3VyZSBgaW5zdGFuY2VvZmAgd29ya3NcbiAgICAgIChcbiAgICAgICAgY29udGVudC5kYXRhID8gbmV3IFVpbnQ4QXJyYXkoY29udGVudC5kYXRhLmJ1ZmZlciwgY29udGVudC5kYXRhLmJ5dGVPZmZzZXQsIGNvbnRlbnQuZGF0YS5sZW5ndGgpIDogY29udGVudC5kYXRhXG4gICAgICApIGFzIGFueVxuICAgICk7XG4gIH1cbn1cblxuLyoqXG4gKiBDb252ZXJ0cyBiZXR3ZWVuIG5vbi11bmRlZmluZWQgdmFsdWVzIGFuZCBzZXJpYWxpemVkIEpTT04gUGF5bG9hZFxuICovXG5leHBvcnQgY2xhc3MgSnNvblBheWxvYWRDb252ZXJ0ZXIgaW1wbGVtZW50cyBQYXlsb2FkQ29udmVydGVyV2l0aEVuY29kaW5nIHtcbiAgcHVibGljIGVuY29kaW5nVHlwZSA9IGVuY29kaW5nVHlwZXMuTUVUQURBVEFfRU5DT0RJTkdfSlNPTjtcblxuICBwdWJsaWMgdG9QYXlsb2FkKHZhbHVlOiB1bmtub3duKTogUGF5bG9hZCB8IHVuZGVmaW5lZCB7XG4gICAgaWYgKHZhbHVlID09PSB1bmRlZmluZWQpIHtcbiAgICAgIHJldHVybiB1bmRlZmluZWQ7XG4gICAgfVxuXG4gICAgbGV0IGpzb247XG4gICAgdHJ5IHtcbiAgICAgIGpzb24gPSBKU09OLnN0cmluZ2lmeSh2YWx1ZSk7XG4gICAgfSBjYXRjaCAoX2Vycikge1xuICAgICAgcmV0dXJuIHVuZGVmaW5lZDtcbiAgICB9XG5cbiAgICByZXR1cm4ge1xuICAgICAgbWV0YWRhdGE6IHtcbiAgICAgICAgW01FVEFEQVRBX0VOQ09ESU5HX0tFWV06IGVuY29kaW5nS2V5cy5NRVRBREFUQV9FTkNPRElOR19KU09OLFxuICAgICAgfSxcbiAgICAgIGRhdGE6IGVuY29kZShqc29uKSxcbiAgICB9O1xuICB9XG5cbiAgcHVibGljIGZyb21QYXlsb2FkPFQ+KGNvbnRlbnQ6IFBheWxvYWQpOiBUIHtcbiAgICBpZiAoY29udGVudC5kYXRhID09PSB1bmRlZmluZWQgfHwgY29udGVudC5kYXRhID09PSBudWxsKSB7XG4gICAgICB0aHJvdyBuZXcgVmFsdWVFcnJvcignR290IHBheWxvYWQgd2l0aCBubyBkYXRhJyk7XG4gICAgfVxuICAgIHJldHVybiBKU09OLnBhcnNlKGRlY29kZShjb250ZW50LmRhdGEpKTtcbiAgfVxufVxuXG4vKipcbiAqIENvbnZlcnRzIFNlYXJjaCBBdHRyaWJ1dGUgdmFsdWVzIHVzaW5nIEpzb25QYXlsb2FkQ29udmVydGVyXG4gKi9cbmV4cG9ydCBjbGFzcyBTZWFyY2hBdHRyaWJ1dGVQYXlsb2FkQ29udmVydGVyIGltcGxlbWVudHMgUGF5bG9hZENvbnZlcnRlciB7XG4gIGpzb25Db252ZXJ0ZXIgPSBuZXcgSnNvblBheWxvYWRDb252ZXJ0ZXIoKTtcbiAgdmFsaWROb25EYXRlVHlwZXMgPSBbJ3N0cmluZycsICdudW1iZXInLCAnYm9vbGVhbiddO1xuXG4gIHB1YmxpYyB0b1BheWxvYWQodmFsdWVzOiB1bmtub3duKTogUGF5bG9hZCB7XG4gICAgaWYgKCFBcnJheS5pc0FycmF5KHZhbHVlcykpIHtcbiAgICAgIHRocm93IG5ldyBWYWx1ZUVycm9yKGBTZWFyY2hBdHRyaWJ1dGUgdmFsdWUgbXVzdCBiZSBhbiBhcnJheWApO1xuICAgIH1cblxuICAgIGlmICh2YWx1ZXMubGVuZ3RoID4gMCkge1xuICAgICAgY29uc3QgZmlyc3RWYWx1ZSA9IHZhbHVlc1swXTtcbiAgICAgIGNvbnN0IGZpcnN0VHlwZSA9IHR5cGVvZiBmaXJzdFZhbHVlO1xuICAgICAgaWYgKGZpcnN0VHlwZSA9PT0gJ29iamVjdCcpIHtcbiAgICAgICAgZm9yIChjb25zdCBbaWR4LCB2YWx1ZV0gb2YgdmFsdWVzLmVudHJpZXMoKSkge1xuICAgICAgICAgIGlmICghKHZhbHVlIGluc3RhbmNlb2YgRGF0ZSkpIHtcbiAgICAgICAgICAgIHRocm93IG5ldyBWYWx1ZUVycm9yKFxuICAgICAgICAgICAgICBgU2VhcmNoQXR0cmlidXRlIHZhbHVlcyBtdXN0IGFycmF5cyBvZiBzdHJpbmdzLCBudW1iZXJzLCBib29sZWFucywgb3IgRGF0ZXMuIFRoZSB2YWx1ZSAke3ZhbHVlfSBhdCBpbmRleCAke2lkeH0gaXMgb2YgdHlwZSAke3R5cGVvZiB2YWx1ZX1gXG4gICAgICAgICAgICApO1xuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgfSBlbHNlIHtcbiAgICAgICAgaWYgKCF0aGlzLnZhbGlkTm9uRGF0ZVR5cGVzLmluY2x1ZGVzKGZpcnN0VHlwZSkpIHtcbiAgICAgICAgICB0aHJvdyBuZXcgVmFsdWVFcnJvcihgU2VhcmNoQXR0cmlidXRlIGFycmF5IHZhbHVlcyBtdXN0IGJlOiBzdHJpbmcgfCBudW1iZXIgfCBib29sZWFuIHwgRGF0ZWApO1xuICAgICAgICB9XG5cbiAgICAgICAgZm9yIChjb25zdCBbaWR4LCB2YWx1ZV0gb2YgdmFsdWVzLmVudHJpZXMoKSkge1xuICAgICAgICAgIGlmICh0eXBlb2YgdmFsdWUgIT09IGZpcnN0VHlwZSkge1xuICAgICAgICAgICAgdGhyb3cgbmV3IFZhbHVlRXJyb3IoXG4gICAgICAgICAgICAgIGBBbGwgU2VhcmNoQXR0cmlidXRlIGFycmF5IHZhbHVlcyBtdXN0IGJlIG9mIHRoZSBzYW1lIHR5cGUuIFRoZSBmaXJzdCB2YWx1ZSAke2ZpcnN0VmFsdWV9IG9mIHR5cGUgJHtmaXJzdFR5cGV9IGRvZXNuJ3QgbWF0Y2ggdmFsdWUgJHt2YWx1ZX0gb2YgdHlwZSAke3R5cGVvZiB2YWx1ZX0gYXQgaW5kZXggJHtpZHh9YFxuICAgICAgICAgICAgKTtcbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9XG5cbiAgICAvLyBKU09OLnN0cmluZ2lmeSB0YWtlcyBjYXJlIG9mIGNvbnZlcnRpbmcgRGF0ZXMgdG8gSVNPIHN0cmluZ3NcbiAgICBjb25zdCByZXQgPSB0aGlzLmpzb25Db252ZXJ0ZXIudG9QYXlsb2FkKHZhbHVlcyk7XG4gICAgaWYgKHJldCA9PT0gdW5kZWZpbmVkKSB7XG4gICAgICB0aHJvdyBuZXcgVmFsdWVFcnJvcignQ291bGQgbm90IGNvbnZlcnQgc2VhcmNoIGF0dHJpYnV0ZXMgdG8gcGF5bG9hZHMnKTtcbiAgICB9XG4gICAgcmV0dXJuIHJldDtcbiAgfVxuXG4gIC8qKlxuICAgKiBEYXRldGltZSBTZWFyY2ggQXR0cmlidXRlIHZhbHVlcyBhcmUgY29udmVydGVkIHRvIGBEYXRlYHNcbiAgICovXG4gIHB1YmxpYyBmcm9tUGF5bG9hZDxUPihwYXlsb2FkOiBQYXlsb2FkKTogVCB7XG4gICAgaWYgKHBheWxvYWQubWV0YWRhdGEgPT09IHVuZGVmaW5lZCB8fCBwYXlsb2FkLm1ldGFkYXRhID09PSBudWxsKSB7XG4gICAgICB0aHJvdyBuZXcgVmFsdWVFcnJvcignTWlzc2luZyBwYXlsb2FkIG1ldGFkYXRhJyk7XG4gICAgfVxuXG4gICAgY29uc3QgdmFsdWUgPSB0aGlzLmpzb25Db252ZXJ0ZXIuZnJvbVBheWxvYWQocGF5bG9hZCk7XG4gICAgbGV0IGFycmF5V3JhcHBlZFZhbHVlID0gQXJyYXkuaXNBcnJheSh2YWx1ZSkgPyB2YWx1ZSA6IFt2YWx1ZV07XG5cbiAgICBjb25zdCBzZWFyY2hBdHRyaWJ1dGVUeXBlID0gZGVjb2RlKHBheWxvYWQubWV0YWRhdGEudHlwZSk7XG4gICAgaWYgKHNlYXJjaEF0dHJpYnV0ZVR5cGUgPT09ICdEYXRldGltZScpIHtcbiAgICAgIGFycmF5V3JhcHBlZFZhbHVlID0gYXJyYXlXcmFwcGVkVmFsdWUubWFwKChkYXRlU3RyaW5nKSA9PiBuZXcgRGF0ZShkYXRlU3RyaW5nKSk7XG4gICAgfVxuICAgIHJldHVybiBhcnJheVdyYXBwZWRWYWx1ZSBhcyB1bmtub3duIGFzIFQ7XG4gIH1cbn1cblxuZXhwb3J0IGNvbnN0IHNlYXJjaEF0dHJpYnV0ZVBheWxvYWRDb252ZXJ0ZXIgPSBuZXcgU2VhcmNoQXR0cmlidXRlUGF5bG9hZENvbnZlcnRlcigpO1xuXG5leHBvcnQgY2xhc3MgRGVmYXVsdFBheWxvYWRDb252ZXJ0ZXIgZXh0ZW5kcyBDb21wb3NpdGVQYXlsb2FkQ29udmVydGVyIHtcbiAgLy8gTWF0Y2ggdGhlIG9yZGVyIHVzZWQgaW4gb3RoZXIgU0RLcywgYnV0IGV4Y2x1ZGUgUHJvdG9idWYgY29udmVydGVycyBzbyB0aGF0IHRoZSBjb2RlLCBpbmNsdWRpbmdcbiAgLy8gYHByb3RvMy1qc29uLXNlcmlhbGl6ZXJgLCBkb2Vzbid0IHRha2Ugc3BhY2UgaW4gV29ya2Zsb3cgYnVuZGxlcyB0aGF0IGRvbid0IHVzZSBQcm90b2J1ZnMuIFRvIHVzZSBQcm90b2J1ZnMsIHVzZVxuICAvLyB7QGxpbmsgRGVmYXVsdFBheWxvYWRDb252ZXJ0ZXJXaXRoUHJvdG9idWZzfS5cbiAgLy9cbiAgLy8gR28gU0RLOlxuICAvLyBodHRwczovL2dpdGh1Yi5jb20vdGVtcG9yYWxpby9zZGstZ28vYmxvYi81ZTU2NDVmMGM1NTBkY2Y3MTdjMDk1YWUzMmM3NmE3MDg3ZDJlOTg1L2NvbnZlcnRlci9kZWZhdWx0X2RhdGFfY29udmVydGVyLmdvI0wyOFxuICBjb25zdHJ1Y3RvcigpIHtcbiAgICBzdXBlcihuZXcgVW5kZWZpbmVkUGF5bG9hZENvbnZlcnRlcigpLCBuZXcgQmluYXJ5UGF5bG9hZENvbnZlcnRlcigpLCBuZXcgSnNvblBheWxvYWRDb252ZXJ0ZXIoKSk7XG4gIH1cbn1cblxuLyoqXG4gKiBUaGUgZGVmYXVsdCB7QGxpbmsgUGF5bG9hZENvbnZlcnRlcn0gdXNlZCBieSB0aGUgU0RLLiBTdXBwb3J0cyBgVWludDhBcnJheWAgYW5kIEpTT04gc2VyaWFsaXphYmxlcyAoc28gaWZcbiAqIHtAbGluayBodHRwczovL2RldmVsb3Blci5tb3ppbGxhLm9yZy9lbi1VUy9kb2NzL1dlYi9KYXZhU2NyaXB0L1JlZmVyZW5jZS9HbG9iYWxfT2JqZWN0cy9KU09OL3N0cmluZ2lmeSNkZXNjcmlwdGlvbiB8IGBKU09OLnN0cmluZ2lmeSh5b3VyQXJnT3JSZXR2YWwpYH1cbiAqIHdvcmtzLCB0aGUgZGVmYXVsdCBwYXlsb2FkIGNvbnZlcnRlciB3aWxsIHdvcmspLlxuICpcbiAqIFRvIGFsc28gc3VwcG9ydCBQcm90b2J1ZnMsIGNyZWF0ZSBhIGN1c3RvbSBwYXlsb2FkIGNvbnZlcnRlciB3aXRoIHtAbGluayBEZWZhdWx0UGF5bG9hZENvbnZlcnRlcn06XG4gKlxuICogYGNvbnN0IG15Q29udmVydGVyID0gbmV3IERlZmF1bHRQYXlsb2FkQ29udmVydGVyKHsgcHJvdG9idWZSb290IH0pYFxuICovXG5leHBvcnQgY29uc3QgZGVmYXVsdFBheWxvYWRDb252ZXJ0ZXIgPSBuZXcgRGVmYXVsdFBheWxvYWRDb252ZXJ0ZXIoKTtcbiIsImltcG9ydCB7IGVuY29kZSB9IGZyb20gJy4uL2VuY29kaW5nJztcblxuZXhwb3J0IGNvbnN0IE1FVEFEQVRBX0VOQ09ESU5HX0tFWSA9ICdlbmNvZGluZyc7XG5leHBvcnQgY29uc3QgZW5jb2RpbmdUeXBlcyA9IHtcbiAgTUVUQURBVEFfRU5DT0RJTkdfTlVMTDogJ2JpbmFyeS9udWxsJyxcbiAgTUVUQURBVEFfRU5DT0RJTkdfUkFXOiAnYmluYXJ5L3BsYWluJyxcbiAgTUVUQURBVEFfRU5DT0RJTkdfSlNPTjogJ2pzb24vcGxhaW4nLFxuICBNRVRBREFUQV9FTkNPRElOR19QUk9UT0JVRl9KU09OOiAnanNvbi9wcm90b2J1ZicsXG4gIE1FVEFEQVRBX0VOQ09ESU5HX1BST1RPQlVGOiAnYmluYXJ5L3Byb3RvYnVmJyxcbn0gYXMgY29uc3Q7XG5leHBvcnQgdHlwZSBFbmNvZGluZ1R5cGUgPSAodHlwZW9mIGVuY29kaW5nVHlwZXMpW2tleW9mIHR5cGVvZiBlbmNvZGluZ1R5cGVzXTtcblxuZXhwb3J0IGNvbnN0IGVuY29kaW5nS2V5cyA9IHtcbiAgTUVUQURBVEFfRU5DT0RJTkdfTlVMTDogZW5jb2RlKGVuY29kaW5nVHlwZXMuTUVUQURBVEFfRU5DT0RJTkdfTlVMTCksXG4gIE1FVEFEQVRBX0VOQ09ESU5HX1JBVzogZW5jb2RlKGVuY29kaW5nVHlwZXMuTUVUQURBVEFfRU5DT0RJTkdfUkFXKSxcbiAgTUVUQURBVEFfRU5DT0RJTkdfSlNPTjogZW5jb2RlKGVuY29kaW5nVHlwZXMuTUVUQURBVEFfRU5DT0RJTkdfSlNPTiksXG4gIE1FVEFEQVRBX0VOQ09ESU5HX1BST1RPQlVGX0pTT046IGVuY29kZShlbmNvZGluZ1R5cGVzLk1FVEFEQVRBX0VOQ09ESU5HX1BST1RPQlVGX0pTT04pLFxuICBNRVRBREFUQV9FTkNPRElOR19QUk9UT0JVRjogZW5jb2RlKGVuY29kaW5nVHlwZXMuTUVUQURBVEFfRU5DT0RJTkdfUFJPVE9CVUYpLFxufSBhcyBjb25zdDtcblxuZXhwb3J0IGNvbnN0IE1FVEFEQVRBX01FU1NBR0VfVFlQRV9LRVkgPSAnbWVzc2FnZVR5cGUnO1xuIiwiaW1wb3J0ICogYXMgdGltZSBmcm9tICcuL3RpbWUnO1xuaW1wb3J0IHsgdHlwZSBUaW1lc3RhbXAsIER1cmF0aW9uIH0gZnJvbSAnLi90aW1lJztcblxuLyoqXG4gKiBMb3NzeSBjb252ZXJzaW9uIGZ1bmN0aW9uIGZyb20gVGltZXN0YW1wIHRvIG51bWJlciBkdWUgdG8gcG9zc2libGUgb3ZlcmZsb3cuXG4gKiBJZiB0cyBpcyBudWxsIG9yIHVuZGVmaW5lZCByZXR1cm5zIHVuZGVmaW5lZC5cbiAqXG4gKiBAaGlkZGVuXG4gKiBAZGVwcmVjYXRlZCAtIG1lYW50IGZvciBpbnRlcm5hbCB1c2Ugb25seVxuICovXG5leHBvcnQgZnVuY3Rpb24gb3B0aW9uYWxUc1RvTXModHM6IFRpbWVzdGFtcCB8IG51bGwgfCB1bmRlZmluZWQpOiBudW1iZXIgfCB1bmRlZmluZWQge1xuICByZXR1cm4gdGltZS5vcHRpb25hbFRzVG9Ncyh0cyk7XG59XG5cbi8qKlxuICogTG9zc3kgY29udmVyc2lvbiBmdW5jdGlvbiBmcm9tIFRpbWVzdGFtcCB0byBudW1iZXIgZHVlIHRvIHBvc3NpYmxlIG92ZXJmbG93XG4gKlxuICogQGhpZGRlblxuICogQGRlcHJlY2F0ZWQgLSBtZWFudCBmb3IgaW50ZXJuYWwgdXNlIG9ubHlcbiAqIEBkZXByZWNhdGVkIC0gbWVhbnQgZm9yIGludGVybmFsIHVzZSBvbmx5XG4gKi9cbmV4cG9ydCBmdW5jdGlvbiB0c1RvTXModHM6IFRpbWVzdGFtcCB8IG51bGwgfCB1bmRlZmluZWQpOiBudW1iZXIge1xuICByZXR1cm4gdGltZS50c1RvTXModHMpO1xufVxuXG4vKipcbiAqIEBoaWRkZW5cbiAqIEBkZXByZWNhdGVkIC0gbWVhbnQgZm9yIGludGVybmFsIHVzZSBvbmx5XG4gKi9cbmV4cG9ydCBmdW5jdGlvbiBtc051bWJlclRvVHMobWlsbGlzOiBudW1iZXIpOiBUaW1lc3RhbXAge1xuICByZXR1cm4gdGltZS5tc051bWJlclRvVHMobWlsbGlzKTtcbn1cblxuLyoqXG4gKiBAaGlkZGVuXG4gKiBAZGVwcmVjYXRlZCAtIG1lYW50IGZvciBpbnRlcm5hbCB1c2Ugb25seVxuICovXG5leHBvcnQgZnVuY3Rpb24gbXNUb1RzKHN0cjogRHVyYXRpb24pOiBUaW1lc3RhbXAge1xuICByZXR1cm4gdGltZS5tc1RvVHMoc3RyKTtcbn1cblxuLyoqXG4gKiBAaGlkZGVuXG4gKiBAZGVwcmVjYXRlZCAtIG1lYW50IGZvciBpbnRlcm5hbCB1c2Ugb25seVxuICovXG5leHBvcnQgZnVuY3Rpb24gbXNPcHRpb25hbFRvVHMoc3RyOiBEdXJhdGlvbiB8IHVuZGVmaW5lZCk6IFRpbWVzdGFtcCB8IHVuZGVmaW5lZCB7XG4gIHJldHVybiB0aW1lLm1zT3B0aW9uYWxUb1RzKHN0cik7XG59XG5cbi8qKlxuICogQGhpZGRlblxuICogQGRlcHJlY2F0ZWQgLSBtZWFudCBmb3IgaW50ZXJuYWwgdXNlIG9ubHlcbiAqL1xuZXhwb3J0IGZ1bmN0aW9uIG1zT3B0aW9uYWxUb051bWJlcih2YWw6IER1cmF0aW9uIHwgdW5kZWZpbmVkKTogbnVtYmVyIHwgdW5kZWZpbmVkIHtcbiAgcmV0dXJuIHRpbWUubXNPcHRpb25hbFRvTnVtYmVyKHZhbCk7XG59XG5cbi8qKlxuICogQGhpZGRlblxuICogQGRlcHJlY2F0ZWQgLSBtZWFudCBmb3IgaW50ZXJuYWwgdXNlIG9ubHlcbiAqL1xuZXhwb3J0IGZ1bmN0aW9uIG1zVG9OdW1iZXIodmFsOiBEdXJhdGlvbik6IG51bWJlciB7XG4gIHJldHVybiB0aW1lLm1zVG9OdW1iZXIodmFsKTtcbn1cblxuLyoqXG4gKiBAaGlkZGVuXG4gKiBAZGVwcmVjYXRlZCAtIG1lYW50IGZvciBpbnRlcm5hbCB1c2Ugb25seVxuICovXG5leHBvcnQgZnVuY3Rpb24gdHNUb0RhdGUodHM6IFRpbWVzdGFtcCk6IERhdGUge1xuICByZXR1cm4gdGltZS50c1RvRGF0ZSh0cyk7XG59XG5cbi8qKlxuICogQGhpZGRlblxuICogQGRlcHJlY2F0ZWQgLSBtZWFudCBmb3IgaW50ZXJuYWwgdXNlIG9ubHlcbiAqL1xuZXhwb3J0IGZ1bmN0aW9uIG9wdGlvbmFsVHNUb0RhdGUodHM6IFRpbWVzdGFtcCB8IG51bGwgfCB1bmRlZmluZWQpOiBEYXRlIHwgdW5kZWZpbmVkIHtcbiAgcmV0dXJuIHRpbWUub3B0aW9uYWxUc1RvRGF0ZSh0cyk7XG59XG4iLCIvLyBQYXN0ZWQgd2l0aCBtb2RpZmljYXRpb25zIGZyb206IGh0dHBzOi8vcmF3LmdpdGh1YnVzZXJjb250ZW50LmNvbS9hbm9ueWNvL0Zhc3Rlc3RTbWFsbGVzdFRleHRFbmNvZGVyRGVjb2Rlci9tYXN0ZXIvRW5jb2RlckRlY29kZXJUb2dldGhlci5zcmMuanNcbi8qIGVzbGludCBuby1mYWxsdGhyb3VnaDogMCAqL1xuXG5jb25zdCBmcm9tQ2hhckNvZGUgPSBTdHJpbmcuZnJvbUNoYXJDb2RlO1xuY29uc3QgZW5jb2RlclJlZ2V4cCA9IC9bXFx4ODAtXFx1RDdmZlxcdURDMDAtXFx1RkZGRl18W1xcdUQ4MDAtXFx1REJGRl1bXFx1REMwMC1cXHVERkZGXT8vZztcbmNvbnN0IHRtcEJ1ZmZlclUxNiA9IG5ldyBVaW50MTZBcnJheSgzMik7XG5cbmV4cG9ydCBjbGFzcyBUZXh0RGVjb2RlciB7XG4gIGRlY29kZShpbnB1dEFycmF5T3JCdWZmZXI6IFVpbnQ4QXJyYXkgfCBBcnJheUJ1ZmZlciB8IFNoYXJlZEFycmF5QnVmZmVyKTogc3RyaW5nIHtcbiAgICBjb25zdCBpbnB1dEFzOCA9IGlucHV0QXJyYXlPckJ1ZmZlciBpbnN0YW5jZW9mIFVpbnQ4QXJyYXkgPyBpbnB1dEFycmF5T3JCdWZmZXIgOiBuZXcgVWludDhBcnJheShpbnB1dEFycmF5T3JCdWZmZXIpO1xuXG4gICAgbGV0IHJlc3VsdGluZ1N0cmluZyA9ICcnLFxuICAgICAgdG1wU3RyID0gJycsXG4gICAgICBpbmRleCA9IDAsXG4gICAgICBuZXh0RW5kID0gMCxcbiAgICAgIGNwMCA9IDAsXG4gICAgICBjb2RlUG9pbnQgPSAwLFxuICAgICAgbWluQml0cyA9IDAsXG4gICAgICBjcDEgPSAwLFxuICAgICAgcG9zID0gMCxcbiAgICAgIHRtcCA9IC0xO1xuICAgIGNvbnN0IGxlbiA9IGlucHV0QXM4Lmxlbmd0aCB8IDA7XG4gICAgY29uc3QgbGVuTWludXMzMiA9IChsZW4gLSAzMikgfCAwO1xuICAgIC8vIE5vdGUgdGhhdCB0bXAgcmVwcmVzZW50cyB0aGUgMm5kIGhhbGYgb2YgYSBzdXJyb2dhdGUgcGFpciBpbmNhc2UgYSBzdXJyb2dhdGUgZ2V0cyBkaXZpZGVkIGJldHdlZW4gYmxvY2tzXG4gICAgZm9yICg7IGluZGV4IDwgbGVuOyApIHtcbiAgICAgIG5leHRFbmQgPSBpbmRleCA8PSBsZW5NaW51czMyID8gMzIgOiAobGVuIC0gaW5kZXgpIHwgMDtcbiAgICAgIGZvciAoOyBwb3MgPCBuZXh0RW5kOyBpbmRleCA9IChpbmRleCArIDEpIHwgMCwgcG9zID0gKHBvcyArIDEpIHwgMCkge1xuICAgICAgICBjcDAgPSBpbnB1dEFzOFtpbmRleF0gJiAweGZmO1xuICAgICAgICBzd2l0Y2ggKGNwMCA+PiA0KSB7XG4gICAgICAgICAgY2FzZSAxNTpcbiAgICAgICAgICAgIGNwMSA9IGlucHV0QXM4WyhpbmRleCA9IChpbmRleCArIDEpIHwgMCldICYgMHhmZjtcbiAgICAgICAgICAgIGlmIChjcDEgPj4gNiAhPT0gMGIxMCB8fCAwYjExMTEwMTExIDwgY3AwKSB7XG4gICAgICAgICAgICAgIGluZGV4ID0gKGluZGV4IC0gMSkgfCAwO1xuICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGNvZGVQb2ludCA9ICgoY3AwICYgMGIxMTEpIDw8IDYpIHwgKGNwMSAmIDBiMDAxMTExMTEpO1xuICAgICAgICAgICAgbWluQml0cyA9IDU7IC8vIDIwIGVuc3VyZXMgaXQgbmV2ZXIgcGFzc2VzIC0+IGFsbCBpbnZhbGlkIHJlcGxhY2VtZW50c1xuICAgICAgICAgICAgY3AwID0gMHgxMDA7IC8vICBrZWVwIHRyYWNrIG9mIHRoIGJpdCBzaXplXG4gICAgICAgICAgY2FzZSAxNDpcbiAgICAgICAgICAgIGNwMSA9IGlucHV0QXM4WyhpbmRleCA9IChpbmRleCArIDEpIHwgMCldICYgMHhmZjtcbiAgICAgICAgICAgIGNvZGVQb2ludCA8PD0gNjtcbiAgICAgICAgICAgIGNvZGVQb2ludCB8PSAoKGNwMCAmIDBiMTExMSkgPDwgNikgfCAoY3AxICYgMGIwMDExMTExMSk7XG4gICAgICAgICAgICBtaW5CaXRzID0gY3AxID4+IDYgPT09IDBiMTAgPyAobWluQml0cyArIDQpIHwgMCA6IDI0OyAvLyAyNCBlbnN1cmVzIGl0IG5ldmVyIHBhc3NlcyAtPiBhbGwgaW52YWxpZCByZXBsYWNlbWVudHNcbiAgICAgICAgICAgIGNwMCA9IChjcDAgKyAweDEwMCkgJiAweDMwMDsgLy8ga2VlcCB0cmFjayBvZiB0aCBiaXQgc2l6ZVxuICAgICAgICAgIGNhc2UgMTM6XG4gICAgICAgICAgY2FzZSAxMjpcbiAgICAgICAgICAgIGNwMSA9IGlucHV0QXM4WyhpbmRleCA9IChpbmRleCArIDEpIHwgMCldICYgMHhmZjtcbiAgICAgICAgICAgIGNvZGVQb2ludCA8PD0gNjtcbiAgICAgICAgICAgIGNvZGVQb2ludCB8PSAoKGNwMCAmIDBiMTExMTEpIDw8IDYpIHwgKGNwMSAmIDBiMDAxMTExMTEpO1xuICAgICAgICAgICAgbWluQml0cyA9IChtaW5CaXRzICsgNykgfCAwO1xuXG4gICAgICAgICAgICAvLyBOb3csIHByb2Nlc3MgdGhlIGNvZGUgcG9pbnRcbiAgICAgICAgICAgIGlmIChpbmRleCA8IGxlbiAmJiBjcDEgPj4gNiA9PT0gMGIxMCAmJiBjb2RlUG9pbnQgPj4gbWluQml0cyAmJiBjb2RlUG9pbnQgPCAweDExMDAwMCkge1xuICAgICAgICAgICAgICBjcDAgPSBjb2RlUG9pbnQ7XG4gICAgICAgICAgICAgIGNvZGVQb2ludCA9IChjb2RlUG9pbnQgLSAweDEwMDAwKSB8IDA7XG4gICAgICAgICAgICAgIGlmICgwIDw9IGNvZGVQb2ludCAvKjB4ZmZmZiA8IGNvZGVQb2ludCovKSB7XG4gICAgICAgICAgICAgICAgLy8gQk1QIGNvZGUgcG9pbnRcbiAgICAgICAgICAgICAgICAvL25leHRFbmQgPSBuZXh0RW5kIC0gMXwwO1xuXG4gICAgICAgICAgICAgICAgdG1wID0gKChjb2RlUG9pbnQgPj4gMTApICsgMHhkODAwKSB8IDA7IC8vIGhpZ2hTdXJyb2dhdGVcbiAgICAgICAgICAgICAgICBjcDAgPSAoKGNvZGVQb2ludCAmIDB4M2ZmKSArIDB4ZGMwMCkgfCAwOyAvLyBsb3dTdXJyb2dhdGUgKHdpbGwgYmUgaW5zZXJ0ZWQgbGF0ZXIgaW4gdGhlIHN3aXRjaC1zdGF0ZW1lbnQpXG5cbiAgICAgICAgICAgICAgICBpZiAocG9zIDwgMzEpIHtcbiAgICAgICAgICAgICAgICAgIC8vIG5vdGljZSAzMSBpbnN0ZWFkIG9mIDMyXG4gICAgICAgICAgICAgICAgICB0bXBCdWZmZXJVMTZbcG9zXSA9IHRtcDtcbiAgICAgICAgICAgICAgICAgIHBvcyA9IChwb3MgKyAxKSB8IDA7XG4gICAgICAgICAgICAgICAgICB0bXAgPSAtMTtcbiAgICAgICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgICAgLy8gZWxzZSwgd2UgYXJlIGF0IHRoZSBlbmQgb2YgdGhlIGlucHV0QXM4IGFuZCBsZXQgdG1wMCBiZSBmaWxsZWQgaW4gbGF0ZXIgb25cbiAgICAgICAgICAgICAgICAgIC8vIE5PVEUgdGhhdCBjcDEgaXMgYmVpbmcgdXNlZCBhcyBhIHRlbXBvcmFyeSB2YXJpYWJsZSBmb3IgdGhlIHN3YXBwaW5nIG9mIHRtcCB3aXRoIGNwMFxuICAgICAgICAgICAgICAgICAgY3AxID0gdG1wO1xuICAgICAgICAgICAgICAgICAgdG1wID0gY3AwO1xuICAgICAgICAgICAgICAgICAgY3AwID0gY3AxO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgfSBlbHNlIG5leHRFbmQgPSAobmV4dEVuZCArIDEpIHwgMDsgLy8gYmVjYXVzZSB3ZSBhcmUgYWR2YW5jaW5nIGkgd2l0aG91dCBhZHZhbmNpbmcgcG9zXG4gICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAvLyBpbnZhbGlkIGNvZGUgcG9pbnQgbWVhbnMgcmVwbGFjaW5nIHRoZSB3aG9sZSB0aGluZyB3aXRoIG51bGwgcmVwbGFjZW1lbnQgY2hhcmFjdGVyc1xuICAgICAgICAgICAgICBjcDAgPj49IDg7XG4gICAgICAgICAgICAgIGluZGV4ID0gKGluZGV4IC0gY3AwIC0gMSkgfCAwOyAvLyByZXNldCBpbmRleCAgYmFjayB0byB3aGF0IGl0IHdhcyBiZWZvcmVcbiAgICAgICAgICAgICAgY3AwID0gMHhmZmZkO1xuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAvLyBGaW5hbGx5LCByZXNldCB0aGUgdmFyaWFibGVzIGZvciB0aGUgbmV4dCBnby1hcm91bmRcbiAgICAgICAgICAgIG1pbkJpdHMgPSAwO1xuICAgICAgICAgICAgY29kZVBvaW50ID0gMDtcbiAgICAgICAgICAgIG5leHRFbmQgPSBpbmRleCA8PSBsZW5NaW51czMyID8gMzIgOiAobGVuIC0gaW5kZXgpIHwgMDtcbiAgICAgICAgICAvKmNhc2UgMTE6XG4gICAgICAgIGNhc2UgMTA6XG4gICAgICAgIGNhc2UgOTpcbiAgICAgICAgY2FzZSA4OlxuICAgICAgICAgIGNvZGVQb2ludCA/IGNvZGVQb2ludCA9IDAgOiBjcDAgPSAweGZmZmQ7IC8vIGZpbGwgd2l0aCBpbnZhbGlkIHJlcGxhY2VtZW50IGNoYXJhY3RlclxuICAgICAgICBjYXNlIDc6XG4gICAgICAgIGNhc2UgNjpcbiAgICAgICAgY2FzZSA1OlxuICAgICAgICBjYXNlIDQ6XG4gICAgICAgIGNhc2UgMzpcbiAgICAgICAgY2FzZSAyOlxuICAgICAgICBjYXNlIDE6XG4gICAgICAgIGNhc2UgMDpcbiAgICAgICAgICB0bXBCdWZmZXJVMTZbcG9zXSA9IGNwMDtcbiAgICAgICAgICBjb250aW51ZTsqL1xuICAgICAgICAgIGRlZmF1bHQ6IC8vIGZpbGwgd2l0aCBpbnZhbGlkIHJlcGxhY2VtZW50IGNoYXJhY3RlclxuICAgICAgICAgICAgdG1wQnVmZmVyVTE2W3Bvc10gPSBjcDA7XG4gICAgICAgICAgICBjb250aW51ZTtcbiAgICAgICAgICBjYXNlIDExOlxuICAgICAgICAgIGNhc2UgMTA6XG4gICAgICAgICAgY2FzZSA5OlxuICAgICAgICAgIGNhc2UgODpcbiAgICAgICAgfVxuICAgICAgICB0bXBCdWZmZXJVMTZbcG9zXSA9IDB4ZmZmZDsgLy8gZmlsbCB3aXRoIGludmFsaWQgcmVwbGFjZW1lbnQgY2hhcmFjdGVyXG4gICAgICB9XG4gICAgICB0bXBTdHIgKz0gZnJvbUNoYXJDb2RlKFxuICAgICAgICB0bXBCdWZmZXJVMTZbMF0sXG4gICAgICAgIHRtcEJ1ZmZlclUxNlsxXSxcbiAgICAgICAgdG1wQnVmZmVyVTE2WzJdLFxuICAgICAgICB0bXBCdWZmZXJVMTZbM10sXG4gICAgICAgIHRtcEJ1ZmZlclUxNls0XSxcbiAgICAgICAgdG1wQnVmZmVyVTE2WzVdLFxuICAgICAgICB0bXBCdWZmZXJVMTZbNl0sXG4gICAgICAgIHRtcEJ1ZmZlclUxNls3XSxcbiAgICAgICAgdG1wQnVmZmVyVTE2WzhdLFxuICAgICAgICB0bXBCdWZmZXJVMTZbOV0sXG4gICAgICAgIHRtcEJ1ZmZlclUxNlsxMF0sXG4gICAgICAgIHRtcEJ1ZmZlclUxNlsxMV0sXG4gICAgICAgIHRtcEJ1ZmZlclUxNlsxMl0sXG4gICAgICAgIHRtcEJ1ZmZlclUxNlsxM10sXG4gICAgICAgIHRtcEJ1ZmZlclUxNlsxNF0sXG4gICAgICAgIHRtcEJ1ZmZlclUxNlsxNV0sXG4gICAgICAgIHRtcEJ1ZmZlclUxNlsxNl0sXG4gICAgICAgIHRtcEJ1ZmZlclUxNlsxN10sXG4gICAgICAgIHRtcEJ1ZmZlclUxNlsxOF0sXG4gICAgICAgIHRtcEJ1ZmZlclUxNlsxOV0sXG4gICAgICAgIHRtcEJ1ZmZlclUxNlsyMF0sXG4gICAgICAgIHRtcEJ1ZmZlclUxNlsyMV0sXG4gICAgICAgIHRtcEJ1ZmZlclUxNlsyMl0sXG4gICAgICAgIHRtcEJ1ZmZlclUxNlsyM10sXG4gICAgICAgIHRtcEJ1ZmZlclUxNlsyNF0sXG4gICAgICAgIHRtcEJ1ZmZlclUxNlsyNV0sXG4gICAgICAgIHRtcEJ1ZmZlclUxNlsyNl0sXG4gICAgICAgIHRtcEJ1ZmZlclUxNlsyN10sXG4gICAgICAgIHRtcEJ1ZmZlclUxNlsyOF0sXG4gICAgICAgIHRtcEJ1ZmZlclUxNlsyOV0sXG4gICAgICAgIHRtcEJ1ZmZlclUxNlszMF0sXG4gICAgICAgIHRtcEJ1ZmZlclUxNlszMV1cbiAgICAgICk7XG4gICAgICBpZiAocG9zIDwgMzIpIHRtcFN0ciA9IHRtcFN0ci5zbGljZSgwLCAocG9zIC0gMzIpIHwgMCk7IC8vLSgzMi1wb3MpKTtcbiAgICAgIGlmIChpbmRleCA8IGxlbikge1xuICAgICAgICAvL2Zyb21DaGFyQ29kZS5hcHBseSgwLCB0bXBCdWZmZXJVMTYgOiBVaW50OEFycmF5ID8gIHRtcEJ1ZmZlclUxNi5zdWJhcnJheSgwLHBvcykgOiB0bXBCdWZmZXJVMTYuc2xpY2UoMCxwb3MpKTtcbiAgICAgICAgdG1wQnVmZmVyVTE2WzBdID0gdG1wO1xuICAgICAgICBwb3MgPSB+dG1wID4+PiAzMTsgLy90bXAgIT09IC0xID8gMSA6IDA7XG4gICAgICAgIHRtcCA9IC0xO1xuXG4gICAgICAgIGlmICh0bXBTdHIubGVuZ3RoIDwgcmVzdWx0aW5nU3RyaW5nLmxlbmd0aCkgY29udGludWU7XG4gICAgICB9IGVsc2UgaWYgKHRtcCAhPT0gLTEpIHtcbiAgICAgICAgdG1wU3RyICs9IGZyb21DaGFyQ29kZSh0bXApO1xuICAgICAgfVxuXG4gICAgICByZXN1bHRpbmdTdHJpbmcgKz0gdG1wU3RyO1xuICAgICAgdG1wU3RyID0gJyc7XG4gICAgfVxuXG4gICAgcmV0dXJuIHJlc3VsdGluZ1N0cmluZztcbiAgfVxufVxuXG4vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vL1xuZnVuY3Rpb24gZW5jb2RlclJlcGxhY2VyKG5vbkFzY2lpQ2hhcnM6IHN0cmluZykge1xuICAvLyBtYWtlIHRoZSBVVEYgc3RyaW5nIGludG8gYSBiaW5hcnkgVVRGLTggZW5jb2RlZCBzdHJpbmdcbiAgbGV0IHBvaW50ID0gbm9uQXNjaWlDaGFycy5jaGFyQ29kZUF0KDApIHwgMDtcbiAgaWYgKDB4ZDgwMCA8PSBwb2ludCkge1xuICAgIGlmIChwb2ludCA8PSAweGRiZmYpIHtcbiAgICAgIGNvbnN0IG5leHRjb2RlID0gbm9uQXNjaWlDaGFycy5jaGFyQ29kZUF0KDEpIHwgMDsgLy8gZGVmYXVsdHMgdG8gMCB3aGVuIE5hTiwgY2F1c2luZyBudWxsIHJlcGxhY2VtZW50IGNoYXJhY3RlclxuXG4gICAgICBpZiAoMHhkYzAwIDw9IG5leHRjb2RlICYmIG5leHRjb2RlIDw9IDB4ZGZmZikge1xuICAgICAgICAvL3BvaW50ID0gKChwb2ludCAtIDB4RDgwMCk8PDEwKSArIG5leHRjb2RlIC0gMHhEQzAwICsgMHgxMDAwMHwwO1xuICAgICAgICBwb2ludCA9ICgocG9pbnQgPDwgMTApICsgbmV4dGNvZGUgLSAweDM1ZmRjMDApIHwgMDtcbiAgICAgICAgaWYgKHBvaW50ID4gMHhmZmZmKVxuICAgICAgICAgIHJldHVybiBmcm9tQ2hhckNvZGUoXG4gICAgICAgICAgICAoMHgxZSAvKjBiMTExMTAqLyA8PCAzKSB8IChwb2ludCA+PiAxOCksXG4gICAgICAgICAgICAoMHgyIC8qMGIxMCovIDw8IDYpIHwgKChwb2ludCA+PiAxMikgJiAweDNmKSAvKjBiMDAxMTExMTEqLyxcbiAgICAgICAgICAgICgweDIgLyowYjEwKi8gPDwgNikgfCAoKHBvaW50ID4+IDYpICYgMHgzZikgLyowYjAwMTExMTExKi8sXG4gICAgICAgICAgICAoMHgyIC8qMGIxMCovIDw8IDYpIHwgKHBvaW50ICYgMHgzZikgLyowYjAwMTExMTExKi9cbiAgICAgICAgICApO1xuICAgICAgfSBlbHNlIHBvaW50ID0gNjU1MzMgLyowYjExMTExMTExMTExMTExMDEqLzsgLy9yZXR1cm4gJ1xceEVGXFx4QkZcXHhCRCc7Ly9mcm9tQ2hhckNvZGUoMHhlZiwgMHhiZiwgMHhiZCk7XG4gICAgfSBlbHNlIGlmIChwb2ludCA8PSAweGRmZmYpIHtcbiAgICAgIHBvaW50ID0gNjU1MzMgLyowYjExMTExMTExMTExMTExMDEqLzsgLy9yZXR1cm4gJ1xceEVGXFx4QkZcXHhCRCc7Ly9mcm9tQ2hhckNvZGUoMHhlZiwgMHhiZiwgMHhiZCk7XG4gICAgfVxuICB9XG4gIC8qaWYgKHBvaW50IDw9IDB4MDA3ZikgcmV0dXJuIG5vbkFzY2lpQ2hhcnM7XG4gIGVsc2UgKi8gaWYgKHBvaW50IDw9IDB4MDdmZikge1xuICAgIHJldHVybiBmcm9tQ2hhckNvZGUoKDB4NiA8PCA1KSB8IChwb2ludCA+PiA2KSwgKDB4MiA8PCA2KSB8IChwb2ludCAmIDB4M2YpKTtcbiAgfSBlbHNlXG4gICAgcmV0dXJuIGZyb21DaGFyQ29kZShcbiAgICAgICgweGUgLyowYjExMTAqLyA8PCA0KSB8IChwb2ludCA+PiAxMiksXG4gICAgICAoMHgyIC8qMGIxMCovIDw8IDYpIHwgKChwb2ludCA+PiA2KSAmIDB4M2YpIC8qMGIwMDExMTExMSovLFxuICAgICAgKDB4MiAvKjBiMTAqLyA8PCA2KSB8IChwb2ludCAmIDB4M2YpIC8qMGIwMDExMTExMSovXG4gICAgKTtcbn1cblxuZXhwb3J0IGNsYXNzIFRleHRFbmNvZGVyIHtcbiAgcHVibGljIGVuY29kZShpbnB1dFN0cmluZzogc3RyaW5nKTogVWludDhBcnJheSB7XG4gICAgLy8gMHhjMCA9PiAwYjExMDAwMDAwOyAweGZmID0+IDBiMTExMTExMTE7IDB4YzAtMHhmZiA9PiAwYjExeHh4eHh4XG4gICAgLy8gMHg4MCA9PiAwYjEwMDAwMDAwOyAweGJmID0+IDBiMTAxMTExMTE7IDB4ODAtMHhiZiA9PiAwYjEweHh4eHh4XG4gICAgY29uc3QgZW5jb2RlZFN0cmluZyA9IGlucHV0U3RyaW5nID09PSB2b2lkIDAgPyAnJyA6ICcnICsgaW5wdXRTdHJpbmcsXG4gICAgICBsZW4gPSBlbmNvZGVkU3RyaW5nLmxlbmd0aCB8IDA7XG4gICAgbGV0IHJlc3VsdCA9IG5ldyBVaW50OEFycmF5KCgobGVuIDw8IDEpICsgOCkgfCAwKTtcbiAgICBsZXQgdG1wUmVzdWx0OiBVaW50OEFycmF5O1xuICAgIGxldCBpID0gMCxcbiAgICAgIHBvcyA9IDAsXG4gICAgICBwb2ludCA9IDAsXG4gICAgICBuZXh0Y29kZSA9IDA7XG4gICAgbGV0IHVwZ3JhZGVkZWRBcnJheVNpemUgPSAhVWludDhBcnJheTsgLy8gbm9ybWFsIGFycmF5cyBhcmUgYXV0by1leHBhbmRpbmdcbiAgICBmb3IgKGkgPSAwOyBpIDwgbGVuOyBpID0gKGkgKyAxKSB8IDAsIHBvcyA9IChwb3MgKyAxKSB8IDApIHtcbiAgICAgIHBvaW50ID0gZW5jb2RlZFN0cmluZy5jaGFyQ29kZUF0KGkpIHwgMDtcbiAgICAgIGlmIChwb2ludCA8PSAweDAwN2YpIHtcbiAgICAgICAgcmVzdWx0W3Bvc10gPSBwb2ludDtcbiAgICAgIH0gZWxzZSBpZiAocG9pbnQgPD0gMHgwN2ZmKSB7XG4gICAgICAgIHJlc3VsdFtwb3NdID0gKDB4NiA8PCA1KSB8IChwb2ludCA+PiA2KTtcbiAgICAgICAgcmVzdWx0Wyhwb3MgPSAocG9zICsgMSkgfCAwKV0gPSAoMHgyIDw8IDYpIHwgKHBvaW50ICYgMHgzZik7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICB3aWRlbkNoZWNrOiB7XG4gICAgICAgICAgaWYgKDB4ZDgwMCA8PSBwb2ludCkge1xuICAgICAgICAgICAgaWYgKHBvaW50IDw9IDB4ZGJmZikge1xuICAgICAgICAgICAgICBuZXh0Y29kZSA9IGVuY29kZWRTdHJpbmcuY2hhckNvZGVBdCgoaSA9IChpICsgMSkgfCAwKSkgfCAwOyAvLyBkZWZhdWx0cyB0byAwIHdoZW4gTmFOLCBjYXVzaW5nIG51bGwgcmVwbGFjZW1lbnQgY2hhcmFjdGVyXG5cbiAgICAgICAgICAgICAgaWYgKDB4ZGMwMCA8PSBuZXh0Y29kZSAmJiBuZXh0Y29kZSA8PSAweGRmZmYpIHtcbiAgICAgICAgICAgICAgICAvL3BvaW50ID0gKChwb2ludCAtIDB4RDgwMCk8PDEwKSArIG5leHRjb2RlIC0gMHhEQzAwICsgMHgxMDAwMHwwO1xuICAgICAgICAgICAgICAgIHBvaW50ID0gKChwb2ludCA8PCAxMCkgKyBuZXh0Y29kZSAtIDB4MzVmZGMwMCkgfCAwO1xuICAgICAgICAgICAgICAgIGlmIChwb2ludCA+IDB4ZmZmZikge1xuICAgICAgICAgICAgICAgICAgcmVzdWx0W3Bvc10gPSAoMHgxZSAvKjBiMTExMTAqLyA8PCAzKSB8IChwb2ludCA+PiAxOCk7XG4gICAgICAgICAgICAgICAgICByZXN1bHRbKHBvcyA9IChwb3MgKyAxKSB8IDApXSA9ICgweDIgLyowYjEwKi8gPDwgNikgfCAoKHBvaW50ID4+IDEyKSAmIDB4M2YpIC8qMGIwMDExMTExMSovO1xuICAgICAgICAgICAgICAgICAgcmVzdWx0Wyhwb3MgPSAocG9zICsgMSkgfCAwKV0gPSAoMHgyIC8qMGIxMCovIDw8IDYpIHwgKChwb2ludCA+PiA2KSAmIDB4M2YpIC8qMGIwMDExMTExMSovO1xuICAgICAgICAgICAgICAgICAgcmVzdWx0Wyhwb3MgPSAocG9zICsgMSkgfCAwKV0gPSAoMHgyIC8qMGIxMCovIDw8IDYpIHwgKHBvaW50ICYgMHgzZikgLyowYjAwMTExMTExKi87XG4gICAgICAgICAgICAgICAgICBjb250aW51ZTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgYnJlYWsgd2lkZW5DaGVjaztcbiAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICBwb2ludCA9IDY1NTMzIC8qMGIxMTExMTExMTExMTExMTAxKi87IC8vcmV0dXJuICdcXHhFRlxceEJGXFx4QkQnOy8vZnJvbUNoYXJDb2RlKDB4ZWYsIDB4YmYsIDB4YmQpO1xuICAgICAgICAgICAgfSBlbHNlIGlmIChwb2ludCA8PSAweGRmZmYpIHtcbiAgICAgICAgICAgICAgcG9pbnQgPSA2NTUzMyAvKjBiMTExMTExMTExMTExMTEwMSovOyAvL3JldHVybiAnXFx4RUZcXHhCRlxceEJEJzsvL2Zyb21DaGFyQ29kZSgweGVmLCAweGJmLCAweGJkKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9XG4gICAgICAgICAgaWYgKCF1cGdyYWRlZGVkQXJyYXlTaXplICYmIGkgPDwgMSA8IHBvcyAmJiBpIDw8IDEgPCAoKHBvcyAtIDcpIHwgMCkpIHtcbiAgICAgICAgICAgIHVwZ3JhZGVkZWRBcnJheVNpemUgPSB0cnVlO1xuICAgICAgICAgICAgdG1wUmVzdWx0ID0gbmV3IFVpbnQ4QXJyYXkobGVuICogMyk7XG4gICAgICAgICAgICB0bXBSZXN1bHQuc2V0KHJlc3VsdCk7XG4gICAgICAgICAgICByZXN1bHQgPSB0bXBSZXN1bHQ7XG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIHJlc3VsdFtwb3NdID0gKDB4ZSAvKjBiMTExMCovIDw8IDQpIHwgKHBvaW50ID4+IDEyKTtcbiAgICAgICAgcmVzdWx0Wyhwb3MgPSAocG9zICsgMSkgfCAwKV0gPSAoMHgyIC8qMGIxMCovIDw8IDYpIHwgKChwb2ludCA+PiA2KSAmIDB4M2YpIC8qMGIwMDExMTExMSovO1xuICAgICAgICByZXN1bHRbKHBvcyA9IChwb3MgKyAxKSB8IDApXSA9ICgweDIgLyowYjEwKi8gPDwgNikgfCAocG9pbnQgJiAweDNmKSAvKjBiMDAxMTExMTEqLztcbiAgICAgIH1cbiAgICB9XG4gICAgcmV0dXJuIFVpbnQ4QXJyYXkgPyByZXN1bHQuc3ViYXJyYXkoMCwgcG9zKSA6IHJlc3VsdC5zbGljZSgwLCBwb3MpO1xuICB9XG5cbiAgcHVibGljIGVuY29kZUludG8oaW5wdXRTdHJpbmc6IHN0cmluZywgdThBcnI6IFVpbnQ4QXJyYXkpOiB7IHdyaXR0ZW46IG51bWJlcjsgcmVhZDogbnVtYmVyIH0ge1xuICAgIGNvbnN0IGVuY29kZWRTdHJpbmcgPSBpbnB1dFN0cmluZyA9PT0gdm9pZCAwID8gJycgOiAoJycgKyBpbnB1dFN0cmluZykucmVwbGFjZShlbmNvZGVyUmVnZXhwLCBlbmNvZGVyUmVwbGFjZXIpO1xuICAgIGxldCBsZW4gPSBlbmNvZGVkU3RyaW5nLmxlbmd0aCB8IDAsXG4gICAgICBpID0gMCxcbiAgICAgIGNoYXIgPSAwLFxuICAgICAgcmVhZCA9IDA7XG4gICAgY29uc3QgdThBcnJMZW4gPSB1OEFyci5sZW5ndGggfCAwO1xuICAgIGNvbnN0IGlucHV0TGVuZ3RoID0gaW5wdXRTdHJpbmcubGVuZ3RoIHwgMDtcbiAgICBpZiAodThBcnJMZW4gPCBsZW4pIGxlbiA9IHU4QXJyTGVuO1xuICAgIHB1dENoYXJzOiB7XG4gICAgICBmb3IgKDsgaSA8IGxlbjsgaSA9IChpICsgMSkgfCAwKSB7XG4gICAgICAgIGNoYXIgPSBlbmNvZGVkU3RyaW5nLmNoYXJDb2RlQXQoaSkgfCAwO1xuICAgICAgICBzd2l0Y2ggKGNoYXIgPj4gNCkge1xuICAgICAgICAgIGNhc2UgMDpcbiAgICAgICAgICBjYXNlIDE6XG4gICAgICAgICAgY2FzZSAyOlxuICAgICAgICAgIGNhc2UgMzpcbiAgICAgICAgICBjYXNlIDQ6XG4gICAgICAgICAgY2FzZSA1OlxuICAgICAgICAgIGNhc2UgNjpcbiAgICAgICAgICBjYXNlIDc6XG4gICAgICAgICAgICByZWFkID0gKHJlYWQgKyAxKSB8IDA7XG4gICAgICAgICAgLy8gZXh0ZW5zaW9uIHBvaW50czpcbiAgICAgICAgICBjYXNlIDg6XG4gICAgICAgICAgY2FzZSA5OlxuICAgICAgICAgIGNhc2UgMTA6XG4gICAgICAgICAgY2FzZSAxMTpcbiAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgIGNhc2UgMTI6XG4gICAgICAgICAgY2FzZSAxMzpcbiAgICAgICAgICAgIGlmICgoKGkgKyAxKSB8IDApIDwgdThBcnJMZW4pIHtcbiAgICAgICAgICAgICAgcmVhZCA9IChyZWFkICsgMSkgfCAwO1xuICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgIH1cbiAgICAgICAgICBjYXNlIDE0OlxuICAgICAgICAgICAgaWYgKCgoaSArIDIpIHwgMCkgPCB1OEFyckxlbikge1xuICAgICAgICAgICAgICAvL2lmICghKGNoYXIgPT09IDB4RUYgJiYgZW5jb2RlZFN0cmluZy5zdWJzdHIoaSsxfDAsMikgPT09IFwiXFx4QkZcXHhCRFwiKSlcbiAgICAgICAgICAgICAgcmVhZCA9IChyZWFkICsgMSkgfCAwO1xuICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgIH1cbiAgICAgICAgICBjYXNlIDE1OlxuICAgICAgICAgICAgaWYgKCgoaSArIDMpIHwgMCkgPCB1OEFyckxlbikge1xuICAgICAgICAgICAgICByZWFkID0gKHJlYWQgKyAxKSB8IDA7XG4gICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgfVxuICAgICAgICAgIGRlZmF1bHQ6XG4gICAgICAgICAgICBicmVhayBwdXRDaGFycztcbiAgICAgICAgfVxuICAgICAgICAvL3JlYWQgPSByZWFkICsgKChjaGFyID4+IDYpICE9PSAyKSB8MDtcbiAgICAgICAgdThBcnJbaV0gPSBjaGFyO1xuICAgICAgfVxuICAgIH1cbiAgICByZXR1cm4geyB3cml0dGVuOiBpLCByZWFkOiBpbnB1dExlbmd0aCA8IHJlYWQgPyBpbnB1dExlbmd0aCA6IHJlYWQgfTtcbiAgfVxufVxuXG4vKipcbiAqIEVuY29kZSBhIFVURi04IHN0cmluZyBpbnRvIGEgVWludDhBcnJheVxuICovXG5leHBvcnQgZnVuY3Rpb24gZW5jb2RlKHM6IHN0cmluZyk6IFVpbnQ4QXJyYXkge1xuICByZXR1cm4gVGV4dEVuY29kZXIucHJvdG90eXBlLmVuY29kZShzKTtcbn1cblxuLyoqXG4gKiBEZWNvZGUgYSBVaW50OEFycmF5IGludG8gYSBVVEYtOCBzdHJpbmdcbiAqL1xuZXhwb3J0IGZ1bmN0aW9uIGRlY29kZShhOiBVaW50OEFycmF5KTogc3RyaW5nIHtcbiAgcmV0dXJuIFRleHREZWNvZGVyLnByb3RvdHlwZS5kZWNvZGUoYSk7XG59XG4iLCJpbXBvcnQgeyBTeW1ib2xCYXNlZEluc3RhbmNlT2ZFcnJvciB9IGZyb20gJy4vdHlwZS1oZWxwZXJzJztcblxuLyoqXG4gKiBUaHJvd24gZnJvbSBjb2RlIHRoYXQgcmVjZWl2ZXMgYSB2YWx1ZSB0aGF0IGlzIHVuZXhwZWN0ZWQgb3IgdGhhdCBpdCdzIHVuYWJsZSB0byBoYW5kbGUuXG4gKi9cbkBTeW1ib2xCYXNlZEluc3RhbmNlT2ZFcnJvcignVmFsdWVFcnJvcicpXG5leHBvcnQgY2xhc3MgVmFsdWVFcnJvciBleHRlbmRzIEVycm9yIHtcbiAgY29uc3RydWN0b3IoXG4gICAgbWVzc2FnZTogc3RyaW5nIHwgdW5kZWZpbmVkLFxuICAgIHB1YmxpYyByZWFkb25seSBjYXVzZT86IHVua25vd25cbiAgKSB7XG4gICAgc3VwZXIobWVzc2FnZSA/PyB1bmRlZmluZWQpO1xuICB9XG59XG5cbi8qKlxuICogVGhyb3duIHdoZW4gYSBQYXlsb2FkIENvbnZlcnRlciBpcyBtaXNjb25maWd1cmVkLlxuICovXG5AU3ltYm9sQmFzZWRJbnN0YW5jZU9mRXJyb3IoJ1BheWxvYWRDb252ZXJ0ZXJFcnJvcicpXG5leHBvcnQgY2xhc3MgUGF5bG9hZENvbnZlcnRlckVycm9yIGV4dGVuZHMgVmFsdWVFcnJvciB7fVxuXG4vKipcbiAqIFVzZWQgaW4gZGlmZmVyZW50IHBhcnRzIG9mIHRoZSBTREsgdG8gbm90ZSB0aGF0IHNvbWV0aGluZyB1bmV4cGVjdGVkIGhhcyBoYXBwZW5lZC5cbiAqL1xuQFN5bWJvbEJhc2VkSW5zdGFuY2VPZkVycm9yKCdJbGxlZ2FsU3RhdGVFcnJvcicpXG5leHBvcnQgY2xhc3MgSWxsZWdhbFN0YXRlRXJyb3IgZXh0ZW5kcyBFcnJvciB7fVxuXG4vKipcbiAqIFRocm93biB3aGVuIGEgV29ya2Zsb3cgd2l0aCB0aGUgZ2l2ZW4gSWQgaXMgbm90IGtub3duIHRvIFRlbXBvcmFsIFNlcnZlci5cbiAqIEl0IGNvdWxkIGJlIGJlY2F1c2U6XG4gKiAtIElkIHBhc3NlZCBpcyBpbmNvcnJlY3RcbiAqIC0gV29ya2Zsb3cgaXMgY2xvc2VkIChmb3Igc29tZSBjYWxscywgZS5nLiBgdGVybWluYXRlYClcbiAqIC0gV29ya2Zsb3cgd2FzIGRlbGV0ZWQgZnJvbSB0aGUgU2VydmVyIGFmdGVyIHJlYWNoaW5nIGl0cyByZXRlbnRpb24gbGltaXRcbiAqL1xuQFN5bWJvbEJhc2VkSW5zdGFuY2VPZkVycm9yKCdXb3JrZmxvd05vdEZvdW5kRXJyb3InKVxuZXhwb3J0IGNsYXNzIFdvcmtmbG93Tm90Rm91bmRFcnJvciBleHRlbmRzIEVycm9yIHtcbiAgY29uc3RydWN0b3IoXG4gICAgbWVzc2FnZTogc3RyaW5nLFxuICAgIHB1YmxpYyByZWFkb25seSB3b3JrZmxvd0lkOiBzdHJpbmcsXG4gICAgcHVibGljIHJlYWRvbmx5IHJ1bklkOiBzdHJpbmcgfCB1bmRlZmluZWRcbiAgKSB7XG4gICAgc3VwZXIobWVzc2FnZSk7XG4gIH1cbn1cblxuLyoqXG4gKiBUaHJvd24gd2hlbiB0aGUgc3BlY2lmaWVkIG5hbWVzcGFjZSBpcyBub3Qga25vd24gdG8gVGVtcG9yYWwgU2VydmVyLlxuICovXG5AU3ltYm9sQmFzZWRJbnN0YW5jZU9mRXJyb3IoJ05hbWVzcGFjZU5vdEZvdW5kRXJyb3InKVxuZXhwb3J0IGNsYXNzIE5hbWVzcGFjZU5vdEZvdW5kRXJyb3IgZXh0ZW5kcyBFcnJvciB7XG4gIGNvbnN0cnVjdG9yKHB1YmxpYyByZWFkb25seSBuYW1lc3BhY2U6IHN0cmluZykge1xuICAgIHN1cGVyKGBOYW1lc3BhY2Ugbm90IGZvdW5kOiAnJHtuYW1lc3BhY2V9J2ApO1xuICB9XG59XG4iLCJpbXBvcnQgdHlwZSB7IHRlbXBvcmFsIH0gZnJvbSAnQHRlbXBvcmFsaW8vcHJvdG8nO1xuaW1wb3J0IHsgZXJyb3JNZXNzYWdlLCBpc1JlY29yZCwgU3ltYm9sQmFzZWRJbnN0YW5jZU9mRXJyb3IgfSBmcm9tICcuL3R5cGUtaGVscGVycyc7XG5pbXBvcnQgeyBEdXJhdGlvbiB9IGZyb20gJy4vdGltZSc7XG5pbXBvcnQgeyBtYWtlUHJvdG9FbnVtQ29udmVydGVycyB9IGZyb20gJy4vaW50ZXJuYWwtd29ya2Zsb3cnO1xuXG5leHBvcnQgY29uc3QgRkFJTFVSRV9TT1VSQ0UgPSAnVHlwZVNjcmlwdFNESyc7XG5leHBvcnQgdHlwZSBQcm90b0ZhaWx1cmUgPSB0ZW1wb3JhbC5hcGkuZmFpbHVyZS52MS5JRmFpbHVyZTtcblxuZXhwb3J0IGNvbnN0IFRpbWVvdXRUeXBlID0ge1xuICBTVEFSVF9UT19DTE9TRTogJ1NUQVJUX1RPX0NMT1NFJyxcbiAgU0NIRURVTEVfVE9fU1RBUlQ6ICdTQ0hFRFVMRV9UT19TVEFSVCcsXG4gIFNDSEVEVUxFX1RPX0NMT1NFOiAnU0NIRURVTEVfVE9fQ0xPU0UnLFxuICBIRUFSVEJFQVQ6ICdIRUFSVEJFQVQnLFxuXG4gIC8qKiBAZGVwcmVjYXRlZCBVc2Uge0BsaW5rIFNUQVJUX1RPX0NMT1NFfSBpbnN0ZWFkLiAqL1xuICBUSU1FT1VUX1RZUEVfU1RBUlRfVE9fQ0xPU0U6ICdTVEFSVF9UT19DTE9TRScsIC8vIGVzbGludC1kaXNhYmxlLWxpbmUgZGVwcmVjYXRpb24vZGVwcmVjYXRpb25cblxuICAvKiogQGRlcHJlY2F0ZWQgVXNlIHtAbGluayBTQ0hFRFVMRV9UT19TVEFSVH0gaW5zdGVhZC4gKi9cbiAgVElNRU9VVF9UWVBFX1NDSEVEVUxFX1RPX1NUQVJUOiAnU0NIRURVTEVfVE9fU1RBUlQnLCAvLyBlc2xpbnQtZGlzYWJsZS1saW5lIGRlcHJlY2F0aW9uL2RlcHJlY2F0aW9uXG5cbiAgLyoqIEBkZXByZWNhdGVkIFVzZSB7QGxpbmsgU0NIRURVTEVfVE9fQ0xPU0V9IGluc3RlYWQuICovXG4gIFRJTUVPVVRfVFlQRV9TQ0hFRFVMRV9UT19DTE9TRTogJ1NDSEVEVUxFX1RPX0NMT1NFJywgLy8gZXNsaW50LWRpc2FibGUtbGluZSBkZXByZWNhdGlvbi9kZXByZWNhdGlvblxuXG4gIC8qKiBAZGVwcmVjYXRlZCBVc2Uge0BsaW5rIEhFQVJUQkVBVH0gaW5zdGVhZC4gKi9cbiAgVElNRU9VVF9UWVBFX0hFQVJUQkVBVDogJ0hFQVJUQkVBVCcsIC8vIGVzbGludC1kaXNhYmxlLWxpbmUgZGVwcmVjYXRpb24vZGVwcmVjYXRpb25cblxuICAvKiogQGRlcHJlY2F0ZWQgVXNlIGB1bmRlZmluZWRgIGluc3RlYWQuICovXG4gIFRJTUVPVVRfVFlQRV9VTlNQRUNJRklFRDogdW5kZWZpbmVkLCAvLyBlc2xpbnQtZGlzYWJsZS1saW5lIGRlcHJlY2F0aW9uL2RlcHJlY2F0aW9uXG59IGFzIGNvbnN0O1xuZXhwb3J0IHR5cGUgVGltZW91dFR5cGUgPSAodHlwZW9mIFRpbWVvdXRUeXBlKVtrZXlvZiB0eXBlb2YgVGltZW91dFR5cGVdO1xuXG5leHBvcnQgY29uc3QgW2VuY29kZVRpbWVvdXRUeXBlLCBkZWNvZGVUaW1lb3V0VHlwZV0gPSBtYWtlUHJvdG9FbnVtQ29udmVydGVyczxcbiAgdGVtcG9yYWwuYXBpLmVudW1zLnYxLlRpbWVvdXRUeXBlLFxuICB0eXBlb2YgdGVtcG9yYWwuYXBpLmVudW1zLnYxLlRpbWVvdXRUeXBlLFxuICBrZXlvZiB0eXBlb2YgdGVtcG9yYWwuYXBpLmVudW1zLnYxLlRpbWVvdXRUeXBlLFxuICB0eXBlb2YgVGltZW91dFR5cGUsXG4gICdUSU1FT1VUX1RZUEVfJ1xuPihcbiAge1xuICAgIFtUaW1lb3V0VHlwZS5TVEFSVF9UT19DTE9TRV06IDEsXG4gICAgW1RpbWVvdXRUeXBlLlNDSEVEVUxFX1RPX1NUQVJUXTogMixcbiAgICBbVGltZW91dFR5cGUuU0NIRURVTEVfVE9fQ0xPU0VdOiAzLFxuICAgIFtUaW1lb3V0VHlwZS5IRUFSVEJFQVRdOiA0LFxuICAgIFVOU1BFQ0lGSUVEOiAwLFxuICB9IGFzIGNvbnN0LFxuICAnVElNRU9VVF9UWVBFXydcbik7XG5cbmV4cG9ydCBjb25zdCBSZXRyeVN0YXRlID0ge1xuICBJTl9QUk9HUkVTUzogJ0lOX1BST0dSRVNTJyxcbiAgTk9OX1JFVFJZQUJMRV9GQUlMVVJFOiAnTk9OX1JFVFJZQUJMRV9GQUlMVVJFJyxcbiAgVElNRU9VVDogJ1RJTUVPVVQnLFxuICBNQVhJTVVNX0FUVEVNUFRTX1JFQUNIRUQ6ICdNQVhJTVVNX0FUVEVNUFRTX1JFQUNIRUQnLFxuICBSRVRSWV9QT0xJQ1lfTk9UX1NFVDogJ1JFVFJZX1BPTElDWV9OT1RfU0VUJyxcbiAgSU5URVJOQUxfU0VSVkVSX0VSUk9SOiAnSU5URVJOQUxfU0VSVkVSX0VSUk9SJyxcbiAgQ0FOQ0VMX1JFUVVFU1RFRDogJ0NBTkNFTF9SRVFVRVNURUQnLFxuXG4gIC8qKiBAZGVwcmVjYXRlZCBVc2Uge0BsaW5rIElOX1BST0dSRVNTfSBpbnN0ZWFkLiAqL1xuICBSRVRSWV9TVEFURV9JTl9QUk9HUkVTUzogJ0lOX1BST0dSRVNTJywgLy8gZXNsaW50LWRpc2FibGUtbGluZSBkZXByZWNhdGlvbi9kZXByZWNhdGlvblxuXG4gIC8qKiBAZGVwcmVjYXRlZCBVc2Uge0BsaW5rIE5PTl9SRVRSWUFCTEVfRkFJTFVSRX0gaW5zdGVhZC4gKi9cbiAgUkVUUllfU1RBVEVfTk9OX1JFVFJZQUJMRV9GQUlMVVJFOiAnTk9OX1JFVFJZQUJMRV9GQUlMVVJFJywgLy8gZXNsaW50LWRpc2FibGUtbGluZSBkZXByZWNhdGlvbi9kZXByZWNhdGlvblxuXG4gIC8qKiBAZGVwcmVjYXRlZCBVc2Uge0BsaW5rIFRJTUVPVVR9IGluc3RlYWQuICovXG4gIFJFVFJZX1NUQVRFX1RJTUVPVVQ6ICdUSU1FT1VUJywgLy8gZXNsaW50LWRpc2FibGUtbGluZSBkZXByZWNhdGlvbi9kZXByZWNhdGlvblxuXG4gIC8qKiBAZGVwcmVjYXRlZCBVc2Uge0BsaW5rIE1BWElNVU1fQVRURU1QVFNfUkVBQ0hFRH0gaW5zdGVhZC4gKi9cbiAgUkVUUllfU1RBVEVfTUFYSU1VTV9BVFRFTVBUU19SRUFDSEVEOiAnTUFYSU1VTV9BVFRFTVBUU19SRUFDSEVEJywgLy8gZXNsaW50LWRpc2FibGUtbGluZSBkZXByZWNhdGlvbi9kZXByZWNhdGlvblxuXG4gIC8qKiBAZGVwcmVjYXRlZCBVc2Uge0BsaW5rIFJFVFJZX1BPTElDWV9OT1RfU0VUfSBpbnN0ZWFkLiAqL1xuICBSRVRSWV9TVEFURV9SRVRSWV9QT0xJQ1lfTk9UX1NFVDogJ1JFVFJZX1BPTElDWV9OT1RfU0VUJywgLy8gZXNsaW50LWRpc2FibGUtbGluZSBkZXByZWNhdGlvbi9kZXByZWNhdGlvblxuXG4gIC8qKiBAZGVwcmVjYXRlZCBVc2Uge0BsaW5rIElOVEVSTkFMX1NFUlZFUl9FUlJPUn0gaW5zdGVhZC4gKi9cbiAgUkVUUllfU1RBVEVfSU5URVJOQUxfU0VSVkVSX0VSUk9SOiAnSU5URVJOQUxfU0VSVkVSX0VSUk9SJywgLy8gZXNsaW50LWRpc2FibGUtbGluZSBkZXByZWNhdGlvbi9kZXByZWNhdGlvblxuXG4gIC8qKiBAZGVwcmVjYXRlZCBVc2Uge0BsaW5rIENBTkNFTF9SRVFVRVNURUR9IGluc3RlYWQuICovXG4gIFJFVFJZX1NUQVRFX0NBTkNFTF9SRVFVRVNURUQ6ICdDQU5DRUxfUkVRVUVTVEVEJywgLy8gZXNsaW50LWRpc2FibGUtbGluZSBkZXByZWNhdGlvbi9kZXByZWNhdGlvblxuXG4gIC8qKiBAZGVwcmVjYXRlZCBVc2UgYHVuZGVmaW5lZGAgaW5zdGVhZC4gKi9cbiAgUkVUUllfU1RBVEVfVU5TUEVDSUZJRUQ6IHVuZGVmaW5lZCwgLy8gZXNsaW50LWRpc2FibGUtbGluZSBkZXByZWNhdGlvbi9kZXByZWNhdGlvblxufSBhcyBjb25zdDtcbmV4cG9ydCB0eXBlIFJldHJ5U3RhdGUgPSAodHlwZW9mIFJldHJ5U3RhdGUpW2tleW9mIHR5cGVvZiBSZXRyeVN0YXRlXTtcblxuZXhwb3J0IGNvbnN0IFtlbmNvZGVSZXRyeVN0YXRlLCBkZWNvZGVSZXRyeVN0YXRlXSA9IG1ha2VQcm90b0VudW1Db252ZXJ0ZXJzPFxuICB0ZW1wb3JhbC5hcGkuZW51bXMudjEuUmV0cnlTdGF0ZSxcbiAgdHlwZW9mIHRlbXBvcmFsLmFwaS5lbnVtcy52MS5SZXRyeVN0YXRlLFxuICBrZXlvZiB0eXBlb2YgdGVtcG9yYWwuYXBpLmVudW1zLnYxLlJldHJ5U3RhdGUsXG4gIHR5cGVvZiBSZXRyeVN0YXRlLFxuICAnUkVUUllfU1RBVEVfJ1xuPihcbiAge1xuICAgIFtSZXRyeVN0YXRlLklOX1BST0dSRVNTXTogMSxcbiAgICBbUmV0cnlTdGF0ZS5OT05fUkVUUllBQkxFX0ZBSUxVUkVdOiAyLFxuICAgIFtSZXRyeVN0YXRlLlRJTUVPVVRdOiAzLFxuICAgIFtSZXRyeVN0YXRlLk1BWElNVU1fQVRURU1QVFNfUkVBQ0hFRF06IDQsXG4gICAgW1JldHJ5U3RhdGUuUkVUUllfUE9MSUNZX05PVF9TRVRdOiA1LFxuICAgIFtSZXRyeVN0YXRlLklOVEVSTkFMX1NFUlZFUl9FUlJPUl06IDYsXG4gICAgW1JldHJ5U3RhdGUuQ0FOQ0VMX1JFUVVFU1RFRF06IDcsXG4gICAgVU5TUEVDSUZJRUQ6IDAsXG4gIH0gYXMgY29uc3QsXG4gICdSRVRSWV9TVEFURV8nXG4pO1xuXG5leHBvcnQgdHlwZSBXb3JrZmxvd0V4ZWN1dGlvbiA9IHRlbXBvcmFsLmFwaS5jb21tb24udjEuSVdvcmtmbG93RXhlY3V0aW9uO1xuXG4vKipcbiAqIFJlcHJlc2VudHMgZmFpbHVyZXMgdGhhdCBjYW4gY3Jvc3MgV29ya2Zsb3cgYW5kIEFjdGl2aXR5IGJvdW5kYXJpZXMuXG4gKlxuICogKipOZXZlciBleHRlbmQgdGhpcyBjbGFzcyBvciBhbnkgb2YgaXRzIGNoaWxkcmVuLioqXG4gKlxuICogVGhlIG9ubHkgY2hpbGQgY2xhc3MgeW91IHNob3VsZCBldmVyIHRocm93IGZyb20geW91ciBjb2RlIGlzIHtAbGluayBBcHBsaWNhdGlvbkZhaWx1cmV9LlxuICovXG5AU3ltYm9sQmFzZWRJbnN0YW5jZU9mRXJyb3IoJ1RlbXBvcmFsRmFpbHVyZScpXG5leHBvcnQgY2xhc3MgVGVtcG9yYWxGYWlsdXJlIGV4dGVuZHMgRXJyb3Ige1xuICAvKipcbiAgICogVGhlIG9yaWdpbmFsIGZhaWx1cmUgdGhhdCBjb25zdHJ1Y3RlZCB0aGlzIGVycm9yLlxuICAgKlxuICAgKiBPbmx5IHByZXNlbnQgaWYgdGhpcyBlcnJvciB3YXMgZ2VuZXJhdGVkIGZyb20gYW4gZXh0ZXJuYWwgb3BlcmF0aW9uLlxuICAgKi9cbiAgcHVibGljIGZhaWx1cmU/OiBQcm90b0ZhaWx1cmU7XG5cbiAgY29uc3RydWN0b3IoXG4gICAgbWVzc2FnZT86IHN0cmluZyB8IHVuZGVmaW5lZCB8IG51bGwsXG4gICAgcHVibGljIHJlYWRvbmx5IGNhdXNlPzogRXJyb3JcbiAgKSB7XG4gICAgc3VwZXIobWVzc2FnZSA/PyB1bmRlZmluZWQpO1xuICB9XG59XG5cbi8qKiBFeGNlcHRpb25zIG9yaWdpbmF0ZWQgYXQgdGhlIFRlbXBvcmFsIHNlcnZpY2UuICovXG5AU3ltYm9sQmFzZWRJbnN0YW5jZU9mRXJyb3IoJ1NlcnZlckZhaWx1cmUnKVxuZXhwb3J0IGNsYXNzIFNlcnZlckZhaWx1cmUgZXh0ZW5kcyBUZW1wb3JhbEZhaWx1cmUge1xuICBjb25zdHJ1Y3RvcihcbiAgICBtZXNzYWdlOiBzdHJpbmcgfCB1bmRlZmluZWQsXG4gICAgcHVibGljIHJlYWRvbmx5IG5vblJldHJ5YWJsZTogYm9vbGVhbixcbiAgICBjYXVzZT86IEVycm9yXG4gICkge1xuICAgIHN1cGVyKG1lc3NhZ2UsIGNhdXNlKTtcbiAgfVxufVxuXG4vKipcbiAqIGBBcHBsaWNhdGlvbkZhaWx1cmVgcyBhcmUgdXNlZCB0byBjb21tdW5pY2F0ZSBhcHBsaWNhdGlvbi1zcGVjaWZpYyBmYWlsdXJlcyBpbiBXb3JrZmxvd3MgYW5kIEFjdGl2aXRpZXMuXG4gKlxuICogVGhlIHtAbGluayB0eXBlfSBwcm9wZXJ0eSBpcyBtYXRjaGVkIGFnYWluc3Qge0BsaW5rIFJldHJ5UG9saWN5Lm5vblJldHJ5YWJsZUVycm9yVHlwZXN9IHRvIGRldGVybWluZSBpZiBhbiBpbnN0YW5jZVxuICogb2YgdGhpcyBlcnJvciBpcyByZXRyeWFibGUuIEFub3RoZXIgd2F5IHRvIGF2b2lkIHJldHJ5aW5nIGlzIGJ5IHNldHRpbmcgdGhlIHtAbGluayBub25SZXRyeWFibGV9IGZsYWcgdG8gYHRydWVgLlxuICpcbiAqIEluIFdvcmtmbG93cywgaWYgeW91IHRocm93IGEgbm9uLWBBcHBsaWNhdGlvbkZhaWx1cmVgLCB0aGUgV29ya2Zsb3cgVGFzayB3aWxsIGZhaWwgYW5kIGJlIHJldHJpZWQuIElmIHlvdSB0aHJvdyBhblxuICogYEFwcGxpY2F0aW9uRmFpbHVyZWAsIHRoZSBXb3JrZmxvdyBFeGVjdXRpb24gd2lsbCBmYWlsLlxuICpcbiAqIEluIEFjdGl2aXRpZXMsIHlvdSBjYW4gZWl0aGVyIHRocm93IGFuIGBBcHBsaWNhdGlvbkZhaWx1cmVgIG9yIGFub3RoZXIgYEVycm9yYCB0byBmYWlsIHRoZSBBY3Rpdml0eSBUYXNrLiBJbiB0aGVcbiAqIGxhdHRlciBjYXNlLCB0aGUgYEVycm9yYCB3aWxsIGJlIGNvbnZlcnRlZCB0byBhbiBgQXBwbGljYXRpb25GYWlsdXJlYC4gVGhlIGNvbnZlcnNpb24gaXMgZG9uZSBhcyBmb2xsb3dpbmc6XG4gKlxuICogLSBgdHlwZWAgaXMgc2V0IHRvIGBlcnJvci5jb25zdHJ1Y3Rvcj8ubmFtZSA/PyBlcnJvci5uYW1lYFxuICogLSBgbWVzc2FnZWAgaXMgc2V0IHRvIGBlcnJvci5tZXNzYWdlYFxuICogLSBgbm9uUmV0cnlhYmxlYCBpcyBzZXQgdG8gZmFsc2VcbiAqIC0gYGRldGFpbHNgIGFyZSBzZXQgdG8gbnVsbFxuICogLSBzdGFjayB0cmFjZSBpcyBjb3BpZWQgZnJvbSB0aGUgb3JpZ2luYWwgZXJyb3JcbiAqXG4gKiBXaGVuIGFuIHtAbGluayBodHRwczovL2RvY3MudGVtcG9yYWwuaW8vY29uY2VwdHMvd2hhdC1pcy1hbi1hY3Rpdml0eS1leGVjdXRpb24gfCBBY3Rpdml0eSBFeGVjdXRpb259IGZhaWxzLCB0aGVcbiAqIGBBcHBsaWNhdGlvbkZhaWx1cmVgIGZyb20gdGhlIGxhc3QgQWN0aXZpdHkgVGFzayB3aWxsIGJlIHRoZSBgY2F1c2VgIG9mIHRoZSB7QGxpbmsgQWN0aXZpdHlGYWlsdXJlfSB0aHJvd24gaW4gdGhlXG4gKiBXb3JrZmxvdy5cbiAqL1xuQFN5bWJvbEJhc2VkSW5zdGFuY2VPZkVycm9yKCdBcHBsaWNhdGlvbkZhaWx1cmUnKVxuZXhwb3J0IGNsYXNzIEFwcGxpY2F0aW9uRmFpbHVyZSBleHRlbmRzIFRlbXBvcmFsRmFpbHVyZSB7XG4gIC8qKlxuICAgKiBBbHRlcm5hdGl2ZWx5LCB1c2Uge0BsaW5rIGZyb21FcnJvcn0gb3Ige0BsaW5rIGNyZWF0ZX0uXG4gICAqL1xuICBjb25zdHJ1Y3RvcihcbiAgICBtZXNzYWdlPzogc3RyaW5nIHwgdW5kZWZpbmVkIHwgbnVsbCxcbiAgICBwdWJsaWMgcmVhZG9ubHkgdHlwZT86IHN0cmluZyB8IHVuZGVmaW5lZCB8IG51bGwsXG4gICAgcHVibGljIHJlYWRvbmx5IG5vblJldHJ5YWJsZT86IGJvb2xlYW4gfCB1bmRlZmluZWQgfCBudWxsLFxuICAgIHB1YmxpYyByZWFkb25seSBkZXRhaWxzPzogdW5rbm93bltdIHwgdW5kZWZpbmVkIHwgbnVsbCxcbiAgICBjYXVzZT86IEVycm9yLFxuICAgIHB1YmxpYyByZWFkb25seSBuZXh0UmV0cnlEZWxheT86IER1cmF0aW9uIHwgdW5kZWZpbmVkIHwgbnVsbFxuICApIHtcbiAgICBzdXBlcihtZXNzYWdlLCBjYXVzZSk7XG4gIH1cblxuICAvKipcbiAgICogQ3JlYXRlIGEgbmV3IGBBcHBsaWNhdGlvbkZhaWx1cmVgIGZyb20gYW4gRXJyb3Igb2JqZWN0LlxuICAgKlxuICAgKiBGaXJzdCBjYWxscyB7QGxpbmsgZW5zdXJlQXBwbGljYXRpb25GYWlsdXJlIHwgYGVuc3VyZUFwcGxpY2F0aW9uRmFpbHVyZShlcnJvcilgfSBhbmQgdGhlbiBvdmVycmlkZXMgYW55IGZpZWxkc1xuICAgKiBwcm92aWRlZCBpbiBgb3ZlcnJpZGVzYC5cbiAgICovXG4gIHB1YmxpYyBzdGF0aWMgZnJvbUVycm9yKGVycm9yOiBFcnJvciB8IHVua25vd24sIG92ZXJyaWRlcz86IEFwcGxpY2F0aW9uRmFpbHVyZU9wdGlvbnMpOiBBcHBsaWNhdGlvbkZhaWx1cmUge1xuICAgIGNvbnN0IGZhaWx1cmUgPSBlbnN1cmVBcHBsaWNhdGlvbkZhaWx1cmUoZXJyb3IpO1xuICAgIE9iamVjdC5hc3NpZ24oZmFpbHVyZSwgb3ZlcnJpZGVzKTtcbiAgICByZXR1cm4gZmFpbHVyZTtcbiAgfVxuXG4gIC8qKlxuICAgKiBDcmVhdGUgYSBuZXcgYEFwcGxpY2F0aW9uRmFpbHVyZWAuXG4gICAqXG4gICAqIEJ5IGRlZmF1bHQsIHdpbGwgYmUgcmV0cnlhYmxlICh1bmxlc3MgaXRzIGB0eXBlYCBpcyBpbmNsdWRlZCBpbiB7QGxpbmsgUmV0cnlQb2xpY3kubm9uUmV0cnlhYmxlRXJyb3JUeXBlc30pLlxuICAgKi9cbiAgcHVibGljIHN0YXRpYyBjcmVhdGUob3B0aW9uczogQXBwbGljYXRpb25GYWlsdXJlT3B0aW9ucyk6IEFwcGxpY2F0aW9uRmFpbHVyZSB7XG4gICAgY29uc3QgeyBtZXNzYWdlLCB0eXBlLCBub25SZXRyeWFibGUgPSBmYWxzZSwgZGV0YWlscywgbmV4dFJldHJ5RGVsYXksIGNhdXNlIH0gPSBvcHRpb25zO1xuICAgIHJldHVybiBuZXcgdGhpcyhtZXNzYWdlLCB0eXBlLCBub25SZXRyeWFibGUsIGRldGFpbHMsIGNhdXNlLCBuZXh0UmV0cnlEZWxheSk7XG4gIH1cblxuICAvKipcbiAgICogR2V0IGEgbmV3IGBBcHBsaWNhdGlvbkZhaWx1cmVgIHdpdGggdGhlIHtAbGluayBub25SZXRyeWFibGV9IGZsYWcgc2V0IHRvIGZhbHNlLiBOb3RlIHRoYXQgdGhpcyBlcnJvciB3aWxsIHN0aWxsXG4gICAqIG5vdCBiZSByZXRyaWVkIGlmIGl0cyBgdHlwZWAgaXMgaW5jbHVkZWQgaW4ge0BsaW5rIFJldHJ5UG9saWN5Lm5vblJldHJ5YWJsZUVycm9yVHlwZXN9LlxuICAgKlxuICAgKiBAcGFyYW0gbWVzc2FnZSBPcHRpb25hbCBlcnJvciBtZXNzYWdlXG4gICAqIEBwYXJhbSB0eXBlIE9wdGlvbmFsIGVycm9yIHR5cGUgKHVzZWQgYnkge0BsaW5rIFJldHJ5UG9saWN5Lm5vblJldHJ5YWJsZUVycm9yVHlwZXN9KVxuICAgKiBAcGFyYW0gZGV0YWlscyBPcHRpb25hbCBkZXRhaWxzIGFib3V0IHRoZSBmYWlsdXJlLiBTZXJpYWxpemVkIGJ5IHRoZSBXb3JrZXIncyB7QGxpbmsgUGF5bG9hZENvbnZlcnRlcn0uXG4gICAqL1xuICBwdWJsaWMgc3RhdGljIHJldHJ5YWJsZShtZXNzYWdlPzogc3RyaW5nIHwgbnVsbCwgdHlwZT86IHN0cmluZyB8IG51bGwsIC4uLmRldGFpbHM6IHVua25vd25bXSk6IEFwcGxpY2F0aW9uRmFpbHVyZSB7XG4gICAgcmV0dXJuIG5ldyB0aGlzKG1lc3NhZ2UsIHR5cGUgPz8gJ0Vycm9yJywgZmFsc2UsIGRldGFpbHMpO1xuICB9XG5cbiAgLyoqXG4gICAqIEdldCBhIG5ldyBgQXBwbGljYXRpb25GYWlsdXJlYCB3aXRoIHRoZSB7QGxpbmsgbm9uUmV0cnlhYmxlfSBmbGFnIHNldCB0byB0cnVlLlxuICAgKlxuICAgKiBXaGVuIHRocm93biBmcm9tIGFuIEFjdGl2aXR5IG9yIFdvcmtmbG93LCB0aGUgQWN0aXZpdHkgb3IgV29ya2Zsb3cgd2lsbCBub3QgYmUgcmV0cmllZCAoZXZlbiBpZiBgdHlwZWAgaXMgbm90XG4gICAqIGxpc3RlZCBpbiB7QGxpbmsgUmV0cnlQb2xpY3kubm9uUmV0cnlhYmxlRXJyb3JUeXBlc30pLlxuICAgKlxuICAgKiBAcGFyYW0gbWVzc2FnZSBPcHRpb25hbCBlcnJvciBtZXNzYWdlXG4gICAqIEBwYXJhbSB0eXBlIE9wdGlvbmFsIGVycm9yIHR5cGVcbiAgICogQHBhcmFtIGRldGFpbHMgT3B0aW9uYWwgZGV0YWlscyBhYm91dCB0aGUgZmFpbHVyZS4gU2VyaWFsaXplZCBieSB0aGUgV29ya2VyJ3Mge0BsaW5rIFBheWxvYWRDb252ZXJ0ZXJ9LlxuICAgKi9cbiAgcHVibGljIHN0YXRpYyBub25SZXRyeWFibGUobWVzc2FnZT86IHN0cmluZyB8IG51bGwsIHR5cGU/OiBzdHJpbmcgfCBudWxsLCAuLi5kZXRhaWxzOiB1bmtub3duW10pOiBBcHBsaWNhdGlvbkZhaWx1cmUge1xuICAgIHJldHVybiBuZXcgdGhpcyhtZXNzYWdlLCB0eXBlID8/ICdFcnJvcicsIHRydWUsIGRldGFpbHMpO1xuICB9XG59XG5cbmV4cG9ydCBpbnRlcmZhY2UgQXBwbGljYXRpb25GYWlsdXJlT3B0aW9ucyB7XG4gIC8qKlxuICAgKiBFcnJvciBtZXNzYWdlXG4gICAqL1xuICBtZXNzYWdlPzogc3RyaW5nO1xuXG4gIC8qKlxuICAgKiBFcnJvciB0eXBlICh1c2VkIGJ5IHtAbGluayBSZXRyeVBvbGljeS5ub25SZXRyeWFibGVFcnJvclR5cGVzfSlcbiAgICovXG4gIHR5cGU/OiBzdHJpbmc7XG5cbiAgLyoqXG4gICAqIFdoZXRoZXIgdGhlIGN1cnJlbnQgQWN0aXZpdHkgb3IgV29ya2Zsb3cgY2FuIGJlIHJldHJpZWRcbiAgICpcbiAgICogQGRlZmF1bHQgZmFsc2VcbiAgICovXG4gIG5vblJldHJ5YWJsZT86IGJvb2xlYW47XG5cbiAgLyoqXG4gICAqIERldGFpbHMgYWJvdXQgdGhlIGZhaWx1cmUuIFNlcmlhbGl6ZWQgYnkgdGhlIFdvcmtlcidzIHtAbGluayBQYXlsb2FkQ29udmVydGVyfS5cbiAgICovXG4gIGRldGFpbHM/OiB1bmtub3duW107XG5cbiAgLyoqXG4gICAqIElmIHNldCwgb3ZlcnJpZGVzIHRoZSBkZWxheSB1bnRpbCB0aGUgbmV4dCByZXRyeSBvZiB0aGlzIEFjdGl2aXR5IC8gV29ya2Zsb3cgVGFzay5cbiAgICpcbiAgICogUmV0cnkgYXR0ZW1wdHMgd2lsbCBzdGlsbCBiZSBzdWJqZWN0IHRvIHRoZSBtYXhpbXVtIHJldHJpZXMgbGltaXQgYW5kIHRvdGFsIHRpbWUgbGltaXQgZGVmaW5lZFxuICAgKiBieSB0aGUgcG9saWN5LlxuICAgKi9cbiAgbmV4dFJldHJ5RGVsYXk/OiBEdXJhdGlvbjtcblxuICAvKipcbiAgICogQ2F1c2Ugb2YgdGhlIGZhaWx1cmVcbiAgICovXG4gIGNhdXNlPzogRXJyb3I7XG59XG5cbi8qKlxuICogVGhpcyBlcnJvciBpcyB0aHJvd24gd2hlbiBDYW5jZWxsYXRpb24gaGFzIGJlZW4gcmVxdWVzdGVkLiBUbyBhbGxvdyBDYW5jZWxsYXRpb24gdG8gaGFwcGVuLCBsZXQgaXQgcHJvcGFnYXRlLiBUb1xuICogaWdub3JlIENhbmNlbGxhdGlvbiwgY2F0Y2ggaXQgYW5kIGNvbnRpbnVlIGV4ZWN1dGluZy4gTm90ZSB0aGF0IENhbmNlbGxhdGlvbiBjYW4gb25seSBiZSByZXF1ZXN0ZWQgYSBzaW5nbGUgdGltZSwgc29cbiAqIHlvdXIgV29ya2Zsb3cvQWN0aXZpdHkgRXhlY3V0aW9uIHdpbGwgbm90IHJlY2VpdmUgZnVydGhlciBDYW5jZWxsYXRpb24gcmVxdWVzdHMuXG4gKlxuICogV2hlbiBhIFdvcmtmbG93IG9yIEFjdGl2aXR5IGhhcyBiZWVuIHN1Y2Nlc3NmdWxseSBjYW5jZWxsZWQsIGEgYENhbmNlbGxlZEZhaWx1cmVgIHdpbGwgYmUgdGhlIGBjYXVzZWAuXG4gKi9cbkBTeW1ib2xCYXNlZEluc3RhbmNlT2ZFcnJvcignQ2FuY2VsbGVkRmFpbHVyZScpXG5leHBvcnQgY2xhc3MgQ2FuY2VsbGVkRmFpbHVyZSBleHRlbmRzIFRlbXBvcmFsRmFpbHVyZSB7XG4gIGNvbnN0cnVjdG9yKFxuICAgIG1lc3NhZ2U6IHN0cmluZyB8IHVuZGVmaW5lZCxcbiAgICBwdWJsaWMgcmVhZG9ubHkgZGV0YWlsczogdW5rbm93bltdID0gW10sXG4gICAgY2F1c2U/OiBFcnJvclxuICApIHtcbiAgICBzdXBlcihtZXNzYWdlLCBjYXVzZSk7XG4gIH1cbn1cblxuLyoqXG4gKiBVc2VkIGFzIHRoZSBgY2F1c2VgIHdoZW4gYSBXb3JrZmxvdyBoYXMgYmVlbiB0ZXJtaW5hdGVkXG4gKi9cbkBTeW1ib2xCYXNlZEluc3RhbmNlT2ZFcnJvcignVGVybWluYXRlZEZhaWx1cmUnKVxuZXhwb3J0IGNsYXNzIFRlcm1pbmF0ZWRGYWlsdXJlIGV4dGVuZHMgVGVtcG9yYWxGYWlsdXJlIHtcbiAgY29uc3RydWN0b3IobWVzc2FnZTogc3RyaW5nIHwgdW5kZWZpbmVkLCBjYXVzZT86IEVycm9yKSB7XG4gICAgc3VwZXIobWVzc2FnZSwgY2F1c2UpO1xuICB9XG59XG5cbi8qKlxuICogVXNlZCB0byByZXByZXNlbnQgdGltZW91dHMgb2YgQWN0aXZpdGllcyBhbmQgV29ya2Zsb3dzXG4gKi9cbkBTeW1ib2xCYXNlZEluc3RhbmNlT2ZFcnJvcignVGltZW91dEZhaWx1cmUnKVxuZXhwb3J0IGNsYXNzIFRpbWVvdXRGYWlsdXJlIGV4dGVuZHMgVGVtcG9yYWxGYWlsdXJlIHtcbiAgY29uc3RydWN0b3IoXG4gICAgbWVzc2FnZTogc3RyaW5nIHwgdW5kZWZpbmVkLFxuICAgIHB1YmxpYyByZWFkb25seSBsYXN0SGVhcnRiZWF0RGV0YWlsczogdW5rbm93bixcbiAgICBwdWJsaWMgcmVhZG9ubHkgdGltZW91dFR5cGU6IFRpbWVvdXRUeXBlXG4gICkge1xuICAgIHN1cGVyKG1lc3NhZ2UpO1xuICB9XG59XG5cbi8qKlxuICogQ29udGFpbnMgaW5mb3JtYXRpb24gYWJvdXQgYW4gQWN0aXZpdHkgZmFpbHVyZS4gQWx3YXlzIGNvbnRhaW5zIHRoZSBvcmlnaW5hbCByZWFzb24gZm9yIHRoZSBmYWlsdXJlIGFzIGl0cyBgY2F1c2VgLlxuICogRm9yIGV4YW1wbGUsIGlmIGFuIEFjdGl2aXR5IHRpbWVkIG91dCwgdGhlIGNhdXNlIHdpbGwgYmUgYSB7QGxpbmsgVGltZW91dEZhaWx1cmV9LlxuICpcbiAqIFRoaXMgZXhjZXB0aW9uIGlzIGV4cGVjdGVkIHRvIGJlIHRocm93biBvbmx5IGJ5IHRoZSBmcmFtZXdvcmsgY29kZS5cbiAqL1xuQFN5bWJvbEJhc2VkSW5zdGFuY2VPZkVycm9yKCdBY3Rpdml0eUZhaWx1cmUnKVxuZXhwb3J0IGNsYXNzIEFjdGl2aXR5RmFpbHVyZSBleHRlbmRzIFRlbXBvcmFsRmFpbHVyZSB7XG4gIHB1YmxpYyBjb25zdHJ1Y3RvcihcbiAgICBtZXNzYWdlOiBzdHJpbmcgfCB1bmRlZmluZWQsXG4gICAgcHVibGljIHJlYWRvbmx5IGFjdGl2aXR5VHlwZTogc3RyaW5nLFxuICAgIHB1YmxpYyByZWFkb25seSBhY3Rpdml0eUlkOiBzdHJpbmcgfCB1bmRlZmluZWQsXG4gICAgcHVibGljIHJlYWRvbmx5IHJldHJ5U3RhdGU6IFJldHJ5U3RhdGUsXG4gICAgcHVibGljIHJlYWRvbmx5IGlkZW50aXR5OiBzdHJpbmcgfCB1bmRlZmluZWQsXG4gICAgY2F1c2U/OiBFcnJvclxuICApIHtcbiAgICBzdXBlcihtZXNzYWdlLCBjYXVzZSk7XG4gIH1cbn1cblxuLyoqXG4gKiBDb250YWlucyBpbmZvcm1hdGlvbiBhYm91dCBhIENoaWxkIFdvcmtmbG93IGZhaWx1cmUuIEFsd2F5cyBjb250YWlucyB0aGUgcmVhc29uIGZvciB0aGUgZmFpbHVyZSBhcyBpdHMge0BsaW5rIGNhdXNlfS5cbiAqIEZvciBleGFtcGxlLCBpZiB0aGUgQ2hpbGQgd2FzIFRlcm1pbmF0ZWQsIHRoZSBgY2F1c2VgIGlzIGEge0BsaW5rIFRlcm1pbmF0ZWRGYWlsdXJlfS5cbiAqXG4gKiBUaGlzIGV4Y2VwdGlvbiBpcyBleHBlY3RlZCB0byBiZSB0aHJvd24gb25seSBieSB0aGUgZnJhbWV3b3JrIGNvZGUuXG4gKi9cbkBTeW1ib2xCYXNlZEluc3RhbmNlT2ZFcnJvcignQ2hpbGRXb3JrZmxvd0ZhaWx1cmUnKVxuZXhwb3J0IGNsYXNzIENoaWxkV29ya2Zsb3dGYWlsdXJlIGV4dGVuZHMgVGVtcG9yYWxGYWlsdXJlIHtcbiAgcHVibGljIGNvbnN0cnVjdG9yKFxuICAgIHB1YmxpYyByZWFkb25seSBuYW1lc3BhY2U6IHN0cmluZyB8IHVuZGVmaW5lZCxcbiAgICBwdWJsaWMgcmVhZG9ubHkgZXhlY3V0aW9uOiBXb3JrZmxvd0V4ZWN1dGlvbixcbiAgICBwdWJsaWMgcmVhZG9ubHkgd29ya2Zsb3dUeXBlOiBzdHJpbmcsXG4gICAgcHVibGljIHJlYWRvbmx5IHJldHJ5U3RhdGU6IFJldHJ5U3RhdGUsXG4gICAgY2F1c2U/OiBFcnJvclxuICApIHtcbiAgICBzdXBlcignQ2hpbGQgV29ya2Zsb3cgZXhlY3V0aW9uIGZhaWxlZCcsIGNhdXNlKTtcbiAgfVxufVxuXG4vKipcbiAqIFRoaXMgZXhjZXB0aW9uIGlzIHRocm93biBpbiB0aGUgZm9sbG93aW5nIGNhc2VzOlxuICogIC0gV29ya2Zsb3cgd2l0aCB0aGUgc2FtZSBXb3JrZmxvdyBJRCBpcyBjdXJyZW50bHkgcnVubmluZyBhbmQgdGhlIHtAbGluayBXb3JrZmxvd09wdGlvbnMud29ya2Zsb3dJZENvbmZsaWN0UG9saWN5fSBpcyBgV09SS0ZMT1dfSURfQ09ORkxJQ1RfUE9MSUNZX0ZBSUxgXG4gKiAgLSBUaGVyZSBpcyBhIGNsb3NlZCBXb3JrZmxvdyB3aXRoIHRoZSBzYW1lIFdvcmtmbG93IElkIGFuZCB0aGUge0BsaW5rIFdvcmtmbG93T3B0aW9ucy53b3JrZmxvd0lkUmV1c2VQb2xpY3l9XG4gKiAgICBpcyBgV09SS0ZMT1dfSURfUkVVU0VfUE9MSUNZX1JFSkVDVF9EVVBMSUNBVEVgXG4gKiAgLSBUaGVyZSBpcyBjbG9zZWQgV29ya2Zsb3cgaW4gdGhlIGBDb21wbGV0ZWRgIHN0YXRlIHdpdGggdGhlIHNhbWUgV29ya2Zsb3cgSWQgYW5kIHRoZSB7QGxpbmsgV29ya2Zsb3dPcHRpb25zLndvcmtmbG93SWRSZXVzZVBvbGljeX1cbiAqICAgIGlzIGBXT1JLRkxPV19JRF9SRVVTRV9QT0xJQ1lfQUxMT1dfRFVQTElDQVRFX0ZBSUxFRF9PTkxZYFxuICovXG5AU3ltYm9sQmFzZWRJbnN0YW5jZU9mRXJyb3IoJ1dvcmtmbG93RXhlY3V0aW9uQWxyZWFkeVN0YXJ0ZWRFcnJvcicpXG5leHBvcnQgY2xhc3MgV29ya2Zsb3dFeGVjdXRpb25BbHJlYWR5U3RhcnRlZEVycm9yIGV4dGVuZHMgVGVtcG9yYWxGYWlsdXJlIHtcbiAgY29uc3RydWN0b3IoXG4gICAgbWVzc2FnZTogc3RyaW5nLFxuICAgIHB1YmxpYyByZWFkb25seSB3b3JrZmxvd0lkOiBzdHJpbmcsXG4gICAgcHVibGljIHJlYWRvbmx5IHdvcmtmbG93VHlwZTogc3RyaW5nXG4gICkge1xuICAgIHN1cGVyKG1lc3NhZ2UpO1xuICB9XG59XG5cbi8qKlxuICogSWYgYGVycm9yYCBpcyBhbHJlYWR5IGFuIGBBcHBsaWNhdGlvbkZhaWx1cmVgLCByZXR1cm5zIGBlcnJvcmAuXG4gKlxuICogT3RoZXJ3aXNlLCBjb252ZXJ0cyBgZXJyb3JgIGludG8gYW4gYEFwcGxpY2F0aW9uRmFpbHVyZWAgd2l0aDpcbiAqXG4gKiAtIGBtZXNzYWdlYDogYGVycm9yLm1lc3NhZ2VgIG9yIGBTdHJpbmcoZXJyb3IpYFxuICogLSBgdHlwZWA6IGBlcnJvci5jb25zdHJ1Y3Rvci5uYW1lYCBvciBgZXJyb3IubmFtZWBcbiAqIC0gYHN0YWNrYDogYGVycm9yLnN0YWNrYCBvciBgJydgXG4gKi9cbmV4cG9ydCBmdW5jdGlvbiBlbnN1cmVBcHBsaWNhdGlvbkZhaWx1cmUoZXJyb3I6IHVua25vd24pOiBBcHBsaWNhdGlvbkZhaWx1cmUge1xuICBpZiAoZXJyb3IgaW5zdGFuY2VvZiBBcHBsaWNhdGlvbkZhaWx1cmUpIHtcbiAgICByZXR1cm4gZXJyb3I7XG4gIH1cblxuICBjb25zdCBtZXNzYWdlID0gKGlzUmVjb3JkKGVycm9yKSAmJiBTdHJpbmcoZXJyb3IubWVzc2FnZSkpIHx8IFN0cmluZyhlcnJvcik7XG4gIGNvbnN0IHR5cGUgPSAoaXNSZWNvcmQoZXJyb3IpICYmIChlcnJvci5jb25zdHJ1Y3Rvcj8ubmFtZSA/PyBlcnJvci5uYW1lKSkgfHwgdW5kZWZpbmVkO1xuICBjb25zdCBmYWlsdXJlID0gQXBwbGljYXRpb25GYWlsdXJlLmNyZWF0ZSh7IG1lc3NhZ2UsIHR5cGUsIG5vblJldHJ5YWJsZTogZmFsc2UgfSk7XG4gIGZhaWx1cmUuc3RhY2sgPSAoaXNSZWNvcmQoZXJyb3IpICYmIFN0cmluZyhlcnJvci5zdGFjaykpIHx8ICcnO1xuICByZXR1cm4gZmFpbHVyZTtcbn1cblxuLyoqXG4gKiBJZiBgZXJyYCBpcyBhbiBFcnJvciBpdCBpcyB0dXJuZWQgaW50byBhbiBgQXBwbGljYXRpb25GYWlsdXJlYC5cbiAqXG4gKiBJZiBgZXJyYCB3YXMgYWxyZWFkeSBhIGBUZW1wb3JhbEZhaWx1cmVgLCByZXR1cm5zIHRoZSBvcmlnaW5hbCBlcnJvci5cbiAqXG4gKiBPdGhlcndpc2UgcmV0dXJucyBhbiBgQXBwbGljYXRpb25GYWlsdXJlYCB3aXRoIGBTdHJpbmcoZXJyKWAgYXMgdGhlIG1lc3NhZ2UuXG4gKi9cbmV4cG9ydCBmdW5jdGlvbiBlbnN1cmVUZW1wb3JhbEZhaWx1cmUoZXJyOiB1bmtub3duKTogVGVtcG9yYWxGYWlsdXJlIHtcbiAgaWYgKGVyciBpbnN0YW5jZW9mIFRlbXBvcmFsRmFpbHVyZSkge1xuICAgIHJldHVybiBlcnI7XG4gIH1cbiAgcmV0dXJuIGVuc3VyZUFwcGxpY2F0aW9uRmFpbHVyZShlcnIpO1xufVxuXG4vKipcbiAqIEdldCB0aGUgcm9vdCBjYXVzZSBtZXNzYWdlIG9mIGdpdmVuIGBlcnJvcmAuXG4gKlxuICogSW4gY2FzZSBgZXJyb3JgIGlzIGEge0BsaW5rIFRlbXBvcmFsRmFpbHVyZX0sIHJlY3Vyc2UgdGhlIGBjYXVzZWAgY2hhaW4gYW5kIHJldHVybiB0aGUgcm9vdCBgY2F1c2UubWVzc2FnZWAuXG4gKiBPdGhlcndpc2UsIHJldHVybiBgZXJyb3IubWVzc2FnZWAuXG4gKi9cbmV4cG9ydCBmdW5jdGlvbiByb290Q2F1c2UoZXJyb3I6IHVua25vd24pOiBzdHJpbmcgfCB1bmRlZmluZWQge1xuICBpZiAoZXJyb3IgaW5zdGFuY2VvZiBUZW1wb3JhbEZhaWx1cmUpIHtcbiAgICByZXR1cm4gZXJyb3IuY2F1c2UgPyByb290Q2F1c2UoZXJyb3IuY2F1c2UpIDogZXJyb3IubWVzc2FnZTtcbiAgfVxuICByZXR1cm4gZXJyb3JNZXNzYWdlKGVycm9yKTtcbn1cbiIsIi8qKlxuICogQ29tbW9uIGxpYnJhcnkgZm9yIGNvZGUgdGhhdCdzIHVzZWQgYWNyb3NzIHRoZSBDbGllbnQsIFdvcmtlciwgYW5kL29yIFdvcmtmbG93XG4gKlxuICogQG1vZHVsZVxuICovXG5cbmltcG9ydCAqIGFzIGVuY29kaW5nIGZyb20gJy4vZW5jb2RpbmcnO1xuaW1wb3J0ICogYXMgaGVscGVycyBmcm9tICcuL3R5cGUtaGVscGVycyc7XG5cbmV4cG9ydCAqIGZyb20gJy4vYWN0aXZpdHktb3B0aW9ucyc7XG5leHBvcnQgKiBmcm9tICcuL2NvbnZlcnRlci9kYXRhLWNvbnZlcnRlcic7XG5leHBvcnQgKiBmcm9tICcuL2NvbnZlcnRlci9mYWlsdXJlLWNvbnZlcnRlcic7XG5leHBvcnQgKiBmcm9tICcuL2NvbnZlcnRlci9wYXlsb2FkLWNvZGVjJztcbmV4cG9ydCAqIGZyb20gJy4vY29udmVydGVyL3BheWxvYWQtY29udmVydGVyJztcbmV4cG9ydCAqIGZyb20gJy4vY29udmVydGVyL3R5cGVzJztcbmV4cG9ydCAqIGZyb20gJy4vZGVwcmVjYXRlZC10aW1lJztcbmV4cG9ydCAqIGZyb20gJy4vZXJyb3JzJztcbmV4cG9ydCAqIGZyb20gJy4vZmFpbHVyZSc7XG5leHBvcnQgeyBIZWFkZXJzLCBOZXh0IH0gZnJvbSAnLi9pbnRlcmNlcHRvcnMnO1xuZXhwb3J0ICogZnJvbSAnLi9pbnRlcmZhY2VzJztcbmV4cG9ydCAqIGZyb20gJy4vbG9nZ2VyJztcbmV4cG9ydCAqIGZyb20gJy4vcmV0cnktcG9saWN5JztcbmV4cG9ydCB0eXBlIHsgVGltZXN0YW1wLCBEdXJhdGlvbiwgU3RyaW5nVmFsdWUgfSBmcm9tICcuL3RpbWUnO1xuZXhwb3J0ICogZnJvbSAnLi93b3JrZmxvdy1oYW5kbGUnO1xuZXhwb3J0ICogZnJvbSAnLi93b3JrZmxvdy1vcHRpb25zJztcbmV4cG9ydCAqIGZyb20gJy4vdmVyc2lvbmluZy1pbnRlbnQnO1xuXG4vKipcbiAqIEVuY29kZSBhIFVURi04IHN0cmluZyBpbnRvIGEgVWludDhBcnJheVxuICpcbiAqIEBoaWRkZW5cbiAqIEBkZXByZWNhdGVkIC0gbWVhbnQgZm9yIGludGVybmFsIHVzZSBvbmx5XG4gKi9cbmV4cG9ydCBmdW5jdGlvbiB1OChzOiBzdHJpbmcpOiBVaW50OEFycmF5IHtcbiAgcmV0dXJuIGVuY29kaW5nLmVuY29kZShzKTtcbn1cblxuLyoqXG4gKiBEZWNvZGUgYSBVaW50OEFycmF5IGludG8gYSBVVEYtOCBzdHJpbmdcbiAqXG4gKiBAaGlkZGVuXG4gKiBAZGVwcmVjYXRlZCAtIG1lYW50IGZvciBpbnRlcm5hbCB1c2Ugb25seVxuICovXG5leHBvcnQgZnVuY3Rpb24gc3RyKGFycjogVWludDhBcnJheSk6IHN0cmluZyB7XG4gIHJldHVybiBlbmNvZGluZy5kZWNvZGUoYXJyKTtcbn1cblxuLyoqXG4gKiBHZXQgYGVycm9yLm1lc3NhZ2VgIChvciBgdW5kZWZpbmVkYCBpZiBub3QgcHJlc2VudClcbiAqXG4gKiBAaGlkZGVuXG4gKiBAZGVwcmVjYXRlZCAtIG1lYW50IGZvciBpbnRlcm5hbCB1c2Ugb25seVxuICovXG5leHBvcnQgZnVuY3Rpb24gZXJyb3JNZXNzYWdlKGVycm9yOiB1bmtub3duKTogc3RyaW5nIHwgdW5kZWZpbmVkIHtcbiAgcmV0dXJuIGhlbHBlcnMuZXJyb3JNZXNzYWdlKGVycm9yKTtcbn1cblxuLyoqXG4gKiBHZXQgYGVycm9yLmNvZGVgIChvciBgdW5kZWZpbmVkYCBpZiBub3QgcHJlc2VudClcbiAqXG4gKiBAaGlkZGVuXG4gKiBAZGVwcmVjYXRlZCAtIG1lYW50IGZvciBpbnRlcm5hbCB1c2Ugb25seVxuICovXG5leHBvcnQgZnVuY3Rpb24gZXJyb3JDb2RlKGVycm9yOiB1bmtub3duKTogc3RyaW5nIHwgdW5kZWZpbmVkIHtcbiAgcmV0dXJuIGhlbHBlcnMuZXJyb3JDb2RlKGVycm9yKTtcbn1cbiIsImltcG9ydCB0eXBlIHsgdGVtcG9yYWwgfSBmcm9tICdAdGVtcG9yYWxpby9wcm90byc7XG5cbmV4cG9ydCB0eXBlIFBheWxvYWQgPSB0ZW1wb3JhbC5hcGkuY29tbW9uLnYxLklQYXlsb2FkO1xuXG4vKiogVHlwZSB0aGF0IGNhbiBiZSByZXR1cm5lZCBmcm9tIGEgV29ya2Zsb3cgYGV4ZWN1dGVgIGZ1bmN0aW9uICovXG5leHBvcnQgdHlwZSBXb3JrZmxvd1JldHVyblR5cGUgPSBQcm9taXNlPGFueT47XG5leHBvcnQgdHlwZSBXb3JrZmxvd1VwZGF0ZVR5cGUgPSAoLi4uYXJnczogYW55W10pID0+IFByb21pc2U8YW55PiB8IGFueTtcbmV4cG9ydCB0eXBlIFdvcmtmbG93VXBkYXRlVmFsaWRhdG9yVHlwZSA9ICguLi5hcmdzOiBhbnlbXSkgPT4gdm9pZDtcbmV4cG9ydCB0eXBlIFdvcmtmbG93VXBkYXRlQW5ub3RhdGVkVHlwZSA9IHtcbiAgaGFuZGxlcjogV29ya2Zsb3dVcGRhdGVUeXBlO1xuICB1bmZpbmlzaGVkUG9saWN5OiBIYW5kbGVyVW5maW5pc2hlZFBvbGljeTtcbiAgdmFsaWRhdG9yPzogV29ya2Zsb3dVcGRhdGVWYWxpZGF0b3JUeXBlO1xuICBkZXNjcmlwdGlvbj86IHN0cmluZztcbn07XG5leHBvcnQgdHlwZSBXb3JrZmxvd1NpZ25hbFR5cGUgPSAoLi4uYXJnczogYW55W10pID0+IFByb21pc2U8dm9pZD4gfCB2b2lkO1xuZXhwb3J0IHR5cGUgV29ya2Zsb3dTaWduYWxBbm5vdGF0ZWRUeXBlID0ge1xuICBoYW5kbGVyOiBXb3JrZmxvd1NpZ25hbFR5cGU7XG4gIHVuZmluaXNoZWRQb2xpY3k6IEhhbmRsZXJVbmZpbmlzaGVkUG9saWN5O1xuICBkZXNjcmlwdGlvbj86IHN0cmluZztcbn07XG5leHBvcnQgdHlwZSBXb3JrZmxvd1F1ZXJ5VHlwZSA9ICguLi5hcmdzOiBhbnlbXSkgPT4gYW55O1xuZXhwb3J0IHR5cGUgV29ya2Zsb3dRdWVyeUFubm90YXRlZFR5cGUgPSB7IGhhbmRsZXI6IFdvcmtmbG93UXVlcnlUeXBlOyBkZXNjcmlwdGlvbj86IHN0cmluZyB9O1xuXG4vKipcbiAqIEJyb2FkIFdvcmtmbG93IGZ1bmN0aW9uIGRlZmluaXRpb24sIHNwZWNpZmljIFdvcmtmbG93cyB3aWxsIHR5cGljYWxseSB1c2UgYSBuYXJyb3dlciB0eXBlIGRlZmluaXRpb24sIGUuZzpcbiAqIGBgYHRzXG4gKiBleHBvcnQgYXN5bmMgZnVuY3Rpb24gbXlXb3JrZmxvdyhhcmcxOiBudW1iZXIsIGFyZzI6IHN0cmluZyk6IFByb21pc2U8c3RyaW5nPjtcbiAqIGBgYFxuICovXG5leHBvcnQgdHlwZSBXb3JrZmxvdyA9ICguLi5hcmdzOiBhbnlbXSkgPT4gV29ya2Zsb3dSZXR1cm5UeXBlO1xuXG5kZWNsYXJlIGNvbnN0IGFyZ3NCcmFuZDogdW5pcXVlIHN5bWJvbDtcbmRlY2xhcmUgY29uc3QgcmV0QnJhbmQ6IHVuaXF1ZSBzeW1ib2w7XG5cbi8qKlxuICogQW4gaW50ZXJmYWNlIHJlcHJlc2VudGluZyBhIFdvcmtmbG93IHVwZGF0ZSBkZWZpbml0aW9uLCBhcyByZXR1cm5lZCBmcm9tIHtAbGluayBkZWZpbmVVcGRhdGV9XG4gKlxuICogQHJlbWFya3MgYEFyZ3NgIGNhbiBiZSB1c2VkIGZvciBwYXJhbWV0ZXIgdHlwZSBpbmZlcmVuY2UgaW4gaGFuZGxlciBmdW5jdGlvbnMgYW5kIFdvcmtmbG93SGFuZGxlIG1ldGhvZHMuXG4gKiBgTmFtZWAgY2FuIG9wdGlvbmFsbHkgYmUgc3BlY2lmaWVkIHdpdGggYSBzdHJpbmcgbGl0ZXJhbCB0eXBlIHRvIHByZXNlcnZlIHR5cGUtbGV2ZWwga25vd2xlZGdlIG9mIHRoZSB1cGRhdGUgbmFtZS5cbiAqL1xuZXhwb3J0IGludGVyZmFjZSBVcGRhdGVEZWZpbml0aW9uPFJldCwgQXJncyBleHRlbmRzIGFueVtdID0gW10sIE5hbWUgZXh0ZW5kcyBzdHJpbmcgPSBzdHJpbmc+IHtcbiAgdHlwZTogJ3VwZGF0ZSc7XG4gIG5hbWU6IE5hbWU7XG4gIC8qKlxuICAgKiBWaXJ0dWFsIHR5cGUgYnJhbmQgdG8gbWFpbnRhaW4gYSBkaXN0aW5jdGlvbiBiZXR3ZWVuIHtAbGluayBVcGRhdGVEZWZpbml0aW9ufSB0eXBlcyB3aXRoIGRpZmZlcmVudCBhcmdzLlxuICAgKiBUaGlzIGZpZWxkIGlzIG5vdCBwcmVzZW50IGF0IHJ1bi10aW1lLlxuICAgKi9cbiAgW2FyZ3NCcmFuZF06IEFyZ3M7XG4gIC8qKlxuICAgKiBWaXJ0dWFsIHR5cGUgYnJhbmQgdG8gbWFpbnRhaW4gYSBkaXN0aW5jdGlvbiBiZXR3ZWVuIHtAbGluayBVcGRhdGVEZWZpbml0aW9ufSB0eXBlcyB3aXRoIGRpZmZlcmVudCByZXR1cm4gdHlwZXMuXG4gICAqIFRoaXMgZmllbGQgaXMgbm90IHByZXNlbnQgYXQgcnVuLXRpbWUuXG4gICAqL1xuICBbcmV0QnJhbmRdOiBSZXQ7XG59XG5cbi8qKlxuICogQW4gaW50ZXJmYWNlIHJlcHJlc2VudGluZyBhIFdvcmtmbG93IHNpZ25hbCBkZWZpbml0aW9uLCBhcyByZXR1cm5lZCBmcm9tIHtAbGluayBkZWZpbmVTaWduYWx9XG4gKlxuICogQHJlbWFya3MgYEFyZ3NgIGNhbiBiZSB1c2VkIGZvciBwYXJhbWV0ZXIgdHlwZSBpbmZlcmVuY2UgaW4gaGFuZGxlciBmdW5jdGlvbnMgYW5kIFdvcmtmbG93SGFuZGxlIG1ldGhvZHMuXG4gKiBgTmFtZWAgY2FuIG9wdGlvbmFsbHkgYmUgc3BlY2lmaWVkIHdpdGggYSBzdHJpbmcgbGl0ZXJhbCB0eXBlIHRvIHByZXNlcnZlIHR5cGUtbGV2ZWwga25vd2xlZGdlIG9mIHRoZSBzaWduYWwgbmFtZS5cbiAqL1xuZXhwb3J0IGludGVyZmFjZSBTaWduYWxEZWZpbml0aW9uPEFyZ3MgZXh0ZW5kcyBhbnlbXSA9IFtdLCBOYW1lIGV4dGVuZHMgc3RyaW5nID0gc3RyaW5nPiB7XG4gIHR5cGU6ICdzaWduYWwnO1xuICBuYW1lOiBOYW1lO1xuICAvKipcbiAgICogVmlydHVhbCB0eXBlIGJyYW5kIHRvIG1haW50YWluIGEgZGlzdGluY3Rpb24gYmV0d2VlbiB7QGxpbmsgU2lnbmFsRGVmaW5pdGlvbn0gdHlwZXMgd2l0aCBkaWZmZXJlbnQgYXJncy5cbiAgICogVGhpcyBmaWVsZCBpcyBub3QgcHJlc2VudCBhdCBydW4tdGltZS5cbiAgICovXG4gIFthcmdzQnJhbmRdOiBBcmdzO1xufVxuXG4vKipcbiAqIEFuIGludGVyZmFjZSByZXByZXNlbnRpbmcgYSBXb3JrZmxvdyBxdWVyeSBkZWZpbml0aW9uIGFzIHJldHVybmVkIGZyb20ge0BsaW5rIGRlZmluZVF1ZXJ5fVxuICpcbiAqIEByZW1hcmtzIGBBcmdzYCBhbmQgYFJldGAgY2FuIGJlIHVzZWQgZm9yIHBhcmFtZXRlciB0eXBlIGluZmVyZW5jZSBpbiBoYW5kbGVyIGZ1bmN0aW9ucyBhbmQgV29ya2Zsb3dIYW5kbGUgbWV0aG9kcy5cbiAqIGBOYW1lYCBjYW4gb3B0aW9uYWxseSBiZSBzcGVjaWZpZWQgd2l0aCBhIHN0cmluZyBsaXRlcmFsIHR5cGUgdG8gcHJlc2VydmUgdHlwZS1sZXZlbCBrbm93bGVkZ2Ugb2YgdGhlIHF1ZXJ5IG5hbWUuXG4gKi9cbmV4cG9ydCBpbnRlcmZhY2UgUXVlcnlEZWZpbml0aW9uPFJldCwgQXJncyBleHRlbmRzIGFueVtdID0gW10sIE5hbWUgZXh0ZW5kcyBzdHJpbmcgPSBzdHJpbmc+IHtcbiAgdHlwZTogJ3F1ZXJ5JztcbiAgbmFtZTogTmFtZTtcbiAgLyoqXG4gICAqIFZpcnR1YWwgdHlwZSBicmFuZCB0byBtYWludGFpbiBhIGRpc3RpbmN0aW9uIGJldHdlZW4ge0BsaW5rIFF1ZXJ5RGVmaW5pdGlvbn0gdHlwZXMgd2l0aCBkaWZmZXJlbnQgYXJncy5cbiAgICogVGhpcyBmaWVsZCBpcyBub3QgcHJlc2VudCBhdCBydW4tdGltZS5cbiAgICovXG4gIFthcmdzQnJhbmRdOiBBcmdzO1xuICAvKipcbiAgICogVmlydHVhbCB0eXBlIGJyYW5kIHRvIG1haW50YWluIGEgZGlzdGluY3Rpb24gYmV0d2VlbiB7QGxpbmsgUXVlcnlEZWZpbml0aW9ufSB0eXBlcyB3aXRoIGRpZmZlcmVudCByZXR1cm4gdHlwZXMuXG4gICAqIFRoaXMgZmllbGQgaXMgbm90IHByZXNlbnQgYXQgcnVuLXRpbWUuXG4gICAqL1xuICBbcmV0QnJhbmRdOiBSZXQ7XG59XG5cbi8qKiBHZXQgdGhlIFwidW53cmFwcGVkXCIgcmV0dXJuIHR5cGUgKHdpdGhvdXQgUHJvbWlzZSkgb2YgdGhlIGV4ZWN1dGUgaGFuZGxlciBmcm9tIFdvcmtmbG93IHR5cGUgYFdgICovXG5leHBvcnQgdHlwZSBXb3JrZmxvd1Jlc3VsdFR5cGU8VyBleHRlbmRzIFdvcmtmbG93PiA9IFJldHVyblR5cGU8Vz4gZXh0ZW5kcyBQcm9taXNlPGluZmVyIFI+ID8gUiA6IG5ldmVyO1xuXG4vKipcbiAqIElmIGFub3RoZXIgU0RLIGNyZWF0ZXMgYSBTZWFyY2ggQXR0cmlidXRlIHRoYXQncyBub3QgYW4gYXJyYXksIHdlIHdyYXAgaXQgaW4gYW4gYXJyYXkuXG4gKlxuICogRGF0ZXMgYXJlIHNlcmlhbGl6ZWQgYXMgSVNPIHN0cmluZ3MuXG4gKi9cbmV4cG9ydCB0eXBlIFNlYXJjaEF0dHJpYnV0ZXMgPSBSZWNvcmQ8c3RyaW5nLCBTZWFyY2hBdHRyaWJ1dGVWYWx1ZSB8IFJlYWRvbmx5PFNlYXJjaEF0dHJpYnV0ZVZhbHVlPiB8IHVuZGVmaW5lZD47XG5leHBvcnQgdHlwZSBTZWFyY2hBdHRyaWJ1dGVWYWx1ZSA9IHN0cmluZ1tdIHwgbnVtYmVyW10gfCBib29sZWFuW10gfCBEYXRlW107XG5cbmV4cG9ydCBpbnRlcmZhY2UgQWN0aXZpdHlGdW5jdGlvbjxQIGV4dGVuZHMgYW55W10gPSBhbnlbXSwgUiA9IGFueT4ge1xuICAoLi4uYXJnczogUCk6IFByb21pc2U8Uj47XG59XG5cbi8qKlxuICogTWFwcGluZyBvZiBBY3Rpdml0eSBuYW1lIHRvIGZ1bmN0aW9uXG4gKiBAZGVwcmVjYXRlZCBub3QgcmVxdWlyZWQgYW55bW9yZSwgZm9yIHVudHlwZWQgYWN0aXZpdGllcyB1c2Uge0BsaW5rIFVudHlwZWRBY3Rpdml0aWVzfVxuICovXG5leHBvcnQgdHlwZSBBY3Rpdml0eUludGVyZmFjZSA9IFJlY29yZDxzdHJpbmcsIEFjdGl2aXR5RnVuY3Rpb24+O1xuXG4vKipcbiAqIE1hcHBpbmcgb2YgQWN0aXZpdHkgbmFtZSB0byBmdW5jdGlvblxuICovXG5leHBvcnQgdHlwZSBVbnR5cGVkQWN0aXZpdGllcyA9IFJlY29yZDxzdHJpbmcsIEFjdGl2aXR5RnVuY3Rpb24+O1xuXG4vKipcbiAqIEEgd29ya2Zsb3cncyBoaXN0b3J5IGFuZCBJRC4gVXNlZnVsIGZvciByZXBsYXkuXG4gKi9cbmV4cG9ydCBpbnRlcmZhY2UgSGlzdG9yeUFuZFdvcmtmbG93SWQge1xuICB3b3JrZmxvd0lkOiBzdHJpbmc7XG4gIGhpc3Rvcnk6IHRlbXBvcmFsLmFwaS5oaXN0b3J5LnYxLkhpc3RvcnkgfCB1bmtub3duIHwgdW5kZWZpbmVkO1xufVxuXG4vKipcbiAqIFBvbGljeSBkZWZpbmluZyBhY3Rpb25zIHRha2VuIHdoZW4gYSB3b3JrZmxvdyBleGl0cyB3aGlsZSB1cGRhdGUgb3Igc2lnbmFsIGhhbmRsZXJzIGFyZSBydW5uaW5nLlxuICogVGhlIHdvcmtmbG93IGV4aXQgbWF5IGJlIGR1ZSB0byBzdWNjZXNzZnVsIHJldHVybiwgZmFpbHVyZSwgY2FuY2VsbGF0aW9uLCBvciBjb250aW51ZS1hcy1uZXcuXG4gKi9cbmV4cG9ydCBjb25zdCBIYW5kbGVyVW5maW5pc2hlZFBvbGljeSA9IHtcbiAgLyoqXG4gICAqIElzc3VlIGEgd2FybmluZyBpbiBhZGRpdGlvbiB0byBhYmFuZG9uaW5nIHRoZSBoYW5kbGVyIGV4ZWN1dGlvbi4gVGhlIHdhcm5pbmcgd2lsbCBub3QgYmUgaXNzdWVkIGlmIHRoZSB3b3JrZmxvdyBmYWlscy5cbiAgICovXG4gIFdBUk5fQU5EX0FCQU5ET046ICdXQVJOX0FORF9BQkFORE9OJyxcblxuICAvKipcbiAgICogQWJhbmRvbiB0aGUgaGFuZGxlciBleGVjdXRpb24uXG4gICAqXG4gICAqIEluIHRoZSBjYXNlIG9mIGFuIHVwZGF0ZSBoYW5kbGVyIHRoaXMgbWVhbnMgdGhhdCB0aGUgY2xpZW50IHdpbGwgcmVjZWl2ZSBhbiBlcnJvciByYXRoZXIgdGhhblxuICAgKiB0aGUgdXBkYXRlIHJlc3VsdC5cbiAgICovXG4gIEFCQU5ET046ICdBQkFORE9OJyxcbn0gYXMgY29uc3Q7XG5leHBvcnQgdHlwZSBIYW5kbGVyVW5maW5pc2hlZFBvbGljeSA9ICh0eXBlb2YgSGFuZGxlclVuZmluaXNoZWRQb2xpY3kpW2tleW9mIHR5cGVvZiBIYW5kbGVyVW5maW5pc2hlZFBvbGljeV07XG4iLCJpbXBvcnQgeyBWYWx1ZUVycm9yIH0gZnJvbSAnLi4vZXJyb3JzJztcbmltcG9ydCB7IEV4YWN0LCBSZW1vdmVQcmVmaXgsIFVuaW9uVG9JbnRlcnNlY3Rpb24gfSBmcm9tICcuLi90eXBlLWhlbHBlcnMnO1xuXG4vKipcbiAqIENyZWF0ZSBlbmNvZGluZyBhbmQgZGVjb2RpbmcgZnVuY3Rpb25zIHRvIGNvbnZlcnQgYmV0d2VlbiB0aGUgbnVtZXJpYyBgZW51bWAgdHlwZXMgcHJvZHVjZWQgYnkgb3VyXG4gKiBQcm90b2J1ZiBjb21waWxlciBhbmQgXCJjb25zdCBvYmplY3Qgb2Ygc3RyaW5nc1wiIGVudW0gdmFsdWVzIHRoYXQgd2UgZXhwb3NlIGluIG91ciBwdWJsaWMgQVBJcy5cbiAqXG4gKiAjIyMgVXNhZ2VcbiAqXG4gKiBOZXdseSBpbnRyb2R1Y2VkIGVudW1zIHNob3VsZCBmb2xsb3cgdGhlIGZvbGxvd2luZyBwYXR0ZXJuOlxuICpcbiAqIGBgYHRzXG4gKiAgICAgdHlwZSBQYXJlbnRDbG9zZVBvbGljeSA9ICh0eXBlb2YgUGFyZW50Q2xvc2VQb2xpY3kpW2tleW9mIHR5cGVvZiBQYXJlbnRDbG9zZVBvbGljeV07XG4gKiAgICAgY29uc3QgUGFyZW50Q2xvc2VQb2xpY3kgPSB7XG4gKiAgICAgICBURVJNSU5BVEU6ICdURVJNSU5BVEUnLFxuICogICAgICAgQUJBTkRPTjogJ0FCQU5ET04nLFxuICogICAgICAgUkVRVUVTVF9DQU5DRUw6ICdSRVFVRVNUX0NBTkNFTCcsXG4gKiAgICAgfSBhcyBjb25zdDtcbiAqXG4gKiAgICAgY29uc3QgW2VuY29kZVBhcmVudENsb3NlUG9saWN5LCBkZWNvZGVQYXJlbnRDbG9zZVBvbGljeV0gPSAvL1xuICogICAgICAgbWFrZVByb3RvRW51bUNvbnZlcnRlcnM8XG4gKiAgICAgICAgIGNvcmVzZGsuY2hpbGRfd29ya2Zsb3cuUGFyZW50Q2xvc2VQb2xpY3ksXG4gKiAgICAgICAgIHR5cGVvZiBjb3Jlc2RrLmNoaWxkX3dvcmtmbG93LlBhcmVudENsb3NlUG9saWN5LFxuICogICAgICAgICBrZXlvZiB0eXBlb2YgY29yZXNkay5jaGlsZF93b3JrZmxvdy5QYXJlbnRDbG9zZVBvbGljeSxcbiAqICAgICAgICAgdHlwZW9mIFBhcmVudENsb3NlUG9saWN5LFxuICogICAgICAgICAnUEFSRU5UX0NMT1NFX1BPTElDWV8nICAvLyBUaGlzIG1heSBiZSBhbiBlbXB0eSBzdHJpbmcgaWYgdGhlIHByb3RvIGVudW0gZG9lc24ndCBhZGQgYSByZXBlYXRlZCBwcmVmaXggb24gdmFsdWVzXG4gKiAgICAgICA+KFxuICogICAgICAgICB7XG4gKiAgICAgICAgICAgW1BhcmVudENsb3NlUG9saWN5LlRFUk1JTkFURV06IDEsIC8vIFRoZXNlIG51bWJlcnMgbXVzdCBtYXRjaCB0aGUgb25lcyBpbiB0aGUgcHJvdG8gZW51bVxuICogICAgICAgICAgIFtQYXJlbnRDbG9zZVBvbGljeS5BQkFORE9OXTogMixcbiAqICAgICAgICAgICBbUGFyZW50Q2xvc2VQb2xpY3kuUkVRVUVTVF9DQU5DRUxdOiAzLFxuICpcbiAqICAgICAgICAgICBVTlNQRUNJRklFRDogMCxcbiAqICAgICAgICAgfSBhcyBjb25zdCxcbiAqICAgICAgICAgJ1BBUkVOVF9DTE9TRV9QT0xJQ1lfJ1xuICogICAgICAgKTtcbiAqIGBgYFxuICpcbiAqIGBtYWtlUHJvdG9FbnVtQ29udmVydGVyc2Agc3VwcG9ydHMgb3RoZXIgdXNhZ2UgcGF0dGVybnMsIGJ1dCB0aGV5IGFyZSBvbmx5IG1lYW50IGZvclxuICogYmFja3dhcmQgY29tcGF0aWJpbGl0eSB3aXRoIGZvcm1lciBlbnVtIGRlZmluaXRpb25zIGFuZCBzaG91bGQgbm90IGJlIHVzZWQgZm9yIG5ldyBlbnVtcy5cbiAqXG4gKiAjIyMgQ29udGV4dFxuICpcbiAqIFRlbXBvcmFsJ3MgUHJvdG9idWYgQVBJcyBkZWZpbmUgc2V2ZXJhbCBgZW51bWAgdHlwZXM7IG91ciBQcm90b2J1ZiBjb21waWxlciB0cmFuc2Zvcm1zIHRoZXNlIHRvXG4gKiB0cmFkaXRpb25hbCAoaS5lLiBub24tY29uc3QpIFtUeXBlU2NyaXB0IG51bWVyaWMgYGVudW1gc10oaHR0cHM6Ly93d3cudHlwZXNjcmlwdGxhbmcub3JnL2RvY3MvaGFuZGJvb2svZW51bXMuaHRtbCNudW1lcmljLWVudW1zKS5cbiAqXG4gKiBGb3IgdmFyaW91cyByZWFzb25zLCB0aGlzIGlzIGZhciBmcm9tIGlkZWFsOlxuICpcbiAqICAtIER1ZSB0byB0aGUgZHVhbCBuYXR1cmUgb2Ygbm9uLWNvbnN0IFR5cGVTY3JpcHQgYGVudW1gcyAodGhleSBhcmUgYm90aCBhIHR5cGUgYW5kIGEgdmFsdWUpLFxuICogICAgaXQgaXMgbm90IHBvc3NpYmxlIHRvIHJlZmVyIHRvIGFuIGVudW0gdmFsdWUgZnJvbSBjb2RlIHdpdGhvdXQgYSBcInJlYWxcIiBpbXBvcnQgb2YgdGhlIGVudW0gdHlwZVxuICogICAgKGkuZS4gY2FuJ3Qgc2ltcGx5IGRvIGBpbXBvcnQgdHlwZSAuLi5gKS4gSW4gV29ya2Zsb3cgY29kZSwgc3VjaCBhbiBpbXBvcnQgd291bGQgcmVzdWx0IGluXG4gKiAgICBsb2FkaW5nIG91ciBlbnRpcmUgUHJvdG9idWYgZGVmaW5pdGlvbnMgaW50byB0aGUgd29ya2Zsb3cgc2FuZGJveCwgYWRkaW5nIHNldmVyYWwgbWVnYWJ5dGVzIHRvXG4gKiAgICB0aGUgcGVyLXdvcmtmbG93IG1lbW9yeSBmb290cHJpbnQsIHdoaWNoIGlzIHVuYWNjZXB0YWJsZTsgdG8gYXZvaWQgdGhhdCwgd2UgbmVlZCB0byBtYWludGFpblxuICogICAgYSBtaXJyb3IgY29weSBvZiBlYWNoIGVudW0gdHlwZXMgdXNlZCBieSBpbi13b3JrZmxvdyBBUElzLCBhbmQgZXhwb3J0IHRoZXNlIGZyb20gZWl0aGVyXG4gKiAgICBgQHRlbXBvcmFsaW8vY29tbW9uYCBvciBgQHRlbXBvcmFsaW8vd29ya2Zsb3dgLlxuICogIC0gSXQgaXMgbm90IGRlc2lyYWJsZSBmb3IgdXNlcnMgdG8gbmVlZCBhbiBleHBsaWNpdCBkZXBlbmRlbmN5IG9uIGBAdGVtcG9yYWxpby9wcm90b2AganVzdCB0b1xuICogICAgZ2V0IGFjY2VzcyB0byB0aGVzZSBlbnVtIHR5cGVzOyB3ZSB0aGVyZWZvcmUgbWFkZSBpdCBhIGNvbW1vbiBwcmFjdGljZSB0byByZWV4cG9ydCB0aGVzZSBlbnVtc1xuICogICAgZnJvbSBvdXIgcHVibGljIGZhY2luZyBwYWNrYWdlcy4gSG93ZXZlciwgZXhwZXJpZW5jZSBkZW1vbnRyYXRlZCB0aGF0IHRoZXNlIHJlZXhwb3J0cyBlZmZlY3RpdmVseVxuICogICAgcmVzdWx0ZWQgaW4gcG9vciBhbmQgaW5jb25zaXN0ZW50IGRvY3VtZW50YXRpb24gY292ZXJhZ2UgY29tcGFyZWQgdG8gbWlycm9yZWQgZW51bXMgdHlwZXMuXG4gKiAgLSBPdXIgUHJvdG9idWYgZW51bSB0eXBlcyB0ZW5kIHRvIGZvbGxvdyBhIHZlcmJvc2UgYW5kIHJlZHVuZGFudCBuYW1pbmcgY29udmVudGlvbiwgd2hpY2ggZmVlbHNcbiAqICAgIHVuYXR1cmFsIGFuZCBleGNlc3NpdmUgYWNjb3JkaW5nIHRvIG1vc3QgVHlwZVNjcmlwdCBzdHlsZSBndWlkZXM7IGUuZy4gaW5zdGVhZCBvZlxuICogICAgYHdvcmtmbG93SWRSZXVzZVBvbGljeTogV29ya2Zsb3dJZFJldXNlUG9saWN5LldPUktGTE9XX0lEX1JFVVNFX1BPTElDWV9SRUpFQ1RfRFVQTElDQVRFYCxcbiAqICAgIGEgVHlwZVNjcmlwdCBkZXZlbG9wZXIgd291bGQgZ2VuZXJhbGx5IGV4cGVjdCB0byBiZSBhYmxlIHRvIHdyaXRlIHNvbWV0aGluZyBzaW1pbGFyIHRvXG4gKiAgICBgd29ya2Zsb3dJZFJldXNlUG9saWN5OiAnUkVKRUNUX0RVUExJQ0FURSdgLlxuICogIC0gQmVjYXVzZSBvZiB0aGUgd2F5IFByb3RvYnVmIHdvcmtzLCBtYW55IG9mIG91ciBlbnVtIHR5cGVzIGNvbnRhaW4gYW4gYFVOU1BFQ0lGSUVEYCB2YWx1ZSwgd2hpY2hcbiAqICAgIGlzIHVzZWQgdG8gZXhwbGljaXRseSBpZGVudGlmeSBhIHZhbHVlIHRoYXQgaXMgdW5zZXQuIEluIFR5cGVTY3JpcHQgY29kZSwgdGhlIGB1bmRlZmluZWRgIHZhbHVlXG4gKiAgICBhbHJlYWR5IHNlcnZlcyB0aGF0IHB1cnBvc2UsIGFuZCBpcyBkZWZpbml0ZWx5IG1vcmUgaWRpb21hdGljIHRvIFRTIGRldmVsb3BlcnMsIHdoZXJlYXMgdGhlc2VcbiAqICAgIGBVTlNQRUNJRklFRGAgdmFsdWVzIGNyZWF0ZSBub2lzZSBhbmQgY29uZnVzaW9uIGluIG91ciBBUElzLlxuICogIC0gVHlwZVNjcmlwdCBlZGl0b3JzIGdlbmVyYWxseSBkbyBhIHZlcnkgYmFkIGpvYiBhdCBwcm92aWRpbmcgYXV0b2NvbXBsZXRpb24gdGhhdCBpbXBsaWVzIHJlYWNoaW5nXG4gKiAgICBmb3IgdmFsdWVzIG9mIGEgVHlwZVNjcmlwdCBlbnVtIHR5cGUsIGZvcmNpbmcgZGV2ZWxvcGVycyB0byBleHBsaWNpdGx5IHR5cGUgaW4gYXQgbGVhc3QgcGFydFxuICogICAgb2YgdGhlIG5hbWUgb2YgdGhlIGVudW0gdHlwZSBiZWZvcmUgdGhleSBjYW4gZ2V0IGF1dG9jb21wbGV0aW9uIGZvciBpdHMgdmFsdWVzLiBPbiB0aGUgb3RoZXJcbiAqICAgIGhhbmQsIGFsbCBUUyBlZGl0b3JzIGltbWVkaWF0ZWx5IHByb3ZpZGUgYXV0b2NvbXBsZXRpb24gZm9yIHN0cmluZyB1bmlvbiB0eXBlcy5cbiAqICAtIFRoZSBbVHlwZVNjcmlwdCdzIG9mZmljaWFsIGRvY3VtZW50YXRpb25dKGh0dHBzOi8vd3d3LnR5cGVzY3JpcHRsYW5nLm9yZy9kb2NzL2hhbmRib29rL2VudW1zLmh0bWwjb2JqZWN0cy12cy1lbnVtcylcbiAqICAgIGl0c2VsZiBzdWdnZXN0cyB0aGF0LCBpbiBtb2Rlcm4gVHlwZVNjcmlwdCwgdGhlIHVzZSBvZiBgYXMgY29uc3RgIG9iamVjdHMgbWF5IGdlbmVyYWxseSBzdWZmaWNlXG4gKiAgICBhbmQgbWF5IGJlIGFkdmFudGFnZW91cyBvdmVyIHRoZSB1c2Ugb2YgYGVudW1gIHR5cGVzLlxuICpcbiAqIEEgY29uc3Qgb2JqZWN0IG9mIHN0cmluZ3MsIGNvbWJpbmVkIHdpdGggYSB1bmlvbiB0eXBlIG9mIHBvc3NpYmxlIHN0cmluZyB2YWx1ZXMsIHByb3ZpZGVzIGEgbXVjaFxuICogbW9yZSBpZGlvbWF0aWMgc3ludGF4IGFuZCBhIGJldHRlciBEWCBmb3IgVHlwZVNjcmlwdCBkZXZlbG9wZXJzLiBUaGlzIGhvd2V2ZXIgcmVxdWlyZXMgYSB3YXkgdG9cbiAqIGNvbnZlcnQgYmFjayBhbmQgZm9ydGggYmV0d2VlbiB0aGUgYGVudW1gIHZhbHVlcyBwcm9kdWNlZCBieSB0aGUgUHJvdG9idWYgY29tcGlsZXIgYW5kIHRoZVxuICogZXF1aXZhbGVudCBzdHJpbmcgdmFsdWVzLlxuICpcbiAqIFRoaXMgaGVscGVyIGR5bmFtaWNhbGx5IGNyZWF0ZXMgdGhlc2UgY29udmVyc2lvbiBmdW5jdGlvbnMgZm9yIGEgZ2l2ZW4gUHJvdG9idWYgZW51bSB0eXBlLFxuICogc3Ryb25nbHkgYnVpbGRpbmcgdXBvbiBzcGVjaWZpYyBjb252ZW50aW9ucyB0aGF0IHdlIGhhdmUgYWRvcHRlZCBpbiBvdXIgUHJvdG9idWYgZGVmaW5pdGlvbnMuXG4gKlxuICogIyMjIFZhbGlkYXRpb25zXG4gKlxuICogVGhlIGNvbXBsZXggdHlwZSBzaWduYXR1cmUgb2YgdGhpcyBoZWxwZXIgaXMgdGhlcmUgdG8gcHJldmVudCBtb3N0IHBvdGVudGlhbCBpbmNvaGVyZW5jaWVzXG4gKiB0aGF0IGNvdWxkIHJlc3VsdCBmcm9tIGhhdmluZyB0byBtYW51YWxseSBzeW5jaHJvbml6ZSB0aGUgY29uc3Qgb2JqZWN0IG9mIHN0cmluZ3MgZW51bSBhbmQgdGhlXG4gKiBjb252ZXJzaW9uIHRhYmxlIHdpdGggdGhlIHByb3RvIGVudW0sIHdoaWxlIG5vdCByZXF1aXJpbmcgYSByZWd1bGFyIGltcG9ydCBvbiB0aGUgUHJvdG9idWYgZW51bVxuICogaXRzZWxmIChzbyBpdCBjYW4gYmUgdXNlZCBzYWZlbHkgZm9yIGVudW1zIG1lYW50IHRvIGJlIHVzZWQgZnJvbSB3b3JrZmxvdyBjb2RlKS5cbiAqXG4gKiBJbiBwYXJ0aWN1bGFyLCBmYWlsaW5nIGFueSBvZiB0aGUgZm9sbG93aW5nIGludmFyaWFudHMgd2lsbCByZXN1bHQgaW4gYnVpbGQgdGltZSBlcnJvcnM6XG4gKlxuICogLSBGb3IgZXZlcnkga2V5IG9mIHRoZSBmb3JtIGBQUkVGSVhfS0VZOiBudW1iZXJgIGluIHRoZSBwcm90byBlbnVtLCBleGNsdWRpbmcgdGhlIGBVTlNQRUNJRklFRGAga2V5OlxuICogICAtIFRoZXJlIE1VU1QgYmUgYSBjb3JyZXNwb25kaW5nIGBLRVk6ICdLRVknYCBlbnRyeSBpbiB0aGUgY29uc3Qgb2JqZWN0IG9mIHN0cmluZ3MgZW51bTtcbiAqICAgLSBUaGVyZSBNQVkgYmUgYSBjb3JyZXNwb25kaW5nIGBQUkVGSVhfS0VZOiAnS0VZJ2AgaW4gdGhlIGNvbnN0IG9iamVjdCBvZiBzdHJpbmdzIGVudW1cbiAqICAgICAodGhpcyBpcyBtZWFudCB0byBwcmVzZXJ2ZSBiYWNrd2FyZCBjb21wYXRpYmlsaXR5IHdpdGggdGhlIGZvcm1lciBzeW50YXg7IHN1Y2ggYWxpYXNlcyBzaG91bGRcbiAqICAgICBub3QgYmUgYWRkZWQgZm9yIG5ldyBlbnVtcyBhbmQgZW51bSBlbnRyaWVzIGludHJvZHVjZWQgZ29pbmcgZm9yd2FyZCk7XG4gKiAgIC0gVGhlcmUgTVVTVCBiZSBhIGNvcnJlc3BvbmRpbmcgYEtFWTogbnVtYmVyYCBpbiB0aGUgbWFwcGluZyB0YWJsZS5cbiAqIC0gSWYgdGhlIHByb3RvIGVudW0gY29udGFpbnMgYSBgUFJFRklYX1VOU1BFQ0lGSUVEYCBlbnRyeSwgdGhlbjpcbiAqICAgLSBUaGVyZSBNQVkgYmUgYSBjb3JyZXNwb25kaW5nIGBQUkVGSVhfVU5TUEVDSUZJRUQ6IHVuZGVmaW5lZGAgYW5kL29yIGBVTlNQRUNJRklFRDogdW5kZWZpbmVkYFxuICogICAgIGVudHJpZXMgaW4gdGhlIGNvbnN0IG9iamVjdCBvZiBzdHJpbmdzIGVudW0g4oCUIHRoaXMgaXMgbWVhbnQgdG8gcHJlc2VydmUgYmFja3dhcmQgY29tcGF0aWJpbGl0eVxuICogICAgIHdpdGggdGhlIGZvcm1lciBzeW50YXg7IHRoaXMgYWxpYXMgc2hvdWxkIG5vdCBiZSBhZGRlZCBmb3IgbmV3IGVudW1zIGludHJvZHVjZWQgZ29pbmcgZm9yd2FyZDtcbiAqICAgLSBUaGVyZSBNVVNUIGJlIGFuIGBVTlNQRUNJRklFRDogMGAgaW4gdGhlIG1hcHBpbmcgdGFibGUuXG4gKiAtIFRoZSBjb25zdCBvYmplY3Qgb2Ygc3RyaW5ncyBlbnVtIE1VU1QgTk9UIGNvbnRhaW4gYW55IG90aGVyIGtleXMgdGhhbiB0aGUgb25lcyBtYW5kYXRlZCBvclxuICogICBvcHRpb25hbGx5IGFsbG93ZWQgYmUgdGhlIHByZWNlZWRpbmcgcnVsZXMuXG4gKiAtIFRoZSBtYXBwaW5nIHRhYmxlIE1VU1QgTk9UIGNvbnRhaW4gYW55IG90aGVyIGtleXMgdGhhbiB0aGUgb25lcyBtYW5kYXRlZCBhYm92ZS5cbiAqXG4gKiBUaGVzZSBydWxlcyBub3RhYmx5IGVuc3VyZSB0aGF0IHdoZW5ldmVyIGEgbmV3IHZhbHVlIGlzIGFkZGVkIHRvIGFuIGV4aXN0aW5nIFByb3RvIGVudW0sIHRoZSBjb2RlXG4gKiB3aWxsIGZhaWwgdG8gY29tcGlsZSB1bnRpbCB0aGUgY29ycmVzcG9uZGluZyBlbnRyeSBpcyBhZGRlZCBvbiB0aGUgY29uc3Qgb2JqZWN0IG9mIHN0cmluZ3MgZW51bVxuICogYW5kIHRoZSBtYXBwaW5nIHRhYmxlLlxuICpcbiAqIEBpbnRlcm5hbFxuICovXG5leHBvcnQgZnVuY3Rpb24gbWFrZVByb3RvRW51bUNvbnZlcnRlcnM8XG4gIFByb3RvRW51bVZhbHVlIGV4dGVuZHMgbnVtYmVyLFxuICBQcm90b0VudW0gZXh0ZW5kcyB7IFtrIGluIFByb3RvRW51bUtleV06IFByb3RvRW51bVZhbHVlIH0sXG4gIFByb3RvRW51bUtleSBleHRlbmRzIGAke1ByZWZpeH0ke3N0cmluZ31gLFxuICBTdHJpbmdFbnVtVHlwZUFjdHVhbCBleHRlbmRzIEV4YWN0PFN0cmluZ0VudW1UeXBlLCBTdHJpbmdFbnVtVHlwZUFjdHVhbD4sXG4gIFByZWZpeCBleHRlbmRzIHN0cmluZyxcbiAgLy9cbiAgLy8gUGFyYW1ldGVycyBhZnRlciB0aGlzIHBvaW50IHdpbGwgYmUgaW5mZXJyZWQ7IHRoZXkncmUgbm90IG1lYW50IG5vdCB0byBiZSBzcGVjaWZpZWQgYnkgZGV2ZWxvcGVyc1xuICBVbnNwZWNpZmllZCA9IFByb3RvRW51bUtleSBleHRlbmRzIGAke1ByZWZpeH1VTlNQRUNJRklFRGAgPyAnVU5TUEVDSUZJRUQnIDogbmV2ZXIsXG4gIFNob3J0U3RyaW5nRW51bUtleSBleHRlbmRzIFJlbW92ZVByZWZpeDxQcmVmaXgsIFByb3RvRW51bUtleT4gPSBFeGNsdWRlPFxuICAgIFJlbW92ZVByZWZpeDxQcmVmaXgsIFByb3RvRW51bUtleT4sXG4gICAgVW5zcGVjaWZpZWRcbiAgPixcbiAgU3RyaW5nRW51bVR5cGUgZXh0ZW5kcyBQcm90b0NvbnN0T2JqZWN0T2ZTdHJpbmdzRW51bTxcbiAgICBTaG9ydFN0cmluZ0VudW1LZXksXG4gICAgUHJlZml4LFxuICAgIFVuc3BlY2lmaWVkXG4gID4gPSBQcm90b0NvbnN0T2JqZWN0T2ZTdHJpbmdzRW51bTxTaG9ydFN0cmluZ0VudW1LZXksIFByZWZpeCwgVW5zcGVjaWZpZWQ+LFxuICBNYXBUYWJsZSBleHRlbmRzIFByb3RvRW51bVRvQ29uc3RPYmplY3RPZlN0cmluZ01hcFRhYmxlPFxuICAgIFN0cmluZ0VudW1UeXBlLFxuICAgIFByb3RvRW51bVZhbHVlLFxuICAgIFByb3RvRW51bSxcbiAgICBQcm90b0VudW1LZXksXG4gICAgUHJlZml4LFxuICAgIFVuc3BlY2lmaWVkLFxuICAgIFNob3J0U3RyaW5nRW51bUtleVxuICA+ID0gUHJvdG9FbnVtVG9Db25zdE9iamVjdE9mU3RyaW5nTWFwVGFibGU8XG4gICAgU3RyaW5nRW51bVR5cGUsXG4gICAgUHJvdG9FbnVtVmFsdWUsXG4gICAgUHJvdG9FbnVtLFxuICAgIFByb3RvRW51bUtleSxcbiAgICBQcmVmaXgsXG4gICAgVW5zcGVjaWZpZWQsXG4gICAgU2hvcnRTdHJpbmdFbnVtS2V5XG4gID4sXG4+KFxuICBtYXBUYWJsZTogTWFwVGFibGUsXG4gIHByZWZpeDogUHJlZml4XG4pOiBbXG4gIChcbiAgICBpbnB1dDogU2hvcnRTdHJpbmdFbnVtS2V5IHwgYCR7UHJlZml4fSR7U2hvcnRTdHJpbmdFbnVtS2V5fWAgfCBQcm90b0VudW1WYWx1ZSB8IG51bGwgfCB1bmRlZmluZWRcbiAgKSA9PiBQcm90b0VudW1WYWx1ZSB8IHVuZGVmaW5lZCwgLy9cbiAgKGlucHV0OiBQcm90b0VudW1WYWx1ZSB8IG51bGwgfCB1bmRlZmluZWQpID0+IFNob3J0U3RyaW5nRW51bUtleSB8IHVuZGVmaW5lZCwgLy9cbl0ge1xuICBjb25zdCByZXZlcnNlVGFibGU6IFJlY29yZDxQcm90b0VudW1WYWx1ZSwgU2hvcnRTdHJpbmdFbnVtS2V5PiA9IE9iamVjdC5mcm9tRW50cmllcyhcbiAgICBPYmplY3QuZW50cmllcyhtYXBUYWJsZSkubWFwKChbaywgdl0pID0+IFt2LCBrXSlcbiAgKTtcbiAgY29uc3QgaGFzVW5zcGVjaWZpZWQgPSAobWFwVGFibGUgYXMgYW55KVsnVU5TUEVDSUZJRUQnXSA9PT0gMCB8fCAobWFwVGFibGUgYXMgYW55KVtgJHtwcmVmaXh9VU5TUEVDSUZJRURgXSA9PT0gMDtcblxuICBmdW5jdGlvbiBpc1Nob3J0U3RyaW5nRW51bUtleXMoeDogdW5rbm93bik6IHggaXMgU2hvcnRTdHJpbmdFbnVtS2V5IHtcbiAgICByZXR1cm4gdHlwZW9mIHggPT09ICdzdHJpbmcnICYmIHggaW4gbWFwVGFibGU7XG4gIH1cblxuICBmdW5jdGlvbiBpc051bWVyaWNFbnVtVmFsdWUoeDogdW5rbm93bik6IHggaXMgUHJvdG9FbnVtW2tleW9mIFByb3RvRW51bV0ge1xuICAgIHJldHVybiB0eXBlb2YgeCA9PT0gJ251bWJlcicgJiYgeCBpbiByZXZlcnNlVGFibGU7XG4gIH1cblxuICBmdW5jdGlvbiBlbmNvZGUoXG4gICAgaW5wdXQ6IFNob3J0U3RyaW5nRW51bUtleSB8IGAke1ByZWZpeH0ke1Nob3J0U3RyaW5nRW51bUtleX1gIHwgUHJvdG9FbnVtVmFsdWUgfCBudWxsIHwgdW5kZWZpbmVkXG4gICk6IFByb3RvRW51bVZhbHVlIHwgdW5kZWZpbmVkIHtcbiAgICBpZiAoaW5wdXQgPT0gbnVsbCkge1xuICAgICAgcmV0dXJuIHVuZGVmaW5lZDtcbiAgICB9IGVsc2UgaWYgKHR5cGVvZiBpbnB1dCA9PT0gJ3N0cmluZycpIHtcbiAgICAgIGxldCBzaG9ydGVuOiBzdHJpbmcgPSBpbnB1dDtcbiAgICAgIGlmIChzaG9ydGVuLnN0YXJ0c1dpdGgocHJlZml4KSkge1xuICAgICAgICBzaG9ydGVuID0gc2hvcnRlbi5zbGljZShwcmVmaXgubGVuZ3RoKTtcbiAgICAgIH1cbiAgICAgIGlmIChpc1Nob3J0U3RyaW5nRW51bUtleXMoc2hvcnRlbikpIHtcbiAgICAgICAgcmV0dXJuIG1hcFRhYmxlW3Nob3J0ZW5dO1xuICAgICAgfVxuICAgICAgdGhyb3cgbmV3IFZhbHVlRXJyb3IoYEludmFsaWQgZW51bSB2YWx1ZTogJyR7aW5wdXR9J2ApO1xuICAgIH0gZWxzZSBpZiAodHlwZW9mIGlucHV0ID09PSAnbnVtYmVyJykge1xuICAgICAgcmV0dXJuIGlucHV0O1xuICAgIH0gZWxzZSB7XG4gICAgICB0aHJvdyBuZXcgVmFsdWVFcnJvcihgSW52YWxpZCBlbnVtIHZhbHVlOiAnJHtpbnB1dH0nIG9mIHR5cGUgJHt0eXBlb2YgaW5wdXR9YCk7XG4gICAgfVxuICB9XG5cbiAgZnVuY3Rpb24gZGVjb2RlKGlucHV0OiBQcm90b0VudW1WYWx1ZSB8IG51bGwgfCB1bmRlZmluZWQpOiBTaG9ydFN0cmluZ0VudW1LZXkgfCB1bmRlZmluZWQge1xuICAgIGlmIChpbnB1dCA9PSBudWxsKSB7XG4gICAgICByZXR1cm4gdW5kZWZpbmVkO1xuICAgIH0gZWxzZSBpZiAodHlwZW9mIGlucHV0ID09PSAnbnVtYmVyJykge1xuICAgICAgaWYgKGhhc1Vuc3BlY2lmaWVkICYmIGlucHV0ID09PSAwKSB7XG4gICAgICAgIHJldHVybiB1bmRlZmluZWQ7XG4gICAgICB9XG5cbiAgICAgIGlmIChpc051bWVyaWNFbnVtVmFsdWUoaW5wdXQpKSB7XG4gICAgICAgIHJldHVybiByZXZlcnNlVGFibGVbaW5wdXRdO1xuICAgICAgfVxuXG4gICAgICAvLyBXZSBnb3QgYSBwcm90byBlbnVtIHZhbHVlIHRoYXQgd2UgZG9uJ3QgeWV0IGtub3cgYWJvdXQgKGkuZS4gaXQgZGlkbid0IGV4aXN0IHdoZW4gdGhpcyBjb2RlXG4gICAgICAvLyB3YXMgY29tcGlsZWQpLiBUaGlzIGlzIGNlcnRhaW5seSBhIHBvc3NpYmlsaXR5LCBidXQgZ2l2ZW4gaG93IG91ciBBUElzIGV2b2x2ZSwgdGhpcyBpcyBpc1xuICAgICAgLy8gdW5saWtlbHkgdG8gYmUgYSB0ZXJyaWJseSBiYWQgdGhpbmcgYnkgaXRzZWxmICh3ZSBhdm9pZCBhZGRpbmcgbmV3IGVudW0gdmFsdWVzIGluIHBsYWNlc1xuICAgICAgLy8gdGhhdCB3b3VsZCBicmVhayBiYWNrd2FyZCBjb21wYXRpYmlsaXR5IHdpdGggZXhpc3RpbmcgZGVwbG95ZWQgY29kZSkuIFRoZXJlZm9yZSwgdGhyb3dpbmdcbiAgICAgIC8vIG9uIFwidW5leHBlY3RlZFwiIHZhbHVlcyBpcyBsaWtlbHkgdG8gZW5kIHVwIGNhdXNpbmcgbW9yZSBwcm9ibGVtcyB0aGFuIGl0IG1pZ2h0IGF2b2lkLFxuICAgICAgLy8gZXNwZWNpYWxseSBnaXZlbiB0aGF0IHRoZSBkZWNvZGVkIHZhbHVlIG1heSBhY3R1YWxseSBuZXZlciBnZXQgcmVhZCBhbnd5YXkuXG4gICAgICAvL1xuICAgICAgLy8gVGhlcmVmb3JlLCB3ZSBpbnN0ZWFkIGNoZWF0IG9uIHR5cGUgY29uc3RyYWludHMgYW5kIHJldHVybiBhIHN0cmluZyBvZiB0aGUgZm9ybSBcInVua25vd25fMjNcIi5cbiAgICAgIC8vIFRoYXQgc29tZXdoYXQgbWlycm9ycyB0aGUgYmVoYXZpb3Igd2UnZCBnZXQgd2l0aCB0aGUgcHVyZSBudW1lcmljYWwgYXBwcm9hY2guXG4gICAgICByZXR1cm4gYHVua25vd25fJHtpbnB1dH1gIGFzIFNob3J0U3RyaW5nRW51bUtleTtcbiAgICB9XG5cbiAgICB0aHJvdyBuZXcgVmFsdWVFcnJvcihgSW52YWxpZCBwcm90byBlbnVtIHZhbHVlOiAnJHtpbnB1dH0nIG9mIHR5cGUgJHt0eXBlb2YgaW5wdXR9YCk7XG4gIH1cblxuICByZXR1cm4gW2VuY29kZSwgZGVjb2RlXSBhcyBjb25zdDtcbn1cblxuLyoqXG4gKiBHaXZlbiB0aGUgZXhwbG9kZWQgcGFyYW1ldGVycyBvZiBhIHByb3RvIGVudW0gKGkuZS4gc2hvcnQga2V5cywgcHJlZml4LCBhbmQgc2hvcnQga2V5IG9mIHRoZVxuICogdW5zcGVjaWZpZWQgdmFsdWUpLCBtYWtlIGEgdHlwZSB0aGF0IF9leGFjdGx5XyBjb3JyZXNwb25kcyB0byB0aGUgY29uc3Qgb2JqZWN0IG9mIHN0cmluZ3MgZW51bSxcbiAqIGUuZy4gdGhlIHR5cGUgdGhhdCB0aGUgZGV2ZWxvcGVyIGlzIGV4cGVjdGVkIHRvIHdyaXRlLlxuICpcbiAqIEZvciBleGFtcGxlLCBmb3IgY29yZXNkay5jaGlsZF93b3JrZmxvdy5QYXJlbnRDbG9zZVBvbGljeSwgdGhpcyBldmFsdWF0ZXMgdG86XG4gKlxuICoge1xuICogICBURVJNSU5BVEU6IFwiVEVSTUlOQVRFXCI7XG4gKiAgIEFCQU5ET046IFwiQUJBTkRPTlwiO1xuICogICBSRVFVRVNUX0NBTkNFTDogXCJSRVFVRVNUX0NBTkNFTFwiO1xuICpcbiAqICAgUEFSRU5UX0NMT1NFX1BPTElDWV9URVJNSU5BVEU/OiBcIlRFUk1JTkFURVwiO1xuICogICBQQVJFTlRfQ0xPU0VfUE9MSUNZX0FCQU5ET04/OiBcIkFCQU5ET05cIjtcbiAqICAgUEFSRU5UX0NMT1NFX1BPTElDWV9SRVFVRVNUX0NBTkNFTD86IFwiUkVRVUVTVF9DQU5DRUxcIjtcbiAqXG4gKiAgIFBBUkVOVF9DTE9TRV9QT0xJQ1lfVU5TUEVDSUZJRUQ/OiB1bmRlZmluZWQ7XG4gKiB9XG4gKi9cbnR5cGUgUHJvdG9Db25zdE9iamVjdE9mU3RyaW5nc0VudW08XG4gIFNob3J0U3RyaW5nRW51bUtleSBleHRlbmRzIHN0cmluZyxcbiAgUHJlZml4IGV4dGVuZHMgc3RyaW5nLFxuICBVbnNwZWNpZmllZCwgLy8gZS5nLiAnVU5TUEVDSUZJRUQnXG4+ID0gVW5pb25Ub0ludGVyc2VjdGlvbjxcbiAgfCB7XG4gICAgICAvLyBlLmcuOiBcIlRFUk1JTkFURVwiOiBcIlRFUk1JTkFURVwiXG4gICAgICByZWFkb25seSBbayBpbiBTaG9ydFN0cmluZ0VudW1LZXldOiBrO1xuICAgIH1cbiAgfCB7XG4gICAgICBbayBpbiBTaG9ydFN0cmluZ0VudW1LZXldOiBQcmVmaXggZXh0ZW5kcyAnJ1xuICAgICAgICA/IG9iamVjdFxuICAgICAgICA6IHtcbiAgICAgICAgICAgIC8vIGUuZy46IFwiUEFSRU5UX0NMT1NFX1BPTElDWV9URVJNSU5BVEVcIj86IFwiVEVSTUlOQVRFXCJcbiAgICAgICAgICAgIHJlYWRvbmx5IFtrayBpbiBgJHtQcmVmaXh9JHtrfWBdPzogaztcbiAgICAgICAgICB9O1xuICAgIH1bU2hvcnRTdHJpbmdFbnVtS2V5XVxuICB8IChVbnNwZWNpZmllZCBleHRlbmRzIHN0cmluZ1xuICAgICAgPyB7XG4gICAgICAgICAgLy8gZS5nLjogXCJQQVJFTlRfQ0xPU0VfUE9MSUNZX1VOU1BFQ0lGSUVEXCI/OiB1bmRlZmluZWRcbiAgICAgICAgICBbayBpbiBgJHtQcmVmaXh9JHtVbnNwZWNpZmllZH1gXT86IHVuZGVmaW5lZDtcbiAgICAgICAgfVxuICAgICAgOiBvYmplY3QpXG4gIHwgKFVuc3BlY2lmaWVkIGV4dGVuZHMgc3RyaW5nXG4gICAgICA/IHtcbiAgICAgICAgICAvLyBlLmcuOiBcIlVOU1BFQ0lGSUVEXCI/OiB1bmRlZmluZWRcbiAgICAgICAgICBbayBpbiBgJHtVbnNwZWNpZmllZH1gXT86IHVuZGVmaW5lZDtcbiAgICAgICAgfVxuICAgICAgOiBvYmplY3QpXG4+O1xuXG4vKipcbiAqIEdpdmVuIHRoZSBleHBsb2RlZCBwYXJhbWV0ZXJzIG9mIGEgcHJvdG8gZW51bSAoaS5lLiBzaG9ydCBrZXlzLCBwcmVmaXgsIGFuZCBzaG9ydCBrZXkgb2YgdGhlXG4gKiB1bnNwZWNpZmllZCB2YWx1ZSksIG1ha2UgYSB0eXBlIHRoYXQgX2V4YWN0bHlfIGNvcnJlc3BvbmRzIHRvIHRoZSBtYXBwaW5nIHRhYmxlIHRoYXQgdGhlIHVzZXIgaXNcbiAqIGV4cGVjdGVkIHRvIHByb3ZpZGUuXG4gKlxuICogRm9yIGV4YW1wbGUsIGZvciBjb3Jlc2RrLmNoaWxkX3dvcmtmbG93LlBhcmVudENsb3NlUG9saWN5LCB0aGlzIGV2YWx1YXRlcyB0bzpcbiAqXG4gKiB7XG4gKiAgVU5TUEVDSUZJRUQ6IDAsXG4gKiAgVEVSTUlOQVRFOiAxLFxuICogIEFCQU5ET046IDIsXG4gKiAgUkVRVUVTVF9DQU5DRUw6IDMsXG4gKiB9XG4gKi9cbnR5cGUgUHJvdG9FbnVtVG9Db25zdE9iamVjdE9mU3RyaW5nTWFwVGFibGU8XG4gIF9TdHJpbmdFbnVtIGV4dGVuZHMgUHJvdG9Db25zdE9iamVjdE9mU3RyaW5nc0VudW08U2hvcnRTdHJpbmdFbnVtS2V5LCBQcmVmaXgsIFVuc3BlY2lmaWVkPixcbiAgUHJvdG9FbnVtVmFsdWUgZXh0ZW5kcyBudW1iZXIsXG4gIFByb3RvRW51bSBleHRlbmRzIHsgW2sgaW4gUHJvdG9FbnVtS2V5XTogUHJvdG9FbnVtVmFsdWUgfSxcbiAgUHJvdG9FbnVtS2V5IGV4dGVuZHMgYCR7UHJlZml4fSR7c3RyaW5nfWAsXG4gIFByZWZpeCBleHRlbmRzIHN0cmluZyxcbiAgVW5zcGVjaWZpZWQsXG4gIFNob3J0U3RyaW5nRW51bUtleSBleHRlbmRzIFJlbW92ZVByZWZpeDxQcmVmaXgsIFByb3RvRW51bUtleT4sXG4+ID0gVW5pb25Ub0ludGVyc2VjdGlvbjxcbiAge1xuICAgIFtrIGluIFByb3RvRW51bUtleV06IHtcbiAgICAgIFtrayBpbiBSZW1vdmVQcmVmaXg8UHJlZml4LCBrPl06IFByb3RvRW51bVtrXSBleHRlbmRzIG51bWJlciA/IFByb3RvRW51bVtrXSA6IG5ldmVyO1xuICAgIH07XG4gIH1bUHJvdG9FbnVtS2V5XVxuPjtcbiIsImV4cG9ydCAqIGZyb20gJy4vZW51bXMtaGVscGVycyc7XG4iLCJleHBvcnQgdHlwZSBMb2dMZXZlbCA9ICdUUkFDRScgfCAnREVCVUcnIHwgJ0lORk8nIHwgJ1dBUk4nIHwgJ0VSUk9SJztcblxuZXhwb3J0IHR5cGUgTG9nTWV0YWRhdGEgPSBSZWNvcmQ8c3RyaW5nIHwgc3ltYm9sLCBhbnk+O1xuXG4vKipcbiAqIEltcGxlbWVudCB0aGlzIGludGVyZmFjZSBpbiBvcmRlciB0byBjdXN0b21pemUgd29ya2VyIGxvZ2dpbmdcbiAqL1xuZXhwb3J0IGludGVyZmFjZSBMb2dnZXIge1xuICBsb2cobGV2ZWw6IExvZ0xldmVsLCBtZXNzYWdlOiBzdHJpbmcsIG1ldGE/OiBMb2dNZXRhZGF0YSk6IGFueTtcbiAgdHJhY2UobWVzc2FnZTogc3RyaW5nLCBtZXRhPzogTG9nTWV0YWRhdGEpOiBhbnk7XG4gIGRlYnVnKG1lc3NhZ2U6IHN0cmluZywgbWV0YT86IExvZ01ldGFkYXRhKTogYW55O1xuICBpbmZvKG1lc3NhZ2U6IHN0cmluZywgbWV0YT86IExvZ01ldGFkYXRhKTogYW55O1xuICB3YXJuKG1lc3NhZ2U6IHN0cmluZywgbWV0YT86IExvZ01ldGFkYXRhKTogYW55O1xuICBlcnJvcihtZXNzYWdlOiBzdHJpbmcsIG1ldGE/OiBMb2dNZXRhZGF0YSk6IGFueTtcbn1cblxuLyoqXG4gKiBQb3NzaWJsZSB2YWx1ZXMgb2YgdGhlIGBzZGtDb21wb25lbnRgIG1ldGEgYXR0cmlidXRlcyBvbiBsb2cgbWVzc2FnZXMuIFRoaXNcbiAqIGF0dHJpYnV0ZSBpbmRpY2F0ZXMgd2hpY2ggc3Vic3lzdGVtIGVtaXR0ZWQgdGhlIGxvZyBtZXNzYWdlOyB0aGlzIG1heSBmb3JcbiAqIGV4YW1wbGUgYmUgdXNlZCB0byBpbXBsZW1lbnQgZmluZS1ncmFpbmVkIGZpbHRlcmluZyBvZiBsb2cgbWVzc2FnZXMuXG4gKlxuICogTm90ZSB0aGF0IHRoZXJlIGlzIG5vIGd1YXJhbnRlZSB0aGF0IHRoaXMgbGlzdCB3aWxsIHJlbWFpbiBzdGFibGUgaW4gdGhlXG4gKiBmdXR1cmU7IHZhbHVlcyBtYXkgYmUgYWRkZWQgb3IgcmVtb3ZlZCwgYW5kIG1lc3NhZ2VzIHRoYXQgYXJlIGN1cnJlbnRseVxuICogZW1pdHRlZCB3aXRoIHNvbWUgYHNka0NvbXBvbmVudGAgdmFsdWUgbWF5IHVzZSBhIGRpZmZlcmVudCB2YWx1ZSBpbiB0aGUgZnV0dXJlLlxuICovXG5leHBvcnQgZW51bSBTZGtDb21wb25lbnQge1xuICAvKipcbiAgICogQ29tcG9uZW50IG5hbWUgZm9yIG1lc3NhZ2VzIGVtaXRlZCBmcm9tIFdvcmtmbG93IGNvZGUsIHVzaW5nIHRoZSB7QGxpbmsgV29ya2Zsb3cgY29udGV4dCBsb2dnZXJ8d29ya2Zsb3cubG9nfS5cbiAgICogVGhlIFNESyBpdHNlbGYgbmV2ZXIgcHVibGlzaGVzIG1lc3NhZ2VzIHdpdGggdGhpcyBjb21wb25lbnQgbmFtZS5cbiAgICovXG4gIHdvcmtmbG93ID0gJ3dvcmtmbG93JyxcblxuICAvKipcbiAgICogQ29tcG9uZW50IG5hbWUgZm9yIG1lc3NhZ2VzIGVtaXRlZCBmcm9tIGFuIGFjdGl2aXR5LCB1c2luZyB0aGUge0BsaW5rIGFjdGl2aXR5IGNvbnRleHQgbG9nZ2VyfENvbnRleHQubG9nfS5cbiAgICogVGhlIFNESyBpdHNlbGYgbmV2ZXIgcHVibGlzaGVzIG1lc3NhZ2VzIHdpdGggdGhpcyBjb21wb25lbnQgbmFtZS5cbiAgICovXG4gIGFjdGl2aXR5ID0gJ2FjdGl2aXR5JyxcblxuICAvKipcbiAgICogQ29tcG9uZW50IG5hbWUgZm9yIG1lc3NhZ2VzIGVtaXRlZCBmcm9tIGEgVGVtcG9yYWwgV29ya2VyIGluc3RhbmNlLlxuICAgKlxuICAgKiBUaGlzIG5vdGFibHkgaW5jbHVkZXM6XG4gICAqIC0gSXNzdWVzIHdpdGggV29ya2VyIG9yIHJ1bnRpbWUgY29uZmlndXJhdGlvbiwgb3IgdGhlIEpTIGV4ZWN1dGlvbiBlbnZpcm9ubWVudDtcbiAgICogLSBXb3JrZXIncywgQWN0aXZpdHkncywgYW5kIFdvcmtmbG93J3MgbGlmZWN5Y2xlIGV2ZW50cztcbiAgICogLSBXb3JrZmxvdyBBY3RpdmF0aW9uIGFuZCBBY3Rpdml0eSBUYXNrIHByb2Nlc3NpbmcgZXZlbnRzO1xuICAgKiAtIFdvcmtmbG93IGJ1bmRsaW5nIG1lc3NhZ2VzO1xuICAgKiAtIFNpbmsgcHJvY2Vzc2luZyBpc3N1ZXMuXG4gICAqL1xuICB3b3JrZXIgPSAnd29ya2VyJyxcblxuICAvKipcbiAgICogQ29tcG9uZW50IG5hbWUgZm9yIGFsbCBtZXNzYWdlcyBlbWl0dGVkIGJ5IHRoZSBSdXN0IENvcmUgU0RLIGxpYnJhcnkuXG4gICAqL1xuICBjb3JlID0gJ2NvcmUnLFxufVxuIiwiaW1wb3J0IHR5cGUgeyB0ZW1wb3JhbCB9IGZyb20gJ0B0ZW1wb3JhbGlvL3Byb3RvJztcbmltcG9ydCB7IFZhbHVlRXJyb3IgfSBmcm9tICcuL2Vycm9ycyc7XG5pbXBvcnQgeyBEdXJhdGlvbiwgbXNPcHRpb25hbFRvTnVtYmVyLCBtc09wdGlvbmFsVG9UcywgbXNUb051bWJlciwgbXNUb1RzLCBvcHRpb25hbFRzVG9NcyB9IGZyb20gJy4vdGltZSc7XG5cbi8qKlxuICogT3B0aW9ucyBmb3IgcmV0cnlpbmcgV29ya2Zsb3dzIGFuZCBBY3Rpdml0aWVzXG4gKi9cbmV4cG9ydCBpbnRlcmZhY2UgUmV0cnlQb2xpY3kge1xuICAvKipcbiAgICogQ29lZmZpY2llbnQgdXNlZCB0byBjYWxjdWxhdGUgdGhlIG5leHQgcmV0cnkgaW50ZXJ2YWwuXG4gICAqIFRoZSBuZXh0IHJldHJ5IGludGVydmFsIGlzIHByZXZpb3VzIGludGVydmFsIG11bHRpcGxpZWQgYnkgdGhpcyBjb2VmZmljaWVudC5cbiAgICogQG1pbmltdW0gMVxuICAgKiBAZGVmYXVsdCAyXG4gICAqL1xuICBiYWNrb2ZmQ29lZmZpY2llbnQ/OiBudW1iZXI7XG4gIC8qKlxuICAgKiBJbnRlcnZhbCBvZiB0aGUgZmlyc3QgcmV0cnkuXG4gICAqIElmIGNvZWZmaWNpZW50IGlzIDEgdGhlbiBpdCBpcyB1c2VkIGZvciBhbGwgcmV0cmllc1xuICAgKiBAZm9ybWF0IG51bWJlciBvZiBtaWxsaXNlY29uZHMgb3Ige0BsaW5rIGh0dHBzOi8vd3d3Lm5wbWpzLmNvbS9wYWNrYWdlL21zIHwgbXMtZm9ybWF0dGVkIHN0cmluZ31cbiAgICogQGRlZmF1bHQgMSBzZWNvbmRcbiAgICovXG4gIGluaXRpYWxJbnRlcnZhbD86IER1cmF0aW9uO1xuICAvKipcbiAgICogTWF4aW11bSBudW1iZXIgb2YgYXR0ZW1wdHMuIFdoZW4gZXhjZWVkZWQsIHJldHJpZXMgc3RvcCAoZXZlbiBpZiB7QGxpbmsgQWN0aXZpdHlPcHRpb25zLnNjaGVkdWxlVG9DbG9zZVRpbWVvdXR9XG4gICAqIGhhc24ndCBiZWVuIHJlYWNoZWQpLlxuICAgKlxuICAgKiBAZGVmYXVsdCBJbmZpbml0eVxuICAgKi9cbiAgbWF4aW11bUF0dGVtcHRzPzogbnVtYmVyO1xuICAvKipcbiAgICogTWF4aW11bSBpbnRlcnZhbCBiZXR3ZWVuIHJldHJpZXMuXG4gICAqIEV4cG9uZW50aWFsIGJhY2tvZmYgbGVhZHMgdG8gaW50ZXJ2YWwgaW5jcmVhc2UuXG4gICAqIFRoaXMgdmFsdWUgaXMgdGhlIGNhcCBvZiB0aGUgaW5jcmVhc2UuXG4gICAqXG4gICAqIEBkZWZhdWx0IDEwMHggb2Yge0BsaW5rIGluaXRpYWxJbnRlcnZhbH1cbiAgICogQGZvcm1hdCBudW1iZXIgb2YgbWlsbGlzZWNvbmRzIG9yIHtAbGluayBodHRwczovL3d3dy5ucG1qcy5jb20vcGFja2FnZS9tcyB8IG1zLWZvcm1hdHRlZCBzdHJpbmd9XG4gICAqL1xuICBtYXhpbXVtSW50ZXJ2YWw/OiBEdXJhdGlvbjtcblxuICAvKipcbiAgICogTGlzdCBvZiBhcHBsaWNhdGlvbiBmYWlsdXJlcyB0eXBlcyB0byBub3QgcmV0cnkuXG4gICAqL1xuICBub25SZXRyeWFibGVFcnJvclR5cGVzPzogc3RyaW5nW107XG59XG5cbi8qKlxuICogVHVybiBhIFRTIFJldHJ5UG9saWN5IGludG8gYSBwcm90byBjb21wYXRpYmxlIFJldHJ5UG9saWN5XG4gKi9cbmV4cG9ydCBmdW5jdGlvbiBjb21waWxlUmV0cnlQb2xpY3kocmV0cnlQb2xpY3k6IFJldHJ5UG9saWN5KTogdGVtcG9yYWwuYXBpLmNvbW1vbi52MS5JUmV0cnlQb2xpY3kge1xuICBpZiAocmV0cnlQb2xpY3kuYmFja29mZkNvZWZmaWNpZW50ICE9IG51bGwgJiYgcmV0cnlQb2xpY3kuYmFja29mZkNvZWZmaWNpZW50IDw9IDApIHtcbiAgICB0aHJvdyBuZXcgVmFsdWVFcnJvcignUmV0cnlQb2xpY3kuYmFja29mZkNvZWZmaWNpZW50IG11c3QgYmUgZ3JlYXRlciB0aGFuIDAnKTtcbiAgfVxuICBpZiAocmV0cnlQb2xpY3kubWF4aW11bUF0dGVtcHRzICE9IG51bGwpIHtcbiAgICBpZiAocmV0cnlQb2xpY3kubWF4aW11bUF0dGVtcHRzID09PSBOdW1iZXIuUE9TSVRJVkVfSU5GSU5JVFkpIHtcbiAgICAgIC8vIGRyb3AgZmllbGQgKEluZmluaXR5IGlzIHRoZSBkZWZhdWx0KVxuICAgICAgY29uc3QgeyBtYXhpbXVtQXR0ZW1wdHM6IF8sIC4uLndpdGhvdXQgfSA9IHJldHJ5UG9saWN5O1xuICAgICAgcmV0cnlQb2xpY3kgPSB3aXRob3V0O1xuICAgIH0gZWxzZSBpZiAocmV0cnlQb2xpY3kubWF4aW11bUF0dGVtcHRzIDw9IDApIHtcbiAgICAgIHRocm93IG5ldyBWYWx1ZUVycm9yKCdSZXRyeVBvbGljeS5tYXhpbXVtQXR0ZW1wdHMgbXVzdCBiZSBhIHBvc2l0aXZlIGludGVnZXInKTtcbiAgICB9IGVsc2UgaWYgKCFOdW1iZXIuaXNJbnRlZ2VyKHJldHJ5UG9saWN5Lm1heGltdW1BdHRlbXB0cykpIHtcbiAgICAgIHRocm93IG5ldyBWYWx1ZUVycm9yKCdSZXRyeVBvbGljeS5tYXhpbXVtQXR0ZW1wdHMgbXVzdCBiZSBhbiBpbnRlZ2VyJyk7XG4gICAgfVxuICB9XG4gIGNvbnN0IG1heGltdW1JbnRlcnZhbCA9IG1zT3B0aW9uYWxUb051bWJlcihyZXRyeVBvbGljeS5tYXhpbXVtSW50ZXJ2YWwpO1xuICBjb25zdCBpbml0aWFsSW50ZXJ2YWwgPSBtc1RvTnVtYmVyKHJldHJ5UG9saWN5LmluaXRpYWxJbnRlcnZhbCA/PyAxMDAwKTtcbiAgaWYgKG1heGltdW1JbnRlcnZhbCA9PT0gMCkge1xuICAgIHRocm93IG5ldyBWYWx1ZUVycm9yKCdSZXRyeVBvbGljeS5tYXhpbXVtSW50ZXJ2YWwgY2Fubm90IGJlIDAnKTtcbiAgfVxuICBpZiAoaW5pdGlhbEludGVydmFsID09PSAwKSB7XG4gICAgdGhyb3cgbmV3IFZhbHVlRXJyb3IoJ1JldHJ5UG9saWN5LmluaXRpYWxJbnRlcnZhbCBjYW5ub3QgYmUgMCcpO1xuICB9XG4gIGlmIChtYXhpbXVtSW50ZXJ2YWwgIT0gbnVsbCAmJiBtYXhpbXVtSW50ZXJ2YWwgPCBpbml0aWFsSW50ZXJ2YWwpIHtcbiAgICB0aHJvdyBuZXcgVmFsdWVFcnJvcignUmV0cnlQb2xpY3kubWF4aW11bUludGVydmFsIGNhbm5vdCBiZSBsZXNzIHRoYW4gaXRzIGluaXRpYWxJbnRlcnZhbCcpO1xuICB9XG4gIHJldHVybiB7XG4gICAgbWF4aW11bUF0dGVtcHRzOiByZXRyeVBvbGljeS5tYXhpbXVtQXR0ZW1wdHMsXG4gICAgaW5pdGlhbEludGVydmFsOiBtc1RvVHMoaW5pdGlhbEludGVydmFsKSxcbiAgICBtYXhpbXVtSW50ZXJ2YWw6IG1zT3B0aW9uYWxUb1RzKG1heGltdW1JbnRlcnZhbCksXG4gICAgYmFja29mZkNvZWZmaWNpZW50OiByZXRyeVBvbGljeS5iYWNrb2ZmQ29lZmZpY2llbnQsXG4gICAgbm9uUmV0cnlhYmxlRXJyb3JUeXBlczogcmV0cnlQb2xpY3kubm9uUmV0cnlhYmxlRXJyb3JUeXBlcyxcbiAgfTtcbn1cblxuLyoqXG4gKiBUdXJuIGEgcHJvdG8gY29tcGF0aWJsZSBSZXRyeVBvbGljeSBpbnRvIGEgVFMgUmV0cnlQb2xpY3lcbiAqL1xuZXhwb3J0IGZ1bmN0aW9uIGRlY29tcGlsZVJldHJ5UG9saWN5KFxuICByZXRyeVBvbGljeT86IHRlbXBvcmFsLmFwaS5jb21tb24udjEuSVJldHJ5UG9saWN5IHwgbnVsbFxuKTogUmV0cnlQb2xpY3kgfCB1bmRlZmluZWQge1xuICBpZiAoIXJldHJ5UG9saWN5KSB7XG4gICAgcmV0dXJuIHVuZGVmaW5lZDtcbiAgfVxuXG4gIHJldHVybiB7XG4gICAgYmFja29mZkNvZWZmaWNpZW50OiByZXRyeVBvbGljeS5iYWNrb2ZmQ29lZmZpY2llbnQgPz8gdW5kZWZpbmVkLFxuICAgIG1heGltdW1BdHRlbXB0czogcmV0cnlQb2xpY3kubWF4aW11bUF0dGVtcHRzID8/IHVuZGVmaW5lZCxcbiAgICBtYXhpbXVtSW50ZXJ2YWw6IG9wdGlvbmFsVHNUb01zKHJldHJ5UG9saWN5Lm1heGltdW1JbnRlcnZhbCksXG4gICAgaW5pdGlhbEludGVydmFsOiBvcHRpb25hbFRzVG9NcyhyZXRyeVBvbGljeS5pbml0aWFsSW50ZXJ2YWwpLFxuICAgIG5vblJldHJ5YWJsZUVycm9yVHlwZXM6IHJldHJ5UG9saWN5Lm5vblJldHJ5YWJsZUVycm9yVHlwZXMgPz8gdW5kZWZpbmVkLFxuICB9O1xufVxuIiwiaW1wb3J0IExvbmcgZnJvbSAnbG9uZyc7IC8vIGVzbGludC1kaXNhYmxlLWxpbmUgaW1wb3J0L25vLW5hbWVkLWFzLWRlZmF1bHRcbmltcG9ydCBtcywgeyBTdHJpbmdWYWx1ZSB9IGZyb20gJ21zJztcbmltcG9ydCB0eXBlIHsgZ29vZ2xlIH0gZnJvbSAnQHRlbXBvcmFsaW8vcHJvdG8nO1xuaW1wb3J0IHsgVmFsdWVFcnJvciB9IGZyb20gJy4vZXJyb3JzJztcblxuLy8gTk9URTogdGhlc2UgYXJlIHRoZSBzYW1lIGludGVyZmFjZSBpbiBKU1xuLy8gZ29vZ2xlLnByb3RvYnVmLklEdXJhdGlvbjtcbi8vIGdvb2dsZS5wcm90b2J1Zi5JVGltZXN0YW1wO1xuLy8gVGhlIGNvbnZlcnNpb24gZnVuY3Rpb25zIGJlbG93IHNob3VsZCB3b3JrIGZvciBib3RoXG5cbmV4cG9ydCB0eXBlIFRpbWVzdGFtcCA9IGdvb2dsZS5wcm90b2J1Zi5JVGltZXN0YW1wO1xuXG4vKipcbiAqIEEgZHVyYXRpb24sIGV4cHJlc3NlZCBlaXRoZXIgYXMgYSBudW1iZXIgb2YgbWlsbGlzZWNvbmRzLCBvciBhcyBhIHtAbGluayBodHRwczovL3d3dy5ucG1qcy5jb20vcGFja2FnZS9tcyB8IG1zLWZvcm1hdHRlZCBzdHJpbmd9LlxuICovXG5leHBvcnQgdHlwZSBEdXJhdGlvbiA9IFN0cmluZ1ZhbHVlIHwgbnVtYmVyO1xuXG5leHBvcnQgdHlwZSB7IFN0cmluZ1ZhbHVlIH0gZnJvbSAnbXMnO1xuXG4vKipcbiAqIExvc3N5IGNvbnZlcnNpb24gZnVuY3Rpb24gZnJvbSBUaW1lc3RhbXAgdG8gbnVtYmVyIGR1ZSB0byBwb3NzaWJsZSBvdmVyZmxvdy5cbiAqIElmIHRzIGlzIG51bGwgb3IgdW5kZWZpbmVkIHJldHVybnMgdW5kZWZpbmVkLlxuICovXG5leHBvcnQgZnVuY3Rpb24gb3B0aW9uYWxUc1RvTXModHM6IFRpbWVzdGFtcCB8IG51bGwgfCB1bmRlZmluZWQpOiBudW1iZXIgfCB1bmRlZmluZWQge1xuICBpZiAodHMgPT09IHVuZGVmaW5lZCB8fCB0cyA9PT0gbnVsbCkge1xuICAgIHJldHVybiB1bmRlZmluZWQ7XG4gIH1cbiAgcmV0dXJuIHRzVG9Ncyh0cyk7XG59XG5cbi8qKlxuICogTG9zc3kgY29udmVyc2lvbiBmdW5jdGlvbiBmcm9tIFRpbWVzdGFtcCB0byBudW1iZXIgZHVlIHRvIHBvc3NpYmxlIG92ZXJmbG93LlxuICogSWYgdHMgaXMgbnVsbCBvciB1bmRlZmluZWQsIHRocm93cyBhIFR5cGVFcnJvciwgd2l0aCBlcnJvciBtZXNzYWdlIGluY2x1ZGluZyB0aGUgbmFtZSBvZiB0aGUgZmllbGQuXG4gKi9cbmV4cG9ydCBmdW5jdGlvbiByZXF1aXJlZFRzVG9Ncyh0czogVGltZXN0YW1wIHwgbnVsbCB8IHVuZGVmaW5lZCwgZmllbGROYW1lOiBzdHJpbmcpOiBudW1iZXIge1xuICBpZiAodHMgPT09IHVuZGVmaW5lZCB8fCB0cyA9PT0gbnVsbCkge1xuICAgIHRocm93IG5ldyBUeXBlRXJyb3IoYEV4cGVjdGVkICR7ZmllbGROYW1lfSB0byBiZSBhIHRpbWVzdGFtcCwgZ290ICR7dHN9YCk7XG4gIH1cbiAgcmV0dXJuIHRzVG9Ncyh0cyk7XG59XG5cbi8qKlxuICogTG9zc3kgY29udmVyc2lvbiBmdW5jdGlvbiBmcm9tIFRpbWVzdGFtcCB0byBudW1iZXIgZHVlIHRvIHBvc3NpYmxlIG92ZXJmbG93XG4gKi9cbmV4cG9ydCBmdW5jdGlvbiB0c1RvTXModHM6IFRpbWVzdGFtcCB8IG51bGwgfCB1bmRlZmluZWQpOiBudW1iZXIge1xuICBpZiAodHMgPT09IHVuZGVmaW5lZCB8fCB0cyA9PT0gbnVsbCkge1xuICAgIHRocm93IG5ldyBFcnJvcihgRXhwZWN0ZWQgdGltZXN0YW1wLCBnb3QgJHt0c31gKTtcbiAgfVxuICBjb25zdCB7IHNlY29uZHMsIG5hbm9zIH0gPSB0cztcbiAgcmV0dXJuIChzZWNvbmRzIHx8IExvbmcuVVpFUk8pXG4gICAgLm11bCgxMDAwKVxuICAgIC5hZGQoTWF0aC5mbG9vcigobmFub3MgfHwgMCkgLyAxMDAwMDAwKSlcbiAgICAudG9OdW1iZXIoKTtcbn1cblxuZXhwb3J0IGZ1bmN0aW9uIG1zTnVtYmVyVG9UcyhtaWxsaXM6IG51bWJlcik6IFRpbWVzdGFtcCB7XG4gIGNvbnN0IHNlY29uZHMgPSBNYXRoLmZsb29yKG1pbGxpcyAvIDEwMDApO1xuICBjb25zdCBuYW5vcyA9IChtaWxsaXMgJSAxMDAwKSAqIDEwMDAwMDA7XG4gIGlmIChOdW1iZXIuaXNOYU4oc2Vjb25kcykgfHwgTnVtYmVyLmlzTmFOKG5hbm9zKSkge1xuICAgIHRocm93IG5ldyBWYWx1ZUVycm9yKGBJbnZhbGlkIG1pbGxpcyAke21pbGxpc31gKTtcbiAgfVxuICByZXR1cm4geyBzZWNvbmRzOiBMb25nLmZyb21OdW1iZXIoc2Vjb25kcyksIG5hbm9zIH07XG59XG5cbmV4cG9ydCBmdW5jdGlvbiBtc1RvVHMoc3RyOiBEdXJhdGlvbik6IFRpbWVzdGFtcCB7XG4gIHJldHVybiBtc051bWJlclRvVHMobXNUb051bWJlcihzdHIpKTtcbn1cblxuZXhwb3J0IGZ1bmN0aW9uIG1zT3B0aW9uYWxUb1RzKHN0cjogRHVyYXRpb24gfCB1bmRlZmluZWQgfCBudWxsKTogVGltZXN0YW1wIHwgdW5kZWZpbmVkIHtcbiAgcmV0dXJuIHN0ciA/IG1zVG9UcyhzdHIpIDogdW5kZWZpbmVkO1xufVxuXG5leHBvcnQgZnVuY3Rpb24gbXNPcHRpb25hbFRvTnVtYmVyKHZhbDogRHVyYXRpb24gfCB1bmRlZmluZWQpOiBudW1iZXIgfCB1bmRlZmluZWQge1xuICBpZiAodmFsID09PSB1bmRlZmluZWQpIHJldHVybiB1bmRlZmluZWQ7XG4gIHJldHVybiBtc1RvTnVtYmVyKHZhbCk7XG59XG5cbmV4cG9ydCBmdW5jdGlvbiBtc1RvTnVtYmVyKHZhbDogRHVyYXRpb24pOiBudW1iZXIge1xuICBpZiAodHlwZW9mIHZhbCA9PT0gJ251bWJlcicpIHtcbiAgICByZXR1cm4gdmFsO1xuICB9XG4gIHJldHVybiBtc1dpdGhWYWxpZGF0aW9uKHZhbCk7XG59XG5cbmZ1bmN0aW9uIG1zV2l0aFZhbGlkYXRpb24oc3RyOiBTdHJpbmdWYWx1ZSk6IG51bWJlciB7XG4gIGNvbnN0IG1pbGxpcyA9IG1zKHN0cik7XG4gIGlmIChtaWxsaXMgPT0gbnVsbCB8fCBpc05hTihtaWxsaXMpKSB7XG4gICAgdGhyb3cgbmV3IFR5cGVFcnJvcihgSW52YWxpZCBkdXJhdGlvbiBzdHJpbmc6ICcke3N0cn0nYCk7XG4gIH1cbiAgcmV0dXJuIG1pbGxpcztcbn1cblxuZXhwb3J0IGZ1bmN0aW9uIHRzVG9EYXRlKHRzOiBUaW1lc3RhbXApOiBEYXRlIHtcbiAgcmV0dXJuIG5ldyBEYXRlKHRzVG9Ncyh0cykpO1xufVxuXG4vLyB0cy1wcnVuZS1pZ25vcmUtbmV4dFxuZXhwb3J0IGZ1bmN0aW9uIHJlcXVpcmVkVHNUb0RhdGUodHM6IFRpbWVzdGFtcCB8IG51bGwgfCB1bmRlZmluZWQsIGZpZWxkTmFtZTogc3RyaW5nKTogRGF0ZSB7XG4gIHJldHVybiBuZXcgRGF0ZShyZXF1aXJlZFRzVG9Ncyh0cywgZmllbGROYW1lKSk7XG59XG5cbmV4cG9ydCBmdW5jdGlvbiBvcHRpb25hbFRzVG9EYXRlKHRzOiBUaW1lc3RhbXAgfCBudWxsIHwgdW5kZWZpbmVkKTogRGF0ZSB8IHVuZGVmaW5lZCB7XG4gIGlmICh0cyA9PT0gdW5kZWZpbmVkIHx8IHRzID09PSBudWxsKSB7XG4gICAgcmV0dXJuIHVuZGVmaW5lZDtcbiAgfVxuICByZXR1cm4gbmV3IERhdGUodHNUb01zKHRzKSk7XG59XG5cbi8vIHRzLXBydW5lLWlnbm9yZS1uZXh0IChpbXBvcnRlZCB2aWEgc2NoZWR1bGUtaGVscGVycy50cylcbmV4cG9ydCBmdW5jdGlvbiBvcHRpb25hbERhdGVUb1RzKGRhdGU6IERhdGUgfCBudWxsIHwgdW5kZWZpbmVkKTogVGltZXN0YW1wIHwgdW5kZWZpbmVkIHtcbiAgaWYgKGRhdGUgPT09IHVuZGVmaW5lZCB8fCBkYXRlID09PSBudWxsKSB7XG4gICAgcmV0dXJuIHVuZGVmaW5lZDtcbiAgfVxuICByZXR1cm4gbXNUb1RzKGRhdGUuZ2V0VGltZSgpKTtcbn1cbiIsIi8qKiBTaG9ydGhhbmQgYWxpYXMgKi9cbmV4cG9ydCB0eXBlIEFueUZ1bmMgPSAoLi4uYXJnczogYW55W10pID0+IGFueTtcbi8qKiBBIHR1cGxlIHdpdGhvdXQgaXRzIGxhc3QgZWxlbWVudCAqL1xuZXhwb3J0IHR5cGUgT21pdExhc3Q8VD4gPSBUIGV4dGVuZHMgWy4uLmluZmVyIFJFU1QsIGFueV0gPyBSRVNUIDogbmV2ZXI7XG4vKiogRiB3aXRoIGFsbCBhcmd1bWVudHMgYnV0IHRoZSBsYXN0ICovXG5leHBvcnQgdHlwZSBPbWl0TGFzdFBhcmFtPEYgZXh0ZW5kcyBBbnlGdW5jPiA9ICguLi5hcmdzOiBPbWl0TGFzdDxQYXJhbWV0ZXJzPEY+PikgPT4gUmV0dXJuVHlwZTxGPjtcbi8qKiBSZXF1aXJlIHRoYXQgVCBoYXMgYXQgbGVhc3Qgb25lIG9mIHRoZSBwcm92aWRlZCBwcm9wZXJ0aWVzIGRlZmluZWQgKi9cbmV4cG9ydCB0eXBlIFJlcXVpcmVBdExlYXN0T25lPFQsIEtleXMgZXh0ZW5kcyBrZXlvZiBUID0ga2V5b2YgVD4gPSBQaWNrPFQsIEV4Y2x1ZGU8a2V5b2YgVCwgS2V5cz4+ICZcbiAge1xuICAgIFtLIGluIEtleXNdLT86IFJlcXVpcmVkPFBpY2s8VCwgSz4+ICYgUGFydGlhbDxQaWNrPFQsIEV4Y2x1ZGU8S2V5cywgSz4+PjtcbiAgfVtLZXlzXTtcblxuLyoqIFZlcmlmeSB0aGF0IGFuIHR5cGUgX0NvcHkgZXh0ZW5kcyBfT3JpZyAqL1xuZXhwb3J0IGZ1bmN0aW9uIGNoZWNrRXh0ZW5kczxfT3JpZywgX0NvcHkgZXh0ZW5kcyBfT3JpZz4oKTogdm9pZCB7XG4gIC8vIG5vb3AsIGp1c3QgdHlwZSBjaGVja1xufVxuXG5leHBvcnQgdHlwZSBSZXBsYWNlPEJhc2UsIE5ldz4gPSBPbWl0PEJhc2UsIGtleW9mIE5ldz4gJiBOZXc7XG5cbi8vIEZyb20gaHR0cHM6Ly9naXRodWIuY29tL3NpbmRyZXNvcmh1cy90eXBlLWZlc3QvYmxvYi9tYWluL3NvdXJjZS91bmlvbi10by1pbnRlcnNlY3Rpb24uZC50c1xuLy8gTUlUIG9yIENDMC0xLjAg4oCUIEl0IGlzIG1lYW50IHRvIGJlIGNvcGllZCBpbnRvIHlvdXIgY29kZWJhc2UgcmF0aGVyIHRoYW4gYmVpbmcgdXNlZCBhcyBhIGRlcGVuZGVuY3kuXG5leHBvcnQgdHlwZSBVbmlvblRvSW50ZXJzZWN0aW9uPFVuaW9uPiA9XG4gIC8vIGBleHRlbmRzIHVua25vd25gIGlzIGFsd2F5cyBnb2luZyB0byBiZSB0aGUgY2FzZSBhbmQgaXMgdXNlZCB0byBjb252ZXJ0IHRoZSBgVW5pb25gIGludG8gYVxuICAvLyBbZGlzdHJpYnV0aXZlIGNvbmRpdGlvbmFsIHR5cGVdKGh0dHBzOi8vd3d3LnR5cGVzY3JpcHRsYW5nLm9yZy9kb2NzL2hhbmRib29rL3JlbGVhc2Utbm90ZXMvdHlwZXNjcmlwdC0yLTguaHRtbCNkaXN0cmlidXRpdmUtY29uZGl0aW9uYWwtdHlwZXMpLlxuICAoXG4gICAgVW5pb24gZXh0ZW5kcyB1bmtub3duXG4gICAgICA/IC8vIFRoZSB1bmlvbiB0eXBlIGlzIHVzZWQgYXMgdGhlIG9ubHkgYXJndW1lbnQgdG8gYSBmdW5jdGlvbiBzaW5jZSB0aGUgdW5pb25cbiAgICAgICAgLy8gb2YgZnVuY3Rpb24gYXJndW1lbnRzIGlzIGFuIGludGVyc2VjdGlvbi5cbiAgICAgICAgKGRpc3RyaWJ1dGVkVW5pb246IFVuaW9uKSA9PiB2b2lkXG4gICAgICA6IC8vIFRoaXMgd29uJ3QgaGFwcGVuLlxuICAgICAgICBuZXZlclxuICApIGV4dGVuZHMgLy8gSW5mZXIgdGhlIGBJbnRlcnNlY3Rpb25gIHR5cGUgc2luY2UgVHlwZVNjcmlwdCByZXByZXNlbnRzIHRoZSBwb3NpdGlvbmFsXG4gIC8vIGFyZ3VtZW50cyBvZiB1bmlvbnMgb2YgZnVuY3Rpb25zIGFzIGFuIGludGVyc2VjdGlvbiBvZiB0aGUgdW5pb24uXG4gIChtZXJnZWRJbnRlcnNlY3Rpb246IGluZmVyIEludGVyc2VjdGlvbikgPT4gdm9pZFxuICAgID8gLy8gVGhlIGAmIFVuaW9uYCBpcyB0byBhbGxvdyBpbmRleGluZyBieSB0aGUgcmVzdWx0aW5nIHR5cGVcbiAgICAgIEludGVyc2VjdGlvbiAmIFVuaW9uXG4gICAgOiBuZXZlcjtcblxudHlwZSBJc0VxdWFsPEEsIEI+ID0gKDxHPigpID0+IEcgZXh0ZW5kcyBBID8gMSA6IDIpIGV4dGVuZHMgPEc+KCkgPT4gRyBleHRlbmRzIEIgPyAxIDogMiA/IHRydWUgOiBmYWxzZTtcblxudHlwZSBQcmltaXRpdmUgPSBudWxsIHwgdW5kZWZpbmVkIHwgc3RyaW5nIHwgbnVtYmVyIHwgYm9vbGVhbiB8IHN5bWJvbCB8IGJpZ2ludDtcblxudHlwZSBJc051bGw8VD4gPSBbVF0gZXh0ZW5kcyBbbnVsbF0gPyB0cnVlIDogZmFsc2U7XG5cbnR5cGUgSXNVbmtub3duPFQ+ID0gdW5rbm93biBleHRlbmRzIFQgLy8gYFRgIGNhbiBiZSBgdW5rbm93bmAgb3IgYGFueWBcbiAgPyBJc051bGw8VD4gZXh0ZW5kcyBmYWxzZSAvLyBgYW55YCBjYW4gYmUgYG51bGxgLCBidXQgYHVua25vd25gIGNhbid0IGJlXG4gICAgPyB0cnVlXG4gICAgOiBmYWxzZVxuICA6IGZhbHNlO1xuXG50eXBlIE9iamVjdFZhbHVlPFQsIEs+ID0gSyBleHRlbmRzIGtleW9mIFRcbiAgPyBUW0tdXG4gIDogVG9TdHJpbmc8Sz4gZXh0ZW5kcyBrZXlvZiBUXG4gICAgPyBUW1RvU3RyaW5nPEs+XVxuICAgIDogSyBleHRlbmRzIGAke2luZmVyIE51bWJlcksgZXh0ZW5kcyBudW1iZXJ9YFxuICAgICAgPyBOdW1iZXJLIGV4dGVuZHMga2V5b2YgVFxuICAgICAgICA/IFRbTnVtYmVyS11cbiAgICAgICAgOiBuZXZlclxuICAgICAgOiBuZXZlcjtcblxudHlwZSBUb1N0cmluZzxUPiA9IFQgZXh0ZW5kcyBzdHJpbmcgfCBudW1iZXIgPyBgJHtUfWAgOiBuZXZlcjtcblxudHlwZSBLZXlzT2ZVbmlvbjxPYmplY3RUeXBlPiA9IE9iamVjdFR5cGUgZXh0ZW5kcyB1bmtub3duID8ga2V5b2YgT2JqZWN0VHlwZSA6IG5ldmVyO1xuXG50eXBlIEFycmF5RWxlbWVudDxUPiA9IFQgZXh0ZW5kcyByZWFkb25seSB1bmtub3duW10gPyBUWzBdIDogbmV2ZXI7XG5cbnR5cGUgRXhhY3RPYmplY3Q8UGFyYW1ldGVyVHlwZSwgSW5wdXRUeXBlPiA9IHtcbiAgW0tleSBpbiBrZXlvZiBQYXJhbWV0ZXJUeXBlXTogRXhhY3Q8UGFyYW1ldGVyVHlwZVtLZXldLCBPYmplY3RWYWx1ZTxJbnB1dFR5cGUsIEtleT4+O1xufSAmIFJlY29yZDxFeGNsdWRlPGtleW9mIElucHV0VHlwZSwgS2V5c09mVW5pb248UGFyYW1ldGVyVHlwZT4+LCBuZXZlcj47XG5cbmV4cG9ydCB0eXBlIEV4YWN0PFBhcmFtZXRlclR5cGUsIElucHV0VHlwZT4gPVxuICAvLyBCZWZvcmUgZGlzdHJpYnV0aW5nLCBjaGVjayBpZiB0aGUgdHdvIHR5cGVzIGFyZSBlcXVhbCBhbmQgaWYgc28sIHJldHVybiB0aGUgcGFyYW1ldGVyIHR5cGUgaW1tZWRpYXRlbHlcbiAgSXNFcXVhbDxQYXJhbWV0ZXJUeXBlLCBJbnB1dFR5cGU+IGV4dGVuZHMgdHJ1ZVxuICAgID8gUGFyYW1ldGVyVHlwZVxuICAgIDogLy8gSWYgdGhlIHBhcmFtZXRlciBpcyBhIHByaW1pdGl2ZSwgcmV0dXJuIGl0IGFzIGlzIGltbWVkaWF0ZWx5IHRvIGF2b2lkIGl0IGJlaW5nIGNvbnZlcnRlZCB0byBhIGNvbXBsZXggdHlwZVxuICAgICAgUGFyYW1ldGVyVHlwZSBleHRlbmRzIFByaW1pdGl2ZVxuICAgICAgPyBQYXJhbWV0ZXJUeXBlXG4gICAgICA6IC8vIElmIHRoZSBwYXJhbWV0ZXIgaXMgYW4gdW5rbm93biwgcmV0dXJuIGl0IGFzIGlzIGltbWVkaWF0ZWx5IHRvIGF2b2lkIGl0IGJlaW5nIGNvbnZlcnRlZCB0byBhIGNvbXBsZXggdHlwZVxuICAgICAgICBJc1Vua25vd248UGFyYW1ldGVyVHlwZT4gZXh0ZW5kcyB0cnVlXG4gICAgICAgID8gdW5rbm93blxuICAgICAgICA6IC8vIElmIHRoZSBwYXJhbWV0ZXIgaXMgYSBGdW5jdGlvbiwgcmV0dXJuIGl0IGFzIGlzIGJlY2F1c2UgdGhpcyB0eXBlIGlzIG5vdCBjYXBhYmxlIG9mIGhhbmRsaW5nIGZ1bmN0aW9uLCBsZWF2ZSBpdCB0byBUeXBlU2NyaXB0XG4gICAgICAgICAgLy8gZXNsaW50LWRpc2FibGUtbmV4dC1saW5lIEB0eXBlc2NyaXB0LWVzbGludC9uby11bnNhZmUtZnVuY3Rpb24tdHlwZVxuICAgICAgICAgIFBhcmFtZXRlclR5cGUgZXh0ZW5kcyBGdW5jdGlvblxuICAgICAgICAgID8gUGFyYW1ldGVyVHlwZVxuICAgICAgICAgIDogLy8gQ29udmVydCB1bmlvbiBvZiBhcnJheSB0byBhcnJheSBvZiB1bmlvbjogQVtdICYgQltdID0+IChBICYgQilbXVxuICAgICAgICAgICAgUGFyYW1ldGVyVHlwZSBleHRlbmRzIHVua25vd25bXVxuICAgICAgICAgICAgPyBBcnJheTxFeGFjdDxBcnJheUVsZW1lbnQ8UGFyYW1ldGVyVHlwZT4sIEFycmF5RWxlbWVudDxJbnB1dFR5cGU+Pj5cbiAgICAgICAgICAgIDogLy8gSW4gVHlwZVNjcmlwdCwgQXJyYXkgaXMgYSBzdWJ0eXBlIG9mIFJlYWRvbmx5QXJyYXksIHNvIGFsd2F5cyB0ZXN0IEFycmF5IGJlZm9yZSBSZWFkb25seUFycmF5LlxuICAgICAgICAgICAgICBQYXJhbWV0ZXJUeXBlIGV4dGVuZHMgcmVhZG9ubHkgdW5rbm93bltdXG4gICAgICAgICAgICAgID8gUmVhZG9ubHlBcnJheTxFeGFjdDxBcnJheUVsZW1lbnQ8UGFyYW1ldGVyVHlwZT4sIEFycmF5RWxlbWVudDxJbnB1dFR5cGU+Pj5cbiAgICAgICAgICAgICAgOiBFeGFjdE9iamVjdDxQYXJhbWV0ZXJUeXBlLCBJbnB1dFR5cGU+O1xuLy8gRW5kIG9mIGJvcnJvdyBmcm9tICBodHRwczovL2dpdGh1Yi5jb20vc2luZHJlc29yaHVzL3R5cGUtZmVzdC9ibG9iL21haW4vc291cmNlL3VuaW9uLXRvLWludGVyc2VjdGlvbi5kLnRzXG5cbmV4cG9ydCB0eXBlIFJlbW92ZVByZWZpeDxQcmVmaXggZXh0ZW5kcyBzdHJpbmcsIEtleXMgZXh0ZW5kcyBzdHJpbmc+ID0ge1xuICBbayBpbiBLZXlzXTogayBleHRlbmRzIGAke1ByZWZpeH0ke2luZmVyIFN1ZmZpeH1gID8gU3VmZml4IDogbmV2ZXI7XG59W0tleXNdO1xuXG5leHBvcnQgZnVuY3Rpb24gaXNSZWNvcmQodmFsdWU6IHVua25vd24pOiB2YWx1ZSBpcyBSZWNvcmQ8c3RyaW5nLCB1bmtub3duPiB7XG4gIHJldHVybiB0eXBlb2YgdmFsdWUgPT09ICdvYmplY3QnICYmIHZhbHVlICE9PSBudWxsO1xufVxuXG5leHBvcnQgZnVuY3Rpb24gaGFzT3duUHJvcGVydHk8WCBleHRlbmRzIFJlY29yZDxzdHJpbmcsIHVua25vd24+LCBZIGV4dGVuZHMgUHJvcGVydHlLZXk+KFxuICByZWNvcmQ6IFgsXG4gIHByb3A6IFlcbik6IHJlY29yZCBpcyBYICYgUmVjb3JkPFksIHVua25vd24+IHtcbiAgcmV0dXJuIHByb3AgaW4gcmVjb3JkO1xufVxuXG5leHBvcnQgZnVuY3Rpb24gaGFzT3duUHJvcGVydGllczxYIGV4dGVuZHMgUmVjb3JkPHN0cmluZywgdW5rbm93bj4sIFkgZXh0ZW5kcyBQcm9wZXJ0eUtleT4oXG4gIHJlY29yZDogWCxcbiAgcHJvcHM6IFlbXVxuKTogcmVjb3JkIGlzIFggJiBSZWNvcmQ8WSwgdW5rbm93bj4ge1xuICByZXR1cm4gcHJvcHMuZXZlcnkoKHByb3ApID0+IHByb3AgaW4gcmVjb3JkKTtcbn1cblxuZXhwb3J0IGZ1bmN0aW9uIGlzRXJyb3IoZXJyb3I6IHVua25vd24pOiBlcnJvciBpcyBFcnJvciB7XG4gIHJldHVybiAoXG4gICAgaXNSZWNvcmQoZXJyb3IpICYmXG4gICAgdHlwZW9mIGVycm9yLm5hbWUgPT09ICdzdHJpbmcnICYmXG4gICAgdHlwZW9mIGVycm9yLm1lc3NhZ2UgPT09ICdzdHJpbmcnICYmXG4gICAgKGVycm9yLnN0YWNrID09IG51bGwgfHwgdHlwZW9mIGVycm9yLnN0YWNrID09PSAnc3RyaW5nJylcbiAgKTtcbn1cblxuZXhwb3J0IGZ1bmN0aW9uIGlzQWJvcnRFcnJvcihlcnJvcjogdW5rbm93bik6IGVycm9yIGlzIEVycm9yICYgeyBuYW1lOiAnQWJvcnRFcnJvcicgfSB7XG4gIHJldHVybiBpc0Vycm9yKGVycm9yKSAmJiBlcnJvci5uYW1lID09PSAnQWJvcnRFcnJvcic7XG59XG5cbi8qKlxuICogR2V0IGBlcnJvci5tZXNzYWdlYCAob3IgYHVuZGVmaW5lZGAgaWYgbm90IHByZXNlbnQpXG4gKi9cbmV4cG9ydCBmdW5jdGlvbiBlcnJvck1lc3NhZ2UoZXJyb3I6IHVua25vd24pOiBzdHJpbmcgfCB1bmRlZmluZWQge1xuICBpZiAoaXNFcnJvcihlcnJvcikpIHtcbiAgICByZXR1cm4gZXJyb3IubWVzc2FnZTtcbiAgfSBlbHNlIGlmICh0eXBlb2YgZXJyb3IgPT09ICdzdHJpbmcnKSB7XG4gICAgcmV0dXJuIGVycm9yO1xuICB9XG4gIHJldHVybiB1bmRlZmluZWQ7XG59XG5cbmludGVyZmFjZSBFcnJvcldpdGhDb2RlIHtcbiAgY29kZTogc3RyaW5nO1xufVxuXG5mdW5jdGlvbiBpc0Vycm9yV2l0aENvZGUoZXJyb3I6IHVua25vd24pOiBlcnJvciBpcyBFcnJvcldpdGhDb2RlIHtcbiAgcmV0dXJuIGlzUmVjb3JkKGVycm9yKSAmJiB0eXBlb2YgZXJyb3IuY29kZSA9PT0gJ3N0cmluZyc7XG59XG5cbi8qKlxuICogR2V0IGBlcnJvci5jb2RlYCAob3IgYHVuZGVmaW5lZGAgaWYgbm90IHByZXNlbnQpXG4gKi9cbmV4cG9ydCBmdW5jdGlvbiBlcnJvckNvZGUoZXJyb3I6IHVua25vd24pOiBzdHJpbmcgfCB1bmRlZmluZWQge1xuICBpZiAoaXNFcnJvcldpdGhDb2RlKGVycm9yKSkge1xuICAgIHJldHVybiBlcnJvci5jb2RlO1xuICB9XG5cbiAgcmV0dXJuIHVuZGVmaW5lZDtcbn1cblxuLyoqXG4gKiBBc3NlcnRzIHRoYXQgc29tZSB0eXBlIGlzIHRoZSBuZXZlciB0eXBlXG4gKi9cbmV4cG9ydCBmdW5jdGlvbiBhc3NlcnROZXZlcihtc2c6IHN0cmluZywgeDogbmV2ZXIpOiBuZXZlciB7XG4gIHRocm93IG5ldyBUeXBlRXJyb3IobXNnICsgJzogJyArIHgpO1xufVxuXG5leHBvcnQgdHlwZSBDbGFzczxFIGV4dGVuZHMgRXJyb3I+ID0ge1xuICBuZXcgKC4uLmFyZ3M6IGFueVtdKTogRTtcbiAgcHJvdG90eXBlOiBFO1xufTtcblxuLyoqXG4gKiBBIGRlY29yYXRvciB0byBiZSB1c2VkIG9uIGVycm9yIGNsYXNzZXMuIEl0IGFkZHMgdGhlICduYW1lJyBwcm9wZXJ0eSBBTkQgcHJvdmlkZXMgYSBjdXN0b21cbiAqICdpbnN0YW5jZW9mJyBoYW5kbGVyIHRoYXQgd29ya3MgY29ycmVjdGx5IGFjcm9zcyBleGVjdXRpb24gY29udGV4dHMuXG4gKlxuICogIyMjIERldGFpbHMgIyMjXG4gKlxuICogQWNjb3JkaW5nIHRvIHRoZSBFY21hU2NyaXB0J3Mgc3BlYywgdGhlIGRlZmF1bHQgYmVoYXZpb3Igb2YgSmF2YVNjcmlwdCdzIGB4IGluc3RhbmNlb2YgWWAgb3BlcmF0b3IgaXMgdG8gd2FsayB1cCB0aGVcbiAqIHByb3RvdHlwZSBjaGFpbiBvZiBvYmplY3QgJ3gnLCBjaGVja2luZyBpZiBhbnkgY29uc3RydWN0b3IgaW4gdGhhdCBoaWVyYXJjaHkgaXMgX2V4YWN0bHkgdGhlIHNhbWUgb2JqZWN0XyBhcyB0aGVcbiAqIGNvbnN0cnVjdG9yIGZ1bmN0aW9uICdZJy5cbiAqXG4gKiBVbmZvcnR1bmF0ZWx5LCBpdCBoYXBwZW5zIGluIHZhcmlvdXMgc2l0dWF0aW9ucyB0aGF0IGRpZmZlcmVudCBjb25zdHJ1Y3RvciBmdW5jdGlvbiBvYmplY3RzIGdldCBjcmVhdGVkIGZvciB3aGF0XG4gKiBhcHBlYXJzIHRvIGJlIHRoZSB2ZXJ5IHNhbWUgY2xhc3MuIFRoaXMgbGVhZHMgdG8gc3VycHJpc2luZyBiZWhhdmlvciB3aGVyZSBgaW5zdGFuY2VvZmAgcmV0dXJucyBmYWxzZSB0aG91Z2ggaXQgaXNcbiAqIGtub3duIHRoYXQgdGhlIG9iamVjdCBpcyBpbmRlZWQgYW4gaW5zdGFuY2Ugb2YgdGhhdCBjbGFzcy4gT25lIHBhcnRpY3VsYXIgY2FzZSB3aGVyZSB0aGlzIGhhcHBlbnMgaXMgd2hlbiBjb25zdHJ1Y3RvclxuICogJ1knIGJlbG9uZ3MgdG8gYSBkaWZmZXJlbnQgcmVhbG0gdGhhbiB0aGUgY29uc3R1Y3RvciB3aXRoIHdoaWNoICd4JyB3YXMgaW5zdGFudGlhdGVkLiBBbm90aGVyIGNhc2UgaXMgd2hlbiB0d28gY29waWVzXG4gKiBvZiB0aGUgc2FtZSBsaWJyYXJ5IGdldHMgbG9hZGVkIGluIHRoZSBzYW1lIHJlYWxtLlxuICpcbiAqIEluIHByYWN0aWNlLCB0aGlzIHRlbmRzIHRvIGNhdXNlIGlzc3VlcyB3aGVuIGNyb3NzaW5nIHRoZSB3b3JrZmxvdy1zYW5kYm94aW5nIGJvdW5kYXJ5IChzaW5jZSBOb2RlJ3Mgdm0gbW9kdWxlXG4gKiByZWFsbHkgY3JlYXRlcyBuZXcgZXhlY3V0aW9uIHJlYWxtcyksIGFzIHdlbGwgYXMgd2hlbiBydW5uaW5nIHRlc3RzIHVzaW5nIEplc3QgKHNlZSBodHRwczovL2dpdGh1Yi5jb20vamVzdGpzL2plc3QvaXNzdWVzLzI1NDlcbiAqIGZvciBzb21lIGRldGFpbHMgb24gdGhhdCBvbmUpLlxuICpcbiAqIFRoaXMgZnVuY3Rpb24gaW5qZWN0cyBhIGN1c3RvbSAnaW5zdGFuY2VvZicgaGFuZGxlciBpbnRvIHRoZSBwcm90b3R5cGUgb2YgJ2NsYXp6Jywgd2hpY2ggaXMgYm90aCBjcm9zcy1yZWFsbSBzYWZlIGFuZFxuICogY3Jvc3MtY29waWVzLW9mLXRoZS1zYW1lLWxpYiBzYWZlLiBJdCB3b3JrcyBieSBhZGRpbmcgYSBzcGVjaWFsIHN5bWJvbCBwcm9wZXJ0eSB0byB0aGUgcHJvdG90eXBlIG9mICdjbGF6eicsIGFuZCB0aGVuXG4gKiBjaGVja2luZyBmb3IgdGhlIHByZXNlbmNlIG9mIHRoYXQgc3ltYm9sLlxuICovXG5leHBvcnQgZnVuY3Rpb24gU3ltYm9sQmFzZWRJbnN0YW5jZU9mRXJyb3I8RSBleHRlbmRzIEVycm9yPihtYXJrZXJOYW1lOiBzdHJpbmcpOiAoY2xheno6IENsYXNzPEU+KSA9PiB2b2lkIHtcbiAgcmV0dXJuIChjbGF6ejogQ2xhc3M8RT4pOiB2b2lkID0+IHtcbiAgICBjb25zdCBtYXJrZXIgPSBTeW1ib2wuZm9yKGBfX3RlbXBvcmFsX2lzJHttYXJrZXJOYW1lfWApO1xuXG4gICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KGNsYXp6LnByb3RvdHlwZSwgJ25hbWUnLCB7IHZhbHVlOiBtYXJrZXJOYW1lLCBlbnVtZXJhYmxlOiB0cnVlIH0pO1xuICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eShjbGF6ei5wcm90b3R5cGUsIG1hcmtlciwgeyB2YWx1ZTogdHJ1ZSwgZW51bWVyYWJsZTogZmFsc2UgfSk7XG4gICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KGNsYXp6LCBTeW1ib2wuaGFzSW5zdGFuY2UsIHtcbiAgICAgIC8vIGVzbGludC1kaXNhYmxlLW5leHQtbGluZSBvYmplY3Qtc2hvcnRoYW5kXG4gICAgICB2YWx1ZTogZnVuY3Rpb24gKHRoaXM6IGFueSwgZXJyb3I6IG9iamVjdCk6IGJvb2xlYW4ge1xuICAgICAgICBpZiAodGhpcyA9PT0gY2xhenopIHtcbiAgICAgICAgICByZXR1cm4gaXNSZWNvcmQoZXJyb3IpICYmIChlcnJvciBhcyBhbnkpW21hcmtlcl0gPT09IHRydWU7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgLy8gJ3RoaXMnIG11c3QgYmUgYSBfc3ViY2xhc3NfIG9mIGNsYXp6IHRoYXQgZG9lc24ndCByZWRlZmluZWQgW1N5bWJvbC5oYXNJbnN0YW5jZV0sIHNvIHRoYXQgaXQgaW5oZXJpdGVkXG4gICAgICAgICAgLy8gZnJvbSBjbGF6eidzIFtTeW1ib2wuaGFzSW5zdGFuY2VdLiBJZiB3ZSBkb24ndCBoYW5kbGUgdGhpcyBwYXJ0aWN1bGFyIHNpdHVhdGlvbiwgdGhlblxuICAgICAgICAgIC8vIGB4IGluc3RhbmNlb2YgU3ViY2xhc3NPZlBhcmVudGAgd291bGQgcmV0dXJuIHRydWUgZm9yIGFueSBpbnN0YW5jZSBvZiAnUGFyZW50Jywgd2hpY2ggaXMgY2xlYXJseSB3cm9uZy5cbiAgICAgICAgICAvL1xuICAgICAgICAgIC8vIElkZWFsbHksIGl0J2QgYmUgcHJlZmVyYWJsZSB0byBhdm9pZCB0aGlzIGNhc2UgZW50aXJlbHksIGJ5IG1ha2luZyBzdXJlIHRoYXQgYWxsIHN1YmNsYXNzZXMgb2YgJ2NsYXp6J1xuICAgICAgICAgIC8vIHJlZGVmaW5lIFtTeW1ib2wuaGFzSW5zdGFuY2VdLCBidXQgd2UgY2FuJ3QgZW5mb3JjZSB0aGF0LiBXZSB0aGVyZWZvcmUgZmFsbGJhY2sgdG8gdGhlIGRlZmF1bHQgaW5zdGFuY2VvZlxuICAgICAgICAgIC8vIGJlaGF2aW9yICh3aGljaCBpcyBOT1QgY3Jvc3MtcmVhbG0gc2FmZSkuXG4gICAgICAgICAgcmV0dXJuIHRoaXMucHJvdG90eXBlLmlzUHJvdG90eXBlT2YoZXJyb3IpOyAvLyBlc2xpbnQtZGlzYWJsZS1saW5lIG5vLXByb3RvdHlwZS1idWlsdGluc1xuICAgICAgICB9XG4gICAgICB9LFxuICAgIH0pO1xuICB9O1xufVxuXG4vLyBUaGFua3MgTUROOiBodHRwczovL2RldmVsb3Blci5tb3ppbGxhLm9yZy9lbi1VUy9kb2NzL1dlYi9KYXZhU2NyaXB0L1JlZmVyZW5jZS9HbG9iYWxfT2JqZWN0cy9PYmplY3QvZnJlZXplXG5leHBvcnQgZnVuY3Rpb24gZGVlcEZyZWV6ZTxUPihvYmplY3Q6IFQpOiBUIHtcbiAgLy8gUmV0cmlldmUgdGhlIHByb3BlcnR5IG5hbWVzIGRlZmluZWQgb24gb2JqZWN0XG4gIGNvbnN0IHByb3BOYW1lcyA9IE9iamVjdC5nZXRPd25Qcm9wZXJ0eU5hbWVzKG9iamVjdCk7XG5cbiAgLy8gRnJlZXplIHByb3BlcnRpZXMgYmVmb3JlIGZyZWV6aW5nIHNlbGZcbiAgZm9yIChjb25zdCBuYW1lIG9mIHByb3BOYW1lcykge1xuICAgIGNvbnN0IHZhbHVlID0gKG9iamVjdCBhcyBhbnkpW25hbWVdO1xuXG4gICAgaWYgKHZhbHVlICYmIHR5cGVvZiB2YWx1ZSA9PT0gJ29iamVjdCcpIHtcbiAgICAgIHRyeSB7XG4gICAgICAgIGRlZXBGcmVlemUodmFsdWUpO1xuICAgICAgfSBjYXRjaCAoX2Vycikge1xuICAgICAgICAvLyBUaGlzIGlzIG9rYXksIHRoZXJlIGFyZSBzb21lIHR5cGVkIGFycmF5cyB0aGF0IGNhbm5vdCBiZSBmcm96ZW4gKGVuY29kaW5nS2V5cylcbiAgICAgIH1cbiAgICB9IGVsc2UgaWYgKHR5cGVvZiB2YWx1ZSA9PT0gJ2Z1bmN0aW9uJykge1xuICAgICAgT2JqZWN0LmZyZWV6ZSh2YWx1ZSk7XG4gICAgfVxuICB9XG5cbiAgcmV0dXJuIE9iamVjdC5mcmVlemUob2JqZWN0KTtcbn1cbiIsIi8qKlxuICogSW5kaWNhdGVzIHdoZXRoZXIgdGhlIHVzZXIgaW50ZW5kcyBjZXJ0YWluIGNvbW1hbmRzIHRvIGJlIHJ1biBvbiBhIGNvbXBhdGlibGUgd29ya2VyIEJ1aWxkIElkIHZlcnNpb24gb3Igbm90LlxuICpcbiAqIGBDT01QQVRJQkxFYCBpbmRpY2F0ZXMgdGhhdCB0aGUgY29tbWFuZCBzaG91bGQgcnVuIG9uIGEgd29ya2VyIHdpdGggY29tcGF0aWJsZSB2ZXJzaW9uIGlmIHBvc3NpYmxlLiBJdCBtYXkgbm90IGJlXG4gKiBwb3NzaWJsZSBpZiB0aGUgdGFyZ2V0IHRhc2sgcXVldWUgZG9lcyBub3QgYWxzbyBoYXZlIGtub3dsZWRnZSBvZiB0aGUgY3VycmVudCB3b3JrZXIncyBCdWlsZCBJZC5cbiAqXG4gKiBgREVGQVVMVGAgaW5kaWNhdGVzIHRoYXQgdGhlIGNvbW1hbmQgc2hvdWxkIHJ1biBvbiB0aGUgdGFyZ2V0IHRhc2sgcXVldWUncyBjdXJyZW50IG92ZXJhbGwtZGVmYXVsdCBCdWlsZCBJZC5cbiAqXG4gKiBXaGVyZSB0aGlzIHR5cGUgaXMgYWNjZXB0ZWQgb3B0aW9uYWxseSwgYW4gdW5zZXQgdmFsdWUgaW5kaWNhdGVzIHRoYXQgdGhlIFNESyBzaG91bGQgY2hvb3NlIHRoZSBtb3N0IHNlbnNpYmxlIGRlZmF1bHRcbiAqIGJlaGF2aW9yIGZvciB0aGUgdHlwZSBvZiBjb21tYW5kLCBhY2NvdW50aW5nIGZvciB3aGV0aGVyIHRoZSBjb21tYW5kIHdpbGwgYmUgcnVuIG9uIHRoZSBzYW1lIHRhc2sgcXVldWUgYXMgdGhlXG4gKiBjdXJyZW50IHdvcmtlci4gVGhlIGRlZmF1bHQgYmVoYXZpb3IgZm9yIHN0YXJ0aW5nIFdvcmtmbG93cyBpcyBgREVGQVVMVGAuIFRoZSBkZWZhdWx0IGJlaGF2aW9yIGZvciBXb3JrZmxvd3Mgc3RhcnRpbmdcbiAqIEFjdGl2aXRpZXMsIHN0YXJ0aW5nIENoaWxkIFdvcmtmbG93cywgb3IgQ29udGludWluZyBBcyBOZXcgaXMgYENPTVBBVElCTEVgLlxuICpcbiAqIEBleHBlcmltZW50YWxcbiAqL1xuZXhwb3J0IHR5cGUgVmVyc2lvbmluZ0ludGVudCA9ICdDT01QQVRJQkxFJyB8ICdERUZBVUxUJztcbiIsImltcG9ydCB7IFdvcmtmbG93LCBXb3JrZmxvd1Jlc3VsdFR5cGUsIFNpZ25hbERlZmluaXRpb24gfSBmcm9tICcuL2ludGVyZmFjZXMnO1xuXG4vKipcbiAqIEJhc2UgV29ya2Zsb3dIYW5kbGUgaW50ZXJmYWNlLCBleHRlbmRlZCBpbiB3b3JrZmxvdyBhbmQgY2xpZW50IGxpYnMuXG4gKlxuICogVHJhbnNmb3JtcyBhIHdvcmtmbG93IGludGVyZmFjZSBgVGAgaW50byBhIGNsaWVudCBpbnRlcmZhY2UuXG4gKi9cbmV4cG9ydCBpbnRlcmZhY2UgQmFzZVdvcmtmbG93SGFuZGxlPFQgZXh0ZW5kcyBXb3JrZmxvdz4ge1xuICAvKipcbiAgICogUHJvbWlzZSB0aGF0IHJlc29sdmVzIHdoZW4gV29ya2Zsb3cgZXhlY3V0aW9uIGNvbXBsZXRlc1xuICAgKi9cbiAgcmVzdWx0KCk6IFByb21pc2U8V29ya2Zsb3dSZXN1bHRUeXBlPFQ+PjtcblxuICAvKipcbiAgICogU2lnbmFsIGEgcnVubmluZyBXb3JrZmxvdy5cbiAgICpcbiAgICogQHBhcmFtIGRlZiBhIHNpZ25hbCBkZWZpbml0aW9uIGFzIHJldHVybmVkIGZyb20ge0BsaW5rIGRlZmluZVNpZ25hbH1cbiAgICpcbiAgICogQGV4YW1wbGVcbiAgICogYGBgdHNcbiAgICogYXdhaXQgaGFuZGxlLnNpZ25hbChpbmNyZW1lbnRTaWduYWwsIDMpO1xuICAgKiBgYGBcbiAgICovXG4gIHNpZ25hbDxBcmdzIGV4dGVuZHMgYW55W10gPSBbXSwgTmFtZSBleHRlbmRzIHN0cmluZyA9IHN0cmluZz4oXG4gICAgZGVmOiBTaWduYWxEZWZpbml0aW9uPEFyZ3MsIE5hbWU+IHwgc3RyaW5nLFxuICAgIC4uLmFyZ3M6IEFyZ3NcbiAgKTogUHJvbWlzZTx2b2lkPjtcblxuICAvKipcbiAgICogVGhlIHdvcmtmbG93SWQgb2YgdGhlIGN1cnJlbnQgV29ya2Zsb3dcbiAgICovXG4gIHJlYWRvbmx5IHdvcmtmbG93SWQ6IHN0cmluZztcbn1cbiIsImltcG9ydCB0eXBlIHsgdGVtcG9yYWwgfSBmcm9tICdAdGVtcG9yYWxpby9wcm90byc7XG5pbXBvcnQgeyBTZWFyY2hBdHRyaWJ1dGVzLCBXb3JrZmxvdyB9IGZyb20gJy4vaW50ZXJmYWNlcyc7XG5pbXBvcnQgeyBSZXRyeVBvbGljeSB9IGZyb20gJy4vcmV0cnktcG9saWN5JztcbmltcG9ydCB7IER1cmF0aW9uIH0gZnJvbSAnLi90aW1lJztcbmltcG9ydCB7IG1ha2VQcm90b0VudW1Db252ZXJ0ZXJzIH0gZnJvbSAnLi9pbnRlcm5hbC13b3JrZmxvdyc7XG5cbi8qKlxuICogRGVmaW5lcyB3aGF0IGhhcHBlbnMgd2hlbiB0cnlpbmcgdG8gc3RhcnQgYSBXb3JrZmxvdyB3aXRoIHRoZSBzYW1lIElEIGFzIGEgKkNsb3NlZCogV29ya2Zsb3cuXG4gKlxuICogU2VlIHtAbGluayBXb3JrZmxvd09wdGlvbnMud29ya2Zsb3dJZENvbmZsaWN0UG9saWN5fSBmb3Igd2hhdCBoYXBwZW5zIHdoZW4gdHJ5aW5nIHRvIHN0YXJ0IGFcbiAqIFdvcmtmbG93IHdpdGggdGhlIHNhbWUgSUQgYXMgYSAqUnVubmluZyogV29ya2Zsb3cuXG4gKlxuICogQ29uY2VwdDoge0BsaW5rIGh0dHBzOi8vZG9jcy50ZW1wb3JhbC5pby9jb25jZXB0cy93aGF0LWlzLWEtd29ya2Zsb3ctaWQtcmV1c2UtcG9saWN5LyB8IFdvcmtmbG93IElkIFJldXNlIFBvbGljeX1cbiAqXG4gKiAqTm90ZTogSXQgaXMgbm90IHBvc3NpYmxlIHRvIGhhdmUgdHdvIGFjdGl2ZWx5IHJ1bm5pbmcgV29ya2Zsb3dzIHdpdGggdGhlIHNhbWUgSUQuKlxuICpcbiAqL1xuZXhwb3J0IGNvbnN0IFdvcmtmbG93SWRSZXVzZVBvbGljeSA9IHtcbiAgLyoqXG4gICAqIFRoZSBXb3JrZmxvdyBjYW4gYmUgc3RhcnRlZCBpZiB0aGUgcHJldmlvdXMgV29ya2Zsb3cgaXMgaW4gYSBDbG9zZWQgc3RhdGUuXG4gICAqIEBkZWZhdWx0XG4gICAqL1xuICBBTExPV19EVVBMSUNBVEU6ICdBTExPV19EVVBMSUNBVEUnLFxuXG4gIC8qKlxuICAgKiBUaGUgV29ya2Zsb3cgY2FuIGJlIHN0YXJ0ZWQgaWYgdGhlIHByZXZpb3VzIFdvcmtmbG93IGlzIGluIGEgQ2xvc2VkIHN0YXRlIHRoYXQgaXMgbm90IENvbXBsZXRlZC5cbiAgICovXG4gIEFMTE9XX0RVUExJQ0FURV9GQUlMRURfT05MWTogJ0FMTE9XX0RVUExJQ0FURV9GQUlMRURfT05MWScsXG5cbiAgLyoqXG4gICAqIFRoZSBXb3JrZmxvdyBjYW5ub3QgYmUgc3RhcnRlZC5cbiAgICovXG4gIFJFSkVDVF9EVVBMSUNBVEU6ICdSRUpFQ1RfRFVQTElDQVRFJyxcblxuICAvKipcbiAgICogVGVybWluYXRlIHRoZSBjdXJyZW50IFdvcmtmbG93IGlmIG9uZSBpcyBhbHJlYWR5IHJ1bm5pbmc7IG90aGVyd2lzZSBhbGxvdyByZXVzaW5nIHRoZSBXb3JrZmxvdyBJRC5cbiAgICpcbiAgICogQGRlcHJlY2F0ZWQgVXNlIHtAbGluayBXT1JLRkxPV19JRF9SRVVTRV9QT0xJQ1lfQUxMT1dfRFVQTElDQVRFfSBpbnN0ZWFkLCBhbmRcbiAgICogICAgICAgICAgICAgc2V0IGBXb3JrZmxvd09wdGlvbnMud29ya2Zsb3dJZENvbmZsaWN0UG9saWN5YCB0b1xuICAgKiAgICAgICAgICAgICB7QGxpbmsgV29ya2Zsb3dJZENvbmZsaWN0UG9saWN5LldPUktGTE9XX0lEX0NPTkZMSUNUX1BPTElDWV9URVJNSU5BVEVfRVhJU1RJTkd9LlxuICAgKiAgICAgICAgICAgICBXaGVuIHVzaW5nIHRoaXMgb3B0aW9uLCBgV29ya2Zsb3dPcHRpb25zLndvcmtmbG93SWRDb25mbGljdFBvbGljeWAgbXVzdCBiZSBsZWZ0IHVuc3BlY2lmaWVkLlxuICAgKi9cbiAgVEVSTUlOQVRFX0lGX1JVTk5JTkc6ICdURVJNSU5BVEVfSUZfUlVOTklORycsIC8vIGVzbGludC1kaXNhYmxlLWxpbmUgZGVwcmVjYXRpb24vZGVwcmVjYXRpb25cblxuICAvLy8gQW55dGhpbmcgYmVsb3cgdGhpcyBsaW5lIGhhcyBiZWVuIGRlcHJlY2F0ZWRcblxuICAvKipcbiAgICogTm8gbmVlZCB0byB1c2UgdGhpcy4gSWYgYSBgV29ya2Zsb3dJZFJldXNlUG9saWN5YCBpcyBzZXQgdG8gdGhpcywgb3IgaXMgbm90IHNldCBhdCBhbGwsIHRoZSBkZWZhdWx0IHZhbHVlIHdpbGwgYmUgdXNlZC5cbiAgICpcbiAgICogQGRlcHJlY2F0ZWQgRWl0aGVyIGxlYXZlIHByb3BlcnR5IGB1bmRlZmluZWRgLCBvciB1c2Uge0BsaW5rIEFMTE9XX0RVUExJQ0FURX0gaW5zdGVhZC5cbiAgICovXG4gIFdPUktGTE9XX0lEX1JFVVNFX1BPTElDWV9VTlNQRUNJRklFRDogdW5kZWZpbmVkLCAvLyBlc2xpbnQtZGlzYWJsZS1saW5lIGRlcHJlY2F0aW9uL2RlcHJlY2F0aW9uXG5cbiAgLyoqIEBkZXByZWNhdGVkIFVzZSB7QGxpbmsgQUxMT1dfRFVQTElDQVRFfSBpbnN0ZWFkLiAqL1xuICBXT1JLRkxPV19JRF9SRVVTRV9QT0xJQ1lfQUxMT1dfRFVQTElDQVRFOiAnQUxMT1dfRFVQTElDQVRFJywgLy8gZXNsaW50LWRpc2FibGUtbGluZSBkZXByZWNhdGlvbi9kZXByZWNhdGlvblxuXG4gIC8qKiBAZGVwcmVjYXRlZCBVc2Uge0BsaW5rIEFMTE9XX0RVUExJQ0FURV9GQUlMRURfT05MWX0gaW5zdGVhZC4gKi9cbiAgV09SS0ZMT1dfSURfUkVVU0VfUE9MSUNZX0FMTE9XX0RVUExJQ0FURV9GQUlMRURfT05MWTogJ0FMTE9XX0RVUExJQ0FURV9GQUlMRURfT05MWScsIC8vIGVzbGludC1kaXNhYmxlLWxpbmUgZGVwcmVjYXRpb24vZGVwcmVjYXRpb25cblxuICAvKiogQGRlcHJlY2F0ZWQgVXNlIHtAbGluayBSRUpFQ1RfRFVQTElDQVRFfSBpbnN0ZWFkLiAqL1xuICBXT1JLRkxPV19JRF9SRVVTRV9QT0xJQ1lfUkVKRUNUX0RVUExJQ0FURTogJ1JFSkVDVF9EVVBMSUNBVEUnLCAvLyBlc2xpbnQtZGlzYWJsZS1saW5lIGRlcHJlY2F0aW9uL2RlcHJlY2F0aW9uXG5cbiAgLyoqIEBkZXByZWNhdGVkIFVzZSB7QGxpbmsgVEVSTUlOQVRFX0lGX1JVTk5JTkd9IGluc3RlYWQuICovXG4gIFdPUktGTE9XX0lEX1JFVVNFX1BPTElDWV9URVJNSU5BVEVfSUZfUlVOTklORzogJ1RFUk1JTkFURV9JRl9SVU5OSU5HJywgLy8gZXNsaW50LWRpc2FibGUtbGluZSBkZXByZWNhdGlvbi9kZXByZWNhdGlvblxufSBhcyBjb25zdDtcbmV4cG9ydCB0eXBlIFdvcmtmbG93SWRSZXVzZVBvbGljeSA9ICh0eXBlb2YgV29ya2Zsb3dJZFJldXNlUG9saWN5KVtrZXlvZiB0eXBlb2YgV29ya2Zsb3dJZFJldXNlUG9saWN5XTtcblxuZXhwb3J0IGNvbnN0IFtlbmNvZGVXb3JrZmxvd0lkUmV1c2VQb2xpY3ksIGRlY29kZVdvcmtmbG93SWRSZXVzZVBvbGljeV0gPSBtYWtlUHJvdG9FbnVtQ29udmVydGVyczxcbiAgdGVtcG9yYWwuYXBpLmVudW1zLnYxLldvcmtmbG93SWRSZXVzZVBvbGljeSxcbiAgdHlwZW9mIHRlbXBvcmFsLmFwaS5lbnVtcy52MS5Xb3JrZmxvd0lkUmV1c2VQb2xpY3ksXG4gIGtleW9mIHR5cGVvZiB0ZW1wb3JhbC5hcGkuZW51bXMudjEuV29ya2Zsb3dJZFJldXNlUG9saWN5LFxuICB0eXBlb2YgV29ya2Zsb3dJZFJldXNlUG9saWN5LFxuICAnV09SS0ZMT1dfSURfUkVVU0VfUE9MSUNZXydcbj4oXG4gIHtcbiAgICBbV29ya2Zsb3dJZFJldXNlUG9saWN5LkFMTE9XX0RVUExJQ0FURV06IDEsXG4gICAgW1dvcmtmbG93SWRSZXVzZVBvbGljeS5BTExPV19EVVBMSUNBVEVfRkFJTEVEX09OTFldOiAyLFxuICAgIFtXb3JrZmxvd0lkUmV1c2VQb2xpY3kuUkVKRUNUX0RVUExJQ0FURV06IDMsXG4gICAgW1dvcmtmbG93SWRSZXVzZVBvbGljeS5URVJNSU5BVEVfSUZfUlVOTklOR106IDQsIC8vIGVzbGludC1kaXNhYmxlLWxpbmUgZGVwcmVjYXRpb24vZGVwcmVjYXRpb25cbiAgICBVTlNQRUNJRklFRDogMCxcbiAgfSBhcyBjb25zdCxcbiAgJ1dPUktGTE9XX0lEX1JFVVNFX1BPTElDWV8nXG4pO1xuXG4vKipcbiAqIERlZmluZXMgd2hhdCBoYXBwZW5zIHdoZW4gdHJ5aW5nIHRvIHN0YXJ0IGEgV29ya2Zsb3cgd2l0aCB0aGUgc2FtZSBJRCBhcyBhICpSdW5uaW5nKiBXb3JrZmxvdy5cbiAqXG4gKiBTZWUge0BsaW5rIFdvcmtmbG93T3B0aW9ucy53b3JrZmxvd0lkUmV1c2VQb2xpY3l9IGZvciB3aGF0IGhhcHBlbnMgd2hlbiB0cnlpbmcgdG8gc3RhcnQgYSBXb3JrZmxvd1xuICogd2l0aCB0aGUgc2FtZSBJRCBhcyBhICpDbG9zZWQqIFdvcmtmbG93LlxuICpcbiAqICpOb3RlOiBJdCBpcyBuZXZlciBwb3NzaWJsZSB0byBoYXZlIHR3byBfYWN0aXZlbHkgcnVubmluZ18gV29ya2Zsb3dzIHdpdGggdGhlIHNhbWUgSUQuKlxuICovXG5leHBvcnQgdHlwZSBXb3JrZmxvd0lkQ29uZmxpY3RQb2xpY3kgPSAodHlwZW9mIFdvcmtmbG93SWRDb25mbGljdFBvbGljeSlba2V5b2YgdHlwZW9mIFdvcmtmbG93SWRDb25mbGljdFBvbGljeV07XG5leHBvcnQgY29uc3QgV29ya2Zsb3dJZENvbmZsaWN0UG9saWN5ID0ge1xuICAvKipcbiAgICogRG8gbm90IHN0YXJ0IGEgbmV3IFdvcmtmbG93LiBJbnN0ZWFkIHJhaXNlIGEgYFdvcmtmbG93RXhlY3V0aW9uQWxyZWFkeVN0YXJ0ZWRFcnJvcmAuXG4gICAqL1xuICBGQUlMOiAnRkFJTCcsXG5cbiAgLyoqXG4gICAqIERvIG5vdCBzdGFydCBhIG5ldyBXb3JrZmxvdy4gSW5zdGVhZCByZXR1cm4gYSBXb3JrZmxvdyBIYW5kbGUgZm9yIHRoZSBhbHJlYWR5IFJ1bm5pbmcgV29ya2Zsb3cuXG4gICAqL1xuICBVU0VfRVhJU1RJTkc6ICdVU0VfRVhJU1RJTkcnLFxuXG4gIC8qKlxuICAgKiBTdGFydCBhIG5ldyBXb3JrZmxvdywgdGVybWluYXRpbmcgdGhlIGN1cnJlbnQgd29ya2Zsb3cgaWYgb25lIGlzIGFscmVhZHkgcnVubmluZy5cbiAgICovXG4gIFRFUk1JTkFURV9FWElTVElORzogJ1RFUk1JTkFURV9FWElTVElORycsXG59IGFzIGNvbnN0O1xuXG5leHBvcnQgY29uc3QgW2VuY29kZVdvcmtmbG93SWRDb25mbGljdFBvbGljeSwgZGVjb2RlV29ya2Zsb3dJZENvbmZsaWN0UG9saWN5XSA9IG1ha2VQcm90b0VudW1Db252ZXJ0ZXJzPFxuICB0ZW1wb3JhbC5hcGkuZW51bXMudjEuV29ya2Zsb3dJZENvbmZsaWN0UG9saWN5LFxuICB0eXBlb2YgdGVtcG9yYWwuYXBpLmVudW1zLnYxLldvcmtmbG93SWRDb25mbGljdFBvbGljeSxcbiAga2V5b2YgdHlwZW9mIHRlbXBvcmFsLmFwaS5lbnVtcy52MS5Xb3JrZmxvd0lkQ29uZmxpY3RQb2xpY3ksXG4gIHR5cGVvZiBXb3JrZmxvd0lkQ29uZmxpY3RQb2xpY3ksXG4gICdXT1JLRkxPV19JRF9DT05GTElDVF9QT0xJQ1lfJ1xuPihcbiAge1xuICAgIFtXb3JrZmxvd0lkQ29uZmxpY3RQb2xpY3kuRkFJTF06IDEsXG4gICAgW1dvcmtmbG93SWRDb25mbGljdFBvbGljeS5VU0VfRVhJU1RJTkddOiAyLFxuICAgIFtXb3JrZmxvd0lkQ29uZmxpY3RQb2xpY3kuVEVSTUlOQVRFX0VYSVNUSU5HXTogMyxcbiAgICBVTlNQRUNJRklFRDogMCxcbiAgfSBhcyBjb25zdCxcbiAgJ1dPUktGTE9XX0lEX0NPTkZMSUNUX1BPTElDWV8nXG4pO1xuXG5leHBvcnQgaW50ZXJmYWNlIEJhc2VXb3JrZmxvd09wdGlvbnMge1xuICAvKipcbiAgICogRGVmaW5lcyB3aGF0IGhhcHBlbnMgd2hlbiB0cnlpbmcgdG8gc3RhcnQgYSBXb3JrZmxvdyB3aXRoIHRoZSBzYW1lIElEIGFzIGEgKkNsb3NlZCogV29ya2Zsb3cuXG4gICAqXG4gICAqICpOb3RlOiBJdCBpcyBub3QgcG9zc2libGUgdG8gaGF2ZSB0d28gYWN0aXZlbHkgcnVubmluZyBXb3JrZmxvd3Mgd2l0aCB0aGUgc2FtZSBJRC4qXG4gICAqXG4gICAqIEBkZWZhdWx0IHtAbGluayBXb3JrZmxvd0lkUmV1c2VQb2xpY3kuV09SS0ZMT1dfSURfUkVVU0VfUE9MSUNZX0FMTE9XX0RVUExJQ0FURX1cbiAgICovXG4gIHdvcmtmbG93SWRSZXVzZVBvbGljeT86IFdvcmtmbG93SWRSZXVzZVBvbGljeTtcblxuICAvKipcbiAgICogRGVmaW5lcyB3aGF0IGhhcHBlbnMgd2hlbiB0cnlpbmcgdG8gc3RhcnQgYSBXb3JrZmxvdyB3aXRoIHRoZSBzYW1lIElEIGFzIGEgKlJ1bm5pbmcqIFdvcmtmbG93LlxuICAgKlxuICAgKiAqTm90ZTogSXQgaXMgbm90IHBvc3NpYmxlIHRvIGhhdmUgdHdvIGFjdGl2ZWx5IHJ1bm5pbmcgV29ya2Zsb3dzIHdpdGggdGhlIHNhbWUgSUQuKlxuICAgKlxuICAgKiBAZGVmYXVsdCB7QGxpbmsgV29ya2Zsb3dJZENvbmZsaWN0UG9saWN5LldPUktGTE9XX0lEX0NPTkZMSUNUX1BPTElDWV9VTlNQRUNJRklFRH1cbiAgICovXG4gIHdvcmtmbG93SWRDb25mbGljdFBvbGljeT86IFdvcmtmbG93SWRDb25mbGljdFBvbGljeTtcblxuICAvKipcbiAgICogQ29udHJvbHMgaG93IGEgV29ya2Zsb3cgRXhlY3V0aW9uIGlzIHJldHJpZWQuXG4gICAqXG4gICAqIEJ5IGRlZmF1bHQsIFdvcmtmbG93IEV4ZWN1dGlvbnMgYXJlIG5vdCByZXRyaWVkLiBEbyBub3Qgb3ZlcnJpZGUgdGhpcyBiZWhhdmlvciB1bmxlc3MgeW91IGtub3cgd2hhdCB5b3UncmUgZG9pbmcuXG4gICAqIHtAbGluayBodHRwczovL2RvY3MudGVtcG9yYWwuaW8vY29uY2VwdHMvd2hhdC1pcy1hLXJldHJ5LXBvbGljeS8gfCBNb3JlIGluZm9ybWF0aW9ufS5cbiAgICovXG4gIHJldHJ5PzogUmV0cnlQb2xpY3k7XG5cbiAgLyoqXG4gICAqIE9wdGlvbmFsIGNyb24gc2NoZWR1bGUgZm9yIFdvcmtmbG93LiBJZiBhIGNyb24gc2NoZWR1bGUgaXMgc3BlY2lmaWVkLCB0aGUgV29ya2Zsb3cgd2lsbCBydW4gYXMgYSBjcm9uIGJhc2VkIG9uIHRoZVxuICAgKiBzY2hlZHVsZS4gVGhlIHNjaGVkdWxpbmcgd2lsbCBiZSBiYXNlZCBvbiBVVEMgdGltZS4gVGhlIHNjaGVkdWxlIGZvciB0aGUgbmV4dCBydW4gb25seSBoYXBwZW5zIGFmdGVyIHRoZSBjdXJyZW50XG4gICAqIHJ1biBpcyBjb21wbGV0ZWQvZmFpbGVkL3RpbWVvdXQuIElmIGEgUmV0cnlQb2xpY3kgaXMgYWxzbyBzdXBwbGllZCwgYW5kIHRoZSBXb3JrZmxvdyBmYWlsZWQgb3IgdGltZWQgb3V0LCB0aGVcbiAgICogV29ya2Zsb3cgd2lsbCBiZSByZXRyaWVkIGJhc2VkIG9uIHRoZSByZXRyeSBwb2xpY3kuIFdoaWxlIHRoZSBXb3JrZmxvdyBpcyByZXRyeWluZywgaXQgd29uJ3Qgc2NoZWR1bGUgaXRzIG5leHQgcnVuLlxuICAgKiBJZiB0aGUgbmV4dCBzY2hlZHVsZSBpcyBkdWUgd2hpbGUgdGhlIFdvcmtmbG93IGlzIHJ1bm5pbmcgKG9yIHJldHJ5aW5nKSwgdGhlbiBpdCB3aWxsIHNraXAgdGhhdCBzY2hlZHVsZS4gQ3JvblxuICAgKiBXb3JrZmxvdyB3aWxsIG5vdCBzdG9wIHVudGlsIGl0IGlzIHRlcm1pbmF0ZWQgb3IgY2FuY2VsbGVkIChieSByZXR1cm5pbmcgdGVtcG9yYWwuQ2FuY2VsZWRFcnJvcikuXG4gICAqIGh0dHBzOi8vY3JvbnRhYi5ndXJ1LyBpcyB1c2VmdWwgZm9yIHRlc3RpbmcgeW91ciBjcm9uIGV4cHJlc3Npb25zLlxuICAgKi9cbiAgY3JvblNjaGVkdWxlPzogc3RyaW5nO1xuXG4gIC8qKlxuICAgKiBTcGVjaWZpZXMgYWRkaXRpb25hbCBub24taW5kZXhlZCBpbmZvcm1hdGlvbiB0byBhdHRhY2ggdG8gdGhlIFdvcmtmbG93IEV4ZWN1dGlvbi4gVGhlIHZhbHVlcyBjYW4gYmUgYW55dGhpbmcgdGhhdFxuICAgKiBpcyBzZXJpYWxpemFibGUgYnkge0BsaW5rIERhdGFDb252ZXJ0ZXJ9LlxuICAgKi9cbiAgbWVtbz86IFJlY29yZDxzdHJpbmcsIHVua25vd24+O1xuXG4gIC8qKlxuICAgKiBTcGVjaWZpZXMgYWRkaXRpb25hbCBpbmRleGVkIGluZm9ybWF0aW9uIHRvIGF0dGFjaCB0byB0aGUgV29ya2Zsb3cgRXhlY3V0aW9uLiBNb3JlIGluZm86XG4gICAqIGh0dHBzOi8vZG9jcy50ZW1wb3JhbC5pby9kb2NzL3R5cGVzY3JpcHQvc2VhcmNoLWF0dHJpYnV0ZXNcbiAgICpcbiAgICogVmFsdWVzIGFyZSBhbHdheXMgY29udmVydGVkIHVzaW5nIHtAbGluayBKc29uUGF5bG9hZENvbnZlcnRlcn0sIGV2ZW4gd2hlbiBhIGN1c3RvbSBkYXRhIGNvbnZlcnRlciBpcyBwcm92aWRlZC5cbiAgICovXG4gIHNlYXJjaEF0dHJpYnV0ZXM/OiBTZWFyY2hBdHRyaWJ1dGVzO1xufVxuXG5leHBvcnQgdHlwZSBXaXRoV29ya2Zsb3dBcmdzPFcgZXh0ZW5kcyBXb3JrZmxvdywgVD4gPSBUICZcbiAgKFBhcmFtZXRlcnM8Vz4gZXh0ZW5kcyBbYW55LCAuLi5hbnlbXV1cbiAgICA/IHtcbiAgICAgICAgLyoqXG4gICAgICAgICAqIEFyZ3VtZW50cyB0byBwYXNzIHRvIHRoZSBXb3JrZmxvd1xuICAgICAgICAgKi9cbiAgICAgICAgYXJnczogUGFyYW1ldGVyczxXPiB8IFJlYWRvbmx5PFBhcmFtZXRlcnM8Vz4+O1xuICAgICAgfVxuICAgIDoge1xuICAgICAgICAvKipcbiAgICAgICAgICogQXJndW1lbnRzIHRvIHBhc3MgdG8gdGhlIFdvcmtmbG93XG4gICAgICAgICAqL1xuICAgICAgICBhcmdzPzogUGFyYW1ldGVyczxXPiB8IFJlYWRvbmx5PFBhcmFtZXRlcnM8Vz4+O1xuICAgICAgfSk7XG5cbmV4cG9ydCBpbnRlcmZhY2UgV29ya2Zsb3dEdXJhdGlvbk9wdGlvbnMge1xuICAvKipcbiAgICogVGhlIHRpbWUgYWZ0ZXIgd2hpY2ggd29ya2Zsb3cgcnVuIGlzIGF1dG9tYXRpY2FsbHkgdGVybWluYXRlZCBieSBUZW1wb3JhbCBzZXJ2aWNlLiBEbyBub3RcbiAgICogcmVseSBvbiBydW4gdGltZW91dCBmb3IgYnVzaW5lc3MgbGV2ZWwgdGltZW91dHMuIEl0IGlzIHByZWZlcnJlZCB0byB1c2UgaW4gd29ya2Zsb3cgdGltZXJzXG4gICAqIGZvciB0aGlzIHB1cnBvc2UuXG4gICAqXG4gICAqIEBmb3JtYXQgbnVtYmVyIG9mIG1pbGxpc2Vjb25kcyBvciB7QGxpbmsgaHR0cHM6Ly93d3cubnBtanMuY29tL3BhY2thZ2UvbXMgfCBtcy1mb3JtYXR0ZWQgc3RyaW5nfVxuICAgKi9cbiAgd29ya2Zsb3dSdW5UaW1lb3V0PzogRHVyYXRpb247XG5cbiAgLyoqXG4gICAqXG4gICAqIFRoZSB0aW1lIGFmdGVyIHdoaWNoIHdvcmtmbG93IGV4ZWN1dGlvbiAod2hpY2ggaW5jbHVkZXMgcnVuIHJldHJpZXMgYW5kIGNvbnRpbnVlIGFzIG5ldykgaXNcbiAgICogYXV0b21hdGljYWxseSB0ZXJtaW5hdGVkIGJ5IFRlbXBvcmFsIHNlcnZpY2UuIERvIG5vdCByZWx5IG9uIGV4ZWN1dGlvbiB0aW1lb3V0IGZvciBidXNpbmVzc1xuICAgKiBsZXZlbCB0aW1lb3V0cy4gSXQgaXMgcHJlZmVycmVkIHRvIHVzZSBpbiB3b3JrZmxvdyB0aW1lcnMgZm9yIHRoaXMgcHVycG9zZS5cbiAgICpcbiAgICogQGZvcm1hdCBudW1iZXIgb2YgbWlsbGlzZWNvbmRzIG9yIHtAbGluayBodHRwczovL3d3dy5ucG1qcy5jb20vcGFja2FnZS9tcyB8IG1zLWZvcm1hdHRlZCBzdHJpbmd9XG4gICAqL1xuICB3b3JrZmxvd0V4ZWN1dGlvblRpbWVvdXQ/OiBEdXJhdGlvbjtcblxuICAvKipcbiAgICogTWF4aW11bSBleGVjdXRpb24gdGltZSBvZiBhIHNpbmdsZSB3b3JrZmxvdyB0YXNrLiBEZWZhdWx0IGlzIDEwIHNlY29uZHMuXG4gICAqXG4gICAqIEBmb3JtYXQgbnVtYmVyIG9mIG1pbGxpc2Vjb25kcyBvciB7QGxpbmsgaHR0cHM6Ly93d3cubnBtanMuY29tL3BhY2thZ2UvbXMgfCBtcy1mb3JtYXR0ZWQgc3RyaW5nfVxuICAgKi9cbiAgd29ya2Zsb3dUYXNrVGltZW91dD86IER1cmF0aW9uO1xufVxuXG5leHBvcnQgdHlwZSBDb21tb25Xb3JrZmxvd09wdGlvbnMgPSBCYXNlV29ya2Zsb3dPcHRpb25zICYgV29ya2Zsb3dEdXJhdGlvbk9wdGlvbnM7XG5cbmV4cG9ydCBmdW5jdGlvbiBleHRyYWN0V29ya2Zsb3dUeXBlPFQgZXh0ZW5kcyBXb3JrZmxvdz4od29ya2Zsb3dUeXBlT3JGdW5jOiBzdHJpbmcgfCBUKTogc3RyaW5nIHtcbiAgaWYgKHR5cGVvZiB3b3JrZmxvd1R5cGVPckZ1bmMgPT09ICdzdHJpbmcnKSByZXR1cm4gd29ya2Zsb3dUeXBlT3JGdW5jIGFzIHN0cmluZztcbiAgaWYgKHR5cGVvZiB3b3JrZmxvd1R5cGVPckZ1bmMgPT09ICdmdW5jdGlvbicpIHtcbiAgICBpZiAod29ya2Zsb3dUeXBlT3JGdW5jPy5uYW1lKSByZXR1cm4gd29ya2Zsb3dUeXBlT3JGdW5jLm5hbWU7XG4gICAgdGhyb3cgbmV3IFR5cGVFcnJvcignSW52YWxpZCB3b3JrZmxvdyB0eXBlOiB0aGUgd29ya2Zsb3cgZnVuY3Rpb24gaXMgYW5vbnltb3VzJyk7XG4gIH1cbiAgdGhyb3cgbmV3IFR5cGVFcnJvcihcbiAgICBgSW52YWxpZCB3b3JrZmxvdyB0eXBlOiBleHBlY3RlZCBlaXRoZXIgYSBzdHJpbmcgb3IgYSBmdW5jdGlvbiwgZ290ICcke3R5cGVvZiB3b3JrZmxvd1R5cGVPckZ1bmN9J2BcbiAgKTtcbn1cbiIsIi8vIEEgcG9ydCBvZiBhbiBhbGdvcml0aG0gYnkgSm9oYW5uZXMgQmFhZ8O4ZSA8YmFhZ29lQGJhYWdvZS5jb20+LCAyMDEwXG4vLyBodHRwOi8vYmFhZ29lLmNvbS9lbi9SYW5kb21NdXNpbmdzL2phdmFzY3JpcHQvXG4vLyBodHRwczovL2dpdGh1Yi5jb20vbnF1aW5sYW4vYmV0dGVyLXJhbmRvbS1udW1iZXJzLWZvci1qYXZhc2NyaXB0LW1pcnJvclxuLy8gT3JpZ2luYWwgd29yayBpcyB1bmRlciBNSVQgbGljZW5zZSAtXG5cbi8vIENvcHlyaWdodCAoQykgMjAxMCBieSBKb2hhbm5lcyBCYWFnw7hlIDxiYWFnb2VAYmFhZ29lLm9yZz5cbi8vXG4vLyBQZXJtaXNzaW9uIGlzIGhlcmVieSBncmFudGVkLCBmcmVlIG9mIGNoYXJnZSwgdG8gYW55IHBlcnNvbiBvYnRhaW5pbmcgYSBjb3B5XG4vLyBvZiB0aGlzIHNvZnR3YXJlIGFuZCBhc3NvY2lhdGVkIGRvY3VtZW50YXRpb24gZmlsZXMgKHRoZSBcIlNvZnR3YXJlXCIpLCB0byBkZWFsXG4vLyBpbiB0aGUgU29mdHdhcmUgd2l0aG91dCByZXN0cmljdGlvbiwgaW5jbHVkaW5nIHdpdGhvdXQgbGltaXRhdGlvbiB0aGUgcmlnaHRzXG4vLyB0byB1c2UsIGNvcHksIG1vZGlmeSwgbWVyZ2UsIHB1Ymxpc2gsIGRpc3RyaWJ1dGUsIHN1YmxpY2Vuc2UsIGFuZC9vciBzZWxsXG4vLyBjb3BpZXMgb2YgdGhlIFNvZnR3YXJlLCBhbmQgdG8gcGVybWl0IHBlcnNvbnMgdG8gd2hvbSB0aGUgU29mdHdhcmUgaXNcbi8vIGZ1cm5pc2hlZCB0byBkbyBzbywgc3ViamVjdCB0byB0aGUgZm9sbG93aW5nIGNvbmRpdGlvbnM6XG4vL1xuLy8gVGhlIGFib3ZlIGNvcHlyaWdodCBub3RpY2UgYW5kIHRoaXMgcGVybWlzc2lvbiBub3RpY2Ugc2hhbGwgYmUgaW5jbHVkZWQgaW5cbi8vIGFsbCBjb3BpZXMgb3Igc3Vic3RhbnRpYWwgcG9ydGlvbnMgb2YgdGhlIFNvZnR3YXJlLlxuLy9cbi8vIFRIRSBTT0ZUV0FSRSBJUyBQUk9WSURFRCBcIkFTIElTXCIsIFdJVEhPVVQgV0FSUkFOVFkgT0YgQU5ZIEtJTkQsIEVYUFJFU1MgT1Jcbi8vIElNUExJRUQsIElOQ0xVRElORyBCVVQgTk9UIExJTUlURUQgVE8gVEhFIFdBUlJBTlRJRVMgT0YgTUVSQ0hBTlRBQklMSVRZLFxuLy8gRklUTkVTUyBGT1IgQSBQQVJUSUNVTEFSIFBVUlBPU0UgQU5EIE5PTklORlJJTkdFTUVOVC4gSU4gTk8gRVZFTlQgU0hBTEwgVEhFXG4vLyBBVVRIT1JTIE9SIENPUFlSSUdIVCBIT0xERVJTIEJFIExJQUJMRSBGT1IgQU5ZIENMQUlNLCBEQU1BR0VTIE9SIE9USEVSXG4vLyBMSUFCSUxJVFksIFdIRVRIRVIgSU4gQU4gQUNUSU9OIE9GIENPTlRSQUNULCBUT1JUIE9SIE9USEVSV0lTRSwgQVJJU0lORyBGUk9NLFxuLy8gT1VUIE9GIE9SIElOIENPTk5FQ1RJT04gV0lUSCBUSEUgU09GVFdBUkUgT1IgVEhFIFVTRSBPUiBPVEhFUiBERUFMSU5HUyBJTlxuLy8gVEhFIFNPRlRXQVJFLlxuXG4vLyBUYWtlbiBhbmQgbW9kaWZpZWQgZnJvbSBodHRwczovL2dpdGh1Yi5jb20vZGF2aWRiYXUvc2VlZHJhbmRvbS9ibG9iL3JlbGVhc2VkL2xpYi9hbGVhLmpzXG5cbmNsYXNzIEFsZWEge1xuICBwdWJsaWMgYzogbnVtYmVyO1xuICBwdWJsaWMgczA6IG51bWJlcjtcbiAgcHVibGljIHMxOiBudW1iZXI7XG4gIHB1YmxpYyBzMjogbnVtYmVyO1xuXG4gIGNvbnN0cnVjdG9yKHNlZWQ6IG51bWJlcltdKSB7XG4gICAgY29uc3QgbWFzaCA9IG5ldyBNYXNoKCk7XG4gICAgLy8gQXBwbHkgdGhlIHNlZWRpbmcgYWxnb3JpdGhtIGZyb20gQmFhZ29lLlxuICAgIHRoaXMuYyA9IDE7XG4gICAgdGhpcy5zMCA9IG1hc2gubWFzaChbMzJdKTtcbiAgICB0aGlzLnMxID0gbWFzaC5tYXNoKFszMl0pO1xuICAgIHRoaXMuczIgPSBtYXNoLm1hc2goWzMyXSk7XG4gICAgdGhpcy5zMCAtPSBtYXNoLm1hc2goc2VlZCk7XG4gICAgaWYgKHRoaXMuczAgPCAwKSB7XG4gICAgICB0aGlzLnMwICs9IDE7XG4gICAgfVxuICAgIHRoaXMuczEgLT0gbWFzaC5tYXNoKHNlZWQpO1xuICAgIGlmICh0aGlzLnMxIDwgMCkge1xuICAgICAgdGhpcy5zMSArPSAxO1xuICAgIH1cbiAgICB0aGlzLnMyIC09IG1hc2gubWFzaChzZWVkKTtcbiAgICBpZiAodGhpcy5zMiA8IDApIHtcbiAgICAgIHRoaXMuczIgKz0gMTtcbiAgICB9XG4gIH1cblxuICBwdWJsaWMgbmV4dCgpOiBudW1iZXIge1xuICAgIGNvbnN0IHQgPSAyMDkxNjM5ICogdGhpcy5zMCArIHRoaXMuYyAqIDIuMzI4MzA2NDM2NTM4Njk2M2UtMTA7IC8vIDJeLTMyXG4gICAgdGhpcy5zMCA9IHRoaXMuczE7XG4gICAgdGhpcy5zMSA9IHRoaXMuczI7XG4gICAgcmV0dXJuICh0aGlzLnMyID0gdCAtICh0aGlzLmMgPSB0IHwgMCkpO1xuICB9XG59XG5cbmV4cG9ydCB0eXBlIFJORyA9ICgpID0+IG51bWJlcjtcblxuZXhwb3J0IGZ1bmN0aW9uIGFsZWEoc2VlZDogbnVtYmVyW10pOiBSTkcge1xuICBjb25zdCB4ZyA9IG5ldyBBbGVhKHNlZWQpO1xuICByZXR1cm4geGcubmV4dC5iaW5kKHhnKTtcbn1cblxuZXhwb3J0IGNsYXNzIE1hc2gge1xuICBwcml2YXRlIG4gPSAweGVmYzgyNDlkO1xuXG4gIHB1YmxpYyBtYXNoKGRhdGE6IG51bWJlcltdKTogbnVtYmVyIHtcbiAgICBsZXQgeyBuIH0gPSB0aGlzO1xuICAgIGZvciAobGV0IGkgPSAwOyBpIDwgZGF0YS5sZW5ndGg7IGkrKykge1xuICAgICAgbiArPSBkYXRhW2ldO1xuICAgICAgbGV0IGggPSAwLjAyNTE5NjAzMjgyNDE2OTM4ICogbjtcbiAgICAgIG4gPSBoID4+PiAwO1xuICAgICAgaCAtPSBuO1xuICAgICAgaCAqPSBuO1xuICAgICAgbiA9IGggPj4+IDA7XG4gICAgICBoIC09IG47XG4gICAgICBuICs9IGggKiAweDEwMDAwMDAwMDsgLy8gMl4zMlxuICAgIH1cbiAgICB0aGlzLm4gPSBuO1xuICAgIHJldHVybiAobiA+Pj4gMCkgKiAyLjMyODMwNjQzNjUzODY5NjNlLTEwOyAvLyAyXi0zMlxuICB9XG59XG4iLCJpbXBvcnQgdHlwZSB7IEFzeW5jTG9jYWxTdG9yYWdlIGFzIEFMUyB9IGZyb20gJ25vZGU6YXN5bmNfaG9va3MnO1xuaW1wb3J0IHsgQ2FuY2VsbGVkRmFpbHVyZSwgRHVyYXRpb24sIElsbGVnYWxTdGF0ZUVycm9yIH0gZnJvbSAnQHRlbXBvcmFsaW8vY29tbW9uJztcbmltcG9ydCB7IHVudHJhY2tQcm9taXNlIH0gZnJvbSAnLi9zdGFjay1oZWxwZXJzJztcblxuLy8gQXN5bmNMb2NhbFN0b3JhZ2UgaXMgaW5qZWN0ZWQgdmlhIHZtIG1vZHVsZSBpbnRvIGdsb2JhbCBzY29wZS5cbi8vIEluIGNhc2UgV29ya2Zsb3cgY29kZSBpcyBpbXBvcnRlZCBpbiBOb2RlLmpzIGNvbnRleHQsIHJlcGxhY2Ugd2l0aCBhbiBlbXB0eSBjbGFzcy5cbmV4cG9ydCBjb25zdCBBc3luY0xvY2FsU3RvcmFnZTogbmV3IDxUPigpID0+IEFMUzxUPiA9IChnbG9iYWxUaGlzIGFzIGFueSkuQXN5bmNMb2NhbFN0b3JhZ2UgPz8gY2xhc3Mge307XG5cbi8qKiBNYWdpYyBzeW1ib2wgdXNlZCB0byBjcmVhdGUgdGhlIHJvb3Qgc2NvcGUgLSBpbnRlbnRpb25hbGx5IG5vdCBleHBvcnRlZCAqL1xuY29uc3QgTk9fUEFSRU5UID0gU3ltYm9sKCdOT19QQVJFTlQnKTtcblxuLyoqXG4gKiBPcHRpb24gZm9yIGNvbnN0cnVjdGluZyBhIENhbmNlbGxhdGlvblNjb3BlXG4gKi9cbmV4cG9ydCBpbnRlcmZhY2UgQ2FuY2VsbGF0aW9uU2NvcGVPcHRpb25zIHtcbiAgLyoqXG4gICAqIFRpbWUgaW4gbWlsbGlzZWNvbmRzIGJlZm9yZSB0aGUgc2NvcGUgY2FuY2VsbGF0aW9uIGlzIGF1dG9tYXRpY2FsbHkgcmVxdWVzdGVkXG4gICAqL1xuICB0aW1lb3V0PzogbnVtYmVyO1xuXG4gIC8qKlxuICAgKiBJZiBmYWxzZSwgcHJldmVudCBvdXRlciBjYW5jZWxsYXRpb24gZnJvbSBwcm9wYWdhdGluZyB0byBpbm5lciBzY29wZXMsIEFjdGl2aXRpZXMsIHRpbWVycywgYW5kIFRyaWdnZXJzLCBkZWZhdWx0cyB0byB0cnVlLlxuICAgKiAoU2NvcGUgc3RpbGwgcHJvcGFnYXRlcyBDYW5jZWxsZWRGYWlsdXJlIHRocm93biBmcm9tIHdpdGhpbikuXG4gICAqL1xuICBjYW5jZWxsYWJsZTogYm9vbGVhbjtcbiAgLyoqXG4gICAqIEFuIG9wdGlvbmFsIENhbmNlbGxhdGlvblNjb3BlICh1c2VmdWwgZm9yIHJ1bm5pbmcgYmFja2dyb3VuZCB0YXNrcykuXG4gICAqIFRoZSBgTk9fUEFSRU5UYCBzeW1ib2wgaXMgcmVzZXJ2ZWQgZm9yIHRoZSByb290IHNjb3BlLlxuICAgKi9cbiAgcGFyZW50PzogQ2FuY2VsbGF0aW9uU2NvcGUgfCB0eXBlb2YgTk9fUEFSRU5UO1xufVxuXG4vKipcbiAqIEluIHRoZSBTREssIFdvcmtmbG93cyBhcmUgcmVwcmVzZW50ZWQgaW50ZXJuYWxseSBieSBhIHRyZWUgb2Ygc2NvcGVzIHdoZXJlIHRoZSBgZXhlY3V0ZWAgZnVuY3Rpb24gcnVucyBpbiB0aGUgcm9vdCBzY29wZS5cbiAqIENhbmNlbGxhdGlvbiBwcm9wYWdhdGVzIGZyb20gb3V0ZXIgc2NvcGVzIHRvIGlubmVyIG9uZXMgYW5kIGlzIGhhbmRsZWQgYnkgY2F0Y2hpbmcge0BsaW5rIENhbmNlbGxlZEZhaWx1cmV9c1xuICogdGhyb3duIGJ5IGNhbmNlbGxhYmxlIG9wZXJhdGlvbnMgKHNlZSBiZWxvdykuXG4gKlxuICogU2NvcGVzIGFyZSBjcmVhdGVkIHVzaW5nIHRoZSBgQ2FuY2VsbGF0aW9uU2NvcGVgIGNvbnN0cnVjdG9yIG9yIHRoZSBzdGF0aWMgaGVscGVyIG1ldGhvZHNcbiAqIHtAbGluayBjYW5jZWxsYWJsZX0sIHtAbGluayBub25DYW5jZWxsYWJsZX0gYW5kIHtAbGluayB3aXRoVGltZW91dH0uXG4gKlxuICogV2hlbiBhIGBDYW5jZWxsYXRpb25TY29wZWAgaXMgY2FuY2VsbGVkLCBpdCB3aWxsIHByb3BhZ2F0ZSBjYW5jZWxsYXRpb24gYW55IGNoaWxkIHNjb3BlcyBhbmQgYW55IGNhbmNlbGxhYmxlXG4gKiBvcGVyYXRpb25zIGNyZWF0ZWQgd2l0aGluIGl0LCBzdWNoIGFzOlxuICpcbiAqIC0gQWN0aXZpdGllc1xuICogLSBDaGlsZCBXb3JrZmxvd3NcbiAqIC0gVGltZXJzIChjcmVhdGVkIHdpdGggdGhlIHtAbGluayBzbGVlcH0gZnVuY3Rpb24pXG4gKiAtIHtAbGluayBUcmlnZ2VyfXNcbiAqXG4gKiBAZXhhbXBsZVxuICpcbiAqIGBgYHRzXG4gKiBhd2FpdCBDYW5jZWxsYXRpb25TY29wZS5jYW5jZWxsYWJsZShhc3luYyAoKSA9PiB7XG4gKiAgIGNvbnN0IHByb21pc2UgPSBzb21lQWN0aXZpdHkoKTtcbiAqICAgQ2FuY2VsbGF0aW9uU2NvcGUuY3VycmVudCgpLmNhbmNlbCgpOyAvLyBDYW5jZWxzIHRoZSBhY3Rpdml0eVxuICogICBhd2FpdCBwcm9taXNlOyAvLyBUaHJvd3MgYEFjdGl2aXR5RmFpbHVyZWAgd2l0aCBgY2F1c2VgIHNldCB0byBgQ2FuY2VsbGVkRmFpbHVyZWBcbiAqIH0pO1xuICogYGBgXG4gKlxuICogQGV4YW1wbGVcbiAqXG4gKiBgYGB0c1xuICogY29uc3Qgc2NvcGUgPSBuZXcgQ2FuY2VsbGF0aW9uU2NvcGUoKTtcbiAqIGNvbnN0IHByb21pc2UgPSBzY29wZS5ydW4oc29tZUFjdGl2aXR5KTtcbiAqIHNjb3BlLmNhbmNlbCgpOyAvLyBDYW5jZWxzIHRoZSBhY3Rpdml0eVxuICogYXdhaXQgcHJvbWlzZTsgLy8gVGhyb3dzIGBBY3Rpdml0eUZhaWx1cmVgIHdpdGggYGNhdXNlYCBzZXQgdG8gYENhbmNlbGxlZEZhaWx1cmVgXG4gKiBgYGBcbiAqL1xuZXhwb3J0IGNsYXNzIENhbmNlbGxhdGlvblNjb3BlIHtcbiAgLyoqXG4gICAqIFRpbWUgaW4gbWlsbGlzZWNvbmRzIGJlZm9yZSB0aGUgc2NvcGUgY2FuY2VsbGF0aW9uIGlzIGF1dG9tYXRpY2FsbHkgcmVxdWVzdGVkXG4gICAqL1xuICBwcm90ZWN0ZWQgcmVhZG9ubHkgdGltZW91dD86IG51bWJlcjtcblxuICAvKipcbiAgICogSWYgZmFsc2UsIHByZXZlbnQgb3V0ZXIgY2FuY2VsbGF0aW9uIGZyb20gcHJvcGFnYXRpbmcgdG8gaW5uZXIgc2NvcGVzLCBBY3Rpdml0aWVzLCB0aW1lcnMsIGFuZCBUcmlnZ2VycywgZGVmYXVsdHMgdG8gdHJ1ZS5cbiAgICogKFNjb3BlIHN0aWxsIHByb3BhZ2F0ZXMgQ2FuY2VsbGVkRmFpbHVyZSB0aHJvd24gZnJvbSB3aXRoaW4pXG4gICAqL1xuICBwdWJsaWMgcmVhZG9ubHkgY2FuY2VsbGFibGU6IGJvb2xlYW47XG4gIC8qKlxuICAgKiBBbiBvcHRpb25hbCBDYW5jZWxsYXRpb25TY29wZSAodXNlZnVsIGZvciBydW5uaW5nIGJhY2tncm91bmQgdGFza3MpLCBkZWZhdWx0cyB0byB7QGxpbmsgQ2FuY2VsbGF0aW9uU2NvcGUuY3VycmVudH0oKVxuICAgKi9cbiAgcHVibGljIHJlYWRvbmx5IHBhcmVudD86IENhbmNlbGxhdGlvblNjb3BlO1xuXG4gIC8qKlxuICAgKiBSZWplY3RlZCB3aGVuIHNjb3BlIGNhbmNlbGxhdGlvbiBpcyByZXF1ZXN0ZWRcbiAgICovXG4gIHB1YmxpYyByZWFkb25seSBjYW5jZWxSZXF1ZXN0ZWQ6IFByb21pc2U8bmV2ZXI+O1xuXG4gICNjYW5jZWxSZXF1ZXN0ZWQgPSBmYWxzZTtcblxuICAvLyBUeXBlc2NyaXB0IGRvZXMgbm90IHVuZGVyc3RhbmQgdGhhdCB0aGUgUHJvbWlzZSBleGVjdXRvciBydW5zIHN5bmNocm9ub3VzbHkgaW4gdGhlIGNvbnN0cnVjdG9yXG4gIC8vIGVzbGludC1kaXNhYmxlLW5leHQtbGluZSBAdHlwZXNjcmlwdC1lc2xpbnQvYmFuLXRzLWNvbW1lbnRcbiAgLy8gQHRzLWlnbm9yZVxuICBwcm90ZWN0ZWQgcmVhZG9ubHkgcmVqZWN0OiAocmVhc29uPzogYW55KSA9PiB2b2lkO1xuXG4gIGNvbnN0cnVjdG9yKG9wdGlvbnM/OiBDYW5jZWxsYXRpb25TY29wZU9wdGlvbnMpIHtcbiAgICB0aGlzLnRpbWVvdXQgPSBvcHRpb25zPy50aW1lb3V0O1xuICAgIHRoaXMuY2FuY2VsbGFibGUgPSBvcHRpb25zPy5jYW5jZWxsYWJsZSA/PyB0cnVlO1xuICAgIHRoaXMuY2FuY2VsUmVxdWVzdGVkID0gbmV3IFByb21pc2UoKF8sIHJlamVjdCkgPT4ge1xuICAgICAgLy8gVHlwZXNjcmlwdCBkb2VzIG5vdCB1bmRlcnN0YW5kIHRoYXQgdGhlIFByb21pc2UgZXhlY3V0b3IgcnVucyBzeW5jaHJvbm91c2x5XG4gICAgICAvLyBlc2xpbnQtZGlzYWJsZS1uZXh0LWxpbmUgQHR5cGVzY3JpcHQtZXNsaW50L2Jhbi10cy1jb21tZW50XG4gICAgICAvLyBAdHMtaWdub3JlXG4gICAgICB0aGlzLnJlamVjdCA9IChlcnIpID0+IHtcbiAgICAgICAgdGhpcy4jY2FuY2VsUmVxdWVzdGVkID0gdHJ1ZTtcbiAgICAgICAgcmVqZWN0KGVycik7XG4gICAgICB9O1xuICAgIH0pO1xuICAgIHVudHJhY2tQcm9taXNlKHRoaXMuY2FuY2VsUmVxdWVzdGVkKTtcbiAgICAvLyBBdm9pZCB1bmhhbmRsZWQgcmVqZWN0aW9uc1xuICAgIHVudHJhY2tQcm9taXNlKHRoaXMuY2FuY2VsUmVxdWVzdGVkLmNhdGNoKCgpID0+IHVuZGVmaW5lZCkpO1xuICAgIGlmIChvcHRpb25zPy5wYXJlbnQgIT09IE5PX1BBUkVOVCkge1xuICAgICAgdGhpcy5wYXJlbnQgPSBvcHRpb25zPy5wYXJlbnQgfHwgQ2FuY2VsbGF0aW9uU2NvcGUuY3VycmVudCgpO1xuICAgICAgdGhpcy4jY2FuY2VsUmVxdWVzdGVkID0gdGhpcy5wYXJlbnQuI2NhbmNlbFJlcXVlc3RlZDtcbiAgICAgIHRoaXMucGFyZW50LmNhbmNlbFJlcXVlc3RlZC5jYXRjaCgoZXJyKSA9PiB7XG4gICAgICAgIHRoaXMucmVqZWN0KGVycik7XG4gICAgICB9KTtcbiAgICB9XG4gIH1cblxuICBwdWJsaWMgZ2V0IGNvbnNpZGVyZWRDYW5jZWxsZWQoKTogYm9vbGVhbiB7XG4gICAgcmV0dXJuIHRoaXMuI2NhbmNlbFJlcXVlc3RlZCAmJiB0aGlzLmNhbmNlbGxhYmxlO1xuICB9XG4gIC8qKlxuICAgKiBBY3RpdmF0ZSB0aGUgc2NvcGUgYXMgY3VycmVudCBhbmQgcnVuICBgZm5gXG4gICAqXG4gICAqIEFueSB0aW1lcnMsIEFjdGl2aXRpZXMsIFRyaWdnZXJzIGFuZCBDYW5jZWxsYXRpb25TY29wZXMgY3JlYXRlZCBpbiB0aGUgYm9keSBvZiBgZm5gXG4gICAqIGF1dG9tYXRpY2FsbHkgbGluayB0aGVpciBjYW5jZWxsYXRpb24gdG8gdGhpcyBzY29wZS5cbiAgICpcbiAgICogQHJldHVybiB0aGUgcmVzdWx0IG9mIGBmbmBcbiAgICovXG4gIHJ1bjxUPihmbjogKCkgPT4gUHJvbWlzZTxUPik6IFByb21pc2U8VD4ge1xuICAgIHJldHVybiBzdG9yYWdlLnJ1bih0aGlzLCB0aGlzLnJ1bkluQ29udGV4dC5iaW5kKHRoaXMsIGZuKSBhcyAoKSA9PiBQcm9taXNlPFQ+KTtcbiAgfVxuXG4gIC8qKlxuICAgKiBNZXRob2QgdGhhdCBydW5zIGEgZnVuY3Rpb24gaW4gQXN5bmNMb2NhbFN0b3JhZ2UgY29udGV4dC5cbiAgICpcbiAgICogQ291bGQgaGF2ZSBiZWVuIHdyaXR0ZW4gYXMgYW5vbnltb3VzIGZ1bmN0aW9uLCBtYWRlIGludG8gYSBtZXRob2QgZm9yIGltcHJvdmVkIHN0YWNrIHRyYWNlcy5cbiAgICovXG4gIHByb3RlY3RlZCBhc3luYyBydW5JbkNvbnRleHQ8VD4oZm46ICgpID0+IFByb21pc2U8VD4pOiBQcm9taXNlPFQ+IHtcbiAgICBpZiAodGhpcy50aW1lb3V0KSB7XG4gICAgICB1bnRyYWNrUHJvbWlzZShcbiAgICAgICAgc2xlZXAodGhpcy50aW1lb3V0KS50aGVuKFxuICAgICAgICAgICgpID0+IHRoaXMuY2FuY2VsKCksXG4gICAgICAgICAgKCkgPT4ge1xuICAgICAgICAgICAgLy8gc2NvcGUgd2FzIGFscmVhZHkgY2FuY2VsbGVkLCBpZ25vcmVcbiAgICAgICAgICB9XG4gICAgICAgIClcbiAgICAgICk7XG4gICAgfVxuICAgIHJldHVybiBhd2FpdCBmbigpO1xuICB9XG5cbiAgLyoqXG4gICAqIFJlcXVlc3QgdG8gY2FuY2VsIHRoZSBzY29wZSBhbmQgbGlua2VkIGNoaWxkcmVuXG4gICAqL1xuICBjYW5jZWwoKTogdm9pZCB7XG4gICAgdGhpcy5yZWplY3QobmV3IENhbmNlbGxlZEZhaWx1cmUoJ0NhbmNlbGxhdGlvbiBzY29wZSBjYW5jZWxsZWQnKSk7XG4gIH1cblxuICAvKipcbiAgICogR2V0IHRoZSBjdXJyZW50IFwiYWN0aXZlXCIgc2NvcGVcbiAgICovXG4gIHN0YXRpYyBjdXJyZW50KCk6IENhbmNlbGxhdGlvblNjb3BlIHtcbiAgICAvLyBVc2luZyBnbG9iYWxzIGRpcmVjdGx5IGluc3RlYWQgb2YgYSBoZWxwZXIgZnVuY3Rpb24gdG8gYXZvaWQgY2lyY3VsYXIgaW1wb3J0XG4gICAgcmV0dXJuIHN0b3JhZ2UuZ2V0U3RvcmUoKSA/PyAoZ2xvYmFsVGhpcyBhcyBhbnkpLl9fVEVNUE9SQUxfQUNUSVZBVE9SX18ucm9vdFNjb3BlO1xuICB9XG5cbiAgLyoqIEFsaWFzIHRvIGBuZXcgQ2FuY2VsbGF0aW9uU2NvcGUoeyBjYW5jZWxsYWJsZTogdHJ1ZSB9KS5ydW4oZm4pYCAqL1xuICBzdGF0aWMgY2FuY2VsbGFibGU8VD4oZm46ICgpID0+IFByb21pc2U8VD4pOiBQcm9taXNlPFQ+IHtcbiAgICByZXR1cm4gbmV3IHRoaXMoeyBjYW5jZWxsYWJsZTogdHJ1ZSB9KS5ydW4oZm4pO1xuICB9XG5cbiAgLyoqIEFsaWFzIHRvIGBuZXcgQ2FuY2VsbGF0aW9uU2NvcGUoeyBjYW5jZWxsYWJsZTogZmFsc2UgfSkucnVuKGZuKWAgKi9cbiAgc3RhdGljIG5vbkNhbmNlbGxhYmxlPFQ+KGZuOiAoKSA9PiBQcm9taXNlPFQ+KTogUHJvbWlzZTxUPiB7XG4gICAgcmV0dXJuIG5ldyB0aGlzKHsgY2FuY2VsbGFibGU6IGZhbHNlIH0pLnJ1bihmbik7XG4gIH1cblxuICAvKiogQWxpYXMgdG8gYG5ldyBDYW5jZWxsYXRpb25TY29wZSh7IGNhbmNlbGxhYmxlOiB0cnVlLCB0aW1lb3V0IH0pLnJ1bihmbilgICovXG4gIHN0YXRpYyB3aXRoVGltZW91dDxUPih0aW1lb3V0OiBudW1iZXIsIGZuOiAoKSA9PiBQcm9taXNlPFQ+KTogUHJvbWlzZTxUPiB7XG4gICAgcmV0dXJuIG5ldyB0aGlzKHsgY2FuY2VsbGFibGU6IHRydWUsIHRpbWVvdXQgfSkucnVuKGZuKTtcbiAgfVxufVxuXG5jb25zdCBzdG9yYWdlID0gbmV3IEFzeW5jTG9jYWxTdG9yYWdlPENhbmNlbGxhdGlvblNjb3BlPigpO1xuXG4vKipcbiAqIEF2b2lkIGV4cG9zaW5nIHRoZSBzdG9yYWdlIGRpcmVjdGx5IHNvIGl0IGRvZXNuJ3QgZ2V0IGZyb3plblxuICovXG5leHBvcnQgZnVuY3Rpb24gZGlzYWJsZVN0b3JhZ2UoKTogdm9pZCB7XG4gIHN0b3JhZ2UuZGlzYWJsZSgpO1xufVxuXG5leHBvcnQgY2xhc3MgUm9vdENhbmNlbGxhdGlvblNjb3BlIGV4dGVuZHMgQ2FuY2VsbGF0aW9uU2NvcGUge1xuICBjb25zdHJ1Y3RvcigpIHtcbiAgICBzdXBlcih7IGNhbmNlbGxhYmxlOiB0cnVlLCBwYXJlbnQ6IE5PX1BBUkVOVCB9KTtcbiAgfVxuXG4gIGNhbmNlbCgpOiB2b2lkIHtcbiAgICB0aGlzLnJlamVjdChuZXcgQ2FuY2VsbGVkRmFpbHVyZSgnV29ya2Zsb3cgY2FuY2VsbGVkJykpO1xuICB9XG59XG5cbi8qKiBUaGlzIGZ1bmN0aW9uIGlzIGhlcmUgdG8gYXZvaWQgYSBjaXJjdWxhciBkZXBlbmRlbmN5IGJldHdlZW4gdGhpcyBtb2R1bGUgYW5kIHdvcmtmbG93LnRzICovXG5sZXQgc2xlZXAgPSAoXzogRHVyYXRpb24pOiBQcm9taXNlPHZvaWQ+ID0+IHtcbiAgdGhyb3cgbmV3IElsbGVnYWxTdGF0ZUVycm9yKCdXb3JrZmxvdyBoYXMgbm90IGJlZW4gcHJvcGVybHkgaW5pdGlhbGl6ZWQnKTtcbn07XG5cbmV4cG9ydCBmdW5jdGlvbiByZWdpc3RlclNsZWVwSW1wbGVtZW50YXRpb24oZm46IHR5cGVvZiBzbGVlcCk6IHZvaWQge1xuICBzbGVlcCA9IGZuO1xufVxuIiwiaW1wb3J0IHsgQWN0aXZpdHlGYWlsdXJlLCBDYW5jZWxsZWRGYWlsdXJlLCBDaGlsZFdvcmtmbG93RmFpbHVyZSB9IGZyb20gJ0B0ZW1wb3JhbGlvL2NvbW1vbic7XG5pbXBvcnQgeyBTeW1ib2xCYXNlZEluc3RhbmNlT2ZFcnJvciB9IGZyb20gJ0B0ZW1wb3JhbGlvL2NvbW1vbi9saWIvdHlwZS1oZWxwZXJzJztcbmltcG9ydCB7IGNvcmVzZGsgfSBmcm9tICdAdGVtcG9yYWxpby9wcm90byc7XG5cbi8qKlxuICogQmFzZSBjbGFzcyBmb3IgYWxsIHdvcmtmbG93IGVycm9yc1xuICovXG5AU3ltYm9sQmFzZWRJbnN0YW5jZU9mRXJyb3IoJ1dvcmtmbG93RXJyb3InKVxuZXhwb3J0IGNsYXNzIFdvcmtmbG93RXJyb3IgZXh0ZW5kcyBFcnJvciB7fVxuXG4vKipcbiAqIFRocm93biBpbiB3b3JrZmxvdyB3aGVuIGl0IHRyaWVzIHRvIGRvIHNvbWV0aGluZyB0aGF0IG5vbi1kZXRlcm1pbmlzdGljIHN1Y2ggYXMgY29uc3RydWN0IGEgV2Vha1JlZigpXG4gKi9cbkBTeW1ib2xCYXNlZEluc3RhbmNlT2ZFcnJvcignRGV0ZXJtaW5pc21WaW9sYXRpb25FcnJvcicpXG5leHBvcnQgY2xhc3MgRGV0ZXJtaW5pc21WaW9sYXRpb25FcnJvciBleHRlbmRzIFdvcmtmbG93RXJyb3Ige31cblxuLyoqXG4gKiBBIGNsYXNzIHRoYXQgYWN0cyBhcyBhIG1hcmtlciBmb3IgdGhpcyBzcGVjaWFsIHJlc3VsdCB0eXBlXG4gKi9cbkBTeW1ib2xCYXNlZEluc3RhbmNlT2ZFcnJvcignTG9jYWxBY3Rpdml0eURvQmFja29mZicpXG5leHBvcnQgY2xhc3MgTG9jYWxBY3Rpdml0eURvQmFja29mZiBleHRlbmRzIEVycm9yIHtcbiAgY29uc3RydWN0b3IocHVibGljIHJlYWRvbmx5IGJhY2tvZmY6IGNvcmVzZGsuYWN0aXZpdHlfcmVzdWx0LklEb0JhY2tvZmYpIHtcbiAgICBzdXBlcigpO1xuICB9XG59XG5cbi8qKlxuICogUmV0dXJucyB3aGV0aGVyIHByb3ZpZGVkIGBlcnJgIGlzIGNhdXNlZCBieSBjYW5jZWxsYXRpb25cbiAqL1xuZXhwb3J0IGZ1bmN0aW9uIGlzQ2FuY2VsbGF0aW9uKGVycjogdW5rbm93bik6IGJvb2xlYW4ge1xuICByZXR1cm4gKFxuICAgIGVyciBpbnN0YW5jZW9mIENhbmNlbGxlZEZhaWx1cmUgfHxcbiAgICAoKGVyciBpbnN0YW5jZW9mIEFjdGl2aXR5RmFpbHVyZSB8fCBlcnIgaW5zdGFuY2VvZiBDaGlsZFdvcmtmbG93RmFpbHVyZSkgJiYgZXJyLmNhdXNlIGluc3RhbmNlb2YgQ2FuY2VsbGVkRmFpbHVyZSlcbiAgKTtcbn1cbiIsImltcG9ydCB7IElsbGVnYWxTdGF0ZUVycm9yIH0gZnJvbSAnQHRlbXBvcmFsaW8vY29tbW9uJztcbmltcG9ydCB7IHR5cGUgQWN0aXZhdG9yIH0gZnJvbSAnLi9pbnRlcm5hbHMnO1xuXG5leHBvcnQgZnVuY3Rpb24gbWF5YmVHZXRBY3RpdmF0b3JVbnR5cGVkKCk6IHVua25vd24ge1xuICByZXR1cm4gKGdsb2JhbFRoaXMgYXMgYW55KS5fX1RFTVBPUkFMX0FDVElWQVRPUl9fO1xufVxuXG5leHBvcnQgZnVuY3Rpb24gc2V0QWN0aXZhdG9yVW50eXBlZChhY3RpdmF0b3I6IHVua25vd24pOiB2b2lkIHtcbiAgKGdsb2JhbFRoaXMgYXMgYW55KS5fX1RFTVBPUkFMX0FDVElWQVRPUl9fID0gYWN0aXZhdG9yO1xufVxuXG5leHBvcnQgZnVuY3Rpb24gbWF5YmVHZXRBY3RpdmF0b3IoKTogQWN0aXZhdG9yIHwgdW5kZWZpbmVkIHtcbiAgcmV0dXJuIG1heWJlR2V0QWN0aXZhdG9yVW50eXBlZCgpIGFzIEFjdGl2YXRvciB8IHVuZGVmaW5lZDtcbn1cblxuZXhwb3J0IGZ1bmN0aW9uIGFzc2VydEluV29ya2Zsb3dDb250ZXh0KG1lc3NhZ2U6IHN0cmluZyk6IEFjdGl2YXRvciB7XG4gIGNvbnN0IGFjdGl2YXRvciA9IG1heWJlR2V0QWN0aXZhdG9yKCk7XG4gIGlmIChhY3RpdmF0b3IgPT0gbnVsbCkgdGhyb3cgbmV3IElsbGVnYWxTdGF0ZUVycm9yKG1lc3NhZ2UpO1xuICByZXR1cm4gYWN0aXZhdG9yO1xufVxuXG5leHBvcnQgZnVuY3Rpb24gZ2V0QWN0aXZhdG9yKCk6IEFjdGl2YXRvciB7XG4gIGNvbnN0IGFjdGl2YXRvciA9IG1heWJlR2V0QWN0aXZhdG9yKCk7XG4gIGlmIChhY3RpdmF0b3IgPT09IHVuZGVmaW5lZCkge1xuICAgIHRocm93IG5ldyBJbGxlZ2FsU3RhdGVFcnJvcignV29ya2Zsb3cgdW5pbml0aWFsaXplZCcpO1xuICB9XG4gIHJldHVybiBhY3RpdmF0b3I7XG59XG4iLCIvKipcbiAqIFRoaXMgbGlicmFyeSBwcm92aWRlcyB0b29scyByZXF1aXJlZCBmb3IgYXV0aG9yaW5nIHdvcmtmbG93cy5cbiAqXG4gKiAjIyBVc2FnZVxuICogU2VlIHRoZSB7QGxpbmsgaHR0cHM6Ly9kb2NzLnRlbXBvcmFsLmlvL3R5cGVzY3JpcHQvaGVsbG8td29ybGQjd29ya2Zsb3dzIHwgdHV0b3JpYWx9IGZvciB3cml0aW5nIHlvdXIgZmlyc3Qgd29ya2Zsb3cuXG4gKlxuICogIyMjIFRpbWVyc1xuICpcbiAqIFRoZSByZWNvbW1lbmRlZCB3YXkgb2Ygc2NoZWR1bGluZyB0aW1lcnMgaXMgYnkgdXNpbmcgdGhlIHtAbGluayBzbGVlcH0gZnVuY3Rpb24uIFdlJ3ZlIHJlcGxhY2VkIGBzZXRUaW1lb3V0YCBhbmRcbiAqIGBjbGVhclRpbWVvdXRgIHdpdGggZGV0ZXJtaW5pc3RpYyB2ZXJzaW9ucyBzbyB0aGVzZSBhcmUgYWxzbyB1c2FibGUgYnV0IGhhdmUgYSBsaW1pdGF0aW9uIHRoYXQgdGhleSBkb24ndCBwbGF5IHdlbGxcbiAqIHdpdGgge0BsaW5rIGh0dHBzOi8vZG9jcy50ZW1wb3JhbC5pby90eXBlc2NyaXB0L2NhbmNlbGxhdGlvbi1zY29wZXMgfCBjYW5jZWxsYXRpb24gc2NvcGVzfS5cbiAqXG4gKiA8IS0tU05JUFNUQVJUIHR5cGVzY3JpcHQtc2xlZXAtd29ya2Zsb3ctLT5cbiAqIDwhLS1TTklQRU5ELS0+XG4gKlxuICogIyMjIEFjdGl2aXRpZXNcbiAqXG4gKiBUbyBzY2hlZHVsZSBBY3Rpdml0aWVzLCB1c2Uge0BsaW5rIHByb3h5QWN0aXZpdGllc30gdG8gb2J0YWluIGFuIEFjdGl2aXR5IGZ1bmN0aW9uIGFuZCBjYWxsLlxuICpcbiAqIDwhLS1TTklQU1RBUlQgdHlwZXNjcmlwdC1zY2hlZHVsZS1hY3Rpdml0eS13b3JrZmxvdy0tPlxuICogPCEtLVNOSVBFTkQtLT5cbiAqXG4gKiAjIyMgVXBkYXRlcywgU2lnbmFscyBhbmQgUXVlcmllc1xuICpcbiAqIFVzZSB7QGxpbmsgc2V0SGFuZGxlcn0gdG8gc2V0IGhhbmRsZXJzIGZvciBVcGRhdGVzLCBTaWduYWxzLCBhbmQgUXVlcmllcy5cbiAqXG4gKiBVcGRhdGUgYW5kIFNpZ25hbCBoYW5kbGVycyBjYW4gYmUgZWl0aGVyIGFzeW5jIG9yIG5vbi1hc3luYyBmdW5jdGlvbnMuIFVwZGF0ZSBoYW5kbGVycyBtYXkgcmV0dXJuIGEgdmFsdWUsIGJ1dCBzaWduYWxcbiAqIGhhbmRsZXJzIG1heSBub3QgKHJldHVybiBgdm9pZGAgb3IgYFByb21pc2U8dm9pZD5gKS4gWW91IG1heSB1c2UgQWN0aXZpdGllcywgVGltZXJzLCBjaGlsZCBXb3JrZmxvd3MsIGV0YyBpbiBVcGRhdGVcbiAqIGFuZCBTaWduYWwgaGFuZGxlcnMsIGJ1dCB0aGlzIHNob3VsZCBiZSBkb25lIGNhdXRpb3VzbHk6IGZvciBleGFtcGxlLCBub3RlIHRoYXQgaWYgeW91IGF3YWl0IGFzeW5jIG9wZXJhdGlvbnMgc3VjaCBhc1xuICogdGhlc2UgaW4gYW4gVXBkYXRlIG9yIFNpZ25hbCBoYW5kbGVyLCB0aGVuIHlvdSBhcmUgcmVzcG9uc2libGUgZm9yIGVuc3VyaW5nIHRoYXQgdGhlIHdvcmtmbG93IGRvZXMgbm90IGNvbXBsZXRlIGZpcnN0LlxuICpcbiAqIFF1ZXJ5IGhhbmRsZXJzIG1heSAqKm5vdCoqIGJlIGFzeW5jIGZ1bmN0aW9ucywgYW5kIG1heSAqKm5vdCoqIG11dGF0ZSBhbnkgdmFyaWFibGVzIG9yIHVzZSBBY3Rpdml0aWVzLCBUaW1lcnMsXG4gKiBjaGlsZCBXb3JrZmxvd3MsIGV0Yy5cbiAqXG4gKiAjIyMjIEltcGxlbWVudGF0aW9uXG4gKlxuICogPCEtLVNOSVBTVEFSVCB0eXBlc2NyaXB0LXdvcmtmbG93LXVwZGF0ZS1zaWduYWwtcXVlcnktZXhhbXBsZS0tPlxuICogPCEtLVNOSVBFTkQtLT5cbiAqXG4gKiAjIyMgTW9yZVxuICpcbiAqIC0gW0RldGVybWluaXN0aWMgYnVpbHQtaW5zXShodHRwczovL2RvY3MudGVtcG9yYWwuaW8vdHlwZXNjcmlwdC9kZXRlcm1pbmlzbSNzb3VyY2VzLW9mLW5vbi1kZXRlcm1pbmlzbSlcbiAqIC0gW0NhbmNlbGxhdGlvbiBhbmQgc2NvcGVzXShodHRwczovL2RvY3MudGVtcG9yYWwuaW8vdHlwZXNjcmlwdC9jYW5jZWxsYXRpb24tc2NvcGVzKVxuICogICAtIHtAbGluayBDYW5jZWxsYXRpb25TY29wZX1cbiAqICAgLSB7QGxpbmsgVHJpZ2dlcn1cbiAqIC0gW1NpbmtzXShodHRwczovL2RvY3MudGVtcG9yYWwuaW8vYXBwbGljYXRpb24tZGV2ZWxvcG1lbnQvb2JzZXJ2YWJpbGl0eS8/bGFuZz10cyNsb2dnaW5nKVxuICogICAtIHtAbGluayBTaW5rc31cbiAqXG4gKiBAbW9kdWxlXG4gKi9cblxuZXhwb3J0IHtcbiAgQWN0aXZpdHlDYW5jZWxsYXRpb25UeXBlLFxuICBBY3Rpdml0eUZhaWx1cmUsXG4gIEFjdGl2aXR5T3B0aW9ucyxcbiAgQXBwbGljYXRpb25GYWlsdXJlLFxuICBDYW5jZWxsZWRGYWlsdXJlLFxuICBDaGlsZFdvcmtmbG93RmFpbHVyZSxcbiAgZGVmYXVsdFBheWxvYWRDb252ZXJ0ZXIsXG4gIFBheWxvYWRDb252ZXJ0ZXIsXG4gIFJldHJ5UG9saWN5LFxuICByb290Q2F1c2UsXG4gIFNlcnZlckZhaWx1cmUsXG4gIFRlbXBvcmFsRmFpbHVyZSxcbiAgVGVybWluYXRlZEZhaWx1cmUsXG4gIFRpbWVvdXRGYWlsdXJlLFxufSBmcm9tICdAdGVtcG9yYWxpby9jb21tb24nO1xuZXhwb3J0ICogZnJvbSAnQHRlbXBvcmFsaW8vY29tbW9uL2xpYi9lcnJvcnMnO1xuZXhwb3J0IHtcbiAgQWN0aXZpdHlGdW5jdGlvbixcbiAgQWN0aXZpdHlJbnRlcmZhY2UsIC8vIGVzbGludC1kaXNhYmxlLWxpbmUgZGVwcmVjYXRpb24vZGVwcmVjYXRpb25cbiAgUGF5bG9hZCxcbiAgUXVlcnlEZWZpbml0aW9uLFxuICBTZWFyY2hBdHRyaWJ1dGVzLFxuICBTZWFyY2hBdHRyaWJ1dGVWYWx1ZSxcbiAgU2lnbmFsRGVmaW5pdGlvbixcbiAgVW50eXBlZEFjdGl2aXRpZXMsXG4gIFdvcmtmbG93LFxuICBXb3JrZmxvd1F1ZXJ5VHlwZSxcbiAgV29ya2Zsb3dSZXN1bHRUeXBlLFxuICBXb3JrZmxvd1JldHVyblR5cGUsXG4gIFdvcmtmbG93U2lnbmFsVHlwZSxcbn0gZnJvbSAnQHRlbXBvcmFsaW8vY29tbW9uL2xpYi9pbnRlcmZhY2VzJztcbmV4cG9ydCAqIGZyb20gJ0B0ZW1wb3JhbGlvL2NvbW1vbi9saWIvd29ya2Zsb3ctaGFuZGxlJztcbmV4cG9ydCAqIGZyb20gJ0B0ZW1wb3JhbGlvL2NvbW1vbi9saWIvd29ya2Zsb3ctb3B0aW9ucyc7XG5leHBvcnQgeyBBc3luY0xvY2FsU3RvcmFnZSwgQ2FuY2VsbGF0aW9uU2NvcGUsIENhbmNlbGxhdGlvblNjb3BlT3B0aW9ucyB9IGZyb20gJy4vY2FuY2VsbGF0aW9uLXNjb3BlJztcbmV4cG9ydCAqIGZyb20gJy4vZXJyb3JzJztcbmV4cG9ydCAqIGZyb20gJy4vaW50ZXJjZXB0b3JzJztcbmV4cG9ydCB7XG4gIENoaWxkV29ya2Zsb3dDYW5jZWxsYXRpb25UeXBlLFxuICBDaGlsZFdvcmtmbG93T3B0aW9ucyxcbiAgQ29udGludWVBc05ldyxcbiAgQ29udGludWVBc05ld09wdGlvbnMsXG4gIEVuaGFuY2VkU3RhY2tUcmFjZSxcbiAgRmlsZUxvY2F0aW9uLFxuICBGaWxlU2xpY2UsXG4gIFBhcmVudENsb3NlUG9saWN5LFxuICBQYXJlbnRXb3JrZmxvd0luZm8sXG4gIFNES0luZm8sXG4gIFN0YWNrVHJhY2UsXG4gIFVuc2FmZVdvcmtmbG93SW5mbyxcbiAgV29ya2Zsb3dJbmZvLFxufSBmcm9tICcuL2ludGVyZmFjZXMnO1xuZXhwb3J0IHsgcHJveHlTaW5rcywgU2luaywgU2lua0NhbGwsIFNpbmtGdW5jdGlvbiwgU2lua3MgfSBmcm9tICcuL3NpbmtzJztcbmV4cG9ydCB7IGxvZyB9IGZyb20gJy4vbG9ncyc7XG5leHBvcnQgeyBUcmlnZ2VyIH0gZnJvbSAnLi90cmlnZ2VyJztcbmV4cG9ydCAqIGZyb20gJy4vd29ya2Zsb3cnO1xuZXhwb3J0IHsgQ2hpbGRXb3JrZmxvd0hhbmRsZSwgRXh0ZXJuYWxXb3JrZmxvd0hhbmRsZSB9IGZyb20gJy4vd29ya2Zsb3ctaGFuZGxlJztcblxuLy8gQW55dGhpbmcgYmVsb3cgdGhpcyBsaW5lIGlzIGRlcHJlY2F0ZWRcblxuZXhwb3J0IHtcbiAgLyoqXG4gICAqIEBkZXByZWNhdGVkIERvIG5vdCB1c2UgTG9nZ2VyU2lua3MgZGlyZWN0bHkuIFRvIGxvZyBmcm9tIFdvcmtmbG93IGNvZGUsIHVzZSB0aGUgYGxvZ2Agb2JqZWN0XG4gICAqICAgICAgICAgICAgIGV4cG9ydGVkIGJ5IHRoZSBgQHRlbXBvcmFsaW8vd29ya2Zsb3dgIHBhY2thZ2UuIFRvIGNhcHR1cmUgbG9nIG1lc3NhZ2VzIGVtaXR0ZWRcbiAgICogICAgICAgICAgICAgYnkgV29ya2Zsb3cgY29kZSwgc2V0IHRoZSB7QGxpbmsgUnVudGltZS5sb2dnZXJ9IHByb3BlcnR5LlxuICAgKi9cbiAgLy8gZXNsaW50LWRpc2FibGUtbmV4dC1saW5lIGRlcHJlY2F0aW9uL2RlcHJlY2F0aW9uXG4gIExvZ2dlclNpbmtzRGVwcmVjYXRlZCBhcyBMb2dnZXJTaW5rcyxcbn0gZnJvbSAnLi9sb2dzJztcbiIsIi8qKlxuICogVHlwZSBkZWZpbml0aW9ucyBhbmQgZ2VuZXJpYyBoZWxwZXJzIGZvciBpbnRlcmNlcHRvcnMuXG4gKlxuICogVGhlIFdvcmtmbG93IHNwZWNpZmljIGludGVyY2VwdG9ycyBhcmUgZGVmaW5lZCBoZXJlLlxuICpcbiAqIEBtb2R1bGVcbiAqL1xuXG5pbXBvcnQgeyBBY3Rpdml0eU9wdGlvbnMsIEhlYWRlcnMsIExvY2FsQWN0aXZpdHlPcHRpb25zLCBOZXh0LCBUaW1lc3RhbXAsIFdvcmtmbG93RXhlY3V0aW9uIH0gZnJvbSAnQHRlbXBvcmFsaW8vY29tbW9uJztcbmltcG9ydCB0eXBlIHsgY29yZXNkayB9IGZyb20gJ0B0ZW1wb3JhbGlvL3Byb3RvJztcbmltcG9ydCB7IENoaWxkV29ya2Zsb3dPcHRpb25zV2l0aERlZmF1bHRzLCBDb250aW51ZUFzTmV3T3B0aW9ucyB9IGZyb20gJy4vaW50ZXJmYWNlcyc7XG5cbmV4cG9ydCB7IE5leHQsIEhlYWRlcnMgfTtcblxuLyoqIElucHV0IGZvciBXb3JrZmxvd0luYm91bmRDYWxsc0ludGVyY2VwdG9yLmV4ZWN1dGUgKi9cbmV4cG9ydCBpbnRlcmZhY2UgV29ya2Zsb3dFeGVjdXRlSW5wdXQge1xuICByZWFkb25seSBhcmdzOiB1bmtub3duW107XG4gIHJlYWRvbmx5IGhlYWRlcnM6IEhlYWRlcnM7XG59XG5cbi8qKiBJbnB1dCBmb3IgV29ya2Zsb3dJbmJvdW5kQ2FsbHNJbnRlcmNlcHRvci5oYW5kbGVVcGRhdGUgYW5kXG4gKiBXb3JrZmxvd0luYm91bmRDYWxsc0ludGVyY2VwdG9yLnZhbGlkYXRlVXBkYXRlICovXG5leHBvcnQgaW50ZXJmYWNlIFVwZGF0ZUlucHV0IHtcbiAgcmVhZG9ubHkgdXBkYXRlSWQ6IHN0cmluZztcbiAgcmVhZG9ubHkgbmFtZTogc3RyaW5nO1xuICByZWFkb25seSBhcmdzOiB1bmtub3duW107XG4gIHJlYWRvbmx5IGhlYWRlcnM6IEhlYWRlcnM7XG59XG5cbi8qKiBJbnB1dCBmb3IgV29ya2Zsb3dJbmJvdW5kQ2FsbHNJbnRlcmNlcHRvci5oYW5kbGVTaWduYWwgKi9cbmV4cG9ydCBpbnRlcmZhY2UgU2lnbmFsSW5wdXQge1xuICByZWFkb25seSBzaWduYWxOYW1lOiBzdHJpbmc7XG4gIHJlYWRvbmx5IGFyZ3M6IHVua25vd25bXTtcbiAgcmVhZG9ubHkgaGVhZGVyczogSGVhZGVycztcbn1cblxuLyoqIElucHV0IGZvciBXb3JrZmxvd0luYm91bmRDYWxsc0ludGVyY2VwdG9yLmhhbmRsZVF1ZXJ5ICovXG5leHBvcnQgaW50ZXJmYWNlIFF1ZXJ5SW5wdXQge1xuICByZWFkb25seSBxdWVyeUlkOiBzdHJpbmc7XG4gIHJlYWRvbmx5IHF1ZXJ5TmFtZTogc3RyaW5nO1xuICByZWFkb25seSBhcmdzOiB1bmtub3duW107XG4gIHJlYWRvbmx5IGhlYWRlcnM6IEhlYWRlcnM7XG59XG5cbi8qKlxuICogSW1wbGVtZW50IGFueSBvZiB0aGVzZSBtZXRob2RzIHRvIGludGVyY2VwdCBXb3JrZmxvdyBpbmJvdW5kIGNhbGxzIGxpa2UgZXhlY3V0aW9uLCBhbmQgc2lnbmFsIGFuZCBxdWVyeSBoYW5kbGluZy5cbiAqL1xuZXhwb3J0IGludGVyZmFjZSBXb3JrZmxvd0luYm91bmRDYWxsc0ludGVyY2VwdG9yIHtcbiAgLyoqXG4gICAqIENhbGxlZCB3aGVuIFdvcmtmbG93IGV4ZWN1dGUgbWV0aG9kIGlzIGNhbGxlZFxuICAgKlxuICAgKiBAcmV0dXJuIHJlc3VsdCBvZiB0aGUgV29ya2Zsb3cgZXhlY3V0aW9uXG4gICAqL1xuICBleGVjdXRlPzogKGlucHV0OiBXb3JrZmxvd0V4ZWN1dGVJbnB1dCwgbmV4dDogTmV4dDx0aGlzLCAnZXhlY3V0ZSc+KSA9PiBQcm9taXNlPHVua25vd24+O1xuXG4gIC8qKiBDYWxsZWQgd2hlbiBVcGRhdGUgaGFuZGxlciBpcyBjYWxsZWRcbiAgICpcbiAgICogQHJldHVybiByZXN1bHQgb2YgdGhlIFVwZGF0ZVxuICAgKi9cbiAgaGFuZGxlVXBkYXRlPzogKGlucHV0OiBVcGRhdGVJbnB1dCwgbmV4dDogTmV4dDx0aGlzLCAnaGFuZGxlVXBkYXRlJz4pID0+IFByb21pc2U8dW5rbm93bj47XG5cbiAgLyoqIENhbGxlZCB3aGVuIHVwZGF0ZSB2YWxpZGF0b3IgY2FsbGVkICovXG4gIHZhbGlkYXRlVXBkYXRlPzogKGlucHV0OiBVcGRhdGVJbnB1dCwgbmV4dDogTmV4dDx0aGlzLCAndmFsaWRhdGVVcGRhdGUnPikgPT4gdm9pZDtcblxuICAvKiogQ2FsbGVkIHdoZW4gc2lnbmFsIGlzIGRlbGl2ZXJlZCB0byBhIFdvcmtmbG93IGV4ZWN1dGlvbiAqL1xuICBoYW5kbGVTaWduYWw/OiAoaW5wdXQ6IFNpZ25hbElucHV0LCBuZXh0OiBOZXh0PHRoaXMsICdoYW5kbGVTaWduYWwnPikgPT4gUHJvbWlzZTx2b2lkPjtcblxuICAvKipcbiAgICogQ2FsbGVkIHdoZW4gYSBXb3JrZmxvdyBpcyBxdWVyaWVkXG4gICAqXG4gICAqIEByZXR1cm4gcmVzdWx0IG9mIHRoZSBxdWVyeVxuICAgKi9cbiAgaGFuZGxlUXVlcnk/OiAoaW5wdXQ6IFF1ZXJ5SW5wdXQsIG5leHQ6IE5leHQ8dGhpcywgJ2hhbmRsZVF1ZXJ5Jz4pID0+IFByb21pc2U8dW5rbm93bj47XG59XG5cbi8qKiBJbnB1dCBmb3IgV29ya2Zsb3dPdXRib3VuZENhbGxzSW50ZXJjZXB0b3Iuc2NoZWR1bGVBY3Rpdml0eSAqL1xuZXhwb3J0IGludGVyZmFjZSBBY3Rpdml0eUlucHV0IHtcbiAgcmVhZG9ubHkgYWN0aXZpdHlUeXBlOiBzdHJpbmc7XG4gIHJlYWRvbmx5IGFyZ3M6IHVua25vd25bXTtcbiAgcmVhZG9ubHkgb3B0aW9uczogQWN0aXZpdHlPcHRpb25zO1xuICByZWFkb25seSBoZWFkZXJzOiBIZWFkZXJzO1xuICByZWFkb25seSBzZXE6IG51bWJlcjtcbn1cblxuLyoqIElucHV0IGZvciBXb3JrZmxvd091dGJvdW5kQ2FsbHNJbnRlcmNlcHRvci5zY2hlZHVsZUxvY2FsQWN0aXZpdHkgKi9cbmV4cG9ydCBpbnRlcmZhY2UgTG9jYWxBY3Rpdml0eUlucHV0IHtcbiAgcmVhZG9ubHkgYWN0aXZpdHlUeXBlOiBzdHJpbmc7XG4gIHJlYWRvbmx5IGFyZ3M6IHVua25vd25bXTtcbiAgcmVhZG9ubHkgb3B0aW9uczogTG9jYWxBY3Rpdml0eU9wdGlvbnM7XG4gIHJlYWRvbmx5IGhlYWRlcnM6IEhlYWRlcnM7XG4gIHJlYWRvbmx5IHNlcTogbnVtYmVyO1xuICByZWFkb25seSBvcmlnaW5hbFNjaGVkdWxlVGltZT86IFRpbWVzdGFtcDtcbiAgcmVhZG9ubHkgYXR0ZW1wdDogbnVtYmVyO1xufVxuXG4vKiogSW5wdXQgZm9yIFdvcmtmbG93T3V0Ym91bmRDYWxsc0ludGVyY2VwdG9yLnN0YXJ0Q2hpbGRXb3JrZmxvd0V4ZWN1dGlvbiAqL1xuZXhwb3J0IGludGVyZmFjZSBTdGFydENoaWxkV29ya2Zsb3dFeGVjdXRpb25JbnB1dCB7XG4gIHJlYWRvbmx5IHdvcmtmbG93VHlwZTogc3RyaW5nO1xuICByZWFkb25seSBvcHRpb25zOiBDaGlsZFdvcmtmbG93T3B0aW9uc1dpdGhEZWZhdWx0cztcbiAgcmVhZG9ubHkgaGVhZGVyczogSGVhZGVycztcbiAgcmVhZG9ubHkgc2VxOiBudW1iZXI7XG59XG5cbi8qKiBJbnB1dCBmb3IgV29ya2Zsb3dPdXRib3VuZENhbGxzSW50ZXJjZXB0b3Iuc3RhcnRUaW1lciAqL1xuZXhwb3J0IGludGVyZmFjZSBUaW1lcklucHV0IHtcbiAgcmVhZG9ubHkgZHVyYXRpb25NczogbnVtYmVyO1xuICByZWFkb25seSBzZXE6IG51bWJlcjtcbn1cblxuLyoqXG4gKiBTYW1lIGFzIENvbnRpbnVlQXNOZXdPcHRpb25zIGJ1dCB3b3JrZmxvd1R5cGUgbXVzdCBiZSBkZWZpbmVkXG4gKi9cbmV4cG9ydCB0eXBlIENvbnRpbnVlQXNOZXdJbnB1dE9wdGlvbnMgPSBDb250aW51ZUFzTmV3T3B0aW9ucyAmIFJlcXVpcmVkPFBpY2s8Q29udGludWVBc05ld09wdGlvbnMsICd3b3JrZmxvd1R5cGUnPj47XG5cbi8qKiBJbnB1dCBmb3IgV29ya2Zsb3dPdXRib3VuZENhbGxzSW50ZXJjZXB0b3IuY29udGludWVBc05ldyAqL1xuZXhwb3J0IGludGVyZmFjZSBDb250aW51ZUFzTmV3SW5wdXQge1xuICByZWFkb25seSBhcmdzOiB1bmtub3duW107XG4gIHJlYWRvbmx5IGhlYWRlcnM6IEhlYWRlcnM7XG4gIHJlYWRvbmx5IG9wdGlvbnM6IENvbnRpbnVlQXNOZXdJbnB1dE9wdGlvbnM7XG59XG5cbi8qKiBJbnB1dCBmb3IgV29ya2Zsb3dPdXRib3VuZENhbGxzSW50ZXJjZXB0b3Iuc2lnbmFsV29ya2Zsb3cgKi9cbmV4cG9ydCBpbnRlcmZhY2UgU2lnbmFsV29ya2Zsb3dJbnB1dCB7XG4gIHJlYWRvbmx5IHNlcTogbnVtYmVyO1xuICByZWFkb25seSBzaWduYWxOYW1lOiBzdHJpbmc7XG4gIHJlYWRvbmx5IGFyZ3M6IHVua25vd25bXTtcbiAgcmVhZG9ubHkgaGVhZGVyczogSGVhZGVycztcbiAgcmVhZG9ubHkgdGFyZ2V0OlxuICAgIHwge1xuICAgICAgICByZWFkb25seSB0eXBlOiAnZXh0ZXJuYWwnO1xuICAgICAgICByZWFkb25seSB3b3JrZmxvd0V4ZWN1dGlvbjogV29ya2Zsb3dFeGVjdXRpb247XG4gICAgICB9XG4gICAgfCB7XG4gICAgICAgIHJlYWRvbmx5IHR5cGU6ICdjaGlsZCc7XG4gICAgICAgIHJlYWRvbmx5IGNoaWxkV29ya2Zsb3dJZDogc3RyaW5nO1xuICAgICAgfTtcbn1cblxuLyoqIElucHV0IGZvciBXb3JrZmxvd091dGJvdW5kQ2FsbHNJbnRlcmNlcHRvci5nZXRMb2dBdHRyaWJ1dGVzICovXG5leHBvcnQgdHlwZSBHZXRMb2dBdHRyaWJ1dGVzSW5wdXQgPSBSZWNvcmQ8c3RyaW5nLCB1bmtub3duPjtcblxuLyoqXG4gKiBJbXBsZW1lbnQgYW55IG9mIHRoZXNlIG1ldGhvZHMgdG8gaW50ZXJjZXB0IFdvcmtmbG93IGNvZGUgY2FsbHMgdG8gdGhlIFRlbXBvcmFsIEFQSXMsIGxpa2Ugc2NoZWR1bGluZyBhbiBhY3Rpdml0eSBhbmQgc3RhcnRpbmcgYSB0aW1lclxuICovXG5leHBvcnQgaW50ZXJmYWNlIFdvcmtmbG93T3V0Ym91bmRDYWxsc0ludGVyY2VwdG9yIHtcbiAgLyoqXG4gICAqIENhbGxlZCB3aGVuIFdvcmtmbG93IHNjaGVkdWxlcyBhbiBBY3Rpdml0eVxuICAgKlxuICAgKiBAcmV0dXJuIHJlc3VsdCBvZiB0aGUgYWN0aXZpdHkgZXhlY3V0aW9uXG4gICAqL1xuICBzY2hlZHVsZUFjdGl2aXR5PzogKGlucHV0OiBBY3Rpdml0eUlucHV0LCBuZXh0OiBOZXh0PHRoaXMsICdzY2hlZHVsZUFjdGl2aXR5Jz4pID0+IFByb21pc2U8dW5rbm93bj47XG5cbiAgLyoqXG4gICAqIENhbGxlZCB3aGVuIFdvcmtmbG93IHNjaGVkdWxlcyBhIGxvY2FsIEFjdGl2aXR5XG4gICAqXG4gICAqIEByZXR1cm4gcmVzdWx0IG9mIHRoZSBhY3Rpdml0eSBleGVjdXRpb25cbiAgICovXG4gIHNjaGVkdWxlTG9jYWxBY3Rpdml0eT86IChpbnB1dDogTG9jYWxBY3Rpdml0eUlucHV0LCBuZXh0OiBOZXh0PHRoaXMsICdzY2hlZHVsZUxvY2FsQWN0aXZpdHknPikgPT4gUHJvbWlzZTx1bmtub3duPjtcblxuICAvKipcbiAgICogQ2FsbGVkIHdoZW4gV29ya2Zsb3cgc3RhcnRzIGEgdGltZXJcbiAgICovXG4gIHN0YXJ0VGltZXI/OiAoaW5wdXQ6IFRpbWVySW5wdXQsIG5leHQ6IE5leHQ8dGhpcywgJ3N0YXJ0VGltZXInPikgPT4gUHJvbWlzZTx2b2lkPjtcblxuICAvKipcbiAgICogQ2FsbGVkIHdoZW4gV29ya2Zsb3cgY2FsbHMgY29udGludWVBc05ld1xuICAgKi9cbiAgY29udGludWVBc05ldz86IChpbnB1dDogQ29udGludWVBc05ld0lucHV0LCBuZXh0OiBOZXh0PHRoaXMsICdjb250aW51ZUFzTmV3Jz4pID0+IFByb21pc2U8bmV2ZXI+O1xuXG4gIC8qKlxuICAgKiBDYWxsZWQgd2hlbiBXb3JrZmxvdyBzaWduYWxzIGEgY2hpbGQgb3IgZXh0ZXJuYWwgV29ya2Zsb3dcbiAgICovXG4gIHNpZ25hbFdvcmtmbG93PzogKGlucHV0OiBTaWduYWxXb3JrZmxvd0lucHV0LCBuZXh0OiBOZXh0PHRoaXMsICdzaWduYWxXb3JrZmxvdyc+KSA9PiBQcm9taXNlPHZvaWQ+O1xuXG4gIC8qKlxuICAgKiBDYWxsZWQgd2hlbiBXb3JrZmxvdyBzdGFydHMgYSBjaGlsZCB3b3JrZmxvdyBleGVjdXRpb24sIHRoZSBpbnRlcmNlcHRvciBmdW5jdGlvbiByZXR1cm5zIDIgcHJvbWlzZXM6XG4gICAqXG4gICAqIC0gVGhlIGZpcnN0IHJlc29sdmVzIHdpdGggdGhlIGBydW5JZGAgd2hlbiB0aGUgY2hpbGQgd29ya2Zsb3cgaGFzIHN0YXJ0ZWQgb3IgcmVqZWN0cyBpZiBmYWlsZWQgdG8gc3RhcnQuXG4gICAqIC0gVGhlIHNlY29uZCByZXNvbHZlcyB3aXRoIHRoZSB3b3JrZmxvdyByZXN1bHQgd2hlbiB0aGUgY2hpbGQgd29ya2Zsb3cgY29tcGxldGVzIG9yIHJlamVjdHMgb24gZmFpbHVyZS5cbiAgICovXG4gIHN0YXJ0Q2hpbGRXb3JrZmxvd0V4ZWN1dGlvbj86IChcbiAgICBpbnB1dDogU3RhcnRDaGlsZFdvcmtmbG93RXhlY3V0aW9uSW5wdXQsXG4gICAgbmV4dDogTmV4dDx0aGlzLCAnc3RhcnRDaGlsZFdvcmtmbG93RXhlY3V0aW9uJz5cbiAgKSA9PiBQcm9taXNlPFtQcm9taXNlPHN0cmluZz4sIFByb21pc2U8dW5rbm93bj5dPjtcblxuICAvKipcbiAgICogQ2FsbGVkIG9uIGVhY2ggaW52b2NhdGlvbiBvZiB0aGUgYHdvcmtmbG93LmxvZ2AgbWV0aG9kcy5cbiAgICpcbiAgICogVGhlIGF0dHJpYnV0ZXMgcmV0dXJuZWQgaW4gdGhpcyBjYWxsIGFyZSBhdHRhY2hlZCB0byBldmVyeSBsb2cgbWVzc2FnZS5cbiAgICovXG4gIGdldExvZ0F0dHJpYnV0ZXM/OiAoaW5wdXQ6IEdldExvZ0F0dHJpYnV0ZXNJbnB1dCwgbmV4dDogTmV4dDx0aGlzLCAnZ2V0TG9nQXR0cmlidXRlcyc+KSA9PiBSZWNvcmQ8c3RyaW5nLCB1bmtub3duPjtcbn1cblxuLyoqIElucHV0IGZvciBXb3JrZmxvd0ludGVybmFsc0ludGVyY2VwdG9yLmNvbmNsdWRlQWN0aXZhdGlvbiAqL1xuZXhwb3J0IGludGVyZmFjZSBDb25jbHVkZUFjdGl2YXRpb25JbnB1dCB7XG4gIGNvbW1hbmRzOiBjb3Jlc2RrLndvcmtmbG93X2NvbW1hbmRzLklXb3JrZmxvd0NvbW1hbmRbXTtcbn1cblxuLyoqIE91dHB1dCBmb3IgV29ya2Zsb3dJbnRlcm5hbHNJbnRlcmNlcHRvci5jb25jbHVkZUFjdGl2YXRpb24gKi9cbmV4cG9ydCB0eXBlIENvbmNsdWRlQWN0aXZhdGlvbk91dHB1dCA9IENvbmNsdWRlQWN0aXZhdGlvbklucHV0O1xuXG4vKiogSW5wdXQgZm9yIFdvcmtmbG93SW50ZXJuYWxzSW50ZXJjZXB0b3IuYWN0aXZhdGUgKi9cbmV4cG9ydCBpbnRlcmZhY2UgQWN0aXZhdGVJbnB1dCB7XG4gIGFjdGl2YXRpb246IGNvcmVzZGsud29ya2Zsb3dfYWN0aXZhdGlvbi5JV29ya2Zsb3dBY3RpdmF0aW9uO1xuICBiYXRjaEluZGV4OiBudW1iZXI7XG59XG5cbi8qKiBJbnB1dCBmb3IgV29ya2Zsb3dJbnRlcm5hbHNJbnRlcmNlcHRvci5kaXNwb3NlICovXG4vLyBlc2xpbnQtZGlzYWJsZS1uZXh0LWxpbmUgQHR5cGVzY3JpcHQtZXNsaW50L25vLWVtcHR5LWludGVyZmFjZVxuZXhwb3J0IGludGVyZmFjZSBEaXNwb3NlSW5wdXQge31cblxuLyoqXG4gKiBJbnRlcmNlcHRvciBmb3IgdGhlIGludGVybmFscyBvZiB0aGUgV29ya2Zsb3cgcnVudGltZS5cbiAqXG4gKiBVc2UgdG8gbWFuaXB1bGF0ZSBvciB0cmFjZSBXb3JrZmxvdyBhY3RpdmF0aW9ucy5cbiAqXG4gKiBAZXhwZXJpbWVudGFsIFRoaXMgQVBJIGlzIGZvciBhZHZhbmNlZCB1c2UgY2FzZXMgYW5kIG1heSBjaGFuZ2UgaW4gdGhlIGZ1dHVyZS5cbiAqL1xuZXhwb3J0IGludGVyZmFjZSBXb3JrZmxvd0ludGVybmFsc0ludGVyY2VwdG9yIHtcbiAgLyoqXG4gICAqIENhbGxlZCB3aGVuIHRoZSBXb3JrZmxvdyBydW50aW1lIHJ1bnMgYSBXb3JrZmxvd0FjdGl2YXRpb25Kb2IuXG4gICAqL1xuICBhY3RpdmF0ZT8oaW5wdXQ6IEFjdGl2YXRlSW5wdXQsIG5leHQ6IE5leHQ8dGhpcywgJ2FjdGl2YXRlJz4pOiB2b2lkO1xuXG4gIC8qKlxuICAgKiBDYWxsZWQgYWZ0ZXIgYWxsIGBXb3JrZmxvd0FjdGl2YXRpb25Kb2JgcyBoYXZlIGJlZW4gcHJvY2Vzc2VkIGZvciBhbiBhY3RpdmF0aW9uLlxuICAgKlxuICAgKiBDYW4gbWFuaXB1bGF0ZSB0aGUgY29tbWFuZHMgZ2VuZXJhdGVkIGJ5IHRoZSBXb3JrZmxvd1xuICAgKi9cbiAgY29uY2x1ZGVBY3RpdmF0aW9uPyhpbnB1dDogQ29uY2x1ZGVBY3RpdmF0aW9uSW5wdXQsIG5leHQ6IE5leHQ8dGhpcywgJ2NvbmNsdWRlQWN0aXZhdGlvbic+KTogQ29uY2x1ZGVBY3RpdmF0aW9uT3V0cHV0O1xuXG4gIC8qKlxuICAgKiBDYWxsZWQgYmVmb3JlIGRpc3Bvc2luZyB0aGUgV29ya2Zsb3cgaXNvbGF0ZSBjb250ZXh0LlxuICAgKlxuICAgKiBJbXBsZW1lbnQgdGhpcyBtZXRob2QgdG8gcGVyZm9ybSBhbnkgcmVzb3VyY2UgY2xlYW51cC5cbiAgICovXG4gIGRpc3Bvc2U/KGlucHV0OiBEaXNwb3NlSW5wdXQsIG5leHQ6IE5leHQ8dGhpcywgJ2Rpc3Bvc2UnPik6IHZvaWQ7XG59XG5cbi8qKlxuICogQSBtYXBwaW5nIGZyb20gaW50ZXJjZXB0b3IgdHlwZSB0byBhbiBvcHRpb25hbCBsaXN0IG9mIGludGVyY2VwdG9yIGltcGxlbWVudGF0aW9uc1xuICovXG5leHBvcnQgaW50ZXJmYWNlIFdvcmtmbG93SW50ZXJjZXB0b3JzIHtcbiAgaW5ib3VuZD86IFdvcmtmbG93SW5ib3VuZENhbGxzSW50ZXJjZXB0b3JbXTtcbiAgb3V0Ym91bmQ/OiBXb3JrZmxvd091dGJvdW5kQ2FsbHNJbnRlcmNlcHRvcltdO1xuICBpbnRlcm5hbHM/OiBXb3JrZmxvd0ludGVybmFsc0ludGVyY2VwdG9yW107XG59XG5cbi8qKlxuICogQSBmdW5jdGlvbiB0aGF0IHJldHVybnMge0BsaW5rIFdvcmtmbG93SW50ZXJjZXB0b3JzfSBhbmQgdGFrZXMgbm8gYXJndW1lbnRzLlxuICpcbiAqIFdvcmtmbG93IGludGVyY2VwdG9yIG1vZHVsZXMgc2hvdWxkIGV4cG9ydCBhbiBgaW50ZXJjZXB0b3JzYCBmdW5jdGlvbiBvZiB0aGlzIHR5cGUuXG4gKlxuICogQGV4YW1wbGVcbiAqXG4gKiBgYGB0c1xuICogZXhwb3J0IGZ1bmN0aW9uIGludGVyY2VwdG9ycygpOiBXb3JrZmxvd0ludGVyY2VwdG9ycyB7XG4gKiAgIHJldHVybiB7XG4gKiAgICAgaW5ib3VuZDogW10sICAgLy8gUG9wdWxhdGUgd2l0aCBsaXN0IG9mIGludGVyY2VwdG9yIGltcGxlbWVudGF0aW9uc1xuICogICAgIG91dGJvdW5kOiBbXSwgIC8vIFBvcHVsYXRlIHdpdGggbGlzdCBvZiBpbnRlcmNlcHRvciBpbXBsZW1lbnRhdGlvbnNcbiAqICAgICBpbnRlcm5hbHM6IFtdLCAvLyBQb3B1bGF0ZSB3aXRoIGxpc3Qgb2YgaW50ZXJjZXB0b3IgaW1wbGVtZW50YXRpb25zXG4gKiAgIH07XG4gKiB9XG4gKiBgYGBcbiAqL1xuZXhwb3J0IHR5cGUgV29ya2Zsb3dJbnRlcmNlcHRvcnNGYWN0b3J5ID0gKCkgPT4gV29ya2Zsb3dJbnRlcmNlcHRvcnM7XG4iLCJpbXBvcnQgdHlwZSB7IFJhd1NvdXJjZU1hcCB9IGZyb20gJ3NvdXJjZS1tYXAnO1xuaW1wb3J0IHtcbiAgUmV0cnlQb2xpY3ksXG4gIFRlbXBvcmFsRmFpbHVyZSxcbiAgQ29tbW9uV29ya2Zsb3dPcHRpb25zLFxuICBTZWFyY2hBdHRyaWJ1dGVzLFxuICBTaWduYWxEZWZpbml0aW9uLFxuICBVcGRhdGVEZWZpbml0aW9uLFxuICBRdWVyeURlZmluaXRpb24sXG4gIER1cmF0aW9uLFxuICBWZXJzaW9uaW5nSW50ZW50LFxufSBmcm9tICdAdGVtcG9yYWxpby9jb21tb24nO1xuaW1wb3J0IHsgY2hlY2tFeHRlbmRzLCBTeW1ib2xCYXNlZEluc3RhbmNlT2ZFcnJvciB9IGZyb20gJ0B0ZW1wb3JhbGlvL2NvbW1vbi9saWIvdHlwZS1oZWxwZXJzJztcbmltcG9ydCB0eXBlIHsgY29yZXNkayB9IGZyb20gJ0B0ZW1wb3JhbGlvL3Byb3RvJztcblxuLyoqXG4gKiBXb3JrZmxvdyBFeGVjdXRpb24gaW5mb3JtYXRpb25cbiAqL1xuZXhwb3J0IGludGVyZmFjZSBXb3JrZmxvd0luZm8ge1xuICAvKipcbiAgICogSUQgb2YgdGhlIFdvcmtmbG93LCB0aGlzIGNhbiBiZSBzZXQgYnkgdGhlIGNsaWVudCBkdXJpbmcgV29ya2Zsb3cgY3JlYXRpb24uXG4gICAqIEEgc2luZ2xlIFdvcmtmbG93IG1heSBydW4gbXVsdGlwbGUgdGltZXMgZS5nLiB3aGVuIHNjaGVkdWxlZCB3aXRoIGNyb24uXG4gICAqL1xuICByZWFkb25seSB3b3JrZmxvd0lkOiBzdHJpbmc7XG5cbiAgLyoqXG4gICAqIElEIG9mIGEgc2luZ2xlIFdvcmtmbG93IHJ1blxuICAgKi9cbiAgcmVhZG9ubHkgcnVuSWQ6IHN0cmluZztcblxuICAvKipcbiAgICogV29ya2Zsb3cgZnVuY3Rpb24ncyBuYW1lXG4gICAqL1xuICByZWFkb25seSB3b3JrZmxvd1R5cGU6IHN0cmluZztcblxuICAvKipcbiAgICogSW5kZXhlZCBpbmZvcm1hdGlvbiBhdHRhY2hlZCB0byB0aGUgV29ya2Zsb3cgRXhlY3V0aW9uXG4gICAqXG4gICAqIFRoaXMgdmFsdWUgbWF5IGNoYW5nZSBkdXJpbmcgdGhlIGxpZmV0aW1lIG9mIGFuIEV4ZWN1dGlvbi5cbiAgICovXG4gIHJlYWRvbmx5IHNlYXJjaEF0dHJpYnV0ZXM6IFNlYXJjaEF0dHJpYnV0ZXM7XG5cbiAgLyoqXG4gICAqIE5vbi1pbmRleGVkIGluZm9ybWF0aW9uIGF0dGFjaGVkIHRvIHRoZSBXb3JrZmxvdyBFeGVjdXRpb25cbiAgICovXG4gIHJlYWRvbmx5IG1lbW8/OiBSZWNvcmQ8c3RyaW5nLCB1bmtub3duPjtcblxuICAvKipcbiAgICogUGFyZW50IFdvcmtmbG93IGluZm8gKHByZXNlbnQgaWYgdGhpcyBpcyBhIENoaWxkIFdvcmtmbG93KVxuICAgKi9cbiAgcmVhZG9ubHkgcGFyZW50PzogUGFyZW50V29ya2Zsb3dJbmZvO1xuXG4gIC8qKlxuICAgKiBSZXN1bHQgZnJvbSB0aGUgcHJldmlvdXMgUnVuIChwcmVzZW50IGlmIHRoaXMgaXMgYSBDcm9uIFdvcmtmbG93IG9yIHdhcyBDb250aW51ZWQgQXMgTmV3KS5cbiAgICpcbiAgICogQW4gYXJyYXkgb2YgdmFsdWVzLCBzaW5jZSBvdGhlciBTREtzIG1heSByZXR1cm4gbXVsdGlwbGUgdmFsdWVzIGZyb20gYSBXb3JrZmxvdy5cbiAgICovXG4gIHJlYWRvbmx5IGxhc3RSZXN1bHQ/OiB1bmtub3duO1xuXG4gIC8qKlxuICAgKiBGYWlsdXJlIGZyb20gdGhlIHByZXZpb3VzIFJ1biAocHJlc2VudCB3aGVuIHRoaXMgUnVuIGlzIGEgcmV0cnksIG9yIHRoZSBsYXN0IFJ1biBvZiBhIENyb24gV29ya2Zsb3cgZmFpbGVkKVxuICAgKi9cbiAgcmVhZG9ubHkgbGFzdEZhaWx1cmU/OiBUZW1wb3JhbEZhaWx1cmU7XG5cbiAgLyoqXG4gICAqIExlbmd0aCBvZiBXb3JrZmxvdyBoaXN0b3J5IHVwIHVudGlsIHRoZSBjdXJyZW50IFdvcmtmbG93IFRhc2suXG4gICAqXG4gICAqIFRoaXMgdmFsdWUgY2hhbmdlcyBkdXJpbmcgdGhlIGxpZmV0aW1lIG9mIGFuIEV4ZWN1dGlvbi5cbiAgICpcbiAgICogWW91IG1heSBzYWZlbHkgdXNlIHRoaXMgaW5mb3JtYXRpb24gdG8gZGVjaWRlIHdoZW4gdG8ge0BsaW5rIGNvbnRpbnVlQXNOZXd9LlxuICAgKi9cbiAgcmVhZG9ubHkgaGlzdG9yeUxlbmd0aDogbnVtYmVyO1xuXG4gIC8qKlxuICAgKiBTaXplIG9mIFdvcmtmbG93IGhpc3RvcnkgaW4gYnl0ZXMgdW50aWwgdGhlIGN1cnJlbnQgV29ya2Zsb3cgVGFzay5cbiAgICpcbiAgICogVGhpcyB2YWx1ZSBjaGFuZ2VzIGR1cmluZyB0aGUgbGlmZXRpbWUgb2YgYW4gRXhlY3V0aW9uLlxuICAgKlxuICAgKiBTdXBwb3J0ZWQgb25seSBvbiBUZW1wb3JhbCBTZXJ2ZXIgMS4yMCssIGFsd2F5cyB6ZXJvIG9uIG9sZGVyIHNlcnZlcnMuXG4gICAqXG4gICAqIFlvdSBtYXkgc2FmZWx5IHVzZSB0aGlzIGluZm9ybWF0aW9uIHRvIGRlY2lkZSB3aGVuIHRvIHtAbGluayBjb250aW51ZUFzTmV3fS5cbiAgICovXG4gIHJlYWRvbmx5IGhpc3RvcnlTaXplOiBudW1iZXI7XG5cbiAgLyoqXG4gICAqIEEgaGludCBwcm92aWRlZCBieSB0aGUgY3VycmVudCBXb3JrZmxvd1Rhc2tTdGFydGVkIGV2ZW50IHJlY29tbWVuZGluZyB3aGV0aGVyIHRvXG4gICAqIHtAbGluayBjb250aW51ZUFzTmV3fS5cbiAgICpcbiAgICogVGhpcyB2YWx1ZSBjaGFuZ2VzIGR1cmluZyB0aGUgbGlmZXRpbWUgb2YgYW4gRXhlY3V0aW9uLlxuICAgKlxuICAgKiBTdXBwb3J0ZWQgb25seSBvbiBUZW1wb3JhbCBTZXJ2ZXIgMS4yMCssIGFsd2F5cyBgZmFsc2VgIG9uIG9sZGVyIHNlcnZlcnMuXG4gICAqL1xuICByZWFkb25seSBjb250aW51ZUFzTmV3U3VnZ2VzdGVkOiBib29sZWFuO1xuXG4gIC8qKlxuICAgKiBUYXNrIHF1ZXVlIHRoaXMgV29ya2Zsb3cgaXMgZXhlY3V0aW5nIG9uXG4gICAqL1xuICByZWFkb25seSB0YXNrUXVldWU6IHN0cmluZztcblxuICAvKipcbiAgICogTmFtZXNwYWNlIHRoaXMgV29ya2Zsb3cgaXMgZXhlY3V0aW5nIGluXG4gICAqL1xuICByZWFkb25seSBuYW1lc3BhY2U6IHN0cmluZztcblxuICAvKipcbiAgICogUnVuIElkIG9mIHRoZSBmaXJzdCBSdW4gaW4gdGhpcyBFeGVjdXRpb24gQ2hhaW5cbiAgICovXG4gIHJlYWRvbmx5IGZpcnN0RXhlY3V0aW9uUnVuSWQ6IHN0cmluZztcblxuICAvKipcbiAgICogVGhlIGxhc3QgUnVuIElkIGluIHRoaXMgRXhlY3V0aW9uIENoYWluXG4gICAqL1xuICByZWFkb25seSBjb250aW51ZWRGcm9tRXhlY3V0aW9uUnVuSWQ/OiBzdHJpbmc7XG5cbiAgLyoqXG4gICAqIFRpbWUgYXQgd2hpY2ggdGhpcyBbV29ya2Zsb3cgRXhlY3V0aW9uIENoYWluXShodHRwczovL2RvY3MudGVtcG9yYWwuaW8vd29ya2Zsb3dzI3dvcmtmbG93LWV4ZWN1dGlvbi1jaGFpbikgd2FzIHN0YXJ0ZWRcbiAgICovXG4gIHJlYWRvbmx5IHN0YXJ0VGltZTogRGF0ZTtcblxuICAvKipcbiAgICogVGltZSBhdCB3aGljaCB0aGUgY3VycmVudCBXb3JrZmxvdyBSdW4gc3RhcnRlZFxuICAgKi9cbiAgcmVhZG9ubHkgcnVuU3RhcnRUaW1lOiBEYXRlO1xuXG4gIC8qKlxuICAgKiBNaWxsaXNlY29uZHMgYWZ0ZXIgd2hpY2ggdGhlIFdvcmtmbG93IEV4ZWN1dGlvbiBpcyBhdXRvbWF0aWNhbGx5IHRlcm1pbmF0ZWQgYnkgVGVtcG9yYWwgU2VydmVyLiBTZXQgdmlhIHtAbGluayBXb3JrZmxvd09wdGlvbnMud29ya2Zsb3dFeGVjdXRpb25UaW1lb3V0fS5cbiAgICovXG4gIHJlYWRvbmx5IGV4ZWN1dGlvblRpbWVvdXRNcz86IG51bWJlcjtcblxuICAvKipcbiAgICogVGltZSBhdCB3aGljaCB0aGUgV29ya2Zsb3cgRXhlY3V0aW9uIGV4cGlyZXNcbiAgICovXG4gIHJlYWRvbmx5IGV4ZWN1dGlvbkV4cGlyYXRpb25UaW1lPzogRGF0ZTtcblxuICAvKipcbiAgICogTWlsbGlzZWNvbmRzIGFmdGVyIHdoaWNoIHRoZSBXb3JrZmxvdyBSdW4gaXMgYXV0b21hdGljYWxseSB0ZXJtaW5hdGVkIGJ5IFRlbXBvcmFsIFNlcnZlci4gU2V0IHZpYSB7QGxpbmsgV29ya2Zsb3dPcHRpb25zLndvcmtmbG93UnVuVGltZW91dH0uXG4gICAqL1xuICByZWFkb25seSBydW5UaW1lb3V0TXM/OiBudW1iZXI7XG5cbiAgLyoqXG4gICAqIE1heGltdW0gZXhlY3V0aW9uIHRpbWUgb2YgYSBXb3JrZmxvdyBUYXNrIGluIG1pbGxpc2Vjb25kcy4gU2V0IHZpYSB7QGxpbmsgV29ya2Zsb3dPcHRpb25zLndvcmtmbG93VGFza1RpbWVvdXR9LlxuICAgKi9cbiAgcmVhZG9ubHkgdGFza1RpbWVvdXRNczogbnVtYmVyO1xuXG4gIC8qKlxuICAgKiBSZXRyeSBQb2xpY3kgZm9yIHRoaXMgRXhlY3V0aW9uLiBTZXQgdmlhIHtAbGluayBXb3JrZmxvd09wdGlvbnMucmV0cnl9LlxuICAgKi9cbiAgcmVhZG9ubHkgcmV0cnlQb2xpY3k/OiBSZXRyeVBvbGljeTtcblxuICAvKipcbiAgICogU3RhcnRzIGF0IDEgYW5kIGluY3JlbWVudHMgZm9yIGV2ZXJ5IHJldHJ5IGlmIHRoZXJlIGlzIGEgYHJldHJ5UG9saWN5YFxuICAgKi9cbiAgcmVhZG9ubHkgYXR0ZW1wdDogbnVtYmVyO1xuXG4gIC8qKlxuICAgKiBDcm9uIFNjaGVkdWxlIGZvciB0aGlzIEV4ZWN1dGlvbi4gU2V0IHZpYSB7QGxpbmsgV29ya2Zsb3dPcHRpb25zLmNyb25TY2hlZHVsZX0uXG4gICAqL1xuICByZWFkb25seSBjcm9uU2NoZWR1bGU/OiBzdHJpbmc7XG5cbiAgLyoqXG4gICAqIE1pbGxpc2Vjb25kcyBiZXR3ZWVuIENyb24gUnVuc1xuICAgKi9cbiAgcmVhZG9ubHkgY3JvblNjaGVkdWxlVG9TY2hlZHVsZUludGVydmFsPzogbnVtYmVyO1xuXG4gIC8qKlxuICAgKiBUaGUgQnVpbGQgSUQgb2YgdGhlIHdvcmtlciB3aGljaCBleGVjdXRlZCB0aGUgY3VycmVudCBXb3JrZmxvdyBUYXNrLiBNYXkgYmUgdW5kZWZpbmVkIGlmIHRoZVxuICAgKiB0YXNrIHdhcyBjb21wbGV0ZWQgYnkgYSB3b3JrZXIgd2l0aG91dCBhIEJ1aWxkIElELiBJZiB0aGlzIHdvcmtlciBpcyB0aGUgb25lIGV4ZWN1dGluZyB0aGlzXG4gICAqIHRhc2sgZm9yIHRoZSBmaXJzdCB0aW1lIGFuZCBoYXMgYSBCdWlsZCBJRCBzZXQsIHRoZW4gaXRzIElEIHdpbGwgYmUgdXNlZC4gVGhpcyB2YWx1ZSBtYXkgY2hhbmdlXG4gICAqIG92ZXIgdGhlIGxpZmV0aW1lIG9mIHRoZSB3b3JrZmxvdyBydW4sIGJ1dCBpcyBkZXRlcm1pbmlzdGljIGFuZCBzYWZlIHRvIHVzZSBmb3IgYnJhbmNoaW5nLlxuICAgKi9cbiAgcmVhZG9ubHkgY3VycmVudEJ1aWxkSWQ/OiBzdHJpbmc7XG5cbiAgcmVhZG9ubHkgdW5zYWZlOiBVbnNhZmVXb3JrZmxvd0luZm87XG59XG5cbi8qKlxuICogVW5zYWZlIGluZm9ybWF0aW9uIGFib3V0IHRoZSBjdXJyZW50IFdvcmtmbG93IEV4ZWN1dGlvbi5cbiAqXG4gKiBOZXZlciByZWx5IG9uIHRoaXMgaW5mb3JtYXRpb24gaW4gV29ya2Zsb3cgbG9naWMgYXMgaXQgd2lsbCBjYXVzZSBub24tZGV0ZXJtaW5pc3RpYyBiZWhhdmlvci5cbiAqL1xuZXhwb3J0IGludGVyZmFjZSBVbnNhZmVXb3JrZmxvd0luZm8ge1xuICAvKipcbiAgICogQ3VycmVudCBzeXN0ZW0gdGltZSBpbiBtaWxsaXNlY29uZHNcbiAgICpcbiAgICogVGhlIHNhZmUgdmVyc2lvbiBvZiB0aW1lIGlzIGBuZXcgRGF0ZSgpYCBhbmQgYERhdGUubm93KClgLCB3aGljaCBhcmUgc2V0IG9uIHRoZSBmaXJzdCBpbnZvY2F0aW9uIG9mIGEgV29ya2Zsb3dcbiAgICogVGFzayBhbmQgc3RheSBjb25zdGFudCBmb3IgdGhlIGR1cmF0aW9uIG9mIHRoZSBUYXNrIGFuZCBkdXJpbmcgcmVwbGF5LlxuICAgKi9cbiAgcmVhZG9ubHkgbm93OiAoKSA9PiBudW1iZXI7XG5cbiAgcmVhZG9ubHkgaXNSZXBsYXlpbmc6IGJvb2xlYW47XG59XG5cbmV4cG9ydCBpbnRlcmZhY2UgUGFyZW50V29ya2Zsb3dJbmZvIHtcbiAgd29ya2Zsb3dJZDogc3RyaW5nO1xuICBydW5JZDogc3RyaW5nO1xuICBuYW1lc3BhY2U6IHN0cmluZztcbn1cblxuLyoqXG4gKiBOb3QgYW4gYWN0dWFsIGVycm9yLCB1c2VkIGJ5IHRoZSBXb3JrZmxvdyBydW50aW1lIHRvIGFib3J0IGV4ZWN1dGlvbiB3aGVuIHtAbGluayBjb250aW51ZUFzTmV3fSBpcyBjYWxsZWRcbiAqL1xuQFN5bWJvbEJhc2VkSW5zdGFuY2VPZkVycm9yKCdDb250aW51ZUFzTmV3JylcbmV4cG9ydCBjbGFzcyBDb250aW51ZUFzTmV3IGV4dGVuZHMgRXJyb3Ige1xuICBjb25zdHJ1Y3RvcihwdWJsaWMgcmVhZG9ubHkgY29tbWFuZDogY29yZXNkay53b3JrZmxvd19jb21tYW5kcy5JQ29udGludWVBc05ld1dvcmtmbG93RXhlY3V0aW9uKSB7XG4gICAgc3VwZXIoJ1dvcmtmbG93IGNvbnRpbnVlZCBhcyBuZXcnKTtcbiAgfVxufVxuXG4vKipcbiAqIE9wdGlvbnMgZm9yIGNvbnRpbnVpbmcgYSBXb3JrZmxvdyBhcyBuZXdcbiAqL1xuZXhwb3J0IGludGVyZmFjZSBDb250aW51ZUFzTmV3T3B0aW9ucyB7XG4gIC8qKlxuICAgKiBBIHN0cmluZyByZXByZXNlbnRpbmcgdGhlIFdvcmtmbG93IHR5cGUgbmFtZSwgZS5nLiB0aGUgZmlsZW5hbWUgaW4gdGhlIE5vZGUuanMgU0RLIG9yIGNsYXNzIG5hbWUgaW4gSmF2YVxuICAgKi9cbiAgd29ya2Zsb3dUeXBlPzogc3RyaW5nO1xuICAvKipcbiAgICogVGFzayBxdWV1ZSB0byBjb250aW51ZSB0aGUgV29ya2Zsb3cgaW5cbiAgICovXG4gIHRhc2tRdWV1ZT86IHN0cmluZztcbiAgLyoqXG4gICAqIFRpbWVvdXQgZm9yIHRoZSBlbnRpcmUgV29ya2Zsb3cgcnVuXG4gICAqIEBmb3JtYXQge0BsaW5rIGh0dHBzOi8vd3d3Lm5wbWpzLmNvbS9wYWNrYWdlL21zIHwgbXMtZm9ybWF0dGVkIHN0cmluZ31cbiAgICovXG4gIHdvcmtmbG93UnVuVGltZW91dD86IER1cmF0aW9uO1xuICAvKipcbiAgICogVGltZW91dCBmb3IgYSBzaW5nbGUgV29ya2Zsb3cgdGFza1xuICAgKiBAZm9ybWF0IHtAbGluayBodHRwczovL3d3dy5ucG1qcy5jb20vcGFja2FnZS9tcyB8IG1zLWZvcm1hdHRlZCBzdHJpbmd9XG4gICAqL1xuICB3b3JrZmxvd1Rhc2tUaW1lb3V0PzogRHVyYXRpb247XG4gIC8qKlxuICAgKiBOb24tc2VhcmNoYWJsZSBhdHRyaWJ1dGVzIHRvIGF0dGFjaCB0byBuZXh0IFdvcmtmbG93IHJ1blxuICAgKi9cbiAgbWVtbz86IFJlY29yZDxzdHJpbmcsIHVua25vd24+O1xuICAvKipcbiAgICogU2VhcmNoYWJsZSBhdHRyaWJ1dGVzIHRvIGF0dGFjaCB0byBuZXh0IFdvcmtmbG93IHJ1blxuICAgKi9cbiAgc2VhcmNoQXR0cmlidXRlcz86IFNlYXJjaEF0dHJpYnV0ZXM7XG4gIC8qKlxuICAgKiBXaGVuIHVzaW5nIHRoZSBXb3JrZXIgVmVyc2lvbmluZyBmZWF0dXJlLCBzcGVjaWZpZXMgd2hldGhlciB0aGlzIFdvcmtmbG93IHNob3VsZFxuICAgKiBDb250aW51ZS1hcy1OZXcgb250byBhIHdvcmtlciB3aXRoIGEgY29tcGF0aWJsZSBCdWlsZCBJZCBvciBub3QuIFNlZSB7QGxpbmsgVmVyc2lvbmluZ0ludGVudH0uXG4gICAqXG4gICAqIEBkZWZhdWx0ICdDT01QQVRJQkxFJ1xuICAgKlxuICAgKiBAZXhwZXJpbWVudGFsXG4gICAqL1xuICB2ZXJzaW9uaW5nSW50ZW50PzogVmVyc2lvbmluZ0ludGVudDtcbn1cblxuLyoqXG4gKiBTcGVjaWZpZXM6XG4gKiAtIHdoZXRoZXIgY2FuY2VsbGF0aW9uIHJlcXVlc3RzIGFyZSBzZW50IHRvIHRoZSBDaGlsZFxuICogLSB3aGV0aGVyIGFuZCB3aGVuIGEge0BsaW5rIENhbmNlbGVkRmFpbHVyZX0gaXMgdGhyb3duIGZyb20ge0BsaW5rIGV4ZWN1dGVDaGlsZH0gb3JcbiAqICAge0BsaW5rIENoaWxkV29ya2Zsb3dIYW5kbGUucmVzdWx0fVxuICpcbiAqIEBkZWZhdWx0IHtAbGluayBDaGlsZFdvcmtmbG93Q2FuY2VsbGF0aW9uVHlwZS5XQUlUX0NBTkNFTExBVElPTl9DT01QTEVURUR9XG4gKi9cbmV4cG9ydCBlbnVtIENoaWxkV29ya2Zsb3dDYW5jZWxsYXRpb25UeXBlIHtcbiAgLyoqXG4gICAqIERvbid0IHNlbmQgYSBjYW5jZWxsYXRpb24gcmVxdWVzdCB0byB0aGUgQ2hpbGQuXG4gICAqL1xuICBBQkFORE9OID0gMCxcblxuICAvKipcbiAgICogU2VuZCBhIGNhbmNlbGxhdGlvbiByZXF1ZXN0IHRvIHRoZSBDaGlsZC4gSW1tZWRpYXRlbHkgdGhyb3cgdGhlIGVycm9yLlxuICAgKi9cbiAgVFJZX0NBTkNFTCA9IDEsXG5cbiAgLyoqXG4gICAqIFNlbmQgYSBjYW5jZWxsYXRpb24gcmVxdWVzdCB0byB0aGUgQ2hpbGQuIFRoZSBDaGlsZCBtYXkgcmVzcGVjdCBjYW5jZWxsYXRpb24sIGluIHdoaWNoIGNhc2UgYW4gZXJyb3Igd2lsbCBiZSB0aHJvd25cbiAgICogd2hlbiBjYW5jZWxsYXRpb24gaGFzIGNvbXBsZXRlZCwgYW5kIHtAbGluayBpc0NhbmNlbGxhdGlvbn0oZXJyb3IpIHdpbGwgYmUgdHJ1ZS4gT24gdGhlIG90aGVyIGhhbmQsIHRoZSBDaGlsZCBtYXlcbiAgICogaWdub3JlIHRoZSBjYW5jZWxsYXRpb24gcmVxdWVzdCwgaW4gd2hpY2ggY2FzZSBhbiBlcnJvciBtaWdodCBiZSB0aHJvd24gd2l0aCBhIGRpZmZlcmVudCBjYXVzZSwgb3IgdGhlIENoaWxkIG1heVxuICAgKiBjb21wbGV0ZSBzdWNjZXNzZnVsbHkuXG4gICAqXG4gICAqIEBkZWZhdWx0XG4gICAqL1xuICBXQUlUX0NBTkNFTExBVElPTl9DT01QTEVURUQgPSAyLFxuXG4gIC8qKlxuICAgKiBTZW5kIGEgY2FuY2VsbGF0aW9uIHJlcXVlc3QgdG8gdGhlIENoaWxkLiBUaHJvdyB0aGUgZXJyb3Igb25jZSB0aGUgU2VydmVyIHJlY2VpdmVzIHRoZSBDaGlsZCBjYW5jZWxsYXRpb24gcmVxdWVzdC5cbiAgICovXG4gIFdBSVRfQ0FOQ0VMTEFUSU9OX1JFUVVFU1RFRCA9IDMsXG59XG5cbmNoZWNrRXh0ZW5kczxjb3Jlc2RrLmNoaWxkX3dvcmtmbG93LkNoaWxkV29ya2Zsb3dDYW5jZWxsYXRpb25UeXBlLCBDaGlsZFdvcmtmbG93Q2FuY2VsbGF0aW9uVHlwZT4oKTtcbmNoZWNrRXh0ZW5kczxDaGlsZFdvcmtmbG93Q2FuY2VsbGF0aW9uVHlwZSwgY29yZXNkay5jaGlsZF93b3JrZmxvdy5DaGlsZFdvcmtmbG93Q2FuY2VsbGF0aW9uVHlwZT4oKTtcblxuLyoqXG4gKiBIb3cgYSBDaGlsZCBXb3JrZmxvdyByZWFjdHMgdG8gdGhlIFBhcmVudCBXb3JrZmxvdyByZWFjaGluZyBhIENsb3NlZCBzdGF0ZS5cbiAqXG4gKiBAc2VlIHtAbGluayBodHRwczovL2RvY3MudGVtcG9yYWwuaW8vY29uY2VwdHMvd2hhdC1pcy1hLXBhcmVudC1jbG9zZS1wb2xpY3kvIHwgUGFyZW50IENsb3NlIFBvbGljeX1cbiAqL1xuZXhwb3J0IGVudW0gUGFyZW50Q2xvc2VQb2xpY3kge1xuICAvKipcbiAgICogSWYgYSBgUGFyZW50Q2xvc2VQb2xpY3lgIGlzIHNldCB0byB0aGlzLCBvciBpcyBub3Qgc2V0IGF0IGFsbCwgdGhlIHNlcnZlciBkZWZhdWx0IHZhbHVlIHdpbGwgYmUgdXNlZC5cbiAgICovXG4gIFBBUkVOVF9DTE9TRV9QT0xJQ1lfVU5TUEVDSUZJRUQgPSAwLFxuXG4gIC8qKlxuICAgKiBXaGVuIHRoZSBQYXJlbnQgaXMgQ2xvc2VkLCB0aGUgQ2hpbGQgaXMgVGVybWluYXRlZC5cbiAgICpcbiAgICogQGRlZmF1bHRcbiAgICovXG4gIFBBUkVOVF9DTE9TRV9QT0xJQ1lfVEVSTUlOQVRFID0gMSxcblxuICAvKipcbiAgICogV2hlbiB0aGUgUGFyZW50IGlzIENsb3NlZCwgbm90aGluZyBpcyBkb25lIHRvIHRoZSBDaGlsZC5cbiAgICovXG4gIFBBUkVOVF9DTE9TRV9QT0xJQ1lfQUJBTkRPTiA9IDIsXG5cbiAgLyoqXG4gICAqIFdoZW4gdGhlIFBhcmVudCBpcyBDbG9zZWQsIHRoZSBDaGlsZCBpcyBDYW5jZWxsZWQuXG4gICAqL1xuICBQQVJFTlRfQ0xPU0VfUE9MSUNZX1JFUVVFU1RfQ0FOQ0VMID0gMyxcbn1cblxuY2hlY2tFeHRlbmRzPGNvcmVzZGsuY2hpbGRfd29ya2Zsb3cuUGFyZW50Q2xvc2VQb2xpY3ksIFBhcmVudENsb3NlUG9saWN5PigpO1xuY2hlY2tFeHRlbmRzPFBhcmVudENsb3NlUG9saWN5LCBjb3Jlc2RrLmNoaWxkX3dvcmtmbG93LlBhcmVudENsb3NlUG9saWN5PigpO1xuXG5leHBvcnQgaW50ZXJmYWNlIENoaWxkV29ya2Zsb3dPcHRpb25zIGV4dGVuZHMgQ29tbW9uV29ya2Zsb3dPcHRpb25zIHtcbiAgLyoqXG4gICAqIFdvcmtmbG93IGlkIHRvIHVzZSB3aGVuIHN0YXJ0aW5nLiBJZiBub3Qgc3BlY2lmaWVkIGEgVVVJRCBpcyBnZW5lcmF0ZWQuIE5vdGUgdGhhdCBpdCBpc1xuICAgKiBkYW5nZXJvdXMgYXMgaW4gY2FzZSBvZiBjbGllbnQgc2lkZSByZXRyaWVzIG5vIGRlZHVwbGljYXRpb24gd2lsbCBoYXBwZW4gYmFzZWQgb24gdGhlXG4gICAqIGdlbmVyYXRlZCBpZC4gU28gcHJlZmVyIGFzc2lnbmluZyBidXNpbmVzcyBtZWFuaW5nZnVsIGlkcyBpZiBwb3NzaWJsZS5cbiAgICovXG4gIHdvcmtmbG93SWQ/OiBzdHJpbmc7XG5cbiAgLyoqXG4gICAqIFRhc2sgcXVldWUgdG8gdXNlIGZvciBXb3JrZmxvdyB0YXNrcy4gSXQgc2hvdWxkIG1hdGNoIGEgdGFzayBxdWV1ZSBzcGVjaWZpZWQgd2hlbiBjcmVhdGluZyBhXG4gICAqIGBXb3JrZXJgIHRoYXQgaG9zdHMgdGhlIFdvcmtmbG93IGNvZGUuXG4gICAqL1xuICB0YXNrUXVldWU/OiBzdHJpbmc7XG5cbiAgLyoqXG4gICAqIFNwZWNpZmllczpcbiAgICogLSB3aGV0aGVyIGNhbmNlbGxhdGlvbiByZXF1ZXN0cyBhcmUgc2VudCB0byB0aGUgQ2hpbGRcbiAgICogLSB3aGV0aGVyIGFuZCB3aGVuIGFuIGVycm9yIGlzIHRocm93biBmcm9tIHtAbGluayBleGVjdXRlQ2hpbGR9IG9yXG4gICAqICAge0BsaW5rIENoaWxkV29ya2Zsb3dIYW5kbGUucmVzdWx0fVxuICAgKlxuICAgKiBAZGVmYXVsdCB7QGxpbmsgQ2hpbGRXb3JrZmxvd0NhbmNlbGxhdGlvblR5cGUuV0FJVF9DQU5DRUxMQVRJT05fQ09NUExFVEVEfVxuICAgKi9cbiAgY2FuY2VsbGF0aW9uVHlwZT86IENoaWxkV29ya2Zsb3dDYW5jZWxsYXRpb25UeXBlO1xuXG4gIC8qKlxuICAgKiBTcGVjaWZpZXMgaG93IHRoZSBDaGlsZCByZWFjdHMgdG8gdGhlIFBhcmVudCBXb3JrZmxvdyByZWFjaGluZyBhIENsb3NlZCBzdGF0ZS5cbiAgICpcbiAgICogQGRlZmF1bHQge0BsaW5rIFBhcmVudENsb3NlUG9saWN5LlBBUkVOVF9DTE9TRV9QT0xJQ1lfVEVSTUlOQVRFfVxuICAgKi9cbiAgcGFyZW50Q2xvc2VQb2xpY3k/OiBQYXJlbnRDbG9zZVBvbGljeTtcblxuICAvKipcbiAgICogV2hlbiB1c2luZyB0aGUgV29ya2VyIFZlcnNpb25pbmcgZmVhdHVyZSwgc3BlY2lmaWVzIHdoZXRoZXIgdGhpcyBDaGlsZCBXb3JrZmxvdyBzaG91bGQgcnVuIG9uXG4gICAqIGEgd29ya2VyIHdpdGggYSBjb21wYXRpYmxlIEJ1aWxkIElkIG9yIG5vdC4gU2VlIHtAbGluayBWZXJzaW9uaW5nSW50ZW50fS5cbiAgICpcbiAgICogQGRlZmF1bHQgJ0NPTVBBVElCTEUnXG4gICAqXG4gICAqIEBleHBlcmltZW50YWxcbiAgICovXG4gIHZlcnNpb25pbmdJbnRlbnQ/OiBWZXJzaW9uaW5nSW50ZW50O1xufVxuXG5leHBvcnQgdHlwZSBSZXF1aXJlZENoaWxkV29ya2Zsb3dPcHRpb25zID0gUmVxdWlyZWQ8UGljazxDaGlsZFdvcmtmbG93T3B0aW9ucywgJ3dvcmtmbG93SWQnIHwgJ2NhbmNlbGxhdGlvblR5cGUnPj4gJiB7XG4gIGFyZ3M6IHVua25vd25bXTtcbn07XG5cbmV4cG9ydCB0eXBlIENoaWxkV29ya2Zsb3dPcHRpb25zV2l0aERlZmF1bHRzID0gQ2hpbGRXb3JrZmxvd09wdGlvbnMgJiBSZXF1aXJlZENoaWxkV29ya2Zsb3dPcHRpb25zO1xuXG5leHBvcnQgaW50ZXJmYWNlIFNES0luZm8ge1xuICBuYW1lOiBzdHJpbmc7XG4gIHZlcnNpb246IHN0cmluZztcbn1cblxuLyoqXG4gKiBSZXByZXNlbnRzIGEgc2xpY2Ugb2YgYSBmaWxlIHN0YXJ0aW5nIGF0IGxpbmVPZmZzZXRcbiAqL1xuZXhwb3J0IGludGVyZmFjZSBGaWxlU2xpY2Uge1xuICAvKipcbiAgICogc2xpY2Ugb2YgYSBmaWxlIHdpdGggYFxcbmAgKG5ld2xpbmUpIGxpbmUgdGVybWluYXRvci5cbiAgICovXG4gIGNvbnRlbnQ6IHN0cmluZztcbiAgLyoqXG4gICAqIE9ubHkgdXNlZCBwb3NzaWJsZSB0byB0cmltIHRoZSBmaWxlIHdpdGhvdXQgYnJlYWtpbmcgc3ludGF4IGhpZ2hsaWdodGluZy5cbiAgICovXG4gIGxpbmVPZmZzZXQ6IG51bWJlcjtcbn1cblxuLyoqXG4gKiBBIHBvaW50ZXIgdG8gYSBsb2NhdGlvbiBpbiBhIGZpbGVcbiAqL1xuZXhwb3J0IGludGVyZmFjZSBGaWxlTG9jYXRpb24ge1xuICAvKipcbiAgICogUGF0aCB0byBzb3VyY2UgZmlsZSAoYWJzb2x1dGUgb3IgcmVsYXRpdmUpLlxuICAgKiBXaGVuIHVzaW5nIGEgcmVsYXRpdmUgcGF0aCwgbWFrZSBzdXJlIGFsbCBwYXRocyBhcmUgcmVsYXRpdmUgdG8gdGhlIHNhbWUgcm9vdC5cbiAgICovXG4gIGZpbGVQYXRoPzogc3RyaW5nO1xuICAvKipcbiAgICogSWYgcG9zc2libGUsIFNESyBzaG91bGQgc2VuZCB0aGlzLCByZXF1aXJlZCBmb3IgZGlzcGxheWluZyB0aGUgY29kZSBsb2NhdGlvbi5cbiAgICovXG4gIGxpbmU/OiBudW1iZXI7XG4gIC8qKlxuICAgKiBJZiBwb3NzaWJsZSwgU0RLIHNob3VsZCBzZW5kIHRoaXMuXG4gICAqL1xuICBjb2x1bW4/OiBudW1iZXI7XG4gIC8qKlxuICAgKiBGdW5jdGlvbiBuYW1lIHRoaXMgbGluZSBiZWxvbmdzIHRvIChpZiBhcHBsaWNhYmxlKS5cbiAgICogVXNlZCBmb3IgZmFsbGluZyBiYWNrIHRvIHN0YWNrIHRyYWNlIHZpZXcuXG4gICAqL1xuICBmdW5jdGlvbk5hbWU/OiBzdHJpbmc7XG59XG5cbmV4cG9ydCBpbnRlcmZhY2UgU3RhY2tUcmFjZSB7XG4gIGxvY2F0aW9uczogRmlsZUxvY2F0aW9uW107XG59XG5cbi8qKlxuICogVXNlZCBhcyB0aGUgcmVzdWx0IGZvciB0aGUgZW5oYW5jZWQgc3RhY2sgdHJhY2UgcXVlcnlcbiAqL1xuZXhwb3J0IGludGVyZmFjZSBFbmhhbmNlZFN0YWNrVHJhY2Uge1xuICBzZGs6IFNES0luZm87XG4gIC8qKlxuICAgKiBNYXBwaW5nIG9mIGZpbGUgcGF0aCB0byBmaWxlIGNvbnRlbnRzLlxuICAgKiBTREsgbWF5IGNob29zZSB0byBzZW5kIG5vLCBzb21lIG9yIGFsbCBzb3VyY2VzLlxuICAgKiBTb3VyY2VzIG1pZ2h0IGJlIHRyaW1tZWQsIGFuZCBzb21lIHRpbWUgb25seSB0aGUgZmlsZShzKSBvZiB0aGUgdG9wIGVsZW1lbnQgb2YgdGhlIHRyYWNlIHdpbGwgYmUgc2VudC5cbiAgICovXG4gIHNvdXJjZXM6IFJlY29yZDxzdHJpbmcsIEZpbGVTbGljZVtdPjtcbiAgc3RhY2tzOiBTdGFja1RyYWNlW107XG59XG5cbmV4cG9ydCBpbnRlcmZhY2UgV29ya2Zsb3dDcmVhdGVPcHRpb25zIHtcbiAgaW5mbzogV29ya2Zsb3dJbmZvO1xuICByYW5kb21uZXNzU2VlZDogbnVtYmVyW107XG4gIG5vdzogbnVtYmVyO1xuICBwYXRjaGVzOiBzdHJpbmdbXTtcbiAgc2hvd1N0YWNrVHJhY2VTb3VyY2VzOiBib29sZWFuO1xufVxuXG5leHBvcnQgaW50ZXJmYWNlIFdvcmtmbG93Q3JlYXRlT3B0aW9uc0ludGVybmFsIGV4dGVuZHMgV29ya2Zsb3dDcmVhdGVPcHRpb25zIHtcbiAgc291cmNlTWFwOiBSYXdTb3VyY2VNYXA7XG4gIHJlZ2lzdGVyZWRBY3Rpdml0eU5hbWVzOiBTZXQ8c3RyaW5nPjtcbiAgZ2V0VGltZU9mRGF5KCk6IGJpZ2ludDtcbn1cblxuLyoqXG4gKiBBIGhhbmRsZXIgZnVuY3Rpb24gY2FwYWJsZSBvZiBhY2NlcHRpbmcgdGhlIGFyZ3VtZW50cyBmb3IgYSBnaXZlbiBVcGRhdGVEZWZpbml0aW9uLCBTaWduYWxEZWZpbml0aW9uIG9yIFF1ZXJ5RGVmaW5pdGlvbi5cbiAqL1xuZXhwb3J0IHR5cGUgSGFuZGxlcjxcbiAgUmV0LFxuICBBcmdzIGV4dGVuZHMgYW55W10sXG4gIFQgZXh0ZW5kcyBVcGRhdGVEZWZpbml0aW9uPFJldCwgQXJncz4gfCBTaWduYWxEZWZpbml0aW9uPEFyZ3M+IHwgUXVlcnlEZWZpbml0aW9uPFJldCwgQXJncz4sXG4+ID0gVCBleHRlbmRzIFVwZGF0ZURlZmluaXRpb248aW5mZXIgUiwgaW5mZXIgQT5cbiAgPyAoLi4uYXJnczogQSkgPT4gUiB8IFByb21pc2U8Uj5cbiAgOiBUIGV4dGVuZHMgU2lnbmFsRGVmaW5pdGlvbjxpbmZlciBBPlxuICAgID8gKC4uLmFyZ3M6IEEpID0+IHZvaWQgfCBQcm9taXNlPHZvaWQ+XG4gICAgOiBUIGV4dGVuZHMgUXVlcnlEZWZpbml0aW9uPGluZmVyIFIsIGluZmVyIEE+XG4gICAgICA/ICguLi5hcmdzOiBBKSA9PiBSXG4gICAgICA6IG5ldmVyO1xuXG4vKipcbiAqIEEgaGFuZGxlciBmdW5jdGlvbiBhY2NlcHRpbmcgc2lnbmFsIGNhbGxzIGZvciBub24tcmVnaXN0ZXJlZCBzaWduYWwgbmFtZXMuXG4gKi9cbmV4cG9ydCB0eXBlIERlZmF1bHRTaWduYWxIYW5kbGVyID0gKHNpZ25hbE5hbWU6IHN0cmluZywgLi4uYXJnczogdW5rbm93bltdKSA9PiB2b2lkIHwgUHJvbWlzZTx2b2lkPjtcblxuLyoqXG4gKiBBIHZhbGlkYXRpb24gZnVuY3Rpb24gY2FwYWJsZSBvZiBhY2NlcHRpbmcgdGhlIGFyZ3VtZW50cyBmb3IgYSBnaXZlbiBVcGRhdGVEZWZpbml0aW9uLlxuICovXG5leHBvcnQgdHlwZSBVcGRhdGVWYWxpZGF0b3I8QXJncyBleHRlbmRzIGFueVtdPiA9ICguLi5hcmdzOiBBcmdzKSA9PiB2b2lkO1xuXG4vKipcbiAqIEEgZGVzY3JpcHRpb24gb2YgYSBxdWVyeSBoYW5kbGVyLlxuICovXG5leHBvcnQgdHlwZSBRdWVyeUhhbmRsZXJPcHRpb25zID0geyBkZXNjcmlwdGlvbj86IHN0cmluZyB9O1xuXG4vKipcbiAqIEEgZGVzY3JpcHRpb24gb2YgYSBzaWduYWwgaGFuZGxlci5cbiAqL1xuZXhwb3J0IHR5cGUgU2lnbmFsSGFuZGxlck9wdGlvbnMgPSB7IGRlc2NyaXB0aW9uPzogc3RyaW5nIH07XG5cbi8qKlxuICogQSB2YWxpZGF0b3IgYW5kIGRlc2NyaXB0aW9uIG9mIGFuIHVwZGF0ZSBoYW5kbGVyLlxuICovXG5leHBvcnQgdHlwZSBVcGRhdGVIYW5kbGVyT3B0aW9uczxBcmdzIGV4dGVuZHMgYW55W10+ID0geyB2YWxpZGF0b3I/OiBVcGRhdGVWYWxpZGF0b3I8QXJncz47IGRlc2NyaXB0aW9uPzogc3RyaW5nIH07XG4iLCJpbXBvcnQgdHlwZSB7IFJhd1NvdXJjZU1hcCB9IGZyb20gJ3NvdXJjZS1tYXAnO1xuaW1wb3J0IHtcbiAgZGVmYXVsdEZhaWx1cmVDb252ZXJ0ZXIsXG4gIEZhaWx1cmVDb252ZXJ0ZXIsXG4gIFBheWxvYWRDb252ZXJ0ZXIsXG4gIGFycmF5RnJvbVBheWxvYWRzLFxuICBkZWZhdWx0UGF5bG9hZENvbnZlcnRlcixcbiAgZW5zdXJlVGVtcG9yYWxGYWlsdXJlLFxuICBJbGxlZ2FsU3RhdGVFcnJvcixcbiAgVGVtcG9yYWxGYWlsdXJlLFxuICBXb3JrZmxvdyxcbiAgV29ya2Zsb3dFeGVjdXRpb25BbHJlYWR5U3RhcnRlZEVycm9yLFxuICBXb3JrZmxvd1F1ZXJ5QW5ub3RhdGVkVHlwZSxcbiAgV29ya2Zsb3dTaWduYWxBbm5vdGF0ZWRUeXBlLFxuICBXb3JrZmxvd1VwZGF0ZUFubm90YXRlZFR5cGUsXG4gIFByb3RvRmFpbHVyZSxcbiAgQXBwbGljYXRpb25GYWlsdXJlLFxufSBmcm9tICdAdGVtcG9yYWxpby9jb21tb24nO1xuaW1wb3J0IHsgY29tcG9zZUludGVyY2VwdG9ycyB9IGZyb20gJ0B0ZW1wb3JhbGlvL2NvbW1vbi9saWIvaW50ZXJjZXB0b3JzJztcbmltcG9ydCB7IGNoZWNrRXh0ZW5kcyB9IGZyb20gJ0B0ZW1wb3JhbGlvL2NvbW1vbi9saWIvdHlwZS1oZWxwZXJzJztcbmltcG9ydCB0eXBlIHsgY29yZXNkaywgdGVtcG9yYWwgfSBmcm9tICdAdGVtcG9yYWxpby9wcm90byc7XG5pbXBvcnQgeyBhbGVhLCBSTkcgfSBmcm9tICcuL2FsZWEnO1xuaW1wb3J0IHsgUm9vdENhbmNlbGxhdGlvblNjb3BlIH0gZnJvbSAnLi9jYW5jZWxsYXRpb24tc2NvcGUnO1xuaW1wb3J0IHsgRGV0ZXJtaW5pc21WaW9sYXRpb25FcnJvciwgTG9jYWxBY3Rpdml0eURvQmFja29mZiwgaXNDYW5jZWxsYXRpb24gfSBmcm9tICcuL2Vycm9ycyc7XG5pbXBvcnQgeyBRdWVyeUlucHV0LCBTaWduYWxJbnB1dCwgVXBkYXRlSW5wdXQsIFdvcmtmbG93RXhlY3V0ZUlucHV0LCBXb3JrZmxvd0ludGVyY2VwdG9ycyB9IGZyb20gJy4vaW50ZXJjZXB0b3JzJztcbmltcG9ydCB7XG4gIENvbnRpbnVlQXNOZXcsXG4gIERlZmF1bHRTaWduYWxIYW5kbGVyLFxuICBTREtJbmZvLFxuICBGaWxlU2xpY2UsXG4gIEVuaGFuY2VkU3RhY2tUcmFjZSxcbiAgRmlsZUxvY2F0aW9uLFxuICBXb3JrZmxvd0luZm8sXG4gIFdvcmtmbG93Q3JlYXRlT3B0aW9uc0ludGVybmFsLFxufSBmcm9tICcuL2ludGVyZmFjZXMnO1xuaW1wb3J0IHsgdHlwZSBTaW5rQ2FsbCB9IGZyb20gJy4vc2lua3MnO1xuaW1wb3J0IHsgdW50cmFja1Byb21pc2UgfSBmcm9tICcuL3N0YWNrLWhlbHBlcnMnO1xuaW1wb3J0IHBrZyBmcm9tICcuL3BrZyc7XG5pbXBvcnQgeyBleGVjdXRlV2l0aExpZmVjeWNsZUxvZ2dpbmcgfSBmcm9tICcuL2xvZ3MnO1xuXG5lbnVtIFN0YXJ0Q2hpbGRXb3JrZmxvd0V4ZWN1dGlvbkZhaWxlZENhdXNlIHtcbiAgU1RBUlRfQ0hJTERfV09SS0ZMT1dfRVhFQ1VUSU9OX0ZBSUxFRF9DQVVTRV9VTlNQRUNJRklFRCA9IDAsXG4gIFNUQVJUX0NISUxEX1dPUktGTE9XX0VYRUNVVElPTl9GQUlMRURfQ0FVU0VfV09SS0ZMT1dfQUxSRUFEWV9FWElTVFMgPSAxLFxufVxuXG5jaGVja0V4dGVuZHM8Y29yZXNkay5jaGlsZF93b3JrZmxvdy5TdGFydENoaWxkV29ya2Zsb3dFeGVjdXRpb25GYWlsZWRDYXVzZSwgU3RhcnRDaGlsZFdvcmtmbG93RXhlY3V0aW9uRmFpbGVkQ2F1c2U+KCk7XG5jaGVja0V4dGVuZHM8U3RhcnRDaGlsZFdvcmtmbG93RXhlY3V0aW9uRmFpbGVkQ2F1c2UsIGNvcmVzZGsuY2hpbGRfd29ya2Zsb3cuU3RhcnRDaGlsZFdvcmtmbG93RXhlY3V0aW9uRmFpbGVkQ2F1c2U+KCk7XG5cbmV4cG9ydCBpbnRlcmZhY2UgU3RhY2sge1xuICBmb3JtYXR0ZWQ6IHN0cmluZztcbiAgc3RydWN0dXJlZDogRmlsZUxvY2F0aW9uW107XG59XG5cbi8qKlxuICogR2xvYmFsIHN0b3JlIHRvIHRyYWNrIHByb21pc2Ugc3RhY2tzIGZvciBzdGFjayB0cmFjZSBxdWVyeVxuICovXG5leHBvcnQgaW50ZXJmYWNlIFByb21pc2VTdGFja1N0b3JlIHtcbiAgY2hpbGRUb1BhcmVudDogTWFwPFByb21pc2U8dW5rbm93bj4sIFNldDxQcm9taXNlPHVua25vd24+Pj47XG4gIHByb21pc2VUb1N0YWNrOiBNYXA8UHJvbWlzZTx1bmtub3duPiwgU3RhY2s+O1xufVxuXG5leHBvcnQgaW50ZXJmYWNlIENvbXBsZXRpb24ge1xuICByZXNvbHZlKHZhbDogdW5rbm93bik6IHVua25vd247XG4gIHJlamVjdChyZWFzb246IHVua25vd24pOiB1bmtub3duO1xufVxuXG5leHBvcnQgaW50ZXJmYWNlIENvbmRpdGlvbiB7XG4gIGZuKCk6IGJvb2xlYW47XG4gIHJlc29sdmUoKTogdm9pZDtcbn1cblxuZXhwb3J0IHR5cGUgQWN0aXZhdGlvbkhhbmRsZXJGdW5jdGlvbjxLIGV4dGVuZHMga2V5b2YgY29yZXNkay53b3JrZmxvd19hY3RpdmF0aW9uLklXb3JrZmxvd0FjdGl2YXRpb25Kb2I+ID0gKFxuICBhY3RpdmF0aW9uOiBOb25OdWxsYWJsZTxjb3Jlc2RrLndvcmtmbG93X2FjdGl2YXRpb24uSVdvcmtmbG93QWN0aXZhdGlvbkpvYltLXT5cbikgPT4gdm9pZDtcblxuLyoqXG4gKiBWZXJpZmllcyBhbGwgYWN0aXZhdGlvbiBqb2IgaGFuZGxpbmcgbWV0aG9kcyBhcmUgaW1wbGVtZW50ZWRcbiAqL1xuZXhwb3J0IHR5cGUgQWN0aXZhdGlvbkhhbmRsZXIgPSB7XG4gIFtQIGluIGtleW9mIGNvcmVzZGsud29ya2Zsb3dfYWN0aXZhdGlvbi5JV29ya2Zsb3dBY3RpdmF0aW9uSm9iXTogQWN0aXZhdGlvbkhhbmRsZXJGdW5jdGlvbjxQPjtcbn07XG5cbi8qKlxuICogS2VlcHMgYWxsIG9mIHRoZSBXb3JrZmxvdyBydW50aW1lIHN0YXRlIGxpa2UgcGVuZGluZyBjb21wbGV0aW9ucyBmb3IgYWN0aXZpdGllcyBhbmQgdGltZXJzLlxuICpcbiAqIEltcGxlbWVudHMgaGFuZGxlcnMgZm9yIGFsbCB3b3JrZmxvdyBhY3RpdmF0aW9uIGpvYnMuXG4gKi9cbmV4cG9ydCBjbGFzcyBBY3RpdmF0b3IgaW1wbGVtZW50cyBBY3RpdmF0aW9uSGFuZGxlciB7XG4gIC8qKlxuICAgKiBDYWNoZSBmb3IgbW9kdWxlcyAtIHJlZmVyZW5jZWQgaW4gcmV1c2FibGUtdm0udHNcbiAgICovXG4gIHJlYWRvbmx5IG1vZHVsZUNhY2hlID0gbmV3IE1hcDxzdHJpbmcsIHVua25vd24+KCk7XG4gIC8qKlxuICAgKiBNYXAgb2YgdGFzayBzZXF1ZW5jZSB0byBhIENvbXBsZXRpb25cbiAgICovXG4gIHJlYWRvbmx5IGNvbXBsZXRpb25zID0ge1xuICAgIHRpbWVyOiBuZXcgTWFwPG51bWJlciwgQ29tcGxldGlvbj4oKSxcbiAgICBhY3Rpdml0eTogbmV3IE1hcDxudW1iZXIsIENvbXBsZXRpb24+KCksXG4gICAgY2hpbGRXb3JrZmxvd1N0YXJ0OiBuZXcgTWFwPG51bWJlciwgQ29tcGxldGlvbj4oKSxcbiAgICBjaGlsZFdvcmtmbG93Q29tcGxldGU6IG5ldyBNYXA8bnVtYmVyLCBDb21wbGV0aW9uPigpLFxuICAgIHNpZ25hbFdvcmtmbG93OiBuZXcgTWFwPG51bWJlciwgQ29tcGxldGlvbj4oKSxcbiAgICBjYW5jZWxXb3JrZmxvdzogbmV3IE1hcDxudW1iZXIsIENvbXBsZXRpb24+KCksXG4gIH07XG5cbiAgLyoqXG4gICAqIEhvbGRzIGJ1ZmZlcmVkIFVwZGF0ZSBjYWxscyB1bnRpbCBhIGhhbmRsZXIgaXMgcmVnaXN0ZXJlZFxuICAgKi9cbiAgcmVhZG9ubHkgYnVmZmVyZWRVcGRhdGVzID0gQXJyYXk8Y29yZXNkay53b3JrZmxvd19hY3RpdmF0aW9uLklEb1VwZGF0ZT4oKTtcblxuICAvKipcbiAgICogSG9sZHMgYnVmZmVyZWQgc2lnbmFsIGNhbGxzIHVudGlsIGEgaGFuZGxlciBpcyByZWdpc3RlcmVkXG4gICAqL1xuICByZWFkb25seSBidWZmZXJlZFNpZ25hbHMgPSBBcnJheTxjb3Jlc2RrLndvcmtmbG93X2FjdGl2YXRpb24uSVNpZ25hbFdvcmtmbG93PigpO1xuXG4gIC8qKlxuICAgKiBIb2xkcyBidWZmZXJlZCBxdWVyeSBjYWxscyB1bnRpbCBhIGhhbmRsZXIgaXMgcmVnaXN0ZXJlZC5cbiAgICpcbiAgICogKipJTVBPUlRBTlQqKiBxdWVyaWVzIGFyZSBvbmx5IGJ1ZmZlcmVkIHVudGlsIHdvcmtmbG93IGlzIHN0YXJ0ZWQuXG4gICAqIFRoaXMgaXMgcmVxdWlyZWQgYmVjYXVzZSBhc3luYyBpbnRlcmNlcHRvcnMgbWlnaHQgYmxvY2sgd29ya2Zsb3cgZnVuY3Rpb24gaW52b2NhdGlvblxuICAgKiB3aGljaCBkZWxheXMgcXVlcnkgaGFuZGxlciByZWdpc3RyYXRpb24uXG4gICAqL1xuICBwcm90ZWN0ZWQgcmVhZG9ubHkgYnVmZmVyZWRRdWVyaWVzID0gQXJyYXk8Y29yZXNkay53b3JrZmxvd19hY3RpdmF0aW9uLklRdWVyeVdvcmtmbG93PigpO1xuXG4gIC8qKlxuICAgKiBNYXBwaW5nIG9mIHVwZGF0ZSBuYW1lIHRvIGhhbmRsZXIgYW5kIHZhbGlkYXRvclxuICAgKi9cbiAgcmVhZG9ubHkgdXBkYXRlSGFuZGxlcnMgPSBuZXcgTWFwPHN0cmluZywgV29ya2Zsb3dVcGRhdGVBbm5vdGF0ZWRUeXBlPigpO1xuXG4gIC8qKlxuICAgKiBNYXBwaW5nIG9mIHNpZ25hbCBuYW1lIHRvIGhhbmRsZXJcbiAgICovXG4gIHJlYWRvbmx5IHNpZ25hbEhhbmRsZXJzID0gbmV3IE1hcDxzdHJpbmcsIFdvcmtmbG93U2lnbmFsQW5ub3RhdGVkVHlwZT4oKTtcblxuICAvKipcbiAgICogQSBzaWduYWwgaGFuZGxlciB0aGF0IGNhdGNoZXMgY2FsbHMgZm9yIG5vbi1yZWdpc3RlcmVkIHNpZ25hbCBuYW1lcy5cbiAgICovXG4gIGRlZmF1bHRTaWduYWxIYW5kbGVyPzogRGVmYXVsdFNpZ25hbEhhbmRsZXI7XG5cbiAgLyoqXG4gICAqIFNvdXJjZSBtYXAgZmlsZSBmb3IgbG9va2luZyB1cCB0aGUgc291cmNlIGZpbGVzIGluIHJlc3BvbnNlIHRvIF9fZW5oYW5jZWRfc3RhY2tfdHJhY2VcbiAgICovXG4gIHByb3RlY3RlZCByZWFkb25seSBzb3VyY2VNYXA6IFJhd1NvdXJjZU1hcDtcblxuICAvKipcbiAgICogV2hldGhlciBvciBub3QgdG8gc2VuZCB0aGUgc291cmNlcyBpbiBlbmhhbmNlZCBzdGFjayB0cmFjZSBxdWVyeSByZXNwb25zZXNcbiAgICovXG4gIHByb3RlY3RlZCByZWFkb25seSBzaG93U3RhY2tUcmFjZVNvdXJjZXM7XG5cbiAgcmVhZG9ubHkgcHJvbWlzZVN0YWNrU3RvcmU6IFByb21pc2VTdGFja1N0b3JlID0ge1xuICAgIHByb21pc2VUb1N0YWNrOiBuZXcgTWFwKCksXG4gICAgY2hpbGRUb1BhcmVudDogbmV3IE1hcCgpLFxuICB9O1xuXG4gIHB1YmxpYyByZWFkb25seSByb290U2NvcGUgPSBuZXcgUm9vdENhbmNlbGxhdGlvblNjb3BlKCk7XG5cbiAgLyoqXG4gICAqIE1hcHBpbmcgb2YgcXVlcnkgbmFtZSB0byBoYW5kbGVyXG4gICAqL1xuICBwdWJsaWMgcmVhZG9ubHkgcXVlcnlIYW5kbGVycyA9IG5ldyBNYXA8c3RyaW5nLCBXb3JrZmxvd1F1ZXJ5QW5ub3RhdGVkVHlwZT4oW1xuICAgIFtcbiAgICAgICdfX3N0YWNrX3RyYWNlJyxcbiAgICAgIHtcbiAgICAgICAgaGFuZGxlcjogKCkgPT4ge1xuICAgICAgICAgIHJldHVybiB0aGlzLmdldFN0YWNrVHJhY2VzKClcbiAgICAgICAgICAgIC5tYXAoKHMpID0+IHMuZm9ybWF0dGVkKVxuICAgICAgICAgICAgLmpvaW4oJ1xcblxcbicpO1xuICAgICAgICB9LFxuICAgICAgICBkZXNjcmlwdGlvbjogJ1JldHVybnMgYSBzZW5zaWJsZSBzdGFjayB0cmFjZS4nLFxuICAgICAgfSxcbiAgICBdLFxuICAgIFtcbiAgICAgICdfX2VuaGFuY2VkX3N0YWNrX3RyYWNlJyxcbiAgICAgIHtcbiAgICAgICAgaGFuZGxlcjogKCk6IEVuaGFuY2VkU3RhY2tUcmFjZSA9PiB7XG4gICAgICAgICAgY29uc3QgeyBzb3VyY2VNYXAgfSA9IHRoaXM7XG4gICAgICAgICAgY29uc3Qgc2RrOiBTREtJbmZvID0geyBuYW1lOiAndHlwZXNjcmlwdCcsIHZlcnNpb246IHBrZy52ZXJzaW9uIH07XG4gICAgICAgICAgY29uc3Qgc3RhY2tzID0gdGhpcy5nZXRTdGFja1RyYWNlcygpLm1hcCgoeyBzdHJ1Y3R1cmVkOiBsb2NhdGlvbnMgfSkgPT4gKHsgbG9jYXRpb25zIH0pKTtcbiAgICAgICAgICBjb25zdCBzb3VyY2VzOiBSZWNvcmQ8c3RyaW5nLCBGaWxlU2xpY2VbXT4gPSB7fTtcbiAgICAgICAgICBpZiAodGhpcy5zaG93U3RhY2tUcmFjZVNvdXJjZXMpIHtcbiAgICAgICAgICAgIGZvciAoY29uc3QgeyBsb2NhdGlvbnMgfSBvZiBzdGFja3MpIHtcbiAgICAgICAgICAgICAgZm9yIChjb25zdCB7IGZpbGVQYXRoIH0gb2YgbG9jYXRpb25zKSB7XG4gICAgICAgICAgICAgICAgaWYgKCFmaWxlUGF0aCkgY29udGludWU7XG4gICAgICAgICAgICAgICAgY29uc3QgY29udGVudCA9IHNvdXJjZU1hcD8uc291cmNlc0NvbnRlbnQ/Lltzb3VyY2VNYXA/LnNvdXJjZXMuaW5kZXhPZihmaWxlUGF0aCldO1xuICAgICAgICAgICAgICAgIGlmICghY29udGVudCkgY29udGludWU7XG4gICAgICAgICAgICAgICAgc291cmNlc1tmaWxlUGF0aF0gPSBbXG4gICAgICAgICAgICAgICAgICB7XG4gICAgICAgICAgICAgICAgICAgIGNvbnRlbnQsXG4gICAgICAgICAgICAgICAgICAgIGxpbmVPZmZzZXQ6IDAsXG4gICAgICAgICAgICAgICAgICB9LFxuICAgICAgICAgICAgICAgIF07XG4gICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9XG4gICAgICAgICAgcmV0dXJuIHsgc2RrLCBzdGFja3MsIHNvdXJjZXMgfTtcbiAgICAgICAgfSxcbiAgICAgICAgZGVzY3JpcHRpb246ICdSZXR1cm5zIGEgc3RhY2sgdHJhY2UgYW5ub3RhdGVkIHdpdGggc291cmNlIGluZm9ybWF0aW9uLicsXG4gICAgICB9LFxuICAgIF0sXG4gICAgW1xuICAgICAgJ19fdGVtcG9yYWxfd29ya2Zsb3dfbWV0YWRhdGEnLFxuICAgICAge1xuICAgICAgICBoYW5kbGVyOiAoKTogdGVtcG9yYWwuYXBpLnNkay52MS5JV29ya2Zsb3dNZXRhZGF0YSA9PiB7XG4gICAgICAgICAgY29uc3Qgd29ya2Zsb3dUeXBlID0gdGhpcy5pbmZvLndvcmtmbG93VHlwZTtcbiAgICAgICAgICBjb25zdCBxdWVyeURlZmluaXRpb25zID0gQXJyYXkuZnJvbSh0aGlzLnF1ZXJ5SGFuZGxlcnMuZW50cmllcygpKS5tYXAoKFtuYW1lLCB2YWx1ZV0pID0+ICh7XG4gICAgICAgICAgICBuYW1lLFxuICAgICAgICAgICAgZGVzY3JpcHRpb246IHZhbHVlLmRlc2NyaXB0aW9uLFxuICAgICAgICAgIH0pKTtcbiAgICAgICAgICBjb25zdCBzaWduYWxEZWZpbml0aW9ucyA9IEFycmF5LmZyb20odGhpcy5zaWduYWxIYW5kbGVycy5lbnRyaWVzKCkpLm1hcCgoW25hbWUsIHZhbHVlXSkgPT4gKHtcbiAgICAgICAgICAgIG5hbWUsXG4gICAgICAgICAgICBkZXNjcmlwdGlvbjogdmFsdWUuZGVzY3JpcHRpb24sXG4gICAgICAgICAgfSkpO1xuICAgICAgICAgIGNvbnN0IHVwZGF0ZURlZmluaXRpb25zID0gQXJyYXkuZnJvbSh0aGlzLnVwZGF0ZUhhbmRsZXJzLmVudHJpZXMoKSkubWFwKChbbmFtZSwgdmFsdWVdKSA9PiAoe1xuICAgICAgICAgICAgbmFtZSxcbiAgICAgICAgICAgIGRlc2NyaXB0aW9uOiB2YWx1ZS5kZXNjcmlwdGlvbixcbiAgICAgICAgICB9KSk7XG4gICAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICAgIGRlZmluaXRpb246IHtcbiAgICAgICAgICAgICAgdHlwZTogd29ya2Zsb3dUeXBlLFxuICAgICAgICAgICAgICBkZXNjcmlwdGlvbjogbnVsbCwgLy8gRm9yIG5vdywgZG8gbm90IHNldCB0aGUgd29ya2Zsb3cgZGVzY3JpcHRpb24gaW4gdGhlIFRTIFNESy5cbiAgICAgICAgICAgICAgcXVlcnlEZWZpbml0aW9ucyxcbiAgICAgICAgICAgICAgc2lnbmFsRGVmaW5pdGlvbnMsXG4gICAgICAgICAgICAgIHVwZGF0ZURlZmluaXRpb25zLFxuICAgICAgICAgICAgfSxcbiAgICAgICAgICB9O1xuICAgICAgICB9LFxuICAgICAgICBkZXNjcmlwdGlvbjogJ1JldHVybnMgbWV0YWRhdGEgYXNzb2NpYXRlZCB3aXRoIHRoaXMgd29ya2Zsb3cuJyxcbiAgICAgIH0sXG4gICAgXSxcbiAgXSk7XG5cbiAgLyoqXG4gICAqIExvYWRlZCBpbiB7QGxpbmsgaW5pdFJ1bnRpbWV9XG4gICAqL1xuICBwdWJsaWMgcmVhZG9ubHkgaW50ZXJjZXB0b3JzOiBSZXF1aXJlZDxXb3JrZmxvd0ludGVyY2VwdG9ycz4gPSB7IGluYm91bmQ6IFtdLCBvdXRib3VuZDogW10sIGludGVybmFsczogW10gfTtcblxuICAvKipcbiAgICogQnVmZmVyIHRoYXQgc3RvcmVzIGFsbCBnZW5lcmF0ZWQgY29tbWFuZHMsIHJlc2V0IGFmdGVyIGVhY2ggYWN0aXZhdGlvblxuICAgKi9cbiAgcHJvdGVjdGVkIGNvbW1hbmRzOiBjb3Jlc2RrLndvcmtmbG93X2NvbW1hbmRzLklXb3JrZmxvd0NvbW1hbmRbXSA9IFtdO1xuXG4gIC8qKlxuICAgKiBTdG9yZXMgYWxsIHtAbGluayBjb25kaXRpb259cyB0aGF0IGhhdmVuJ3QgYmVlbiB1bmJsb2NrZWQgeWV0XG4gICAqL1xuICBwdWJsaWMgcmVhZG9ubHkgYmxvY2tlZENvbmRpdGlvbnMgPSBuZXcgTWFwPG51bWJlciwgQ29uZGl0aW9uPigpO1xuXG4gIC8qKlxuICAgKiBJcyB0aGlzIFdvcmtmbG93IGNvbXBsZXRlZD9cbiAgICpcbiAgICogQSBXb3JrZmxvdyB3aWxsIGJlIGNvbnNpZGVyZWQgY29tcGxldGVkIGlmIGl0IGdlbmVyYXRlcyBhIGNvbW1hbmQgdGhhdCB0aGVcbiAgICogc3lzdGVtIGNvbnNpZGVycyBhcyBhIGZpbmFsIFdvcmtmbG93IGNvbW1hbmQgKGUuZy5cbiAgICogY29tcGxldGVXb3JrZmxvd0V4ZWN1dGlvbiBvciBmYWlsV29ya2Zsb3dFeGVjdXRpb24pLlxuICAgKi9cbiAgcHVibGljIGNvbXBsZXRlZCA9IGZhbHNlO1xuXG4gIC8qKlxuICAgKiBXYXMgdGhpcyBXb3JrZmxvdyBjYW5jZWxsZWQ/XG4gICAqL1xuICBwcm90ZWN0ZWQgY2FuY2VsbGVkID0gZmFsc2U7XG5cbiAgLyoqXG4gICAqIFRoaXMgaXMgdHJhY2tlZCB0byBhbGxvdyBidWZmZXJpbmcgcXVlcmllcyB1bnRpbCBhIHdvcmtmbG93IGZ1bmN0aW9uIGlzIGNhbGxlZC5cbiAgICogVE9ETyhiZXJndW5keSk6IEkgZG9uJ3QgdGhpbmsgdGhpcyBtYWtlcyBzZW5zZSBzaW5jZSBxdWVyaWVzIHJ1biBsYXN0IGluIGFuIGFjdGl2YXRpb24gYW5kIG11c3QgYmUgcmVzcG9uZGVkIHRvIGluXG4gICAqIHRoZSBzYW1lIGFjdGl2YXRpb24uXG4gICAqL1xuICBwcm90ZWN0ZWQgd29ya2Zsb3dGdW5jdGlvbldhc0NhbGxlZCA9IGZhbHNlO1xuXG4gIC8qKlxuICAgKiBUaGUgbmV4dCAoaW5jcmVtZW50YWwpIHNlcXVlbmNlIHRvIGFzc2lnbiB3aGVuIGdlbmVyYXRpbmcgY29tcGxldGFibGUgY29tbWFuZHNcbiAgICovXG4gIHB1YmxpYyBuZXh0U2VxcyA9IHtcbiAgICB0aW1lcjogMSxcbiAgICBhY3Rpdml0eTogMSxcbiAgICBjaGlsZFdvcmtmbG93OiAxLFxuICAgIHNpZ25hbFdvcmtmbG93OiAxLFxuICAgIGNhbmNlbFdvcmtmbG93OiAxLFxuICAgIGNvbmRpdGlvbjogMSxcbiAgICAvLyBVc2VkIGludGVybmFsbHkgdG8ga2VlcCB0cmFjayBvZiBhY3RpdmUgc3RhY2sgdHJhY2VzXG4gICAgc3RhY2s6IDEsXG4gIH07XG5cbiAgLyoqXG4gICAqIFRoaXMgaXMgc2V0IGV2ZXJ5IHRpbWUgdGhlIHdvcmtmbG93IGV4ZWN1dGVzIGFuIGFjdGl2YXRpb25cbiAgICovXG4gIG5vdzogbnVtYmVyO1xuXG4gIC8qKlxuICAgKiBSZWZlcmVuY2UgdG8gdGhlIGN1cnJlbnQgV29ya2Zsb3csIGluaXRpYWxpemVkIHdoZW4gYSBXb3JrZmxvdyBpcyBzdGFydGVkXG4gICAqL1xuICBwdWJsaWMgd29ya2Zsb3c/OiBXb3JrZmxvdztcblxuICAvKipcbiAgICogSW5mb3JtYXRpb24gYWJvdXQgdGhlIGN1cnJlbnQgV29ya2Zsb3dcbiAgICovXG4gIHB1YmxpYyBpbmZvOiBXb3JrZmxvd0luZm87XG5cbiAgLyoqXG4gICAqIEEgZGV0ZXJtaW5pc3RpYyBSTkcsIHVzZWQgYnkgdGhlIGlzb2xhdGUncyBvdmVycmlkZGVuIE1hdGgucmFuZG9tXG4gICAqL1xuICBwdWJsaWMgcmFuZG9tOiBSTkc7XG5cbiAgcHVibGljIHBheWxvYWRDb252ZXJ0ZXI6IFBheWxvYWRDb252ZXJ0ZXIgPSBkZWZhdWx0UGF5bG9hZENvbnZlcnRlcjtcbiAgcHVibGljIGZhaWx1cmVDb252ZXJ0ZXI6IEZhaWx1cmVDb252ZXJ0ZXIgPSBkZWZhdWx0RmFpbHVyZUNvbnZlcnRlcjtcblxuICAvKipcbiAgICogUGF0Y2hlcyB3ZSBrbm93IHRoZSBzdGF0dXMgb2YgZm9yIHRoaXMgd29ya2Zsb3csIGFzIGluIHtAbGluayBwYXRjaGVkfVxuICAgKi9cbiAgcHVibGljIHJlYWRvbmx5IGtub3duUHJlc2VudFBhdGNoZXMgPSBuZXcgU2V0PHN0cmluZz4oKTtcblxuICAvKipcbiAgICogUGF0Y2hlcyB3ZSBzZW50IHRvIGNvcmUge0BsaW5rIHBhdGNoZWR9XG4gICAqL1xuICBwdWJsaWMgcmVhZG9ubHkgc2VudFBhdGNoZXMgPSBuZXcgU2V0PHN0cmluZz4oKTtcblxuICAvKipcbiAgICogQnVmZmVyZWQgc2luayBjYWxscyBwZXIgYWN0aXZhdGlvblxuICAgKi9cbiAgc2lua0NhbGxzID0gQXJyYXk8U2lua0NhbGw+KCk7XG5cbiAgLyoqXG4gICAqIEEgbmFub3NlY29uZCByZXNvbHV0aW9uIHRpbWUgZnVuY3Rpb24sIGV4dGVybmFsbHkgaW5qZWN0ZWRcbiAgICovXG4gIHB1YmxpYyByZWFkb25seSBnZXRUaW1lT2ZEYXk6ICgpID0+IGJpZ2ludDtcblxuICBwdWJsaWMgcmVhZG9ubHkgcmVnaXN0ZXJlZEFjdGl2aXR5TmFtZXM6IFNldDxzdHJpbmc+O1xuXG4gIGNvbnN0cnVjdG9yKHtcbiAgICBpbmZvLFxuICAgIG5vdyxcbiAgICBzaG93U3RhY2tUcmFjZVNvdXJjZXMsXG4gICAgc291cmNlTWFwLFxuICAgIGdldFRpbWVPZkRheSxcbiAgICByYW5kb21uZXNzU2VlZCxcbiAgICBwYXRjaGVzLFxuICAgIHJlZ2lzdGVyZWRBY3Rpdml0eU5hbWVzLFxuICB9OiBXb3JrZmxvd0NyZWF0ZU9wdGlvbnNJbnRlcm5hbCkge1xuICAgIHRoaXMuZ2V0VGltZU9mRGF5ID0gZ2V0VGltZU9mRGF5O1xuICAgIHRoaXMuaW5mbyA9IGluZm87XG4gICAgdGhpcy5ub3cgPSBub3c7XG4gICAgdGhpcy5zaG93U3RhY2tUcmFjZVNvdXJjZXMgPSBzaG93U3RhY2tUcmFjZVNvdXJjZXM7XG4gICAgdGhpcy5zb3VyY2VNYXAgPSBzb3VyY2VNYXA7XG4gICAgdGhpcy5yYW5kb20gPSBhbGVhKHJhbmRvbW5lc3NTZWVkKTtcbiAgICB0aGlzLnJlZ2lzdGVyZWRBY3Rpdml0eU5hbWVzID0gcmVnaXN0ZXJlZEFjdGl2aXR5TmFtZXM7XG5cbiAgICBpZiAoaW5mby51bnNhZmUuaXNSZXBsYXlpbmcpIHtcbiAgICAgIGZvciAoY29uc3QgcGF0Y2hJZCBvZiBwYXRjaGVzKSB7XG4gICAgICAgIHRoaXMubm90aWZ5SGFzUGF0Y2goeyBwYXRjaElkIH0pO1xuICAgICAgfVxuICAgIH1cbiAgfVxuXG4gIG11dGF0ZVdvcmtmbG93SW5mbyhmbjogKGluZm86IFdvcmtmbG93SW5mbykgPT4gV29ya2Zsb3dJbmZvKTogdm9pZCB7XG4gICAgdGhpcy5pbmZvID0gZm4odGhpcy5pbmZvKTtcbiAgfVxuXG4gIHByb3RlY3RlZCBnZXRTdGFja1RyYWNlcygpOiBTdGFja1tdIHtcbiAgICBjb25zdCB7IGNoaWxkVG9QYXJlbnQsIHByb21pc2VUb1N0YWNrIH0gPSB0aGlzLnByb21pc2VTdGFja1N0b3JlO1xuICAgIGNvbnN0IGludGVybmFsTm9kZXMgPSBbLi4uY2hpbGRUb1BhcmVudC52YWx1ZXMoKV0ucmVkdWNlKChhY2MsIGN1cnIpID0+IHtcbiAgICAgIGZvciAoY29uc3QgcCBvZiBjdXJyKSB7XG4gICAgICAgIGFjYy5hZGQocCk7XG4gICAgICB9XG4gICAgICByZXR1cm4gYWNjO1xuICAgIH0sIG5ldyBTZXQoKSk7XG4gICAgY29uc3Qgc3RhY2tzID0gbmV3IE1hcDxzdHJpbmcsIFN0YWNrPigpO1xuICAgIGZvciAoY29uc3QgY2hpbGQgb2YgY2hpbGRUb1BhcmVudC5rZXlzKCkpIHtcbiAgICAgIGlmICghaW50ZXJuYWxOb2Rlcy5oYXMoY2hpbGQpKSB7XG4gICAgICAgIGNvbnN0IHN0YWNrID0gcHJvbWlzZVRvU3RhY2suZ2V0KGNoaWxkKTtcbiAgICAgICAgaWYgKCFzdGFjayB8fCAhc3RhY2suZm9ybWF0dGVkKSBjb250aW51ZTtcbiAgICAgICAgc3RhY2tzLnNldChzdGFjay5mb3JtYXR0ZWQsIHN0YWNrKTtcbiAgICAgIH1cbiAgICB9XG4gICAgLy8gTm90IDEwMCUgc3VyZSB3aGVyZSB0aGlzIGNvbWVzIGZyb20sIGp1c3QgZmlsdGVyIGl0IG91dFxuICAgIHN0YWNrcy5kZWxldGUoJyAgICBhdCBQcm9taXNlLnRoZW4gKDxhbm9ueW1vdXM+KScpO1xuICAgIHN0YWNrcy5kZWxldGUoJyAgICBhdCBQcm9taXNlLnRoZW4gKDxhbm9ueW1vdXM+KVxcbicpO1xuICAgIHJldHVybiBbLi4uc3RhY2tzXS5tYXAoKFtfLCBzdGFja10pID0+IHN0YWNrKTtcbiAgfVxuXG4gIGdldEFuZFJlc2V0U2lua0NhbGxzKCk6IFNpbmtDYWxsW10ge1xuICAgIGNvbnN0IHsgc2lua0NhbGxzIH0gPSB0aGlzO1xuICAgIHRoaXMuc2lua0NhbGxzID0gW107XG4gICAgcmV0dXJuIHNpbmtDYWxscztcbiAgfVxuXG4gIC8qKlxuICAgKiBCdWZmZXIgYSBXb3JrZmxvdyBjb21tYW5kIHRvIGJlIGNvbGxlY3RlZCBhdCB0aGUgZW5kIG9mIHRoZSBjdXJyZW50IGFjdGl2YXRpb24uXG4gICAqXG4gICAqIFByZXZlbnRzIGNvbW1hbmRzIGZyb20gYmVpbmcgYWRkZWQgYWZ0ZXIgV29ya2Zsb3cgY29tcGxldGlvbi5cbiAgICovXG4gIHB1c2hDb21tYW5kKGNtZDogY29yZXNkay53b3JrZmxvd19jb21tYW5kcy5JV29ya2Zsb3dDb21tYW5kLCBjb21wbGV0ZSA9IGZhbHNlKTogdm9pZCB7XG4gICAgLy8gT25seSBxdWVyeSByZXNwb25zZXMgbWF5IGJlIHNlbnQgYWZ0ZXIgY29tcGxldGlvblxuICAgIGlmICh0aGlzLmNvbXBsZXRlZCAmJiAhY21kLnJlc3BvbmRUb1F1ZXJ5KSByZXR1cm47XG4gICAgdGhpcy5jb21tYW5kcy5wdXNoKGNtZCk7XG4gICAgaWYgKGNvbXBsZXRlKSB7XG4gICAgICB0aGlzLmNvbXBsZXRlZCA9IHRydWU7XG4gICAgfVxuICB9XG5cbiAgZ2V0QW5kUmVzZXRDb21tYW5kcygpOiBjb3Jlc2RrLndvcmtmbG93X2NvbW1hbmRzLklXb3JrZmxvd0NvbW1hbmRbXSB7XG4gICAgY29uc3QgY29tbWFuZHMgPSB0aGlzLmNvbW1hbmRzO1xuICAgIHRoaXMuY29tbWFuZHMgPSBbXTtcbiAgICByZXR1cm4gY29tbWFuZHM7XG4gIH1cblxuICBwdWJsaWMgYXN5bmMgc3RhcnRXb3JrZmxvd05leHRIYW5kbGVyKHsgYXJncyB9OiBXb3JrZmxvd0V4ZWN1dGVJbnB1dCk6IFByb21pc2U8YW55PiB7XG4gICAgY29uc3QgeyB3b3JrZmxvdyB9ID0gdGhpcztcbiAgICBpZiAod29ya2Zsb3cgPT09IHVuZGVmaW5lZCkge1xuICAgICAgdGhyb3cgbmV3IElsbGVnYWxTdGF0ZUVycm9yKCdXb3JrZmxvdyB1bmluaXRpYWxpemVkJyk7XG4gICAgfVxuICAgIGxldCBwcm9taXNlOiBQcm9taXNlPGFueT47XG4gICAgdHJ5IHtcbiAgICAgIHByb21pc2UgPSB3b3JrZmxvdyguLi5hcmdzKTtcbiAgICB9IGZpbmFsbHkge1xuICAgICAgLy8gUXVlcmllcyBtdXN0IGJlIGhhbmRsZWQgZXZlbiBpZiB0aGVyZSB3YXMgYW4gZXhjZXB0aW9uIHdoZW4gaW52b2tpbmcgdGhlIFdvcmtmbG93IGZ1bmN0aW9uLlxuICAgICAgdGhpcy53b3JrZmxvd0Z1bmN0aW9uV2FzQ2FsbGVkID0gdHJ1ZTtcbiAgICAgIC8vIEVtcHR5IHRoZSBidWZmZXJcbiAgICAgIGNvbnN0IGJ1ZmZlciA9IHRoaXMuYnVmZmVyZWRRdWVyaWVzLnNwbGljZSgwKTtcbiAgICAgIGZvciAoY29uc3QgYWN0aXZhdGlvbiBvZiBidWZmZXIpIHtcbiAgICAgICAgdGhpcy5xdWVyeVdvcmtmbG93KGFjdGl2YXRpb24pO1xuICAgICAgfVxuICAgIH1cbiAgICByZXR1cm4gYXdhaXQgcHJvbWlzZTtcbiAgfVxuXG4gIHB1YmxpYyBzdGFydFdvcmtmbG93KGFjdGl2YXRpb246IGNvcmVzZGsud29ya2Zsb3dfYWN0aXZhdGlvbi5JU3RhcnRXb3JrZmxvdyk6IHZvaWQge1xuICAgIGNvbnN0IGV4ZWN1dGUgPSBjb21wb3NlSW50ZXJjZXB0b3JzKHRoaXMuaW50ZXJjZXB0b3JzLmluYm91bmQsICdleGVjdXRlJywgdGhpcy5zdGFydFdvcmtmbG93TmV4dEhhbmRsZXIuYmluZCh0aGlzKSk7XG5cbiAgICB1bnRyYWNrUHJvbWlzZShcbiAgICAgIGV4ZWN1dGVXaXRoTGlmZWN5Y2xlTG9nZ2luZygoKSA9PlxuICAgICAgICBleGVjdXRlKHtcbiAgICAgICAgICBoZWFkZXJzOiBhY3RpdmF0aW9uLmhlYWRlcnMgPz8ge30sXG4gICAgICAgICAgYXJnczogYXJyYXlGcm9tUGF5bG9hZHModGhpcy5wYXlsb2FkQ29udmVydGVyLCBhY3RpdmF0aW9uLmFyZ3VtZW50cyksXG4gICAgICAgIH0pXG4gICAgICApLnRoZW4odGhpcy5jb21wbGV0ZVdvcmtmbG93LmJpbmQodGhpcyksIHRoaXMuaGFuZGxlV29ya2Zsb3dGYWlsdXJlLmJpbmQodGhpcykpXG4gICAgKTtcbiAgfVxuXG4gIHB1YmxpYyBjYW5jZWxXb3JrZmxvdyhfYWN0aXZhdGlvbjogY29yZXNkay53b3JrZmxvd19hY3RpdmF0aW9uLklDYW5jZWxXb3JrZmxvdyk6IHZvaWQge1xuICAgIHRoaXMuY2FuY2VsbGVkID0gdHJ1ZTtcbiAgICB0aGlzLnJvb3RTY29wZS5jYW5jZWwoKTtcbiAgfVxuXG4gIHB1YmxpYyBmaXJlVGltZXIoYWN0aXZhdGlvbjogY29yZXNkay53b3JrZmxvd19hY3RpdmF0aW9uLklGaXJlVGltZXIpOiB2b2lkIHtcbiAgICAvLyBUaW1lcnMgYXJlIGEgc3BlY2lhbCBjYXNlIHdoZXJlIHRoZWlyIGNvbXBsZXRpb24gbWlnaHQgbm90IGJlIGluIFdvcmtmbG93IHN0YXRlLFxuICAgIC8vIHRoaXMgaXMgZHVlIHRvIGltbWVkaWF0ZSB0aW1lciBjYW5jZWxsYXRpb24gdGhhdCBkb2Vzbid0IGdvIHdhaXQgZm9yIENvcmUuXG4gICAgY29uc3QgY29tcGxldGlvbiA9IHRoaXMubWF5YmVDb25zdW1lQ29tcGxldGlvbigndGltZXInLCBnZXRTZXEoYWN0aXZhdGlvbikpO1xuICAgIGNvbXBsZXRpb24/LnJlc29sdmUodW5kZWZpbmVkKTtcbiAgfVxuXG4gIHB1YmxpYyByZXNvbHZlQWN0aXZpdHkoYWN0aXZhdGlvbjogY29yZXNkay53b3JrZmxvd19hY3RpdmF0aW9uLklSZXNvbHZlQWN0aXZpdHkpOiB2b2lkIHtcbiAgICBpZiAoIWFjdGl2YXRpb24ucmVzdWx0KSB7XG4gICAgICB0aHJvdyBuZXcgVHlwZUVycm9yKCdHb3QgUmVzb2x2ZUFjdGl2aXR5IGFjdGl2YXRpb24gd2l0aCBubyByZXN1bHQnKTtcbiAgICB9XG4gICAgY29uc3QgeyByZXNvbHZlLCByZWplY3QgfSA9IHRoaXMuY29uc3VtZUNvbXBsZXRpb24oJ2FjdGl2aXR5JywgZ2V0U2VxKGFjdGl2YXRpb24pKTtcbiAgICBpZiAoYWN0aXZhdGlvbi5yZXN1bHQuY29tcGxldGVkKSB7XG4gICAgICBjb25zdCBjb21wbGV0ZWQgPSBhY3RpdmF0aW9uLnJlc3VsdC5jb21wbGV0ZWQ7XG4gICAgICBjb25zdCByZXN1bHQgPSBjb21wbGV0ZWQucmVzdWx0ID8gdGhpcy5wYXlsb2FkQ29udmVydGVyLmZyb21QYXlsb2FkKGNvbXBsZXRlZC5yZXN1bHQpIDogdW5kZWZpbmVkO1xuICAgICAgcmVzb2x2ZShyZXN1bHQpO1xuICAgIH0gZWxzZSBpZiAoYWN0aXZhdGlvbi5yZXN1bHQuZmFpbGVkKSB7XG4gICAgICBjb25zdCB7IGZhaWx1cmUgfSA9IGFjdGl2YXRpb24ucmVzdWx0LmZhaWxlZDtcbiAgICAgIGNvbnN0IGVyciA9IGZhaWx1cmUgPyB0aGlzLmZhaWx1cmVUb0Vycm9yKGZhaWx1cmUpIDogdW5kZWZpbmVkO1xuICAgICAgcmVqZWN0KGVycik7XG4gICAgfSBlbHNlIGlmIChhY3RpdmF0aW9uLnJlc3VsdC5jYW5jZWxsZWQpIHtcbiAgICAgIGNvbnN0IHsgZmFpbHVyZSB9ID0gYWN0aXZhdGlvbi5yZXN1bHQuY2FuY2VsbGVkO1xuICAgICAgY29uc3QgZXJyID0gZmFpbHVyZSA/IHRoaXMuZmFpbHVyZVRvRXJyb3IoZmFpbHVyZSkgOiB1bmRlZmluZWQ7XG4gICAgICByZWplY3QoZXJyKTtcbiAgICB9IGVsc2UgaWYgKGFjdGl2YXRpb24ucmVzdWx0LmJhY2tvZmYpIHtcbiAgICAgIHJlamVjdChuZXcgTG9jYWxBY3Rpdml0eURvQmFja29mZihhY3RpdmF0aW9uLnJlc3VsdC5iYWNrb2ZmKSk7XG4gICAgfVxuICB9XG5cbiAgcHVibGljIHJlc29sdmVDaGlsZFdvcmtmbG93RXhlY3V0aW9uU3RhcnQoXG4gICAgYWN0aXZhdGlvbjogY29yZXNkay53b3JrZmxvd19hY3RpdmF0aW9uLklSZXNvbHZlQ2hpbGRXb3JrZmxvd0V4ZWN1dGlvblN0YXJ0XG4gICk6IHZvaWQge1xuICAgIGNvbnN0IHsgcmVzb2x2ZSwgcmVqZWN0IH0gPSB0aGlzLmNvbnN1bWVDb21wbGV0aW9uKCdjaGlsZFdvcmtmbG93U3RhcnQnLCBnZXRTZXEoYWN0aXZhdGlvbikpO1xuICAgIGlmIChhY3RpdmF0aW9uLnN1Y2NlZWRlZCkge1xuICAgICAgcmVzb2x2ZShhY3RpdmF0aW9uLnN1Y2NlZWRlZC5ydW5JZCk7XG4gICAgfSBlbHNlIGlmIChhY3RpdmF0aW9uLmZhaWxlZCkge1xuICAgICAgaWYgKFxuICAgICAgICBhY3RpdmF0aW9uLmZhaWxlZC5jYXVzZSAhPT1cbiAgICAgICAgU3RhcnRDaGlsZFdvcmtmbG93RXhlY3V0aW9uRmFpbGVkQ2F1c2UuU1RBUlRfQ0hJTERfV09SS0ZMT1dfRVhFQ1VUSU9OX0ZBSUxFRF9DQVVTRV9XT1JLRkxPV19BTFJFQURZX0VYSVNUU1xuICAgICAgKSB7XG4gICAgICAgIHRocm93IG5ldyBJbGxlZ2FsU3RhdGVFcnJvcignR290IHVua25vd24gU3RhcnRDaGlsZFdvcmtmbG93RXhlY3V0aW9uRmFpbGVkQ2F1c2UnKTtcbiAgICAgIH1cbiAgICAgIGlmICghKGFjdGl2YXRpb24uc2VxICYmIGFjdGl2YXRpb24uZmFpbGVkLndvcmtmbG93SWQgJiYgYWN0aXZhdGlvbi5mYWlsZWQud29ya2Zsb3dUeXBlKSkge1xuICAgICAgICB0aHJvdyBuZXcgVHlwZUVycm9yKCdNaXNzaW5nIGF0dHJpYnV0ZXMgaW4gYWN0aXZhdGlvbiBqb2InKTtcbiAgICAgIH1cbiAgICAgIHJlamVjdChcbiAgICAgICAgbmV3IFdvcmtmbG93RXhlY3V0aW9uQWxyZWFkeVN0YXJ0ZWRFcnJvcihcbiAgICAgICAgICAnV29ya2Zsb3cgZXhlY3V0aW9uIGFscmVhZHkgc3RhcnRlZCcsXG4gICAgICAgICAgYWN0aXZhdGlvbi5mYWlsZWQud29ya2Zsb3dJZCxcbiAgICAgICAgICBhY3RpdmF0aW9uLmZhaWxlZC53b3JrZmxvd1R5cGVcbiAgICAgICAgKVxuICAgICAgKTtcbiAgICB9IGVsc2UgaWYgKGFjdGl2YXRpb24uY2FuY2VsbGVkKSB7XG4gICAgICBpZiAoIWFjdGl2YXRpb24uY2FuY2VsbGVkLmZhaWx1cmUpIHtcbiAgICAgICAgdGhyb3cgbmV3IFR5cGVFcnJvcignR290IG5vIGZhaWx1cmUgaW4gY2FuY2VsbGVkIHZhcmlhbnQnKTtcbiAgICAgIH1cbiAgICAgIHJlamVjdCh0aGlzLmZhaWx1cmVUb0Vycm9yKGFjdGl2YXRpb24uY2FuY2VsbGVkLmZhaWx1cmUpKTtcbiAgICB9IGVsc2Uge1xuICAgICAgdGhyb3cgbmV3IFR5cGVFcnJvcignR290IFJlc29sdmVDaGlsZFdvcmtmbG93RXhlY3V0aW9uU3RhcnQgd2l0aCBubyBzdGF0dXMnKTtcbiAgICB9XG4gIH1cblxuICBwdWJsaWMgcmVzb2x2ZUNoaWxkV29ya2Zsb3dFeGVjdXRpb24oYWN0aXZhdGlvbjogY29yZXNkay53b3JrZmxvd19hY3RpdmF0aW9uLklSZXNvbHZlQ2hpbGRXb3JrZmxvd0V4ZWN1dGlvbik6IHZvaWQge1xuICAgIGlmICghYWN0aXZhdGlvbi5yZXN1bHQpIHtcbiAgICAgIHRocm93IG5ldyBUeXBlRXJyb3IoJ0dvdCBSZXNvbHZlQ2hpbGRXb3JrZmxvd0V4ZWN1dGlvbiBhY3RpdmF0aW9uIHdpdGggbm8gcmVzdWx0Jyk7XG4gICAgfVxuICAgIGNvbnN0IHsgcmVzb2x2ZSwgcmVqZWN0IH0gPSB0aGlzLmNvbnN1bWVDb21wbGV0aW9uKCdjaGlsZFdvcmtmbG93Q29tcGxldGUnLCBnZXRTZXEoYWN0aXZhdGlvbikpO1xuICAgIGlmIChhY3RpdmF0aW9uLnJlc3VsdC5jb21wbGV0ZWQpIHtcbiAgICAgIGNvbnN0IGNvbXBsZXRlZCA9IGFjdGl2YXRpb24ucmVzdWx0LmNvbXBsZXRlZDtcbiAgICAgIGNvbnN0IHJlc3VsdCA9IGNvbXBsZXRlZC5yZXN1bHQgPyB0aGlzLnBheWxvYWRDb252ZXJ0ZXIuZnJvbVBheWxvYWQoY29tcGxldGVkLnJlc3VsdCkgOiB1bmRlZmluZWQ7XG4gICAgICByZXNvbHZlKHJlc3VsdCk7XG4gICAgfSBlbHNlIGlmIChhY3RpdmF0aW9uLnJlc3VsdC5mYWlsZWQpIHtcbiAgICAgIGNvbnN0IHsgZmFpbHVyZSB9ID0gYWN0aXZhdGlvbi5yZXN1bHQuZmFpbGVkO1xuICAgICAgaWYgKGZhaWx1cmUgPT09IHVuZGVmaW5lZCB8fCBmYWlsdXJlID09PSBudWxsKSB7XG4gICAgICAgIHRocm93IG5ldyBUeXBlRXJyb3IoJ0dvdCBmYWlsZWQgcmVzdWx0IHdpdGggbm8gZmFpbHVyZSBhdHRyaWJ1dGUnKTtcbiAgICAgIH1cbiAgICAgIHJlamVjdCh0aGlzLmZhaWx1cmVUb0Vycm9yKGZhaWx1cmUpKTtcbiAgICB9IGVsc2UgaWYgKGFjdGl2YXRpb24ucmVzdWx0LmNhbmNlbGxlZCkge1xuICAgICAgY29uc3QgeyBmYWlsdXJlIH0gPSBhY3RpdmF0aW9uLnJlc3VsdC5jYW5jZWxsZWQ7XG4gICAgICBpZiAoZmFpbHVyZSA9PT0gdW5kZWZpbmVkIHx8IGZhaWx1cmUgPT09IG51bGwpIHtcbiAgICAgICAgdGhyb3cgbmV3IFR5cGVFcnJvcignR290IGNhbmNlbGxlZCByZXN1bHQgd2l0aCBubyBmYWlsdXJlIGF0dHJpYnV0ZScpO1xuICAgICAgfVxuICAgICAgcmVqZWN0KHRoaXMuZmFpbHVyZVRvRXJyb3IoZmFpbHVyZSkpO1xuICAgIH1cbiAgfVxuXG4gIC8vIEludGVudGlvbmFsbHkgbm9uLWFzeW5jIGZ1bmN0aW9uIHNvIHRoaXMgaGFuZGxlciBkb2Vzbid0IHNob3cgdXAgaW4gdGhlIHN0YWNrIHRyYWNlXG4gIHByb3RlY3RlZCBxdWVyeVdvcmtmbG93TmV4dEhhbmRsZXIoeyBxdWVyeU5hbWUsIGFyZ3MgfTogUXVlcnlJbnB1dCk6IFByb21pc2U8dW5rbm93bj4ge1xuICAgIGNvbnN0IGZuID0gdGhpcy5xdWVyeUhhbmRsZXJzLmdldChxdWVyeU5hbWUpPy5oYW5kbGVyO1xuICAgIGlmIChmbiA9PT0gdW5kZWZpbmVkKSB7XG4gICAgICBjb25zdCBrbm93blF1ZXJ5VHlwZXMgPSBbLi4udGhpcy5xdWVyeUhhbmRsZXJzLmtleXMoKV0uam9pbignICcpO1xuICAgICAgLy8gRmFpbCB0aGUgcXVlcnlcbiAgICAgIHJldHVybiBQcm9taXNlLnJlamVjdChcbiAgICAgICAgbmV3IFJlZmVyZW5jZUVycm9yKFxuICAgICAgICAgIGBXb3JrZmxvdyBkaWQgbm90IHJlZ2lzdGVyIGEgaGFuZGxlciBmb3IgJHtxdWVyeU5hbWV9LiBSZWdpc3RlcmVkIHF1ZXJpZXM6IFske2tub3duUXVlcnlUeXBlc31dYFxuICAgICAgICApXG4gICAgICApO1xuICAgIH1cbiAgICB0cnkge1xuICAgICAgY29uc3QgcmV0ID0gZm4oLi4uYXJncyk7XG4gICAgICBpZiAocmV0IGluc3RhbmNlb2YgUHJvbWlzZSkge1xuICAgICAgICByZXR1cm4gUHJvbWlzZS5yZWplY3QobmV3IERldGVybWluaXNtVmlvbGF0aW9uRXJyb3IoJ1F1ZXJ5IGhhbmRsZXJzIHNob3VsZCBub3QgcmV0dXJuIGEgUHJvbWlzZScpKTtcbiAgICAgIH1cbiAgICAgIHJldHVybiBQcm9taXNlLnJlc29sdmUocmV0KTtcbiAgICB9IGNhdGNoIChlcnIpIHtcbiAgICAgIHJldHVybiBQcm9taXNlLnJlamVjdChlcnIpO1xuICAgIH1cbiAgfVxuXG4gIHB1YmxpYyBxdWVyeVdvcmtmbG93KGFjdGl2YXRpb246IGNvcmVzZGsud29ya2Zsb3dfYWN0aXZhdGlvbi5JUXVlcnlXb3JrZmxvdyk6IHZvaWQge1xuICAgIGlmICghdGhpcy53b3JrZmxvd0Z1bmN0aW9uV2FzQ2FsbGVkKSB7XG4gICAgICB0aGlzLmJ1ZmZlcmVkUXVlcmllcy5wdXNoKGFjdGl2YXRpb24pO1xuICAgICAgcmV0dXJuO1xuICAgIH1cblxuICAgIGNvbnN0IHsgcXVlcnlUeXBlLCBxdWVyeUlkLCBoZWFkZXJzIH0gPSBhY3RpdmF0aW9uO1xuICAgIGlmICghKHF1ZXJ5VHlwZSAmJiBxdWVyeUlkKSkge1xuICAgICAgdGhyb3cgbmV3IFR5cGVFcnJvcignTWlzc2luZyBxdWVyeSBhY3RpdmF0aW9uIGF0dHJpYnV0ZXMnKTtcbiAgICB9XG5cbiAgICBjb25zdCBleGVjdXRlID0gY29tcG9zZUludGVyY2VwdG9ycyhcbiAgICAgIHRoaXMuaW50ZXJjZXB0b3JzLmluYm91bmQsXG4gICAgICAnaGFuZGxlUXVlcnknLFxuICAgICAgdGhpcy5xdWVyeVdvcmtmbG93TmV4dEhhbmRsZXIuYmluZCh0aGlzKVxuICAgICk7XG4gICAgZXhlY3V0ZSh7XG4gICAgICBxdWVyeU5hbWU6IHF1ZXJ5VHlwZSxcbiAgICAgIGFyZ3M6IGFycmF5RnJvbVBheWxvYWRzKHRoaXMucGF5bG9hZENvbnZlcnRlciwgYWN0aXZhdGlvbi5hcmd1bWVudHMpLFxuICAgICAgcXVlcnlJZCxcbiAgICAgIGhlYWRlcnM6IGhlYWRlcnMgPz8ge30sXG4gICAgfSkudGhlbihcbiAgICAgIChyZXN1bHQpID0+IHRoaXMuY29tcGxldGVRdWVyeShxdWVyeUlkLCByZXN1bHQpLFxuICAgICAgKHJlYXNvbikgPT4gdGhpcy5mYWlsUXVlcnkocXVlcnlJZCwgcmVhc29uKVxuICAgICk7XG4gIH1cblxuICBwdWJsaWMgZG9VcGRhdGUoYWN0aXZhdGlvbjogY29yZXNkay53b3JrZmxvd19hY3RpdmF0aW9uLklEb1VwZGF0ZSk6IHZvaWQge1xuICAgIGNvbnN0IHsgaWQ6IHVwZGF0ZUlkLCBwcm90b2NvbEluc3RhbmNlSWQsIG5hbWUsIGhlYWRlcnMsIHJ1blZhbGlkYXRvciB9ID0gYWN0aXZhdGlvbjtcbiAgICBpZiAoIXVwZGF0ZUlkKSB7XG4gICAgICB0aHJvdyBuZXcgVHlwZUVycm9yKCdNaXNzaW5nIGFjdGl2YXRpb24gdXBkYXRlIGlkJyk7XG4gICAgfVxuICAgIGlmICghbmFtZSkge1xuICAgICAgdGhyb3cgbmV3IFR5cGVFcnJvcignTWlzc2luZyBhY3RpdmF0aW9uIHVwZGF0ZSBuYW1lJyk7XG4gICAgfVxuICAgIGlmICghcHJvdG9jb2xJbnN0YW5jZUlkKSB7XG4gICAgICB0aHJvdyBuZXcgVHlwZUVycm9yKCdNaXNzaW5nIGFjdGl2YXRpb24gdXBkYXRlIHByb3RvY29sSW5zdGFuY2VJZCcpO1xuICAgIH1cbiAgICBpZiAoIXRoaXMudXBkYXRlSGFuZGxlcnMuaGFzKG5hbWUpKSB7XG4gICAgICB0aGlzLmJ1ZmZlcmVkVXBkYXRlcy5wdXNoKGFjdGl2YXRpb24pO1xuICAgICAgcmV0dXJuO1xuICAgIH1cblxuICAgIGNvbnN0IG1ha2VJbnB1dCA9ICgpOiBVcGRhdGVJbnB1dCA9PiAoe1xuICAgICAgdXBkYXRlSWQsXG4gICAgICBhcmdzOiBhcnJheUZyb21QYXlsb2Fkcyh0aGlzLnBheWxvYWRDb252ZXJ0ZXIsIGFjdGl2YXRpb24uaW5wdXQpLFxuICAgICAgbmFtZSxcbiAgICAgIGhlYWRlcnM6IGhlYWRlcnMgPz8ge30sXG4gICAgfSk7XG5cbiAgICAvLyBUaGUgaW1wbGVtZW50YXRpb24gYmVsb3cgaXMgcmVzcG9uc2libGUgZm9yIHVwaG9sZGluZywgYW5kIGNvbnN0cmFpbmVkXG4gICAgLy8gYnksIHRoZSBmb2xsb3dpbmcgY29udHJhY3Q6XG4gICAgLy9cbiAgICAvLyAxLiBJZiBubyB2YWxpZGF0b3IgaXMgcHJlc2VudCB0aGVuIHZhbGlkYXRpb24gaW50ZXJjZXB0b3JzIHdpbGwgbm90IGJlIHJ1bi5cbiAgICAvL1xuICAgIC8vIDIuIER1cmluZyB2YWxpZGF0aW9uLCBhbnkgZXJyb3IgbXVzdCBmYWlsIHRoZSBVcGRhdGU7IGR1cmluZyB0aGUgVXBkYXRlXG4gICAgLy8gICAgaXRzZWxmLCBUZW1wb3JhbCBlcnJvcnMgZmFpbCB0aGUgVXBkYXRlIHdoZXJlYXMgb3RoZXIgZXJyb3JzIGZhaWwgdGhlXG4gICAgLy8gICAgYWN0aXZhdGlvbi5cbiAgICAvL1xuICAgIC8vIDMuIFRoZSBoYW5kbGVyIG11c3Qgbm90IHNlZSBhbnkgbXV0YXRpb25zIG9mIHRoZSBhcmd1bWVudHMgbWFkZSBieSB0aGVcbiAgICAvLyAgICB2YWxpZGF0b3IuXG4gICAgLy9cbiAgICAvLyA0LiBBbnkgZXJyb3Igd2hlbiBkZWNvZGluZy9kZXNlcmlhbGl6aW5nIGlucHV0IG11c3QgYmUgY2F1Z2h0IGFuZCByZXN1bHRcbiAgICAvLyAgICBpbiByZWplY3Rpb24gb2YgdGhlIFVwZGF0ZSBiZWZvcmUgaXQgaXMgYWNjZXB0ZWQsIGV2ZW4gaWYgdGhlcmUgaXMgbm9cbiAgICAvLyAgICB2YWxpZGF0b3IuXG4gICAgLy9cbiAgICAvLyA1LiBUaGUgaW5pdGlhbCBzeW5jaHJvbm91cyBwb3J0aW9uIG9mIHRoZSAoYXN5bmMpIFVwZGF0ZSBoYW5kbGVyIHNob3VsZFxuICAgIC8vICAgIGJlIGV4ZWN1dGVkIGFmdGVyIHRoZSAoc3luYykgdmFsaWRhdG9yIGNvbXBsZXRlcyBzdWNoIHRoYXQgdGhlcmUgaXNcbiAgICAvLyAgICBtaW5pbWFsIG9wcG9ydHVuaXR5IGZvciBhIGRpZmZlcmVudCBjb25jdXJyZW50IHRhc2sgdG8gYmUgc2NoZWR1bGVkXG4gICAgLy8gICAgYmV0d2VlbiB0aGVtLlxuICAgIC8vXG4gICAgLy8gNi4gVGhlIHN0YWNrIHRyYWNlIHZpZXcgcHJvdmlkZWQgaW4gdGhlIFRlbXBvcmFsIFVJIG11c3Qgbm90IGJlIHBvbGx1dGVkXG4gICAgLy8gICAgYnkgcHJvbWlzZXMgdGhhdCBkbyBub3QgZGVyaXZlIGZyb20gdXNlciBjb2RlLiBUaGlzIGltcGxpZXMgdGhhdFxuICAgIC8vICAgIGFzeW5jL2F3YWl0IHN5bnRheCBtYXkgbm90IGJlIHVzZWQuXG4gICAgLy9cbiAgICAvLyBOb3RlIHRoYXQgdGhlcmUgaXMgYSBkZWxpYmVyYXRlbHkgdW5oYW5kbGVkIHByb21pc2UgcmVqZWN0aW9uIGJlbG93LlxuICAgIC8vIFRoZXNlIGFyZSBjYXVnaHQgZWxzZXdoZXJlIGFuZCBmYWlsIHRoZSBjb3JyZXNwb25kaW5nIGFjdGl2YXRpb24uXG4gICAgbGV0IGlucHV0OiBVcGRhdGVJbnB1dDtcbiAgICB0cnkge1xuICAgICAgaWYgKHJ1blZhbGlkYXRvciAmJiB0aGlzLnVwZGF0ZUhhbmRsZXJzLmdldChuYW1lKT8udmFsaWRhdG9yKSB7XG4gICAgICAgIGNvbnN0IHZhbGlkYXRlID0gY29tcG9zZUludGVyY2VwdG9ycyhcbiAgICAgICAgICB0aGlzLmludGVyY2VwdG9ycy5pbmJvdW5kLFxuICAgICAgICAgICd2YWxpZGF0ZVVwZGF0ZScsXG4gICAgICAgICAgdGhpcy52YWxpZGF0ZVVwZGF0ZU5leHRIYW5kbGVyLmJpbmQodGhpcylcbiAgICAgICAgKTtcbiAgICAgICAgdmFsaWRhdGUobWFrZUlucHV0KCkpO1xuICAgICAgfVxuICAgICAgaW5wdXQgPSBtYWtlSW5wdXQoKTtcbiAgICB9IGNhdGNoIChlcnJvcikge1xuICAgICAgdGhpcy5yZWplY3RVcGRhdGUocHJvdG9jb2xJbnN0YW5jZUlkLCBlcnJvcik7XG4gICAgICByZXR1cm47XG4gICAgfVxuICAgIGNvbnN0IGV4ZWN1dGUgPSBjb21wb3NlSW50ZXJjZXB0b3JzKHRoaXMuaW50ZXJjZXB0b3JzLmluYm91bmQsICdoYW5kbGVVcGRhdGUnLCB0aGlzLnVwZGF0ZU5leHRIYW5kbGVyLmJpbmQodGhpcykpO1xuICAgIHRoaXMuYWNjZXB0VXBkYXRlKHByb3RvY29sSW5zdGFuY2VJZCk7XG4gICAgdW50cmFja1Byb21pc2UoXG4gICAgICBleGVjdXRlKGlucHV0KVxuICAgICAgICAudGhlbigocmVzdWx0KSA9PiB0aGlzLmNvbXBsZXRlVXBkYXRlKHByb3RvY29sSW5zdGFuY2VJZCwgcmVzdWx0KSlcbiAgICAgICAgLmNhdGNoKChlcnJvcikgPT4ge1xuICAgICAgICAgIGlmIChlcnJvciBpbnN0YW5jZW9mIFRlbXBvcmFsRmFpbHVyZSkge1xuICAgICAgICAgICAgdGhpcy5yZWplY3RVcGRhdGUocHJvdG9jb2xJbnN0YW5jZUlkLCBlcnJvcik7XG4gICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIHRocm93IGVycm9yO1xuICAgICAgICAgIH1cbiAgICAgICAgfSlcbiAgICApO1xuICB9XG5cbiAgcHJvdGVjdGVkIGFzeW5jIHVwZGF0ZU5leHRIYW5kbGVyKHsgbmFtZSwgYXJncyB9OiBVcGRhdGVJbnB1dCk6IFByb21pc2U8dW5rbm93bj4ge1xuICAgIGNvbnN0IGVudHJ5ID0gdGhpcy51cGRhdGVIYW5kbGVycy5nZXQobmFtZSk7XG4gICAgaWYgKCFlbnRyeSkge1xuICAgICAgcmV0dXJuIFByb21pc2UucmVqZWN0KG5ldyBJbGxlZ2FsU3RhdGVFcnJvcihgTm8gcmVnaXN0ZXJlZCB1cGRhdGUgaGFuZGxlciBmb3IgdXBkYXRlOiAke25hbWV9YCkpO1xuICAgIH1cbiAgICBjb25zdCB7IGhhbmRsZXIgfSA9IGVudHJ5O1xuICAgIHJldHVybiBhd2FpdCBoYW5kbGVyKC4uLmFyZ3MpO1xuICB9XG5cbiAgcHJvdGVjdGVkIHZhbGlkYXRlVXBkYXRlTmV4dEhhbmRsZXIoeyBuYW1lLCBhcmdzIH06IFVwZGF0ZUlucHV0KTogdm9pZCB7XG4gICAgY29uc3QgeyB2YWxpZGF0b3IgfSA9IHRoaXMudXBkYXRlSGFuZGxlcnMuZ2V0KG5hbWUpID8/IHt9O1xuICAgIGlmICh2YWxpZGF0b3IpIHtcbiAgICAgIHZhbGlkYXRvciguLi5hcmdzKTtcbiAgICB9XG4gIH1cblxuICBwdWJsaWMgZGlzcGF0Y2hCdWZmZXJlZFVwZGF0ZXMoKTogdm9pZCB7XG4gICAgY29uc3QgYnVmZmVyZWRVcGRhdGVzID0gdGhpcy5idWZmZXJlZFVwZGF0ZXM7XG4gICAgd2hpbGUgKGJ1ZmZlcmVkVXBkYXRlcy5sZW5ndGgpIHtcbiAgICAgIGNvbnN0IGZvdW5kSW5kZXggPSBidWZmZXJlZFVwZGF0ZXMuZmluZEluZGV4KCh1cGRhdGUpID0+IHRoaXMudXBkYXRlSGFuZGxlcnMuaGFzKHVwZGF0ZS5uYW1lIGFzIHN0cmluZykpO1xuICAgICAgaWYgKGZvdW5kSW5kZXggPT09IC0xKSB7XG4gICAgICAgIC8vIE5vIGJ1ZmZlcmVkIFVwZGF0ZXMgaGF2ZSBhIGhhbmRsZXIgeWV0LlxuICAgICAgICBicmVhaztcbiAgICAgIH1cbiAgICAgIGNvbnN0IFt1cGRhdGVdID0gYnVmZmVyZWRVcGRhdGVzLnNwbGljZShmb3VuZEluZGV4LCAxKTtcbiAgICAgIHRoaXMuZG9VcGRhdGUodXBkYXRlKTtcbiAgICB9XG4gIH1cblxuICBwdWJsaWMgcmVqZWN0QnVmZmVyZWRVcGRhdGVzKCk6IHZvaWQge1xuICAgIHdoaWxlICh0aGlzLmJ1ZmZlcmVkVXBkYXRlcy5sZW5ndGgpIHtcbiAgICAgIGNvbnN0IHVwZGF0ZSA9IHRoaXMuYnVmZmVyZWRVcGRhdGVzLnNoaWZ0KCk7XG4gICAgICBpZiAodXBkYXRlKSB7XG4gICAgICAgIHRoaXMucmVqZWN0VXBkYXRlKFxuICAgICAgICAgIC8qIGVzbGludC1kaXNhYmxlIEB0eXBlc2NyaXB0LWVzbGludC9uby1ub24tbnVsbC1hc3NlcnRpb24gKi9cbiAgICAgICAgICB1cGRhdGUucHJvdG9jb2xJbnN0YW5jZUlkISxcbiAgICAgICAgICBBcHBsaWNhdGlvbkZhaWx1cmUubm9uUmV0cnlhYmxlKGBObyByZWdpc3RlcmVkIGhhbmRsZXIgZm9yIHVwZGF0ZTogJHt1cGRhdGUubmFtZX1gKVxuICAgICAgICApO1xuICAgICAgfVxuICAgIH1cbiAgfVxuXG4gIHB1YmxpYyBhc3luYyBzaWduYWxXb3JrZmxvd05leHRIYW5kbGVyKHsgc2lnbmFsTmFtZSwgYXJncyB9OiBTaWduYWxJbnB1dCk6IFByb21pc2U8dm9pZD4ge1xuICAgIGNvbnN0IGZuID0gdGhpcy5zaWduYWxIYW5kbGVycy5nZXQoc2lnbmFsTmFtZSk/LmhhbmRsZXI7XG4gICAgaWYgKGZuKSB7XG4gICAgICByZXR1cm4gYXdhaXQgZm4oLi4uYXJncyk7XG4gICAgfSBlbHNlIGlmICh0aGlzLmRlZmF1bHRTaWduYWxIYW5kbGVyKSB7XG4gICAgICByZXR1cm4gYXdhaXQgdGhpcy5kZWZhdWx0U2lnbmFsSGFuZGxlcihzaWduYWxOYW1lLCAuLi5hcmdzKTtcbiAgICB9IGVsc2Uge1xuICAgICAgdGhyb3cgbmV3IElsbGVnYWxTdGF0ZUVycm9yKGBObyByZWdpc3RlcmVkIHNpZ25hbCBoYW5kbGVyIGZvciBzaWduYWw6ICR7c2lnbmFsTmFtZX1gKTtcbiAgICB9XG4gIH1cblxuICBwdWJsaWMgc2lnbmFsV29ya2Zsb3coYWN0aXZhdGlvbjogY29yZXNkay53b3JrZmxvd19hY3RpdmF0aW9uLklTaWduYWxXb3JrZmxvdyk6IHZvaWQge1xuICAgIGNvbnN0IHsgc2lnbmFsTmFtZSwgaGVhZGVycyB9ID0gYWN0aXZhdGlvbjtcbiAgICBpZiAoIXNpZ25hbE5hbWUpIHtcbiAgICAgIHRocm93IG5ldyBUeXBlRXJyb3IoJ01pc3NpbmcgYWN0aXZhdGlvbiBzaWduYWxOYW1lJyk7XG4gICAgfVxuXG4gICAgaWYgKCF0aGlzLnNpZ25hbEhhbmRsZXJzLmhhcyhzaWduYWxOYW1lKSAmJiAhdGhpcy5kZWZhdWx0U2lnbmFsSGFuZGxlcikge1xuICAgICAgdGhpcy5idWZmZXJlZFNpZ25hbHMucHVzaChhY3RpdmF0aW9uKTtcbiAgICAgIHJldHVybjtcbiAgICB9XG5cbiAgICBjb25zdCBleGVjdXRlID0gY29tcG9zZUludGVyY2VwdG9ycyhcbiAgICAgIHRoaXMuaW50ZXJjZXB0b3JzLmluYm91bmQsXG4gICAgICAnaGFuZGxlU2lnbmFsJyxcbiAgICAgIHRoaXMuc2lnbmFsV29ya2Zsb3dOZXh0SGFuZGxlci5iaW5kKHRoaXMpXG4gICAgKTtcbiAgICBleGVjdXRlKHtcbiAgICAgIGFyZ3M6IGFycmF5RnJvbVBheWxvYWRzKHRoaXMucGF5bG9hZENvbnZlcnRlciwgYWN0aXZhdGlvbi5pbnB1dCksXG4gICAgICBzaWduYWxOYW1lLFxuICAgICAgaGVhZGVyczogaGVhZGVycyA/PyB7fSxcbiAgICB9KS5jYXRjaCh0aGlzLmhhbmRsZVdvcmtmbG93RmFpbHVyZS5iaW5kKHRoaXMpKTtcbiAgfVxuXG4gIHB1YmxpYyBkaXNwYXRjaEJ1ZmZlcmVkU2lnbmFscygpOiB2b2lkIHtcbiAgICBjb25zdCBidWZmZXJlZFNpZ25hbHMgPSB0aGlzLmJ1ZmZlcmVkU2lnbmFscztcbiAgICB3aGlsZSAoYnVmZmVyZWRTaWduYWxzLmxlbmd0aCkge1xuICAgICAgaWYgKHRoaXMuZGVmYXVsdFNpZ25hbEhhbmRsZXIpIHtcbiAgICAgICAgLy8gV2UgaGF2ZSBhIGRlZmF1bHQgc2lnbmFsIGhhbmRsZXIsIHNvIGFsbCBzaWduYWxzIGFyZSBkaXNwYXRjaGFibGVcbiAgICAgICAgLy8gZXNsaW50LWRpc2FibGUtbmV4dC1saW5lIEB0eXBlc2NyaXB0LWVzbGludC9uby1ub24tbnVsbC1hc3NlcnRpb25cbiAgICAgICAgdGhpcy5zaWduYWxXb3JrZmxvdyhidWZmZXJlZFNpZ25hbHMuc2hpZnQoKSEpO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgY29uc3QgZm91bmRJbmRleCA9IGJ1ZmZlcmVkU2lnbmFscy5maW5kSW5kZXgoKHNpZ25hbCkgPT4gdGhpcy5zaWduYWxIYW5kbGVycy5oYXMoc2lnbmFsLnNpZ25hbE5hbWUgYXMgc3RyaW5nKSk7XG4gICAgICAgIGlmIChmb3VuZEluZGV4ID09PSAtMSkgYnJlYWs7XG4gICAgICAgIGNvbnN0IFtzaWduYWxdID0gYnVmZmVyZWRTaWduYWxzLnNwbGljZShmb3VuZEluZGV4LCAxKTtcbiAgICAgICAgdGhpcy5zaWduYWxXb3JrZmxvdyhzaWduYWwpO1xuICAgICAgfVxuICAgIH1cbiAgfVxuXG4gIHB1YmxpYyByZXNvbHZlU2lnbmFsRXh0ZXJuYWxXb3JrZmxvdyhhY3RpdmF0aW9uOiBjb3Jlc2RrLndvcmtmbG93X2FjdGl2YXRpb24uSVJlc29sdmVTaWduYWxFeHRlcm5hbFdvcmtmbG93KTogdm9pZCB7XG4gICAgY29uc3QgeyByZXNvbHZlLCByZWplY3QgfSA9IHRoaXMuY29uc3VtZUNvbXBsZXRpb24oJ3NpZ25hbFdvcmtmbG93JywgZ2V0U2VxKGFjdGl2YXRpb24pKTtcbiAgICBpZiAoYWN0aXZhdGlvbi5mYWlsdXJlKSB7XG4gICAgICByZWplY3QodGhpcy5mYWlsdXJlVG9FcnJvcihhY3RpdmF0aW9uLmZhaWx1cmUpKTtcbiAgICB9IGVsc2Uge1xuICAgICAgcmVzb2x2ZSh1bmRlZmluZWQpO1xuICAgIH1cbiAgfVxuXG4gIHB1YmxpYyByZXNvbHZlUmVxdWVzdENhbmNlbEV4dGVybmFsV29ya2Zsb3coXG4gICAgYWN0aXZhdGlvbjogY29yZXNkay53b3JrZmxvd19hY3RpdmF0aW9uLklSZXNvbHZlUmVxdWVzdENhbmNlbEV4dGVybmFsV29ya2Zsb3dcbiAgKTogdm9pZCB7XG4gICAgY29uc3QgeyByZXNvbHZlLCByZWplY3QgfSA9IHRoaXMuY29uc3VtZUNvbXBsZXRpb24oJ2NhbmNlbFdvcmtmbG93JywgZ2V0U2VxKGFjdGl2YXRpb24pKTtcbiAgICBpZiAoYWN0aXZhdGlvbi5mYWlsdXJlKSB7XG4gICAgICByZWplY3QodGhpcy5mYWlsdXJlVG9FcnJvcihhY3RpdmF0aW9uLmZhaWx1cmUpKTtcbiAgICB9IGVsc2Uge1xuICAgICAgcmVzb2x2ZSh1bmRlZmluZWQpO1xuICAgIH1cbiAgfVxuXG4gIHB1YmxpYyB1cGRhdGVSYW5kb21TZWVkKGFjdGl2YXRpb246IGNvcmVzZGsud29ya2Zsb3dfYWN0aXZhdGlvbi5JVXBkYXRlUmFuZG9tU2VlZCk6IHZvaWQge1xuICAgIGlmICghYWN0aXZhdGlvbi5yYW5kb21uZXNzU2VlZCkge1xuICAgICAgdGhyb3cgbmV3IFR5cGVFcnJvcignRXhwZWN0ZWQgYWN0aXZhdGlvbiB3aXRoIHJhbmRvbW5lc3NTZWVkIGF0dHJpYnV0ZScpO1xuICAgIH1cbiAgICB0aGlzLnJhbmRvbSA9IGFsZWEoYWN0aXZhdGlvbi5yYW5kb21uZXNzU2VlZC50b0J5dGVzKCkpO1xuICB9XG5cbiAgcHVibGljIG5vdGlmeUhhc1BhdGNoKGFjdGl2YXRpb246IGNvcmVzZGsud29ya2Zsb3dfYWN0aXZhdGlvbi5JTm90aWZ5SGFzUGF0Y2gpOiB2b2lkIHtcbiAgICBpZiAoIWFjdGl2YXRpb24ucGF0Y2hJZCkge1xuICAgICAgdGhyb3cgbmV3IFR5cGVFcnJvcignTm90aWZ5IGhhcyBwYXRjaCBtaXNzaW5nIHBhdGNoIG5hbWUnKTtcbiAgICB9XG4gICAgdGhpcy5rbm93blByZXNlbnRQYXRjaGVzLmFkZChhY3RpdmF0aW9uLnBhdGNoSWQpO1xuICB9XG5cbiAgcHVibGljIHJlbW92ZUZyb21DYWNoZSgpOiB2b2lkIHtcbiAgICB0aHJvdyBuZXcgSWxsZWdhbFN0YXRlRXJyb3IoJ3JlbW92ZUZyb21DYWNoZSBhY3RpdmF0aW9uIGpvYiBzaG91bGQgbm90IHJlYWNoIHdvcmtmbG93Jyk7XG4gIH1cblxuICAvKipcbiAgICogVHJhbnNmb3JtcyBmYWlsdXJlcyBpbnRvIGEgY29tbWFuZCB0byBiZSBzZW50IHRvIHRoZSBzZXJ2ZXIuXG4gICAqIFVzZWQgdG8gaGFuZGxlIGFueSBmYWlsdXJlIGVtaXR0ZWQgYnkgdGhlIFdvcmtmbG93LlxuICAgKi9cbiAgYXN5bmMgaGFuZGxlV29ya2Zsb3dGYWlsdXJlKGVycm9yOiB1bmtub3duKTogUHJvbWlzZTx2b2lkPiB7XG4gICAgaWYgKHRoaXMuY2FuY2VsbGVkICYmIGlzQ2FuY2VsbGF0aW9uKGVycm9yKSkge1xuICAgICAgdGhpcy5wdXNoQ29tbWFuZCh7IGNhbmNlbFdvcmtmbG93RXhlY3V0aW9uOiB7fSB9LCB0cnVlKTtcbiAgICB9IGVsc2UgaWYgKGVycm9yIGluc3RhbmNlb2YgQ29udGludWVBc05ldykge1xuICAgICAgdGhpcy5wdXNoQ29tbWFuZCh7IGNvbnRpbnVlQXNOZXdXb3JrZmxvd0V4ZWN1dGlvbjogZXJyb3IuY29tbWFuZCB9LCB0cnVlKTtcbiAgICB9IGVsc2Uge1xuICAgICAgaWYgKCEoZXJyb3IgaW5zdGFuY2VvZiBUZW1wb3JhbEZhaWx1cmUpKSB7XG4gICAgICAgIC8vIFRoaXMgcmVzdWx0cyBpbiBhbiB1bmhhbmRsZWQgcmVqZWN0aW9uIHdoaWNoIHdpbGwgZmFpbCB0aGUgYWN0aXZhdGlvblxuICAgICAgICAvLyBwcmV2ZW50aW5nIGl0IGZyb20gY29tcGxldGluZy5cbiAgICAgICAgdGhyb3cgZXJyb3I7XG4gICAgICB9XG5cbiAgICAgIHRoaXMucHVzaENvbW1hbmQoXG4gICAgICAgIHtcbiAgICAgICAgICBmYWlsV29ya2Zsb3dFeGVjdXRpb246IHtcbiAgICAgICAgICAgIGZhaWx1cmU6IHRoaXMuZXJyb3JUb0ZhaWx1cmUoZXJyb3IpLFxuICAgICAgICAgIH0sXG4gICAgICAgIH0sXG4gICAgICAgIHRydWVcbiAgICAgICk7XG4gICAgfVxuICB9XG5cbiAgcHJpdmF0ZSBjb21wbGV0ZVF1ZXJ5KHF1ZXJ5SWQ6IHN0cmluZywgcmVzdWx0OiB1bmtub3duKTogdm9pZCB7XG4gICAgdGhpcy5wdXNoQ29tbWFuZCh7XG4gICAgICByZXNwb25kVG9RdWVyeTogeyBxdWVyeUlkLCBzdWNjZWVkZWQ6IHsgcmVzcG9uc2U6IHRoaXMucGF5bG9hZENvbnZlcnRlci50b1BheWxvYWQocmVzdWx0KSB9IH0sXG4gICAgfSk7XG4gIH1cblxuICBwcml2YXRlIGZhaWxRdWVyeShxdWVyeUlkOiBzdHJpbmcsIGVycm9yOiB1bmtub3duKTogdm9pZCB7XG4gICAgdGhpcy5wdXNoQ29tbWFuZCh7XG4gICAgICByZXNwb25kVG9RdWVyeToge1xuICAgICAgICBxdWVyeUlkLFxuICAgICAgICBmYWlsZWQ6IHRoaXMuZXJyb3JUb0ZhaWx1cmUoZW5zdXJlVGVtcG9yYWxGYWlsdXJlKGVycm9yKSksXG4gICAgICB9LFxuICAgIH0pO1xuICB9XG5cbiAgcHJpdmF0ZSBhY2NlcHRVcGRhdGUocHJvdG9jb2xJbnN0YW5jZUlkOiBzdHJpbmcpOiB2b2lkIHtcbiAgICB0aGlzLnB1c2hDb21tYW5kKHsgdXBkYXRlUmVzcG9uc2U6IHsgcHJvdG9jb2xJbnN0YW5jZUlkLCBhY2NlcHRlZDoge30gfSB9KTtcbiAgfVxuXG4gIHByaXZhdGUgY29tcGxldGVVcGRhdGUocHJvdG9jb2xJbnN0YW5jZUlkOiBzdHJpbmcsIHJlc3VsdDogdW5rbm93bik6IHZvaWQge1xuICAgIHRoaXMucHVzaENvbW1hbmQoe1xuICAgICAgdXBkYXRlUmVzcG9uc2U6IHsgcHJvdG9jb2xJbnN0YW5jZUlkLCBjb21wbGV0ZWQ6IHRoaXMucGF5bG9hZENvbnZlcnRlci50b1BheWxvYWQocmVzdWx0KSB9LFxuICAgIH0pO1xuICB9XG5cbiAgcHJpdmF0ZSByZWplY3RVcGRhdGUocHJvdG9jb2xJbnN0YW5jZUlkOiBzdHJpbmcsIGVycm9yOiB1bmtub3duKTogdm9pZCB7XG4gICAgdGhpcy5wdXNoQ29tbWFuZCh7XG4gICAgICB1cGRhdGVSZXNwb25zZToge1xuICAgICAgICBwcm90b2NvbEluc3RhbmNlSWQsXG4gICAgICAgIHJlamVjdGVkOiB0aGlzLmVycm9yVG9GYWlsdXJlKGVuc3VyZVRlbXBvcmFsRmFpbHVyZShlcnJvcikpLFxuICAgICAgfSxcbiAgICB9KTtcbiAgfVxuXG4gIC8qKiBDb25zdW1lIGEgY29tcGxldGlvbiBpZiBpdCBleGlzdHMgaW4gV29ya2Zsb3cgc3RhdGUgKi9cbiAgcHJpdmF0ZSBtYXliZUNvbnN1bWVDb21wbGV0aW9uKHR5cGU6IGtleW9mIEFjdGl2YXRvclsnY29tcGxldGlvbnMnXSwgdGFza1NlcTogbnVtYmVyKTogQ29tcGxldGlvbiB8IHVuZGVmaW5lZCB7XG4gICAgY29uc3QgY29tcGxldGlvbiA9IHRoaXMuY29tcGxldGlvbnNbdHlwZV0uZ2V0KHRhc2tTZXEpO1xuICAgIGlmIChjb21wbGV0aW9uICE9PSB1bmRlZmluZWQpIHtcbiAgICAgIHRoaXMuY29tcGxldGlvbnNbdHlwZV0uZGVsZXRlKHRhc2tTZXEpO1xuICAgIH1cbiAgICByZXR1cm4gY29tcGxldGlvbjtcbiAgfVxuXG4gIC8qKiBDb25zdW1lIGEgY29tcGxldGlvbiBpZiBpdCBleGlzdHMgaW4gV29ya2Zsb3cgc3RhdGUsIHRocm93cyBpZiBpdCBkb2Vzbid0ICovXG4gIHByaXZhdGUgY29uc3VtZUNvbXBsZXRpb24odHlwZToga2V5b2YgQWN0aXZhdG9yWydjb21wbGV0aW9ucyddLCB0YXNrU2VxOiBudW1iZXIpOiBDb21wbGV0aW9uIHtcbiAgICBjb25zdCBjb21wbGV0aW9uID0gdGhpcy5tYXliZUNvbnN1bWVDb21wbGV0aW9uKHR5cGUsIHRhc2tTZXEpO1xuICAgIGlmIChjb21wbGV0aW9uID09PSB1bmRlZmluZWQpIHtcbiAgICAgIHRocm93IG5ldyBJbGxlZ2FsU3RhdGVFcnJvcihgTm8gY29tcGxldGlvbiBmb3IgdGFza1NlcSAke3Rhc2tTZXF9YCk7XG4gICAgfVxuICAgIHJldHVybiBjb21wbGV0aW9uO1xuICB9XG5cbiAgcHJpdmF0ZSBjb21wbGV0ZVdvcmtmbG93KHJlc3VsdDogdW5rbm93bik6IHZvaWQge1xuICAgIHRoaXMucHVzaENvbW1hbmQoXG4gICAgICB7XG4gICAgICAgIGNvbXBsZXRlV29ya2Zsb3dFeGVjdXRpb246IHtcbiAgICAgICAgICByZXN1bHQ6IHRoaXMucGF5bG9hZENvbnZlcnRlci50b1BheWxvYWQocmVzdWx0KSxcbiAgICAgICAgfSxcbiAgICAgIH0sXG4gICAgICB0cnVlXG4gICAgKTtcbiAgfVxuXG4gIGVycm9yVG9GYWlsdXJlKGVycjogdW5rbm93bik6IFByb3RvRmFpbHVyZSB7XG4gICAgcmV0dXJuIHRoaXMuZmFpbHVyZUNvbnZlcnRlci5lcnJvclRvRmFpbHVyZShlcnIsIHRoaXMucGF5bG9hZENvbnZlcnRlcik7XG4gIH1cblxuICBmYWlsdXJlVG9FcnJvcihmYWlsdXJlOiBQcm90b0ZhaWx1cmUpOiBFcnJvciB7XG4gICAgcmV0dXJuIHRoaXMuZmFpbHVyZUNvbnZlcnRlci5mYWlsdXJlVG9FcnJvcihmYWlsdXJlLCB0aGlzLnBheWxvYWRDb252ZXJ0ZXIpO1xuICB9XG59XG5cbmZ1bmN0aW9uIGdldFNlcTxUIGV4dGVuZHMgeyBzZXE/OiBudW1iZXIgfCBudWxsIH0+KGFjdGl2YXRpb246IFQpOiBudW1iZXIge1xuICBjb25zdCBzZXEgPSBhY3RpdmF0aW9uLnNlcTtcbiAgaWYgKHNlcSA9PT0gdW5kZWZpbmVkIHx8IHNlcSA9PT0gbnVsbCkge1xuICAgIHRocm93IG5ldyBUeXBlRXJyb3IoYEdvdCBhY3RpdmF0aW9uIHdpdGggbm8gc2VxIGF0dHJpYnV0ZWApO1xuICB9XG4gIHJldHVybiBzZXE7XG59XG4iLCJpbXBvcnQgeyBjb21wb3NlSW50ZXJjZXB0b3JzIH0gZnJvbSAnQHRlbXBvcmFsaW8vY29tbW9uL2xpYi9pbnRlcmNlcHRvcnMnO1xuaW1wb3J0IHsgU2RrQ29tcG9uZW50IH0gZnJvbSAnQHRlbXBvcmFsaW8vY29tbW9uJztcbmltcG9ydCB7IHVudHJhY2tQcm9taXNlIH0gZnJvbSAnLi9zdGFjay1oZWxwZXJzJztcbmltcG9ydCB7IHR5cGUgU2luaywgdHlwZSBTaW5rcywgcHJveHlTaW5rcyB9IGZyb20gJy4vc2lua3MnO1xuaW1wb3J0IHsgaXNDYW5jZWxsYXRpb24gfSBmcm9tICcuL2Vycm9ycyc7XG5pbXBvcnQgeyBXb3JrZmxvd0luZm8sIENvbnRpbnVlQXNOZXcgfSBmcm9tICcuL2ludGVyZmFjZXMnO1xuaW1wb3J0IHsgYXNzZXJ0SW5Xb3JrZmxvd0NvbnRleHQgfSBmcm9tICcuL2dsb2JhbC1hdHRyaWJ1dGVzJztcblxuZXhwb3J0IGludGVyZmFjZSBXb3JrZmxvd0xvZ2dlciBleHRlbmRzIFNpbmsge1xuICB0cmFjZShtZXNzYWdlOiBzdHJpbmcsIGF0dHJzPzogUmVjb3JkPHN0cmluZywgdW5rbm93bj4pOiB2b2lkO1xuICBkZWJ1ZyhtZXNzYWdlOiBzdHJpbmcsIGF0dHJzPzogUmVjb3JkPHN0cmluZywgdW5rbm93bj4pOiB2b2lkO1xuICBpbmZvKG1lc3NhZ2U6IHN0cmluZywgYXR0cnM/OiBSZWNvcmQ8c3RyaW5nLCB1bmtub3duPik6IHZvaWQ7XG4gIHdhcm4obWVzc2FnZTogc3RyaW5nLCBhdHRycz86IFJlY29yZDxzdHJpbmcsIHVua25vd24+KTogdm9pZDtcbiAgZXJyb3IobWVzc2FnZTogc3RyaW5nLCBhdHRycz86IFJlY29yZDxzdHJpbmcsIHVua25vd24+KTogdm9pZDtcbn1cblxuLyoqXG4gKiBTaW5rIGludGVyZmFjZSBmb3IgZm9yd2FyZGluZyBsb2dzIGZyb20gdGhlIFdvcmtmbG93IHNhbmRib3ggdG8gdGhlIFdvcmtlclxuICpcbiAqIEBkZXByZWNhdGVkIERvIG5vdCB1c2UgTG9nZ2VyU2lua3MgZGlyZWN0bHkuIFRvIGxvZyBmcm9tIFdvcmtmbG93IGNvZGUsIHVzZSB0aGUgYGxvZ2Agb2JqZWN0XG4gKiAgICAgICAgICAgICBleHBvcnRlZCBieSB0aGUgYEB0ZW1wb3JhbGlvL3dvcmtmbG93YCBwYWNrYWdlLiBUbyBjYXB0dXJlIGxvZyBtZXNzYWdlcyBlbWl0dGVkXG4gKiAgICAgICAgICAgICBieSBXb3JrZmxvdyBjb2RlLCBzZXQgdGhlIHtAbGluayBSdW50aW1lLmxvZ2dlcn0gcHJvcGVydHkuXG4gKi9cbmV4cG9ydCBpbnRlcmZhY2UgTG9nZ2VyU2lua3NEZXByZWNhdGVkIGV4dGVuZHMgU2lua3Mge1xuICAvKipcbiAgICogQGRlcHJlY2F0ZWQgRG8gbm90IHVzZSBMb2dnZXJTaW5rcyBkaXJlY3RseS4gVG8gbG9nIGZyb20gV29ya2Zsb3cgY29kZSwgdXNlIHRoZSBgbG9nYCBvYmplY3RcbiAgICogICAgICAgICAgICAgZXhwb3J0ZWQgYnkgdGhlIGBAdGVtcG9yYWxpby93b3JrZmxvd2AgcGFja2FnZS4gVG8gY2FwdHVyZSBsb2cgbWVzc2FnZXMgZW1pdHRlZFxuICAgKiAgICAgICAgICAgICBieSBXb3JrZmxvdyBjb2RlLCBzZXQgdGhlIHtAbGluayBSdW50aW1lLmxvZ2dlcn0gcHJvcGVydHkuXG4gICAqL1xuICBkZWZhdWx0V29ya2VyTG9nZ2VyOiBXb3JrZmxvd0xvZ2dlcjtcbn1cblxuLyoqXG4gKiBTaW5rIGludGVyZmFjZSBmb3IgZm9yd2FyZGluZyBsb2dzIGZyb20gdGhlIFdvcmtmbG93IHNhbmRib3ggdG8gdGhlIFdvcmtlclxuICovXG5leHBvcnQgaW50ZXJmYWNlIExvZ2dlclNpbmtzSW50ZXJuYWwgZXh0ZW5kcyBTaW5rcyB7XG4gIF9fdGVtcG9yYWxfbG9nZ2VyOiBXb3JrZmxvd0xvZ2dlcjtcbn1cblxuY29uc3QgbG9nZ2VyU2luayA9IHByb3h5U2lua3M8TG9nZ2VyU2lua3NJbnRlcm5hbD4oKS5fX3RlbXBvcmFsX2xvZ2dlcjtcblxuLyoqXG4gKiBTeW1ib2wgdXNlZCBieSB0aGUgU0RLIGxvZ2dlciB0byBleHRyYWN0IGEgdGltZXN0YW1wIGZyb20gbG9nIGF0dHJpYnV0ZXMuXG4gKiBBbHNvIGRlZmluZWQgaW4gYHdvcmtlci9sb2dnZXIudHNgIC0gaW50ZW50aW9uYWxseSBub3Qgc2hhcmVkLlxuICovXG5jb25zdCBMb2dUaW1lc3RhbXAgPSBTeW1ib2wuZm9yKCdsb2dfdGltZXN0YW1wJyk7XG5cbi8qKlxuICogRGVmYXVsdCB3b3JrZmxvdyBsb2dnZXIuXG4gKlxuICogVGhpcyBsb2dnZXIgaXMgcmVwbGF5LWF3YXJlIGFuZCB3aWxsIG9taXQgbG9nIG1lc3NhZ2VzIG9uIHdvcmtmbG93IHJlcGxheS4gTWVzc2FnZXMgZW1pdHRlZCBieSB0aGlzIGxvZ2dlciBhcmVcbiAqIGZ1bm5lbGxlZCB0aHJvdWdoIGEgc2luayB0aGF0IGZvcndhcmRzIHRoZW0gdG8gdGhlIGxvZ2dlciByZWdpc3RlcmVkIG9uIHtAbGluayBSdW50aW1lLmxvZ2dlcn0uXG4gKlxuICogQXR0cmlidXRlcyBmcm9tIHRoZSBjdXJyZW50IFdvcmtmbG93IEV4ZWN1dGlvbiBjb250ZXh0IGFyZSBhdXRvbWF0aWNhbGx5IGluY2x1ZGVkIGFzIG1ldGFkYXRhIG9uIGV2ZXJ5IGxvZ1xuICogZW50cmllcy4gQW4gZXh0cmEgYHNka0NvbXBvbmVudGAgbWV0YWRhdGEgYXR0cmlidXRlIGlzIGFsc28gYWRkZWQsIHdpdGggdmFsdWUgYHdvcmtmbG93YDsgdGhpcyBjYW4gYmUgdXNlZCBmb3JcbiAqIGZpbmUtZ3JhaW5lZCBmaWx0ZXJpbmcgb2YgbG9nIGVudHJpZXMgZnVydGhlciBkb3duc3RyZWFtLlxuICpcbiAqIFRvIGN1c3RvbWl6ZSBsb2cgYXR0cmlidXRlcywgcmVnaXN0ZXIgYSB7QGxpbmsgV29ya2Zsb3dPdXRib3VuZENhbGxzSW50ZXJjZXB0b3J9IHRoYXQgaW50ZXJjZXB0cyB0aGVcbiAqIGBnZXRMb2dBdHRyaWJ1dGVzKClgIG1ldGhvZC5cbiAqXG4gKiBOb3RpY2UgdGhhdCBzaW5jZSBzaW5rcyBhcmUgdXNlZCB0byBwb3dlciB0aGlzIGxvZ2dlciwgYW55IGxvZyBhdHRyaWJ1dGVzIG11c3QgYmUgdHJhbnNmZXJhYmxlIHZpYSB0aGVcbiAqIHtAbGluayBodHRwczovL25vZGVqcy5vcmcvYXBpL3dvcmtlcl90aHJlYWRzLmh0bWwjd29ya2VyX3RocmVhZHNfcG9ydF9wb3N0bWVzc2FnZV92YWx1ZV90cmFuc2Zlcmxpc3QgfCBwb3N0TWVzc2FnZX1cbiAqIEFQSS5cbiAqXG4gKiBOT1RFOiBTcGVjaWZ5aW5nIGEgY3VzdG9tIGxvZ2dlciB0aHJvdWdoIHtAbGluayBkZWZhdWx0U2lua30gb3IgYnkgbWFudWFsbHkgcmVnaXN0ZXJpbmcgYSBzaW5rIG5hbWVkXG4gKiBgZGVmYXVsdFdvcmtlckxvZ2dlcmAgaGFzIGJlZW4gZGVwcmVjYXRlZC4gUGxlYXNlIHVzZSB7QGxpbmsgUnVudGltZS5sb2dnZXJ9IGluc3RlYWQuXG4gKi9cbmV4cG9ydCBjb25zdCBsb2c6IFdvcmtmbG93TG9nZ2VyID0gT2JqZWN0LmZyb21FbnRyaWVzKFxuICAoWyd0cmFjZScsICdkZWJ1ZycsICdpbmZvJywgJ3dhcm4nLCAnZXJyb3InXSBhcyBBcnJheTxrZXlvZiBXb3JrZmxvd0xvZ2dlcj4pLm1hcCgobGV2ZWwpID0+IHtcbiAgICByZXR1cm4gW1xuICAgICAgbGV2ZWwsXG4gICAgICAobWVzc2FnZTogc3RyaW5nLCBhdHRycz86IFJlY29yZDxzdHJpbmcsIHVua25vd24+KSA9PiB7XG4gICAgICAgIGNvbnN0IGFjdGl2YXRvciA9IGFzc2VydEluV29ya2Zsb3dDb250ZXh0KCdXb3JrZmxvdy5sb2coLi4uKSBtYXkgb25seSBiZSB1c2VkIGZyb20gd29ya2Zsb3cgY29udGV4dC4nKTtcbiAgICAgICAgY29uc3QgZ2V0TG9nQXR0cmlidXRlcyA9IGNvbXBvc2VJbnRlcmNlcHRvcnMoYWN0aXZhdG9yLmludGVyY2VwdG9ycy5vdXRib3VuZCwgJ2dldExvZ0F0dHJpYnV0ZXMnLCAoYSkgPT4gYSk7XG4gICAgICAgIHJldHVybiBsb2dnZXJTaW5rW2xldmVsXShtZXNzYWdlLCB7XG4gICAgICAgICAgLy8gSW5qZWN0IHRoZSBjYWxsIHRpbWUgaW4gbmFub3NlY29uZCByZXNvbHV0aW9uIGFzIGV4cGVjdGVkIGJ5IHRoZSB3b3JrZXIgbG9nZ2VyLlxuICAgICAgICAgIFtMb2dUaW1lc3RhbXBdOiBhY3RpdmF0b3IuZ2V0VGltZU9mRGF5KCksXG4gICAgICAgICAgc2RrQ29tcG9uZW50OiBTZGtDb21wb25lbnQud29ya2Zsb3csXG4gICAgICAgICAgLi4uZ2V0TG9nQXR0cmlidXRlcyh3b3JrZmxvd0xvZ0F0dHJpYnV0ZXMoYWN0aXZhdG9yLmluZm8pKSxcbiAgICAgICAgICAuLi5hdHRycyxcbiAgICAgICAgfSk7XG4gICAgICB9LFxuICAgIF07XG4gIH0pXG4pIGFzIGFueTtcblxuZXhwb3J0IGZ1bmN0aW9uIGV4ZWN1dGVXaXRoTGlmZWN5Y2xlTG9nZ2luZyhmbjogKCkgPT4gUHJvbWlzZTx1bmtub3duPik6IFByb21pc2U8dW5rbm93bj4ge1xuICBsb2cuZGVidWcoJ1dvcmtmbG93IHN0YXJ0ZWQnLCB7IHNka0NvbXBvbmVudDogU2RrQ29tcG9uZW50LndvcmtlciB9KTtcbiAgY29uc3QgcCA9IGZuKCkudGhlbihcbiAgICAocmVzKSA9PiB7XG4gICAgICBsb2cuZGVidWcoJ1dvcmtmbG93IGNvbXBsZXRlZCcsIHsgc2RrQ29tcG9uZW50OiBTZGtDb21wb25lbnQud29ya2VyIH0pO1xuICAgICAgcmV0dXJuIHJlcztcbiAgICB9LFxuICAgIChlcnJvcikgPT4ge1xuICAgICAgLy8gQXZvaWQgdXNpbmcgaW5zdGFuY2VvZiBjaGVja3MgaW4gY2FzZSB0aGUgbW9kdWxlcyB0aGV5J3JlIGRlZmluZWQgaW4gbG9hZGVkIG1vcmUgdGhhbiBvbmNlLFxuICAgICAgLy8gZS5nLiBieSBqZXN0IG9yIHdoZW4gbXVsdGlwbGUgdmVyc2lvbnMgYXJlIGluc3RhbGxlZC5cbiAgICAgIGlmICh0eXBlb2YgZXJyb3IgPT09ICdvYmplY3QnICYmIGVycm9yICE9IG51bGwpIHtcbiAgICAgICAgaWYgKGlzQ2FuY2VsbGF0aW9uKGVycm9yKSkge1xuICAgICAgICAgIGxvZy5kZWJ1ZygnV29ya2Zsb3cgY29tcGxldGVkIGFzIGNhbmNlbGxlZCcsIHsgc2RrQ29tcG9uZW50OiBTZGtDb21wb25lbnQud29ya2VyIH0pO1xuICAgICAgICAgIHRocm93IGVycm9yO1xuICAgICAgICB9IGVsc2UgaWYgKGVycm9yIGluc3RhbmNlb2YgQ29udGludWVBc05ldykge1xuICAgICAgICAgIGxvZy5kZWJ1ZygnV29ya2Zsb3cgY29udGludWVkIGFzIG5ldycsIHsgc2RrQ29tcG9uZW50OiBTZGtDb21wb25lbnQud29ya2VyIH0pO1xuICAgICAgICAgIHRocm93IGVycm9yO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgICBsb2cud2FybignV29ya2Zsb3cgZmFpbGVkJywgeyBlcnJvciwgc2RrQ29tcG9uZW50OiBTZGtDb21wb25lbnQud29ya2VyIH0pO1xuICAgICAgdGhyb3cgZXJyb3I7XG4gICAgfVxuICApO1xuICAvLyBBdm9pZCBzaG93aW5nIHRoaXMgaW50ZXJjZXB0b3IgaW4gc3RhY2sgdHJhY2UgcXVlcnlcbiAgdW50cmFja1Byb21pc2UocCk7XG4gIHJldHVybiBwO1xufVxuXG4vKipcbiAqIFJldHVybnMgYSBtYXAgb2YgYXR0cmlidXRlcyB0byBiZSBzZXQgX2J5IGRlZmF1bHRfIG9uIGxvZyBtZXNzYWdlcyBmb3IgYSBnaXZlbiBXb3JrZmxvdy5cbiAqIE5vdGUgdGhhdCB0aGlzIGZ1bmN0aW9uIG1heSBiZSBjYWxsZWQgZnJvbSBvdXRzaWRlIG9mIHRoZSBXb3JrZmxvdyBjb250ZXh0IChlZy4gYnkgdGhlIHdvcmtlciBpdHNlbGYpLlxuICovXG5leHBvcnQgZnVuY3Rpb24gd29ya2Zsb3dMb2dBdHRyaWJ1dGVzKGluZm86IFdvcmtmbG93SW5mbyk6IFJlY29yZDxzdHJpbmcsIHVua25vd24+IHtcbiAgcmV0dXJuIHtcbiAgICBuYW1lc3BhY2U6IGluZm8ubmFtZXNwYWNlLFxuICAgIHRhc2tRdWV1ZTogaW5mby50YXNrUXVldWUsXG4gICAgd29ya2Zsb3dJZDogaW5mby53b3JrZmxvd0lkLFxuICAgIHJ1bklkOiBpbmZvLnJ1bklkLFxuICAgIHdvcmtmbG93VHlwZTogaW5mby53b3JrZmxvd1R5cGUsXG4gIH07XG59XG4iLCIvLyAuLi9wYWNrYWdlLmpzb24gaXMgb3V0c2lkZSBvZiB0aGUgVFMgcHJvamVjdCByb290RGlyIHdoaWNoIGNhdXNlcyBUUyB0byBjb21wbGFpbiBhYm91dCB0aGlzIGltcG9ydC5cbi8vIFdlIGRvIG5vdCB3YW50IHRvIGNoYW5nZSB0aGUgcm9vdERpciBiZWNhdXNlIGl0IG1lc3NlcyB1cCB0aGUgb3V0cHV0IHN0cnVjdHVyZS5cbi8vIGVzbGludC1kaXNhYmxlLW5leHQtbGluZSBAdHlwZXNjcmlwdC1lc2xpbnQvYmFuLXRzLWNvbW1lbnRcbi8vIEB0cy1pZ25vcmVcbmltcG9ydCBwa2cgZnJvbSAnLi4vcGFja2FnZS5qc29uJztcblxuZXhwb3J0IGRlZmF1bHQgcGtnIGFzIHsgbmFtZTogc3RyaW5nOyB2ZXJzaW9uOiBzdHJpbmcgfTtcbiIsIi8qKlxuICogVHlwZSBkZWZpbml0aW9ucyBmb3IgdGhlIFdvcmtmbG93IGVuZCBvZiB0aGUgc2lua3MgbWVjaGFuaXNtLlxuICpcbiAqIFNpbmtzIGFyZSBhIG1lY2hhbmlzbSBmb3IgZXhwb3J0aW5nIGRhdGEgZnJvbSB0aGUgV29ya2Zsb3cgaXNvbGF0ZSB0byB0aGVcbiAqIE5vZGUuanMgZW52aXJvbm1lbnQsIHRoZXkgYXJlIG5lY2Vzc2FyeSBiZWNhdXNlIHRoZSBXb3JrZmxvdyBoYXMgbm8gd2F5IHRvXG4gKiBjb21tdW5pY2F0ZSB3aXRoIHRoZSBvdXRzaWRlIFdvcmxkLlxuICpcbiAqIFNpbmtzIGFyZSB0eXBpY2FsbHkgdXNlZCBmb3IgZXhwb3J0aW5nIGxvZ3MsIG1ldHJpY3MgYW5kIHRyYWNlcyBvdXQgZnJvbSB0aGVcbiAqIFdvcmtmbG93LlxuICpcbiAqIFNpbmsgZnVuY3Rpb25zIG1heSBub3QgcmV0dXJuIHZhbHVlcyB0byB0aGUgV29ya2Zsb3cgaW4gb3JkZXIgdG8gcHJldmVudFxuICogYnJlYWtpbmcgZGV0ZXJtaW5pc20uXG4gKlxuICogQG1vZHVsZVxuICovXG5cbmltcG9ydCB7IFdvcmtmbG93SW5mbyB9IGZyb20gJy4vaW50ZXJmYWNlcyc7XG5pbXBvcnQgeyBhc3NlcnRJbldvcmtmbG93Q29udGV4dCB9IGZyb20gJy4vZ2xvYmFsLWF0dHJpYnV0ZXMnO1xuXG4vKipcbiAqIEFueSBmdW5jdGlvbiBzaWduYXR1cmUgY2FuIGJlIHVzZWQgZm9yIFNpbmsgZnVuY3Rpb25zIGFzIGxvbmcgYXMgdGhlIHJldHVybiB0eXBlIGlzIGB2b2lkYC5cbiAqXG4gKiBXaGVuIGNhbGxpbmcgYSBTaW5rIGZ1bmN0aW9uLCBhcmd1bWVudHMgYXJlIGNvcGllZCBmcm9tIHRoZSBXb3JrZmxvdyBpc29sYXRlIHRvIHRoZSBOb2RlLmpzIGVudmlyb25tZW50IHVzaW5nXG4gKiB7QGxpbmsgaHR0cHM6Ly9ub2RlanMub3JnL2FwaS93b3JrZXJfdGhyZWFkcy5odG1sI3dvcmtlcl90aHJlYWRzX3BvcnRfcG9zdG1lc3NhZ2VfdmFsdWVfdHJhbnNmZXJsaXN0IHwgcG9zdE1lc3NhZ2V9LlxuXG4gKiBUaGlzIGNvbnN0cmFpbnMgdGhlIGFyZ3VtZW50IHR5cGVzIHRvIHByaW1pdGl2ZXMgKGV4Y2x1ZGluZyBTeW1ib2xzKS5cbiAqL1xuZXhwb3J0IHR5cGUgU2lua0Z1bmN0aW9uID0gKC4uLmFyZ3M6IGFueVtdKSA9PiB2b2lkO1xuXG4vKiogQSBtYXBwaW5nIG9mIG5hbWUgdG8gZnVuY3Rpb24sIGRlZmluZXMgYSBzaW5nbGUgc2luayAoZS5nLiBsb2dnZXIpICovXG5leHBvcnQgdHlwZSBTaW5rID0gUmVjb3JkPHN0cmluZywgU2lua0Z1bmN0aW9uPjtcbi8qKlxuICogV29ya2Zsb3cgU2luayBhcmUgYSBtYXBwaW5nIG9mIG5hbWUgdG8ge0BsaW5rIFNpbmt9XG4gKi9cbmV4cG9ydCB0eXBlIFNpbmtzID0gUmVjb3JkPHN0cmluZywgU2luaz47XG5cbi8qKlxuICogQ2FsbCBpbmZvcm1hdGlvbiBmb3IgYSBTaW5rXG4gKi9cbmV4cG9ydCBpbnRlcmZhY2UgU2lua0NhbGwge1xuICBpZmFjZU5hbWU6IHN0cmluZztcbiAgZm5OYW1lOiBzdHJpbmc7XG4gIGFyZ3M6IGFueVtdO1xuICB3b3JrZmxvd0luZm86IFdvcmtmbG93SW5mbztcbn1cblxuLyoqXG4gKiBHZXQgYSByZWZlcmVuY2UgdG8gU2lua3MgZm9yIGV4cG9ydGluZyBkYXRhIG91dCBvZiB0aGUgV29ya2Zsb3cuXG4gKlxuICogVGhlc2UgU2lua3MgKiptdXN0KiogYmUgcmVnaXN0ZXJlZCB3aXRoIHRoZSBXb3JrZXIgaW4gb3JkZXIgZm9yIHRoaXNcbiAqIG1lY2hhbmlzbSB0byB3b3JrLlxuICpcbiAqIEBleGFtcGxlXG4gKiBgYGB0c1xuICogaW1wb3J0IHsgcHJveHlTaW5rcywgU2lua3MgfSBmcm9tICdAdGVtcG9yYWxpby93b3JrZmxvdyc7XG4gKlxuICogaW50ZXJmYWNlIE15U2lua3MgZXh0ZW5kcyBTaW5rcyB7XG4gKiAgIGxvZ2dlcjoge1xuICogICAgIGluZm8obWVzc2FnZTogc3RyaW5nKTogdm9pZDtcbiAqICAgICBlcnJvcihtZXNzYWdlOiBzdHJpbmcpOiB2b2lkO1xuICogICB9O1xuICogfVxuICpcbiAqIGNvbnN0IHsgbG9nZ2VyIH0gPSBwcm94eVNpbmtzPE15RGVwZW5kZW5jaWVzPigpO1xuICogbG9nZ2VyLmluZm8oJ3NldHRpbmcgdXAnKTtcbiAqXG4gKiBleHBvcnQgZnVuY3Rpb24gbXlXb3JrZmxvdygpIHtcbiAqICAgcmV0dXJuIHtcbiAqICAgICBhc3luYyBleGVjdXRlKCkge1xuICogICAgICAgbG9nZ2VyLmluZm8oXCJoZXkgaG9cIik7XG4gKiAgICAgICBsb2dnZXIuZXJyb3IoXCJsZXRzIGdvXCIpO1xuICogICAgIH1cbiAqICAgfTtcbiAqIH1cbiAqIGBgYFxuICovXG5leHBvcnQgZnVuY3Rpb24gcHJveHlTaW5rczxUIGV4dGVuZHMgU2lua3M+KCk6IFQge1xuICByZXR1cm4gbmV3IFByb3h5KFxuICAgIHt9LFxuICAgIHtcbiAgICAgIGdldChfLCBpZmFjZU5hbWUpIHtcbiAgICAgICAgcmV0dXJuIG5ldyBQcm94eShcbiAgICAgICAgICB7fSxcbiAgICAgICAgICB7XG4gICAgICAgICAgICBnZXQoXywgZm5OYW1lKSB7XG4gICAgICAgICAgICAgIHJldHVybiAoLi4uYXJnczogYW55W10pID0+IHtcbiAgICAgICAgICAgICAgICBjb25zdCBhY3RpdmF0b3IgPSBhc3NlcnRJbldvcmtmbG93Q29udGV4dChcbiAgICAgICAgICAgICAgICAgICdQcm94aWVkIHNpbmtzIGZ1bmN0aW9ucyBtYXkgb25seSBiZSB1c2VkIGZyb20gYSBXb3JrZmxvdyBFeGVjdXRpb24uJ1xuICAgICAgICAgICAgICAgICk7XG4gICAgICAgICAgICAgICAgYWN0aXZhdG9yLnNpbmtDYWxscy5wdXNoKHtcbiAgICAgICAgICAgICAgICAgIGlmYWNlTmFtZTogaWZhY2VOYW1lIGFzIHN0cmluZyxcbiAgICAgICAgICAgICAgICAgIGZuTmFtZTogZm5OYW1lIGFzIHN0cmluZyxcbiAgICAgICAgICAgICAgICAgIC8vIFNpbmsgZnVuY3Rpb24gZG9lc24ndCBnZXQgY2FsbGVkIGltbWVkaWF0ZWx5LiBNYWtlIGEgY2xvbmUgb2YgdGhlIHNpbmsncyBhcmdzLCBzbyB0aGF0IGZ1cnRoZXIgbXV0YXRpb25zXG4gICAgICAgICAgICAgICAgICAvLyB0byB0aGVzZSBvYmplY3RzIGRvbid0IGNvcnJ1cHQgdGhlIGFyZ3MgdGhhdCB0aGUgc2luayBmdW5jdGlvbiB3aWxsIHJlY2VpdmUuIE9ubHkgYXZhaWxhYmxlIGZyb20gbm9kZSAxNy5cbiAgICAgICAgICAgICAgICAgIGFyZ3M6IChnbG9iYWxUaGlzIGFzIGFueSkuc3RydWN0dXJlZENsb25lID8gKGdsb2JhbFRoaXMgYXMgYW55KS5zdHJ1Y3R1cmVkQ2xvbmUoYXJncykgOiBhcmdzLFxuICAgICAgICAgICAgICAgICAgLy8gYWN0aXZhdG9yLmluZm8gaXMgaW50ZXJuYWxseSBjb3B5LW9uLXdyaXRlLiBUaGlzIGVuc3VyZSB0aGF0IGFueSBmdXJ0aGVyIG11dGF0aW9uc1xuICAgICAgICAgICAgICAgICAgLy8gdG8gdGhlIHdvcmtmbG93IHN0YXRlIGluIHRoZSBjb250ZXh0IG9mIHRoZSBwcmVzZW50IGFjdGl2YXRpb24gd2lsbCBub3QgY29ycnVwdCB0aGVcbiAgICAgICAgICAgICAgICAgIC8vIHdvcmtmbG93SW5mbyBzdGF0ZSB0aGF0IGdldHMgcGFzc2VkIHdoZW4gdGhlIHNpbmsgZnVuY3Rpb24gYWN0dWFsbHkgZ2V0cyBjYWxsZWQuXG4gICAgICAgICAgICAgICAgICB3b3JrZmxvd0luZm86IGFjdGl2YXRvci5pbmZvLFxuICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgICB9O1xuICAgICAgICAgICAgfSxcbiAgICAgICAgICB9XG4gICAgICAgICk7XG4gICAgICB9LFxuICAgIH1cbiAgKSBhcyBhbnk7XG59XG4iLCJpbXBvcnQgeyBtYXliZUdldEFjdGl2YXRvclVudHlwZWQgfSBmcm9tICcuL2dsb2JhbC1hdHRyaWJ1dGVzJztcbmltcG9ydCB0eXBlIHsgUHJvbWlzZVN0YWNrU3RvcmUgfSBmcm9tICcuL2ludGVybmFscyc7XG5cbi8qKlxuICogSGVscGVyIGZ1bmN0aW9uIHRvIHJlbW92ZSBhIHByb21pc2UgZnJvbSBiZWluZyB0cmFja2VkIGZvciBzdGFjayB0cmFjZSBxdWVyeSBwdXJwb3Nlc1xuICovXG5leHBvcnQgZnVuY3Rpb24gdW50cmFja1Byb21pc2UocHJvbWlzZTogUHJvbWlzZTx1bmtub3duPik6IHZvaWQge1xuICBjb25zdCBzdG9yZSA9IChtYXliZUdldEFjdGl2YXRvclVudHlwZWQoKSBhcyBhbnkpPy5wcm9taXNlU3RhY2tTdG9yZSBhcyBQcm9taXNlU3RhY2tTdG9yZSB8IHVuZGVmaW5lZDtcbiAgaWYgKCFzdG9yZSkgcmV0dXJuO1xuICBzdG9yZS5jaGlsZFRvUGFyZW50LmRlbGV0ZShwcm9taXNlKTtcbiAgc3RvcmUucHJvbWlzZVRvU3RhY2suZGVsZXRlKHByb21pc2UpO1xufVxuIiwiaW1wb3J0IHsgQ2FuY2VsbGF0aW9uU2NvcGUgfSBmcm9tICcuL2NhbmNlbGxhdGlvbi1zY29wZSc7XG5pbXBvcnQgeyB1bnRyYWNrUHJvbWlzZSB9IGZyb20gJy4vc3RhY2staGVscGVycyc7XG5cbi8qKlxuICogQSBgUHJvbWlzZUxpa2VgIGhlbHBlciB3aGljaCBleHBvc2VzIGl0cyBgcmVzb2x2ZWAgYW5kIGByZWplY3RgIG1ldGhvZHMuXG4gKlxuICogVHJpZ2dlciBpcyBDYW5jZWxsYXRpb25TY29wZS1hd2FyZTogaXQgaXMgbGlua2VkIHRvIHRoZSBjdXJyZW50IHNjb3BlIG9uXG4gKiBjb25zdHJ1Y3Rpb24gYW5kIHRocm93cyB3aGVuIHRoYXQgc2NvcGUgaXMgY2FuY2VsbGVkLlxuICpcbiAqIFVzZWZ1bCBmb3IgZS5nLiB3YWl0aW5nIGZvciB1bmJsb2NraW5nIGEgV29ya2Zsb3cgZnJvbSBhIFNpZ25hbC5cbiAqXG4gKiBAZXhhbXBsZVxuICogPCEtLVNOSVBTVEFSVCB0eXBlc2NyaXB0LXRyaWdnZXItd29ya2Zsb3ctLT5cbiAqIDwhLS1TTklQRU5ELS0+XG4gKi9cbmV4cG9ydCBjbGFzcyBUcmlnZ2VyPFQ+IGltcGxlbWVudHMgUHJvbWlzZUxpa2U8VD4ge1xuICAvLyBUeXBlc2NyaXB0IGRvZXMgbm90IHJlYWxpemUgdGhhdCB0aGUgcHJvbWlzZSBleGVjdXRvciBpcyBydW4gc3luY2hyb25vdXNseSBpbiB0aGUgY29uc3RydWN0b3JcbiAgLy8gZXNsaW50LWRpc2FibGUtbmV4dC1saW5lIEB0eXBlc2NyaXB0LWVzbGludC9iYW4tdHMtY29tbWVudFxuICAvLyBAdHMtaWdub3JlXG4gIHB1YmxpYyByZWFkb25seSByZXNvbHZlOiAodmFsdWU6IFQgfCBQcm9taXNlTGlrZTxUPikgPT4gdm9pZDtcbiAgLy8gZXNsaW50LWRpc2FibGUtbmV4dC1saW5lIEB0eXBlc2NyaXB0LWVzbGludC9iYW4tdHMtY29tbWVudFxuICAvLyBAdHMtaWdub3JlXG4gIHB1YmxpYyByZWFkb25seSByZWplY3Q6IChyZWFzb24/OiBhbnkpID0+IHZvaWQ7XG4gIHByb3RlY3RlZCByZWFkb25seSBwcm9taXNlOiBQcm9taXNlPFQ+O1xuXG4gIGNvbnN0cnVjdG9yKCkge1xuICAgIHRoaXMucHJvbWlzZSA9IG5ldyBQcm9taXNlPFQ+KChyZXNvbHZlLCByZWplY3QpID0+IHtcbiAgICAgIGNvbnN0IHNjb3BlID0gQ2FuY2VsbGF0aW9uU2NvcGUuY3VycmVudCgpO1xuICAgICAgaWYgKHNjb3BlLmNvbnNpZGVyZWRDYW5jZWxsZWQgfHwgc2NvcGUuY2FuY2VsbGFibGUpIHtcbiAgICAgICAgdW50cmFja1Byb21pc2Uoc2NvcGUuY2FuY2VsUmVxdWVzdGVkLmNhdGNoKHJlamVjdCkpO1xuICAgICAgfVxuICAgICAgLy8gZXNsaW50LWRpc2FibGUtbmV4dC1saW5lIEB0eXBlc2NyaXB0LWVzbGludC9iYW4tdHMtY29tbWVudFxuICAgICAgLy8gQHRzLWlnbm9yZVxuICAgICAgdGhpcy5yZXNvbHZlID0gcmVzb2x2ZTtcbiAgICAgIC8vIGVzbGludC1kaXNhYmxlLW5leHQtbGluZSBAdHlwZXNjcmlwdC1lc2xpbnQvYmFuLXRzLWNvbW1lbnRcbiAgICAgIC8vIEB0cy1pZ25vcmVcbiAgICAgIHRoaXMucmVqZWN0ID0gcmVqZWN0O1xuICAgIH0pO1xuICAgIC8vIEF2b2lkIHVuaGFuZGxlZCByZWplY3Rpb25zXG4gICAgdW50cmFja1Byb21pc2UodGhpcy5wcm9taXNlLmNhdGNoKCgpID0+IHVuZGVmaW5lZCkpO1xuICB9XG5cbiAgdGhlbjxUUmVzdWx0MSA9IFQsIFRSZXN1bHQyID0gbmV2ZXI+KFxuICAgIG9uZnVsZmlsbGVkPzogKCh2YWx1ZTogVCkgPT4gVFJlc3VsdDEgfCBQcm9taXNlTGlrZTxUUmVzdWx0MT4pIHwgdW5kZWZpbmVkIHwgbnVsbCxcbiAgICBvbnJlamVjdGVkPzogKChyZWFzb246IGFueSkgPT4gVFJlc3VsdDIgfCBQcm9taXNlTGlrZTxUUmVzdWx0Mj4pIHwgdW5kZWZpbmVkIHwgbnVsbFxuICApOiBQcm9taXNlTGlrZTxUUmVzdWx0MSB8IFRSZXN1bHQyPiB7XG4gICAgcmV0dXJuIHRoaXMucHJvbWlzZS50aGVuKG9uZnVsZmlsbGVkLCBvbnJlamVjdGVkKTtcbiAgfVxufVxuIiwiLyoqXG4gKiBFeHBvcnRlZCBmdW5jdGlvbnMgZm9yIHRoZSBXb3JrZXIgdG8gaW50ZXJhY3Qgd2l0aCB0aGUgV29ya2Zsb3cgaXNvbGF0ZVxuICpcbiAqIEBtb2R1bGVcbiAqL1xuaW1wb3J0IHsgSWxsZWdhbFN0YXRlRXJyb3IgfSBmcm9tICdAdGVtcG9yYWxpby9jb21tb24nO1xuaW1wb3J0IHsgbXNUb1RzLCB0c1RvTXMgfSBmcm9tICdAdGVtcG9yYWxpby9jb21tb24vbGliL3RpbWUnO1xuaW1wb3J0IHsgY29tcG9zZUludGVyY2VwdG9ycyB9IGZyb20gJ0B0ZW1wb3JhbGlvL2NvbW1vbi9saWIvaW50ZXJjZXB0b3JzJztcbmltcG9ydCB7IGNvcmVzZGsgfSBmcm9tICdAdGVtcG9yYWxpby9wcm90byc7XG5pbXBvcnQgeyBkaXNhYmxlU3RvcmFnZSB9IGZyb20gJy4vY2FuY2VsbGF0aW9uLXNjb3BlJztcbmltcG9ydCB7IERldGVybWluaXNtVmlvbGF0aW9uRXJyb3IgfSBmcm9tICcuL2Vycm9ycyc7XG5pbXBvcnQgeyBXb3JrZmxvd0ludGVyY2VwdG9yc0ZhY3RvcnkgfSBmcm9tICcuL2ludGVyY2VwdG9ycyc7XG5pbXBvcnQgeyBXb3JrZmxvd0NyZWF0ZU9wdGlvbnNJbnRlcm5hbCB9IGZyb20gJy4vaW50ZXJmYWNlcyc7XG5pbXBvcnQgeyBBY3RpdmF0b3IgfSBmcm9tICcuL2ludGVybmFscyc7XG5pbXBvcnQgeyBzZXRBY3RpdmF0b3JVbnR5cGVkLCBnZXRBY3RpdmF0b3IgfSBmcm9tICcuL2dsb2JhbC1hdHRyaWJ1dGVzJztcbmltcG9ydCB7IHR5cGUgU2lua0NhbGwgfSBmcm9tICcuL3NpbmtzJztcblxuLy8gRXhwb3J0IHRoZSB0eXBlIGZvciB1c2Ugb24gdGhlIFwid29ya2VyXCIgc2lkZVxuZXhwb3J0IHsgUHJvbWlzZVN0YWNrU3RvcmUgfSBmcm9tICcuL2ludGVybmFscyc7XG5cbmNvbnN0IGdsb2JhbCA9IGdsb2JhbFRoaXMgYXMgYW55O1xuY29uc3QgT3JpZ2luYWxEYXRlID0gZ2xvYmFsVGhpcy5EYXRlO1xuXG5leHBvcnQgZnVuY3Rpb24gb3ZlcnJpZGVHbG9iYWxzKCk6IHZvaWQge1xuICAvLyBNb2NrIGFueSB3ZWFrIHJlZmVyZW5jZSBiZWNhdXNlIEdDIGlzIG5vbi1kZXRlcm1pbmlzdGljIGFuZCB0aGUgZWZmZWN0IGlzIG9ic2VydmFibGUgZnJvbSB0aGUgV29ya2Zsb3cuXG4gIC8vIFdvcmtmbG93IGRldmVsb3BlciB3aWxsIGdldCBhIG1lYW5pbmdmdWwgZXhjZXB0aW9uIGlmIHRoZXkgdHJ5IHRvIHVzZSB0aGVzZS5cbiAgZ2xvYmFsLldlYWtSZWYgPSBmdW5jdGlvbiAoKSB7XG4gICAgdGhyb3cgbmV3IERldGVybWluaXNtVmlvbGF0aW9uRXJyb3IoJ1dlYWtSZWYgY2Fubm90IGJlIHVzZWQgaW4gV29ya2Zsb3dzIGJlY2F1c2UgdjggR0MgaXMgbm9uLWRldGVybWluaXN0aWMnKTtcbiAgfTtcbiAgZ2xvYmFsLkZpbmFsaXphdGlvblJlZ2lzdHJ5ID0gZnVuY3Rpb24gKCkge1xuICAgIHRocm93IG5ldyBEZXRlcm1pbmlzbVZpb2xhdGlvbkVycm9yKFxuICAgICAgJ0ZpbmFsaXphdGlvblJlZ2lzdHJ5IGNhbm5vdCBiZSB1c2VkIGluIFdvcmtmbG93cyBiZWNhdXNlIHY4IEdDIGlzIG5vbi1kZXRlcm1pbmlzdGljJ1xuICAgICk7XG4gIH07XG5cbiAgZ2xvYmFsLkRhdGUgPSBmdW5jdGlvbiAoLi4uYXJnczogdW5rbm93bltdKSB7XG4gICAgaWYgKGFyZ3MubGVuZ3RoID4gMCkge1xuICAgICAgcmV0dXJuIG5ldyAoT3JpZ2luYWxEYXRlIGFzIGFueSkoLi4uYXJncyk7XG4gICAgfVxuICAgIHJldHVybiBuZXcgT3JpZ2luYWxEYXRlKGdldEFjdGl2YXRvcigpLm5vdyk7XG4gIH07XG5cbiAgZ2xvYmFsLkRhdGUubm93ID0gZnVuY3Rpb24gKCkge1xuICAgIHJldHVybiBnZXRBY3RpdmF0b3IoKS5ub3c7XG4gIH07XG5cbiAgZ2xvYmFsLkRhdGUucGFyc2UgPSBPcmlnaW5hbERhdGUucGFyc2UuYmluZChPcmlnaW5hbERhdGUpO1xuICBnbG9iYWwuRGF0ZS5VVEMgPSBPcmlnaW5hbERhdGUuVVRDLmJpbmQoT3JpZ2luYWxEYXRlKTtcblxuICBnbG9iYWwuRGF0ZS5wcm90b3R5cGUgPSBPcmlnaW5hbERhdGUucHJvdG90eXBlO1xuXG4gIC8qKlxuICAgKiBAcGFyYW0gbXMgc2xlZXAgZHVyYXRpb24gLSAgbnVtYmVyIG9mIG1pbGxpc2Vjb25kcy4gSWYgZ2l2ZW4gYSBuZWdhdGl2ZSBudW1iZXIsIHZhbHVlIHdpbGwgYmUgc2V0IHRvIDEuXG4gICAqL1xuICBnbG9iYWwuc2V0VGltZW91dCA9IGZ1bmN0aW9uIChjYjogKC4uLmFyZ3M6IGFueVtdKSA9PiBhbnksIG1zOiBudW1iZXIsIC4uLmFyZ3M6IGFueVtdKTogbnVtYmVyIHtcbiAgICBjb25zdCBhY3RpdmF0b3IgPSBnZXRBY3RpdmF0b3IoKTtcbiAgICBtcyA9IE1hdGgubWF4KDEsIG1zKTtcbiAgICBjb25zdCBzZXEgPSBhY3RpdmF0b3IubmV4dFNlcXMudGltZXIrKztcbiAgICAvLyBDcmVhdGUgYSBQcm9taXNlIGZvciBBc3luY0xvY2FsU3RvcmFnZSB0byBiZSBhYmxlIHRvIHRyYWNrIHRoaXMgY29tcGxldGlvbiB1c2luZyBwcm9taXNlIGhvb2tzLlxuICAgIG5ldyBQcm9taXNlKChyZXNvbHZlLCByZWplY3QpID0+IHtcbiAgICAgIGFjdGl2YXRvci5jb21wbGV0aW9ucy50aW1lci5zZXQoc2VxLCB7IHJlc29sdmUsIHJlamVjdCB9KTtcbiAgICAgIGFjdGl2YXRvci5wdXNoQ29tbWFuZCh7XG4gICAgICAgIHN0YXJ0VGltZXI6IHtcbiAgICAgICAgICBzZXEsXG4gICAgICAgICAgc3RhcnRUb0ZpcmVUaW1lb3V0OiBtc1RvVHMobXMpLFxuICAgICAgICB9LFxuICAgICAgfSk7XG4gICAgfSkudGhlbihcbiAgICAgICgpID0+IGNiKC4uLmFyZ3MpLFxuICAgICAgKCkgPT4gdW5kZWZpbmVkIC8qIGlnbm9yZSBjYW5jZWxsYXRpb24gKi9cbiAgICApO1xuICAgIHJldHVybiBzZXE7XG4gIH07XG5cbiAgZ2xvYmFsLmNsZWFyVGltZW91dCA9IGZ1bmN0aW9uIChoYW5kbGU6IG51bWJlcik6IHZvaWQge1xuICAgIGNvbnN0IGFjdGl2YXRvciA9IGdldEFjdGl2YXRvcigpO1xuICAgIGFjdGl2YXRvci5uZXh0U2Vxcy50aW1lcisrO1xuICAgIGFjdGl2YXRvci5jb21wbGV0aW9ucy50aW1lci5kZWxldGUoaGFuZGxlKTtcbiAgICBhY3RpdmF0b3IucHVzaENvbW1hbmQoe1xuICAgICAgY2FuY2VsVGltZXI6IHtcbiAgICAgICAgc2VxOiBoYW5kbGUsXG4gICAgICB9LFxuICAgIH0pO1xuICB9O1xuXG4gIC8vIGFjdGl2YXRvci5yYW5kb20gaXMgbXV0YWJsZSwgZG9uJ3QgaGFyZGNvZGUgaXRzIHJlZmVyZW5jZVxuICBNYXRoLnJhbmRvbSA9ICgpID0+IGdldEFjdGl2YXRvcigpLnJhbmRvbSgpO1xufVxuXG4vKipcbiAqIEluaXRpYWxpemUgdGhlIGlzb2xhdGUgcnVudGltZS5cbiAqXG4gKiBTZXRzIHJlcXVpcmVkIGludGVybmFsIHN0YXRlIGFuZCBpbnN0YW50aWF0ZXMgdGhlIHdvcmtmbG93IGFuZCBpbnRlcmNlcHRvcnMuXG4gKi9cbmV4cG9ydCBmdW5jdGlvbiBpbml0UnVudGltZShvcHRpb25zOiBXb3JrZmxvd0NyZWF0ZU9wdGlvbnNJbnRlcm5hbCk6IHZvaWQge1xuICBjb25zdCBhY3RpdmF0b3IgPSBuZXcgQWN0aXZhdG9yKHtcbiAgICAuLi5vcHRpb25zLFxuICAgIGluZm86IGZpeFByb3RvdHlwZXMoe1xuICAgICAgLi4ub3B0aW9ucy5pbmZvLFxuICAgICAgdW5zYWZlOiB7IC4uLm9wdGlvbnMuaW5mby51bnNhZmUsIG5vdzogT3JpZ2luYWxEYXRlLm5vdyB9LFxuICAgIH0pLFxuICB9KTtcbiAgLy8gVGhlcmUncyBvbiBhY3RpdmF0b3IgcGVyIHdvcmtmbG93IGluc3RhbmNlLCBzZXQgaXQgZ2xvYmFsbHkgb24gdGhlIGNvbnRleHQuXG4gIC8vIFdlIGRvIHRoaXMgYmVmb3JlIGltcG9ydGluZyBhbnkgdXNlciBjb2RlIHNvIHVzZXIgY29kZSBjYW4gc3RhdGljYWxseSByZWZlcmVuY2UgQHRlbXBvcmFsaW8vd29ya2Zsb3cgZnVuY3Rpb25zXG4gIC8vIGFzIHdlbGwgYXMgRGF0ZSBhbmQgTWF0aC5yYW5kb20uXG4gIHNldEFjdGl2YXRvclVudHlwZWQoYWN0aXZhdG9yKTtcblxuICAvLyB3ZWJwYWNrIGFsaWFzIHRvIHBheWxvYWRDb252ZXJ0ZXJQYXRoXG4gIC8vIGVzbGludC1kaXNhYmxlLW5leHQtbGluZSBAdHlwZXNjcmlwdC1lc2xpbnQvbm8tdmFyLXJlcXVpcmVzXG4gIGNvbnN0IGN1c3RvbVBheWxvYWRDb252ZXJ0ZXIgPSByZXF1aXJlKCdfX3RlbXBvcmFsX2N1c3RvbV9wYXlsb2FkX2NvbnZlcnRlcicpLnBheWxvYWRDb252ZXJ0ZXI7XG4gIC8vIFRoZSBgcGF5bG9hZENvbnZlcnRlcmAgZXhwb3J0IGlzIHZhbGlkYXRlZCBpbiB0aGUgV29ya2VyXG4gIGlmIChjdXN0b21QYXlsb2FkQ29udmVydGVyICE9IG51bGwpIHtcbiAgICBhY3RpdmF0b3IucGF5bG9hZENvbnZlcnRlciA9IGN1c3RvbVBheWxvYWRDb252ZXJ0ZXI7XG4gIH1cbiAgLy8gd2VicGFjayBhbGlhcyB0byBmYWlsdXJlQ29udmVydGVyUGF0aFxuICAvLyBlc2xpbnQtZGlzYWJsZS1uZXh0LWxpbmUgQHR5cGVzY3JpcHQtZXNsaW50L25vLXZhci1yZXF1aXJlc1xuICBjb25zdCBjdXN0b21GYWlsdXJlQ29udmVydGVyID0gcmVxdWlyZSgnX190ZW1wb3JhbF9jdXN0b21fZmFpbHVyZV9jb252ZXJ0ZXInKS5mYWlsdXJlQ29udmVydGVyO1xuICAvLyBUaGUgYGZhaWx1cmVDb252ZXJ0ZXJgIGV4cG9ydCBpcyB2YWxpZGF0ZWQgaW4gdGhlIFdvcmtlclxuICBpZiAoY3VzdG9tRmFpbHVyZUNvbnZlcnRlciAhPSBudWxsKSB7XG4gICAgYWN0aXZhdG9yLmZhaWx1cmVDb252ZXJ0ZXIgPSBjdXN0b21GYWlsdXJlQ29udmVydGVyO1xuICB9XG5cbiAgY29uc3QgeyBpbXBvcnRXb3JrZmxvd3MsIGltcG9ydEludGVyY2VwdG9ycyB9ID0gZ2xvYmFsLl9fVEVNUE9SQUxfXztcbiAgaWYgKGltcG9ydFdvcmtmbG93cyA9PT0gdW5kZWZpbmVkIHx8IGltcG9ydEludGVyY2VwdG9ycyA9PT0gdW5kZWZpbmVkKSB7XG4gICAgdGhyb3cgbmV3IElsbGVnYWxTdGF0ZUVycm9yKCdXb3JrZmxvdyBidW5kbGUgZGlkIG5vdCByZWdpc3RlciBpbXBvcnQgaG9va3MnKTtcbiAgfVxuXG4gIGNvbnN0IGludGVyY2VwdG9ycyA9IGltcG9ydEludGVyY2VwdG9ycygpO1xuICBmb3IgKGNvbnN0IG1vZCBvZiBpbnRlcmNlcHRvcnMpIHtcbiAgICBjb25zdCBmYWN0b3J5OiBXb3JrZmxvd0ludGVyY2VwdG9yc0ZhY3RvcnkgPSBtb2QuaW50ZXJjZXB0b3JzO1xuICAgIGlmIChmYWN0b3J5ICE9PSB1bmRlZmluZWQpIHtcbiAgICAgIGlmICh0eXBlb2YgZmFjdG9yeSAhPT0gJ2Z1bmN0aW9uJykge1xuICAgICAgICB0aHJvdyBuZXcgVHlwZUVycm9yKGBGYWlsZWQgdG8gaW5pdGlhbGl6ZSB3b3JrZmxvd3MgaW50ZXJjZXB0b3JzOiBleHBlY3RlZCBhIGZ1bmN0aW9uLCBidXQgZ290OiAnJHtmYWN0b3J5fSdgKTtcbiAgICAgIH1cbiAgICAgIGNvbnN0IGludGVyY2VwdG9ycyA9IGZhY3RvcnkoKTtcbiAgICAgIGFjdGl2YXRvci5pbnRlcmNlcHRvcnMuaW5ib3VuZC5wdXNoKC4uLihpbnRlcmNlcHRvcnMuaW5ib3VuZCA/PyBbXSkpO1xuICAgICAgYWN0aXZhdG9yLmludGVyY2VwdG9ycy5vdXRib3VuZC5wdXNoKC4uLihpbnRlcmNlcHRvcnMub3V0Ym91bmQgPz8gW10pKTtcbiAgICAgIGFjdGl2YXRvci5pbnRlcmNlcHRvcnMuaW50ZXJuYWxzLnB1c2goLi4uKGludGVyY2VwdG9ycy5pbnRlcm5hbHMgPz8gW10pKTtcbiAgICB9XG4gIH1cblxuICBjb25zdCBtb2QgPSBpbXBvcnRXb3JrZmxvd3MoKTtcbiAgY29uc3Qgd29ya2Zsb3dGbiA9IG1vZFthY3RpdmF0b3IuaW5mby53b3JrZmxvd1R5cGVdO1xuICBjb25zdCBkZWZhdWx0V29ya2Zsb3dGbiA9IG1vZFsnZGVmYXVsdCddO1xuXG4gIGlmICh0eXBlb2Ygd29ya2Zsb3dGbiA9PT0gJ2Z1bmN0aW9uJykge1xuICAgIGFjdGl2YXRvci53b3JrZmxvdyA9IHdvcmtmbG93Rm47XG4gIH0gZWxzZSBpZiAodHlwZW9mIGRlZmF1bHRXb3JrZmxvd0ZuID09PSAnZnVuY3Rpb24nKSB7XG4gICAgYWN0aXZhdG9yLndvcmtmbG93ID0gZGVmYXVsdFdvcmtmbG93Rm47XG4gIH0gZWxzZSB7XG4gICAgY29uc3QgZGV0YWlscyA9XG4gICAgICB3b3JrZmxvd0ZuID09PSB1bmRlZmluZWRcbiAgICAgICAgPyAnbm8gc3VjaCBmdW5jdGlvbiBpcyBleHBvcnRlZCBieSB0aGUgd29ya2Zsb3cgYnVuZGxlJ1xuICAgICAgICA6IGBleHBlY3RlZCBhIGZ1bmN0aW9uLCBidXQgZ290OiAnJHt0eXBlb2Ygd29ya2Zsb3dGbn0nYDtcbiAgICB0aHJvdyBuZXcgVHlwZUVycm9yKGBGYWlsZWQgdG8gaW5pdGlhbGl6ZSB3b3JrZmxvdyBvZiB0eXBlICcke2FjdGl2YXRvci5pbmZvLndvcmtmbG93VHlwZX0nOiAke2RldGFpbHN9YCk7XG4gIH1cbn1cblxuLyoqXG4gKiBPYmplY3RzIHRyYW5zZmVyZWQgdG8gdGhlIFZNIGZyb20gb3V0c2lkZSBoYXZlIHByb3RvdHlwZXMgYmVsb25naW5nIHRvIHRoZVxuICogb3V0ZXIgY29udGV4dCwgd2hpY2ggbWVhbnMgdGhhdCBpbnN0YW5jZW9mIHdvbid0IHdvcmsgaW5zaWRlIHRoZSBWTS4gVGhpc1xuICogZnVuY3Rpb24gcmVjdXJzaXZlbHkgd2Fsa3Mgb3ZlciB0aGUgY29udGVudCBvZiBhbiBvYmplY3QsIGFuZCByZWNyZWF0ZSBzb21lXG4gKiBvZiB0aGVzZSBvYmplY3RzIChub3RhYmx5IEFycmF5LCBEYXRlIGFuZCBPYmplY3RzKS5cbiAqL1xuZnVuY3Rpb24gZml4UHJvdG90eXBlczxYPihvYmo6IFgpOiBYIHtcbiAgaWYgKG9iaiAhPSBudWxsICYmIHR5cGVvZiBvYmogPT09ICdvYmplY3QnKSB7XG4gICAgc3dpdGNoIChPYmplY3QuZ2V0UHJvdG90eXBlT2Yob2JqKT8uY29uc3RydWN0b3I/Lm5hbWUpIHtcbiAgICAgIGNhc2UgJ0FycmF5JzpcbiAgICAgICAgcmV0dXJuIEFycmF5LmZyb20oKG9iaiBhcyBBcnJheTx1bmtub3duPikubWFwKGZpeFByb3RvdHlwZXMpKSBhcyBYO1xuICAgICAgY2FzZSAnRGF0ZSc6XG4gICAgICAgIHJldHVybiBuZXcgRGF0ZShvYmogYXMgdW5rbm93biBhcyBEYXRlKSBhcyBYO1xuICAgICAgZGVmYXVsdDpcbiAgICAgICAgcmV0dXJuIE9iamVjdC5mcm9tRW50cmllcyhPYmplY3QuZW50cmllcyhvYmopLm1hcCgoW2ssIHZdKTogW3N0cmluZywgYW55XSA9PiBbaywgZml4UHJvdG90eXBlcyh2KV0pKSBhcyBYO1xuICAgIH1cbiAgfSBlbHNlIHJldHVybiBvYmo7XG59XG5cbi8qKlxuICogUnVuIGEgY2h1bmsgb2YgYWN0aXZhdGlvbiBqb2JzXG4gKiBAcmV0dXJucyBhIGJvb2xlYW4gaW5kaWNhdGluZyB3aGV0aGVyIGpvYiB3YXMgcHJvY2Vzc2VkIG9yIGlnbm9yZWRcbiAqL1xuZXhwb3J0IGZ1bmN0aW9uIGFjdGl2YXRlKGFjdGl2YXRpb246IGNvcmVzZGsud29ya2Zsb3dfYWN0aXZhdGlvbi5Xb3JrZmxvd0FjdGl2YXRpb24sIGJhdGNoSW5kZXg6IG51bWJlcik6IHZvaWQge1xuICBjb25zdCBhY3RpdmF0b3IgPSBnZXRBY3RpdmF0b3IoKTtcbiAgY29uc3QgaW50ZXJjZXB0ID0gY29tcG9zZUludGVyY2VwdG9ycyhhY3RpdmF0b3IuaW50ZXJjZXB0b3JzLmludGVybmFscywgJ2FjdGl2YXRlJywgKHsgYWN0aXZhdGlvbiwgYmF0Y2hJbmRleCB9KSA9PiB7XG4gICAgaWYgKGJhdGNoSW5kZXggPT09IDApIHtcbiAgICAgIGlmICghYWN0aXZhdGlvbi5qb2JzKSB7XG4gICAgICAgIHRocm93IG5ldyBUeXBlRXJyb3IoJ0dvdCBhY3RpdmF0aW9uIHdpdGggbm8gam9icycpO1xuICAgICAgfVxuICAgICAgaWYgKGFjdGl2YXRpb24udGltZXN0YW1wICE9IG51bGwpIHtcbiAgICAgICAgLy8gdGltZXN0YW1wIHdpbGwgbm90IGJlIHVwZGF0ZWQgZm9yIGFjdGl2YXRpb24gdGhhdCBjb250YWluIG9ubHkgcXVlcmllc1xuICAgICAgICBhY3RpdmF0b3Iubm93ID0gdHNUb01zKGFjdGl2YXRpb24udGltZXN0YW1wKTtcbiAgICAgIH1cblxuICAgICAgLy8gVGhlIFJ1c3QgQ29yZSBlbnN1cmVzIHRoYXQgdGhlc2UgYWN0aXZhdGlvbiBmaWVsZHMgYXJlIG5vdCBudWxsXG4gICAgICBhY3RpdmF0b3IubXV0YXRlV29ya2Zsb3dJbmZvKChpbmZvKSA9PiAoe1xuICAgICAgICAuLi5pbmZvLFxuICAgICAgICBoaXN0b3J5TGVuZ3RoOiBhY3RpdmF0aW9uLmhpc3RvcnlMZW5ndGggYXMgbnVtYmVyLFxuICAgICAgICAvLyBFeGFjdCB0cnVuY2F0aW9uIGZvciBtdWx0aS1wZXRhYnl0ZSBoaXN0b3JpZXNcbiAgICAgICAgLy8gaGlzdG9yeVNpemUgPT09IDAgbWVhbnMgV0ZUIHdhcyBnZW5lcmF0ZWQgYnkgcHJlLTEuMjAuMCBzZXJ2ZXIsIGFuZCB0aGUgaGlzdG9yeSBzaXplIGlzIHVua25vd25cbiAgICAgICAgaGlzdG9yeVNpemU6IGFjdGl2YXRpb24uaGlzdG9yeVNpemVCeXRlcz8udG9OdW1iZXIoKSB8fCAwLFxuICAgICAgICBjb250aW51ZUFzTmV3U3VnZ2VzdGVkOiBhY3RpdmF0aW9uLmNvbnRpbnVlQXNOZXdTdWdnZXN0ZWQgPz8gZmFsc2UsXG4gICAgICAgIGN1cnJlbnRCdWlsZElkOiBhY3RpdmF0aW9uLmJ1aWxkSWRGb3JDdXJyZW50VGFzayA/PyB1bmRlZmluZWQsXG4gICAgICAgIHVuc2FmZToge1xuICAgICAgICAgIC4uLmluZm8udW5zYWZlLFxuICAgICAgICAgIGlzUmVwbGF5aW5nOiBhY3RpdmF0aW9uLmlzUmVwbGF5aW5nID8/IGZhbHNlLFxuICAgICAgICB9LFxuICAgICAgfSkpO1xuICAgIH1cblxuICAgIC8vIENhc3QgZnJvbSB0aGUgaW50ZXJmYWNlIHRvIHRoZSBjbGFzcyB3aGljaCBoYXMgdGhlIGB2YXJpYW50YCBhdHRyaWJ1dGUuXG4gICAgLy8gVGhpcyBpcyBzYWZlIGJlY2F1c2Ugd2Uga25vdyB0aGF0IGFjdGl2YXRpb24gaXMgYSBwcm90byBjbGFzcy5cbiAgICBjb25zdCBqb2JzID0gYWN0aXZhdGlvbi5qb2JzIGFzIGNvcmVzZGsud29ya2Zsb3dfYWN0aXZhdGlvbi5Xb3JrZmxvd0FjdGl2YXRpb25Kb2JbXTtcblxuICAgIGZvciAoY29uc3Qgam9iIG9mIGpvYnMpIHtcbiAgICAgIGlmIChqb2IudmFyaWFudCA9PT0gdW5kZWZpbmVkKSB7XG4gICAgICAgIHRocm93IG5ldyBUeXBlRXJyb3IoJ0V4cGVjdGVkIGpvYi52YXJpYW50IHRvIGJlIGRlZmluZWQnKTtcbiAgICAgIH1cblxuICAgICAgY29uc3QgdmFyaWFudCA9IGpvYltqb2IudmFyaWFudF07XG4gICAgICBpZiAoIXZhcmlhbnQpIHtcbiAgICAgICAgdGhyb3cgbmV3IFR5cGVFcnJvcihgRXhwZWN0ZWQgam9iLiR7am9iLnZhcmlhbnR9IHRvIGJlIHNldGApO1xuICAgICAgfVxuICAgICAgLy8gVGhlIG9ubHkgam9iIHRoYXQgY2FuIGJlIGV4ZWN1dGVkIG9uIGEgY29tcGxldGVkIHdvcmtmbG93IGlzIGEgcXVlcnkuXG4gICAgICAvLyBXZSBtaWdodCBnZXQgb3RoZXIgam9icyBhZnRlciBjb21wbGV0aW9uIGZvciBpbnN0YW5jZSB3aGVuIGEgc2luZ2xlXG4gICAgICAvLyBhY3RpdmF0aW9uIGNvbnRhaW5zIG11bHRpcGxlIGpvYnMgYW5kIHRoZSBmaXJzdCBvbmUgY29tcGxldGVzIHRoZSB3b3JrZmxvdy5cbiAgICAgIGlmIChhY3RpdmF0b3IuY29tcGxldGVkICYmIGpvYi52YXJpYW50ICE9PSAncXVlcnlXb3JrZmxvdycpIHtcbiAgICAgICAgcmV0dXJuO1xuICAgICAgfVxuICAgICAgYWN0aXZhdG9yW2pvYi52YXJpYW50XSh2YXJpYW50IGFzIGFueSAvKiBUUyBjYW4ndCBpbmZlciB0aGlzIHR5cGUgKi8pO1xuICAgICAgaWYgKHNob3VsZFVuYmxvY2tDb25kaXRpb25zKGpvYikpIHtcbiAgICAgICAgdHJ5VW5ibG9ja0NvbmRpdGlvbnMoKTtcbiAgICAgIH1cbiAgICB9XG4gIH0pO1xuICBpbnRlcmNlcHQoe1xuICAgIGFjdGl2YXRpb24sXG4gICAgYmF0Y2hJbmRleCxcbiAgfSk7XG59XG5cbi8qKlxuICogQ29uY2x1ZGUgYSBzaW5nbGUgYWN0aXZhdGlvbi5cbiAqIFNob3VsZCBiZSBjYWxsZWQgYWZ0ZXIgcHJvY2Vzc2luZyBhbGwgYWN0aXZhdGlvbiBqb2JzIGFuZCBxdWV1ZWQgbWljcm90YXNrcy5cbiAqXG4gKiBBY3RpdmF0aW9uIGZhaWx1cmVzIGFyZSBoYW5kbGVkIGluIHRoZSBtYWluIE5vZGUuanMgaXNvbGF0ZS5cbiAqL1xuZXhwb3J0IGZ1bmN0aW9uIGNvbmNsdWRlQWN0aXZhdGlvbigpOiBjb3Jlc2RrLndvcmtmbG93X2NvbXBsZXRpb24uSVdvcmtmbG93QWN0aXZhdGlvbkNvbXBsZXRpb24ge1xuICBjb25zdCBhY3RpdmF0b3IgPSBnZXRBY3RpdmF0b3IoKTtcbiAgYWN0aXZhdG9yLnJlamVjdEJ1ZmZlcmVkVXBkYXRlcygpO1xuICBjb25zdCBpbnRlcmNlcHQgPSBjb21wb3NlSW50ZXJjZXB0b3JzKGFjdGl2YXRvci5pbnRlcmNlcHRvcnMuaW50ZXJuYWxzLCAnY29uY2x1ZGVBY3RpdmF0aW9uJywgKGlucHV0KSA9PiBpbnB1dCk7XG4gIGNvbnN0IHsgaW5mbyB9ID0gYWN0aXZhdG9yO1xuICBjb25zdCB7IGNvbW1hbmRzIH0gPSBpbnRlcmNlcHQoeyBjb21tYW5kczogYWN0aXZhdG9yLmdldEFuZFJlc2V0Q29tbWFuZHMoKSB9KTtcblxuICByZXR1cm4ge1xuICAgIHJ1bklkOiBpbmZvLnJ1bklkLFxuICAgIHN1Y2Nlc3NmdWw6IHsgY29tbWFuZHMgfSxcbiAgfTtcbn1cblxuZXhwb3J0IGZ1bmN0aW9uIGdldEFuZFJlc2V0U2lua0NhbGxzKCk6IFNpbmtDYWxsW10ge1xuICByZXR1cm4gZ2V0QWN0aXZhdG9yKCkuZ2V0QW5kUmVzZXRTaW5rQ2FsbHMoKTtcbn1cblxuLyoqXG4gKiBMb29wIHRocm91Z2ggYWxsIGJsb2NrZWQgY29uZGl0aW9ucywgZXZhbHVhdGUgYW5kIHVuYmxvY2sgaWYgcG9zc2libGUuXG4gKlxuICogQHJldHVybnMgbnVtYmVyIG9mIHVuYmxvY2tlZCBjb25kaXRpb25zLlxuICovXG5leHBvcnQgZnVuY3Rpb24gdHJ5VW5ibG9ja0NvbmRpdGlvbnMoKTogbnVtYmVyIHtcbiAgbGV0IG51bVVuYmxvY2tlZCA9IDA7XG4gIGZvciAoOzspIHtcbiAgICBjb25zdCBwcmV2VW5ibG9ja2VkID0gbnVtVW5ibG9ja2VkO1xuICAgIGZvciAoY29uc3QgW3NlcSwgY29uZF0gb2YgZ2V0QWN0aXZhdG9yKCkuYmxvY2tlZENvbmRpdGlvbnMuZW50cmllcygpKSB7XG4gICAgICBpZiAoY29uZC5mbigpKSB7XG4gICAgICAgIGNvbmQucmVzb2x2ZSgpO1xuICAgICAgICBudW1VbmJsb2NrZWQrKztcbiAgICAgICAgLy8gSXQgaXMgc2FmZSB0byBkZWxldGUgZWxlbWVudHMgZHVyaW5nIG1hcCBpdGVyYXRpb25cbiAgICAgICAgZ2V0QWN0aXZhdG9yKCkuYmxvY2tlZENvbmRpdGlvbnMuZGVsZXRlKHNlcSk7XG4gICAgICB9XG4gICAgfVxuICAgIGlmIChwcmV2VW5ibG9ja2VkID09PSBudW1VbmJsb2NrZWQpIHtcbiAgICAgIGJyZWFrO1xuICAgIH1cbiAgfVxuICByZXR1cm4gbnVtVW5ibG9ja2VkO1xufVxuXG4vKipcbiAqIFByZWRpY2F0ZSB1c2VkIHRvIHByZXZlbnQgdHJpZ2dlcmluZyBjb25kaXRpb25zIGZvciBub24tcXVlcnkgYW5kIG5vbi1wYXRjaCBqb2JzLlxuICovXG5leHBvcnQgZnVuY3Rpb24gc2hvdWxkVW5ibG9ja0NvbmRpdGlvbnMoam9iOiBjb3Jlc2RrLndvcmtmbG93X2FjdGl2YXRpb24uSVdvcmtmbG93QWN0aXZhdGlvbkpvYik6IGJvb2xlYW4ge1xuICByZXR1cm4gIWpvYi5xdWVyeVdvcmtmbG93ICYmICFqb2Iubm90aWZ5SGFzUGF0Y2g7XG59XG5cbmV4cG9ydCBmdW5jdGlvbiBkaXNwb3NlKCk6IHZvaWQge1xuICBjb25zdCBkaXNwb3NlID0gY29tcG9zZUludGVyY2VwdG9ycyhnZXRBY3RpdmF0b3IoKS5pbnRlcmNlcHRvcnMuaW50ZXJuYWxzLCAnZGlzcG9zZScsIGFzeW5jICgpID0+IHtcbiAgICBkaXNhYmxlU3RvcmFnZSgpO1xuICB9KTtcbiAgZGlzcG9zZSh7fSk7XG59XG4iLCJpbXBvcnQge1xuICBBY3Rpdml0eUZ1bmN0aW9uLFxuICBBY3Rpdml0eU9wdGlvbnMsXG4gIGNvbXBpbGVSZXRyeVBvbGljeSxcbiAgZXh0cmFjdFdvcmtmbG93VHlwZSxcbiAgSWxsZWdhbFN0YXRlRXJyb3IsXG4gIExvY2FsQWN0aXZpdHlPcHRpb25zLFxuICBtYXBUb1BheWxvYWRzLFxuICBRdWVyeURlZmluaXRpb24sXG4gIHNlYXJjaEF0dHJpYnV0ZVBheWxvYWRDb252ZXJ0ZXIsXG4gIFNlYXJjaEF0dHJpYnV0ZXMsXG4gIFNpZ25hbERlZmluaXRpb24sXG4gIHRvUGF5bG9hZHMsXG4gIFVudHlwZWRBY3Rpdml0aWVzLFxuICBVcGRhdGVEZWZpbml0aW9uLFxuICBXaXRoV29ya2Zsb3dBcmdzLFxuICBXb3JrZmxvdyxcbiAgV29ya2Zsb3dSZXN1bHRUeXBlLFxuICBXb3JrZmxvd1JldHVyblR5cGUsXG4gIFdvcmtmbG93VXBkYXRlVmFsaWRhdG9yVHlwZSxcbn0gZnJvbSAnQHRlbXBvcmFsaW8vY29tbW9uJztcbmltcG9ydCB7IHZlcnNpb25pbmdJbnRlbnRUb1Byb3RvIH0gZnJvbSAnQHRlbXBvcmFsaW8vY29tbW9uL2xpYi92ZXJzaW9uaW5nLWludGVudC1lbnVtJztcbmltcG9ydCB7IER1cmF0aW9uLCBtc09wdGlvbmFsVG9UcywgbXNUb051bWJlciwgbXNUb1RzLCB0c1RvTXMgfSBmcm9tICdAdGVtcG9yYWxpby9jb21tb24vbGliL3RpbWUnO1xuaW1wb3J0IHsgY29tcG9zZUludGVyY2VwdG9ycyB9IGZyb20gJ0B0ZW1wb3JhbGlvL2NvbW1vbi9saWIvaW50ZXJjZXB0b3JzJztcbmltcG9ydCB7IHRlbXBvcmFsIH0gZnJvbSAnQHRlbXBvcmFsaW8vcHJvdG8nO1xuaW1wb3J0IHsgQ2FuY2VsbGF0aW9uU2NvcGUsIHJlZ2lzdGVyU2xlZXBJbXBsZW1lbnRhdGlvbiB9IGZyb20gJy4vY2FuY2VsbGF0aW9uLXNjb3BlJztcbmltcG9ydCB7XG4gIEFjdGl2aXR5SW5wdXQsXG4gIExvY2FsQWN0aXZpdHlJbnB1dCxcbiAgU2lnbmFsV29ya2Zsb3dJbnB1dCxcbiAgU3RhcnRDaGlsZFdvcmtmbG93RXhlY3V0aW9uSW5wdXQsXG4gIFRpbWVySW5wdXQsXG59IGZyb20gJy4vaW50ZXJjZXB0b3JzJztcbmltcG9ydCB7XG4gIENoaWxkV29ya2Zsb3dDYW5jZWxsYXRpb25UeXBlLFxuICBDaGlsZFdvcmtmbG93T3B0aW9ucyxcbiAgQ2hpbGRXb3JrZmxvd09wdGlvbnNXaXRoRGVmYXVsdHMsXG4gIENvbnRpbnVlQXNOZXcsXG4gIENvbnRpbnVlQXNOZXdPcHRpb25zLFxuICBEZWZhdWx0U2lnbmFsSGFuZGxlcixcbiAgRW5oYW5jZWRTdGFja1RyYWNlLFxuICBIYW5kbGVyLFxuICBRdWVyeUhhbmRsZXJPcHRpb25zLFxuICBTaWduYWxIYW5kbGVyT3B0aW9ucyxcbiAgVXBkYXRlSGFuZGxlck9wdGlvbnMsXG4gIFdvcmtmbG93SW5mbyxcbn0gZnJvbSAnLi9pbnRlcmZhY2VzJztcbmltcG9ydCB7IExvY2FsQWN0aXZpdHlEb0JhY2tvZmYgfSBmcm9tICcuL2Vycm9ycyc7XG5pbXBvcnQgeyBhc3NlcnRJbldvcmtmbG93Q29udGV4dCwgZ2V0QWN0aXZhdG9yLCBtYXliZUdldEFjdGl2YXRvciB9IGZyb20gJy4vZ2xvYmFsLWF0dHJpYnV0ZXMnO1xuaW1wb3J0IHsgdW50cmFja1Byb21pc2UgfSBmcm9tICcuL3N0YWNrLWhlbHBlcnMnO1xuaW1wb3J0IHsgQ2hpbGRXb3JrZmxvd0hhbmRsZSwgRXh0ZXJuYWxXb3JrZmxvd0hhbmRsZSB9IGZyb20gJy4vd29ya2Zsb3ctaGFuZGxlJztcblxuLy8gQXZvaWQgYSBjaXJjdWxhciBkZXBlbmRlbmN5XG5yZWdpc3RlclNsZWVwSW1wbGVtZW50YXRpb24oc2xlZXApO1xuXG4vKipcbiAqIEFkZHMgZGVmYXVsdCB2YWx1ZXMgdG8gYHdvcmtmbG93SWRgIGFuZCBgd29ya2Zsb3dJZFJldXNlUG9saWN5YCB0byBnaXZlbiB3b3JrZmxvdyBvcHRpb25zLlxuICovXG5leHBvcnQgZnVuY3Rpb24gYWRkRGVmYXVsdFdvcmtmbG93T3B0aW9uczxUIGV4dGVuZHMgV29ya2Zsb3c+KFxuICBvcHRzOiBXaXRoV29ya2Zsb3dBcmdzPFQsIENoaWxkV29ya2Zsb3dPcHRpb25zPlxuKTogQ2hpbGRXb3JrZmxvd09wdGlvbnNXaXRoRGVmYXVsdHMge1xuICBjb25zdCB7IGFyZ3MsIHdvcmtmbG93SWQsIC4uLnJlc3QgfSA9IG9wdHM7XG4gIHJldHVybiB7XG4gICAgd29ya2Zsb3dJZDogd29ya2Zsb3dJZCA/PyB1dWlkNCgpLFxuICAgIGFyZ3M6IGFyZ3MgPz8gW10sXG4gICAgY2FuY2VsbGF0aW9uVHlwZTogQ2hpbGRXb3JrZmxvd0NhbmNlbGxhdGlvblR5cGUuV0FJVF9DQU5DRUxMQVRJT05fQ09NUExFVEVELFxuICAgIC4uLnJlc3QsXG4gIH07XG59XG5cbi8qKlxuICogUHVzaCBhIHN0YXJ0VGltZXIgY29tbWFuZCBpbnRvIHN0YXRlIGFjY3VtdWxhdG9yIGFuZCByZWdpc3RlciBjb21wbGV0aW9uXG4gKi9cbmZ1bmN0aW9uIHRpbWVyTmV4dEhhbmRsZXIoaW5wdXQ6IFRpbWVySW5wdXQpIHtcbiAgY29uc3QgYWN0aXZhdG9yID0gZ2V0QWN0aXZhdG9yKCk7XG4gIHJldHVybiBuZXcgUHJvbWlzZTx2b2lkPigocmVzb2x2ZSwgcmVqZWN0KSA9PiB7XG4gICAgY29uc3Qgc2NvcGUgPSBDYW5jZWxsYXRpb25TY29wZS5jdXJyZW50KCk7XG4gICAgaWYgKHNjb3BlLmNvbnNpZGVyZWRDYW5jZWxsZWQpIHtcbiAgICAgIHVudHJhY2tQcm9taXNlKHNjb3BlLmNhbmNlbFJlcXVlc3RlZC5jYXRjaChyZWplY3QpKTtcbiAgICAgIHJldHVybjtcbiAgICB9XG4gICAgaWYgKHNjb3BlLmNhbmNlbGxhYmxlKSB7XG4gICAgICB1bnRyYWNrUHJvbWlzZShcbiAgICAgICAgc2NvcGUuY2FuY2VsUmVxdWVzdGVkLmNhdGNoKChlcnIpID0+IHtcbiAgICAgICAgICBpZiAoIWFjdGl2YXRvci5jb21wbGV0aW9ucy50aW1lci5kZWxldGUoaW5wdXQuc2VxKSkge1xuICAgICAgICAgICAgcmV0dXJuOyAvLyBBbHJlYWR5IHJlc29sdmVkIG9yIG5ldmVyIHNjaGVkdWxlZFxuICAgICAgICAgIH1cbiAgICAgICAgICBhY3RpdmF0b3IucHVzaENvbW1hbmQoe1xuICAgICAgICAgICAgY2FuY2VsVGltZXI6IHtcbiAgICAgICAgICAgICAgc2VxOiBpbnB1dC5zZXEsXG4gICAgICAgICAgICB9LFxuICAgICAgICAgIH0pO1xuICAgICAgICAgIHJlamVjdChlcnIpO1xuICAgICAgICB9KVxuICAgICAgKTtcbiAgICB9XG4gICAgYWN0aXZhdG9yLnB1c2hDb21tYW5kKHtcbiAgICAgIHN0YXJ0VGltZXI6IHtcbiAgICAgICAgc2VxOiBpbnB1dC5zZXEsXG4gICAgICAgIHN0YXJ0VG9GaXJlVGltZW91dDogbXNUb1RzKGlucHV0LmR1cmF0aW9uTXMpLFxuICAgICAgfSxcbiAgICB9KTtcbiAgICBhY3RpdmF0b3IuY29tcGxldGlvbnMudGltZXIuc2V0KGlucHV0LnNlcSwge1xuICAgICAgcmVzb2x2ZSxcbiAgICAgIHJlamVjdCxcbiAgICB9KTtcbiAgfSk7XG59XG5cbi8qKlxuICogQXN5bmNocm9ub3VzIHNsZWVwLlxuICpcbiAqIFNjaGVkdWxlcyBhIHRpbWVyIG9uIHRoZSBUZW1wb3JhbCBzZXJ2aWNlLlxuICpcbiAqIEBwYXJhbSBtcyBzbGVlcCBkdXJhdGlvbiAtIG51bWJlciBvZiBtaWxsaXNlY29uZHMgb3Ige0BsaW5rIGh0dHBzOi8vd3d3Lm5wbWpzLmNvbS9wYWNrYWdlL21zIHwgbXMtZm9ybWF0dGVkIHN0cmluZ30uXG4gKiBJZiBnaXZlbiBhIG5lZ2F0aXZlIG51bWJlciBvciAwLCB2YWx1ZSB3aWxsIGJlIHNldCB0byAxLlxuICovXG5leHBvcnQgZnVuY3Rpb24gc2xlZXAobXM6IER1cmF0aW9uKTogUHJvbWlzZTx2b2lkPiB7XG4gIGNvbnN0IGFjdGl2YXRvciA9IGFzc2VydEluV29ya2Zsb3dDb250ZXh0KCdXb3JrZmxvdy5zbGVlcCguLi4pIG1heSBvbmx5IGJlIHVzZWQgZnJvbSBhIFdvcmtmbG93IEV4ZWN1dGlvbicpO1xuICBjb25zdCBzZXEgPSBhY3RpdmF0b3IubmV4dFNlcXMudGltZXIrKztcblxuICBjb25zdCBkdXJhdGlvbk1zID0gTWF0aC5tYXgoMSwgbXNUb051bWJlcihtcykpO1xuXG4gIGNvbnN0IGV4ZWN1dGUgPSBjb21wb3NlSW50ZXJjZXB0b3JzKGFjdGl2YXRvci5pbnRlcmNlcHRvcnMub3V0Ym91bmQsICdzdGFydFRpbWVyJywgdGltZXJOZXh0SGFuZGxlcik7XG5cbiAgcmV0dXJuIGV4ZWN1dGUoe1xuICAgIGR1cmF0aW9uTXMsXG4gICAgc2VxLFxuICB9KTtcbn1cblxuZnVuY3Rpb24gdmFsaWRhdGVBY3Rpdml0eU9wdGlvbnMob3B0aW9uczogQWN0aXZpdHlPcHRpb25zKTogdm9pZCB7XG4gIGlmIChvcHRpb25zLnNjaGVkdWxlVG9DbG9zZVRpbWVvdXQgPT09IHVuZGVmaW5lZCAmJiBvcHRpb25zLnN0YXJ0VG9DbG9zZVRpbWVvdXQgPT09IHVuZGVmaW5lZCkge1xuICAgIHRocm93IG5ldyBUeXBlRXJyb3IoJ1JlcXVpcmVkIGVpdGhlciBzY2hlZHVsZVRvQ2xvc2VUaW1lb3V0IG9yIHN0YXJ0VG9DbG9zZVRpbWVvdXQnKTtcbiAgfVxufVxuXG4vLyBVc2Ugc2FtZSB2YWxpZGF0aW9uIHdlIHVzZSBmb3Igbm9ybWFsIGFjdGl2aXRpZXNcbmNvbnN0IHZhbGlkYXRlTG9jYWxBY3Rpdml0eU9wdGlvbnMgPSB2YWxpZGF0ZUFjdGl2aXR5T3B0aW9ucztcblxuLyoqXG4gKiBQdXNoIGEgc2NoZWR1bGVBY3Rpdml0eSBjb21tYW5kIGludG8gYWN0aXZhdG9yIGFjY3VtdWxhdG9yIGFuZCByZWdpc3RlciBjb21wbGV0aW9uXG4gKi9cbmZ1bmN0aW9uIHNjaGVkdWxlQWN0aXZpdHlOZXh0SGFuZGxlcih7IG9wdGlvbnMsIGFyZ3MsIGhlYWRlcnMsIHNlcSwgYWN0aXZpdHlUeXBlIH06IEFjdGl2aXR5SW5wdXQpOiBQcm9taXNlPHVua25vd24+IHtcbiAgY29uc3QgYWN0aXZhdG9yID0gZ2V0QWN0aXZhdG9yKCk7XG4gIHZhbGlkYXRlQWN0aXZpdHlPcHRpb25zKG9wdGlvbnMpO1xuICByZXR1cm4gbmV3IFByb21pc2UoKHJlc29sdmUsIHJlamVjdCkgPT4ge1xuICAgIGNvbnN0IHNjb3BlID0gQ2FuY2VsbGF0aW9uU2NvcGUuY3VycmVudCgpO1xuICAgIGlmIChzY29wZS5jb25zaWRlcmVkQ2FuY2VsbGVkKSB7XG4gICAgICB1bnRyYWNrUHJvbWlzZShzY29wZS5jYW5jZWxSZXF1ZXN0ZWQuY2F0Y2gocmVqZWN0KSk7XG4gICAgICByZXR1cm47XG4gICAgfVxuICAgIGlmIChzY29wZS5jYW5jZWxsYWJsZSkge1xuICAgICAgdW50cmFja1Byb21pc2UoXG4gICAgICAgIHNjb3BlLmNhbmNlbFJlcXVlc3RlZC5jYXRjaCgoKSA9PiB7XG4gICAgICAgICAgaWYgKCFhY3RpdmF0b3IuY29tcGxldGlvbnMuYWN0aXZpdHkuaGFzKHNlcSkpIHtcbiAgICAgICAgICAgIHJldHVybjsgLy8gQWxyZWFkeSByZXNvbHZlZCBvciBuZXZlciBzY2hlZHVsZWRcbiAgICAgICAgICB9XG4gICAgICAgICAgYWN0aXZhdG9yLnB1c2hDb21tYW5kKHtcbiAgICAgICAgICAgIHJlcXVlc3RDYW5jZWxBY3Rpdml0eToge1xuICAgICAgICAgICAgICBzZXEsXG4gICAgICAgICAgICB9LFxuICAgICAgICAgIH0pO1xuICAgICAgICB9KVxuICAgICAgKTtcbiAgICB9XG4gICAgYWN0aXZhdG9yLnB1c2hDb21tYW5kKHtcbiAgICAgIHNjaGVkdWxlQWN0aXZpdHk6IHtcbiAgICAgICAgc2VxLFxuICAgICAgICBhY3Rpdml0eUlkOiBvcHRpb25zLmFjdGl2aXR5SWQgPz8gYCR7c2VxfWAsXG4gICAgICAgIGFjdGl2aXR5VHlwZSxcbiAgICAgICAgYXJndW1lbnRzOiB0b1BheWxvYWRzKGFjdGl2YXRvci5wYXlsb2FkQ29udmVydGVyLCAuLi5hcmdzKSxcbiAgICAgICAgcmV0cnlQb2xpY3k6IG9wdGlvbnMucmV0cnkgPyBjb21waWxlUmV0cnlQb2xpY3kob3B0aW9ucy5yZXRyeSkgOiB1bmRlZmluZWQsXG4gICAgICAgIHRhc2tRdWV1ZTogb3B0aW9ucy50YXNrUXVldWUgfHwgYWN0aXZhdG9yLmluZm8udGFza1F1ZXVlLFxuICAgICAgICBoZWFydGJlYXRUaW1lb3V0OiBtc09wdGlvbmFsVG9UcyhvcHRpb25zLmhlYXJ0YmVhdFRpbWVvdXQpLFxuICAgICAgICBzY2hlZHVsZVRvQ2xvc2VUaW1lb3V0OiBtc09wdGlvbmFsVG9UcyhvcHRpb25zLnNjaGVkdWxlVG9DbG9zZVRpbWVvdXQpLFxuICAgICAgICBzdGFydFRvQ2xvc2VUaW1lb3V0OiBtc09wdGlvbmFsVG9UcyhvcHRpb25zLnN0YXJ0VG9DbG9zZVRpbWVvdXQpLFxuICAgICAgICBzY2hlZHVsZVRvU3RhcnRUaW1lb3V0OiBtc09wdGlvbmFsVG9UcyhvcHRpb25zLnNjaGVkdWxlVG9TdGFydFRpbWVvdXQpLFxuICAgICAgICBoZWFkZXJzLFxuICAgICAgICBjYW5jZWxsYXRpb25UeXBlOiBvcHRpb25zLmNhbmNlbGxhdGlvblR5cGUsXG4gICAgICAgIGRvTm90RWFnZXJseUV4ZWN1dGU6ICEob3B0aW9ucy5hbGxvd0VhZ2VyRGlzcGF0Y2ggPz8gdHJ1ZSksXG4gICAgICAgIHZlcnNpb25pbmdJbnRlbnQ6IHZlcnNpb25pbmdJbnRlbnRUb1Byb3RvKG9wdGlvbnMudmVyc2lvbmluZ0ludGVudCksXG4gICAgICB9LFxuICAgIH0pO1xuICAgIGFjdGl2YXRvci5jb21wbGV0aW9ucy5hY3Rpdml0eS5zZXQoc2VxLCB7XG4gICAgICByZXNvbHZlLFxuICAgICAgcmVqZWN0LFxuICAgIH0pO1xuICB9KTtcbn1cblxuLyoqXG4gKiBQdXNoIGEgc2NoZWR1bGVBY3Rpdml0eSBjb21tYW5kIGludG8gc3RhdGUgYWNjdW11bGF0b3IgYW5kIHJlZ2lzdGVyIGNvbXBsZXRpb25cbiAqL1xuYXN5bmMgZnVuY3Rpb24gc2NoZWR1bGVMb2NhbEFjdGl2aXR5TmV4dEhhbmRsZXIoe1xuICBvcHRpb25zLFxuICBhcmdzLFxuICBoZWFkZXJzLFxuICBzZXEsXG4gIGFjdGl2aXR5VHlwZSxcbiAgYXR0ZW1wdCxcbiAgb3JpZ2luYWxTY2hlZHVsZVRpbWUsXG59OiBMb2NhbEFjdGl2aXR5SW5wdXQpOiBQcm9taXNlPHVua25vd24+IHtcbiAgY29uc3QgYWN0aXZhdG9yID0gZ2V0QWN0aXZhdG9yKCk7XG4gIC8vIEVhZ2VybHkgZmFpbCB0aGUgbG9jYWwgYWN0aXZpdHkgKHdoaWNoIHdpbGwgaW4gdHVybiBmYWlsIHRoZSB3b3JrZmxvdyB0YXNrLlxuICAvLyBEbyBub3QgZmFpbCBvbiByZXBsYXkgd2hlcmUgdGhlIGxvY2FsIGFjdGl2aXRpZXMgbWF5IG5vdCBiZSByZWdpc3RlcmVkIG9uIHRoZSByZXBsYXkgd29ya2VyLlxuICBpZiAoIWFjdGl2YXRvci5pbmZvLnVuc2FmZS5pc1JlcGxheWluZyAmJiAhYWN0aXZhdG9yLnJlZ2lzdGVyZWRBY3Rpdml0eU5hbWVzLmhhcyhhY3Rpdml0eVR5cGUpKSB7XG4gICAgdGhyb3cgbmV3IFJlZmVyZW5jZUVycm9yKGBMb2NhbCBhY3Rpdml0eSBvZiB0eXBlICcke2FjdGl2aXR5VHlwZX0nIG5vdCByZWdpc3RlcmVkIG9uIHdvcmtlcmApO1xuICB9XG4gIHZhbGlkYXRlTG9jYWxBY3Rpdml0eU9wdGlvbnMob3B0aW9ucyk7XG5cbiAgcmV0dXJuIG5ldyBQcm9taXNlKChyZXNvbHZlLCByZWplY3QpID0+IHtcbiAgICBjb25zdCBzY29wZSA9IENhbmNlbGxhdGlvblNjb3BlLmN1cnJlbnQoKTtcbiAgICBpZiAoc2NvcGUuY29uc2lkZXJlZENhbmNlbGxlZCkge1xuICAgICAgdW50cmFja1Byb21pc2Uoc2NvcGUuY2FuY2VsUmVxdWVzdGVkLmNhdGNoKHJlamVjdCkpO1xuICAgICAgcmV0dXJuO1xuICAgIH1cbiAgICBpZiAoc2NvcGUuY2FuY2VsbGFibGUpIHtcbiAgICAgIHVudHJhY2tQcm9taXNlKFxuICAgICAgICBzY29wZS5jYW5jZWxSZXF1ZXN0ZWQuY2F0Y2goKCkgPT4ge1xuICAgICAgICAgIGlmICghYWN0aXZhdG9yLmNvbXBsZXRpb25zLmFjdGl2aXR5LmhhcyhzZXEpKSB7XG4gICAgICAgICAgICByZXR1cm47IC8vIEFscmVhZHkgcmVzb2x2ZWQgb3IgbmV2ZXIgc2NoZWR1bGVkXG4gICAgICAgICAgfVxuICAgICAgICAgIGFjdGl2YXRvci5wdXNoQ29tbWFuZCh7XG4gICAgICAgICAgICByZXF1ZXN0Q2FuY2VsTG9jYWxBY3Rpdml0eToge1xuICAgICAgICAgICAgICBzZXEsXG4gICAgICAgICAgICB9LFxuICAgICAgICAgIH0pO1xuICAgICAgICB9KVxuICAgICAgKTtcbiAgICB9XG4gICAgYWN0aXZhdG9yLnB1c2hDb21tYW5kKHtcbiAgICAgIHNjaGVkdWxlTG9jYWxBY3Rpdml0eToge1xuICAgICAgICBzZXEsXG4gICAgICAgIGF0dGVtcHQsXG4gICAgICAgIG9yaWdpbmFsU2NoZWR1bGVUaW1lLFxuICAgICAgICAvLyBJbnRlbnRpb25hbGx5IG5vdCBleHBvc2luZyBhY3Rpdml0eUlkIGFzIGFuIG9wdGlvblxuICAgICAgICBhY3Rpdml0eUlkOiBgJHtzZXF9YCxcbiAgICAgICAgYWN0aXZpdHlUeXBlLFxuICAgICAgICBhcmd1bWVudHM6IHRvUGF5bG9hZHMoYWN0aXZhdG9yLnBheWxvYWRDb252ZXJ0ZXIsIC4uLmFyZ3MpLFxuICAgICAgICByZXRyeVBvbGljeTogb3B0aW9ucy5yZXRyeSA/IGNvbXBpbGVSZXRyeVBvbGljeShvcHRpb25zLnJldHJ5KSA6IHVuZGVmaW5lZCxcbiAgICAgICAgc2NoZWR1bGVUb0Nsb3NlVGltZW91dDogbXNPcHRpb25hbFRvVHMob3B0aW9ucy5zY2hlZHVsZVRvQ2xvc2VUaW1lb3V0KSxcbiAgICAgICAgc3RhcnRUb0Nsb3NlVGltZW91dDogbXNPcHRpb25hbFRvVHMob3B0aW9ucy5zdGFydFRvQ2xvc2VUaW1lb3V0KSxcbiAgICAgICAgc2NoZWR1bGVUb1N0YXJ0VGltZW91dDogbXNPcHRpb25hbFRvVHMob3B0aW9ucy5zY2hlZHVsZVRvU3RhcnRUaW1lb3V0KSxcbiAgICAgICAgbG9jYWxSZXRyeVRocmVzaG9sZDogbXNPcHRpb25hbFRvVHMob3B0aW9ucy5sb2NhbFJldHJ5VGhyZXNob2xkKSxcbiAgICAgICAgaGVhZGVycyxcbiAgICAgICAgY2FuY2VsbGF0aW9uVHlwZTogb3B0aW9ucy5jYW5jZWxsYXRpb25UeXBlLFxuICAgICAgfSxcbiAgICB9KTtcbiAgICBhY3RpdmF0b3IuY29tcGxldGlvbnMuYWN0aXZpdHkuc2V0KHNlcSwge1xuICAgICAgcmVzb2x2ZSxcbiAgICAgIHJlamVjdCxcbiAgICB9KTtcbiAgfSk7XG59XG5cbi8qKlxuICogU2NoZWR1bGUgYW4gYWN0aXZpdHkgYW5kIHJ1biBvdXRib3VuZCBpbnRlcmNlcHRvcnNcbiAqIEBoaWRkZW5cbiAqL1xuZXhwb3J0IGZ1bmN0aW9uIHNjaGVkdWxlQWN0aXZpdHk8Uj4oYWN0aXZpdHlUeXBlOiBzdHJpbmcsIGFyZ3M6IGFueVtdLCBvcHRpb25zOiBBY3Rpdml0eU9wdGlvbnMpOiBQcm9taXNlPFI+IHtcbiAgY29uc3QgYWN0aXZhdG9yID0gYXNzZXJ0SW5Xb3JrZmxvd0NvbnRleHQoXG4gICAgJ1dvcmtmbG93LnNjaGVkdWxlQWN0aXZpdHkoLi4uKSBtYXkgb25seSBiZSB1c2VkIGZyb20gYSBXb3JrZmxvdyBFeGVjdXRpb24nXG4gICk7XG4gIGlmIChvcHRpb25zID09PSB1bmRlZmluZWQpIHtcbiAgICB0aHJvdyBuZXcgVHlwZUVycm9yKCdHb3QgZW1wdHkgYWN0aXZpdHkgb3B0aW9ucycpO1xuICB9XG4gIGNvbnN0IHNlcSA9IGFjdGl2YXRvci5uZXh0U2Vxcy5hY3Rpdml0eSsrO1xuICBjb25zdCBleGVjdXRlID0gY29tcG9zZUludGVyY2VwdG9ycyhhY3RpdmF0b3IuaW50ZXJjZXB0b3JzLm91dGJvdW5kLCAnc2NoZWR1bGVBY3Rpdml0eScsIHNjaGVkdWxlQWN0aXZpdHlOZXh0SGFuZGxlcik7XG5cbiAgcmV0dXJuIGV4ZWN1dGUoe1xuICAgIGFjdGl2aXR5VHlwZSxcbiAgICBoZWFkZXJzOiB7fSxcbiAgICBvcHRpb25zLFxuICAgIGFyZ3MsXG4gICAgc2VxLFxuICB9KSBhcyBQcm9taXNlPFI+O1xufVxuXG4vKipcbiAqIFNjaGVkdWxlIGFuIGFjdGl2aXR5IGFuZCBydW4gb3V0Ym91bmQgaW50ZXJjZXB0b3JzXG4gKiBAaGlkZGVuXG4gKi9cbmV4cG9ydCBhc3luYyBmdW5jdGlvbiBzY2hlZHVsZUxvY2FsQWN0aXZpdHk8Uj4oXG4gIGFjdGl2aXR5VHlwZTogc3RyaW5nLFxuICBhcmdzOiBhbnlbXSxcbiAgb3B0aW9uczogTG9jYWxBY3Rpdml0eU9wdGlvbnNcbik6IFByb21pc2U8Uj4ge1xuICBjb25zdCBhY3RpdmF0b3IgPSBhc3NlcnRJbldvcmtmbG93Q29udGV4dChcbiAgICAnV29ya2Zsb3cuc2NoZWR1bGVMb2NhbEFjdGl2aXR5KC4uLikgbWF5IG9ubHkgYmUgdXNlZCBmcm9tIGEgV29ya2Zsb3cgRXhlY3V0aW9uJ1xuICApO1xuICBpZiAob3B0aW9ucyA9PT0gdW5kZWZpbmVkKSB7XG4gICAgdGhyb3cgbmV3IFR5cGVFcnJvcignR290IGVtcHR5IGFjdGl2aXR5IG9wdGlvbnMnKTtcbiAgfVxuXG4gIGxldCBhdHRlbXB0ID0gMTtcbiAgbGV0IG9yaWdpbmFsU2NoZWR1bGVUaW1lID0gdW5kZWZpbmVkO1xuXG4gIGZvciAoOzspIHtcbiAgICBjb25zdCBzZXEgPSBhY3RpdmF0b3IubmV4dFNlcXMuYWN0aXZpdHkrKztcbiAgICBjb25zdCBleGVjdXRlID0gY29tcG9zZUludGVyY2VwdG9ycyhcbiAgICAgIGFjdGl2YXRvci5pbnRlcmNlcHRvcnMub3V0Ym91bmQsXG4gICAgICAnc2NoZWR1bGVMb2NhbEFjdGl2aXR5JyxcbiAgICAgIHNjaGVkdWxlTG9jYWxBY3Rpdml0eU5leHRIYW5kbGVyXG4gICAgKTtcblxuICAgIHRyeSB7XG4gICAgICByZXR1cm4gKGF3YWl0IGV4ZWN1dGUoe1xuICAgICAgICBhY3Rpdml0eVR5cGUsXG4gICAgICAgIGhlYWRlcnM6IHt9LFxuICAgICAgICBvcHRpb25zLFxuICAgICAgICBhcmdzLFxuICAgICAgICBzZXEsXG4gICAgICAgIGF0dGVtcHQsXG4gICAgICAgIG9yaWdpbmFsU2NoZWR1bGVUaW1lLFxuICAgICAgfSkpIGFzIFByb21pc2U8Uj47XG4gICAgfSBjYXRjaCAoZXJyKSB7XG4gICAgICBpZiAoZXJyIGluc3RhbmNlb2YgTG9jYWxBY3Rpdml0eURvQmFja29mZikge1xuICAgICAgICBhd2FpdCBzbGVlcCh0c1RvTXMoZXJyLmJhY2tvZmYuYmFja29mZkR1cmF0aW9uKSk7XG4gICAgICAgIGlmICh0eXBlb2YgZXJyLmJhY2tvZmYuYXR0ZW1wdCAhPT0gJ251bWJlcicpIHtcbiAgICAgICAgICB0aHJvdyBuZXcgVHlwZUVycm9yKCdJbnZhbGlkIGJhY2tvZmYgYXR0ZW1wdCB0eXBlJyk7XG4gICAgICAgIH1cbiAgICAgICAgYXR0ZW1wdCA9IGVyci5iYWNrb2ZmLmF0dGVtcHQ7XG4gICAgICAgIG9yaWdpbmFsU2NoZWR1bGVUaW1lID0gZXJyLmJhY2tvZmYub3JpZ2luYWxTY2hlZHVsZVRpbWUgPz8gdW5kZWZpbmVkO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgdGhyb3cgZXJyO1xuICAgICAgfVxuICAgIH1cbiAgfVxufVxuXG5mdW5jdGlvbiBzdGFydENoaWxkV29ya2Zsb3dFeGVjdXRpb25OZXh0SGFuZGxlcih7XG4gIG9wdGlvbnMsXG4gIGhlYWRlcnMsXG4gIHdvcmtmbG93VHlwZSxcbiAgc2VxLFxufTogU3RhcnRDaGlsZFdvcmtmbG93RXhlY3V0aW9uSW5wdXQpOiBQcm9taXNlPFtQcm9taXNlPHN0cmluZz4sIFByb21pc2U8dW5rbm93bj5dPiB7XG4gIGNvbnN0IGFjdGl2YXRvciA9IGdldEFjdGl2YXRvcigpO1xuICBjb25zdCB3b3JrZmxvd0lkID0gb3B0aW9ucy53b3JrZmxvd0lkID8/IHV1aWQ0KCk7XG4gIGNvbnN0IHN0YXJ0UHJvbWlzZSA9IG5ldyBQcm9taXNlPHN0cmluZz4oKHJlc29sdmUsIHJlamVjdCkgPT4ge1xuICAgIGNvbnN0IHNjb3BlID0gQ2FuY2VsbGF0aW9uU2NvcGUuY3VycmVudCgpO1xuICAgIGlmIChzY29wZS5jb25zaWRlcmVkQ2FuY2VsbGVkKSB7XG4gICAgICB1bnRyYWNrUHJvbWlzZShzY29wZS5jYW5jZWxSZXF1ZXN0ZWQuY2F0Y2gocmVqZWN0KSk7XG4gICAgICByZXR1cm47XG4gICAgfVxuICAgIGlmIChzY29wZS5jYW5jZWxsYWJsZSkge1xuICAgICAgdW50cmFja1Byb21pc2UoXG4gICAgICAgIHNjb3BlLmNhbmNlbFJlcXVlc3RlZC5jYXRjaCgoKSA9PiB7XG4gICAgICAgICAgY29uc3QgY29tcGxldGUgPSAhYWN0aXZhdG9yLmNvbXBsZXRpb25zLmNoaWxkV29ya2Zsb3dDb21wbGV0ZS5oYXMoc2VxKTtcblxuICAgICAgICAgIGlmICghY29tcGxldGUpIHtcbiAgICAgICAgICAgIGFjdGl2YXRvci5wdXNoQ29tbWFuZCh7XG4gICAgICAgICAgICAgIGNhbmNlbENoaWxkV29ya2Zsb3dFeGVjdXRpb246IHsgY2hpbGRXb3JrZmxvd1NlcTogc2VxIH0sXG4gICAgICAgICAgICB9KTtcbiAgICAgICAgICB9XG4gICAgICAgICAgLy8gTm90aGluZyB0byBjYW5jZWwgb3RoZXJ3aXNlXG4gICAgICAgIH0pXG4gICAgICApO1xuICAgIH1cbiAgICBhY3RpdmF0b3IucHVzaENvbW1hbmQoe1xuICAgICAgc3RhcnRDaGlsZFdvcmtmbG93RXhlY3V0aW9uOiB7XG4gICAgICAgIHNlcSxcbiAgICAgICAgd29ya2Zsb3dJZCxcbiAgICAgICAgd29ya2Zsb3dUeXBlLFxuICAgICAgICBpbnB1dDogdG9QYXlsb2FkcyhhY3RpdmF0b3IucGF5bG9hZENvbnZlcnRlciwgLi4ub3B0aW9ucy5hcmdzKSxcbiAgICAgICAgcmV0cnlQb2xpY3k6IG9wdGlvbnMucmV0cnkgPyBjb21waWxlUmV0cnlQb2xpY3kob3B0aW9ucy5yZXRyeSkgOiB1bmRlZmluZWQsXG4gICAgICAgIHRhc2tRdWV1ZTogb3B0aW9ucy50YXNrUXVldWUgfHwgYWN0aXZhdG9yLmluZm8udGFza1F1ZXVlLFxuICAgICAgICB3b3JrZmxvd0V4ZWN1dGlvblRpbWVvdXQ6IG1zT3B0aW9uYWxUb1RzKG9wdGlvbnMud29ya2Zsb3dFeGVjdXRpb25UaW1lb3V0KSxcbiAgICAgICAgd29ya2Zsb3dSdW5UaW1lb3V0OiBtc09wdGlvbmFsVG9UcyhvcHRpb25zLndvcmtmbG93UnVuVGltZW91dCksXG4gICAgICAgIHdvcmtmbG93VGFza1RpbWVvdXQ6IG1zT3B0aW9uYWxUb1RzKG9wdGlvbnMud29ya2Zsb3dUYXNrVGltZW91dCksXG4gICAgICAgIG5hbWVzcGFjZTogYWN0aXZhdG9yLmluZm8ubmFtZXNwYWNlLCAvLyBOb3QgY29uZmlndXJhYmxlXG4gICAgICAgIGhlYWRlcnMsXG4gICAgICAgIGNhbmNlbGxhdGlvblR5cGU6IG9wdGlvbnMuY2FuY2VsbGF0aW9uVHlwZSxcbiAgICAgICAgd29ya2Zsb3dJZFJldXNlUG9saWN5OiBvcHRpb25zLndvcmtmbG93SWRSZXVzZVBvbGljeSxcbiAgICAgICAgcGFyZW50Q2xvc2VQb2xpY3k6IG9wdGlvbnMucGFyZW50Q2xvc2VQb2xpY3ksXG4gICAgICAgIGNyb25TY2hlZHVsZTogb3B0aW9ucy5jcm9uU2NoZWR1bGUsXG4gICAgICAgIHNlYXJjaEF0dHJpYnV0ZXM6IG9wdGlvbnMuc2VhcmNoQXR0cmlidXRlc1xuICAgICAgICAgID8gbWFwVG9QYXlsb2FkcyhzZWFyY2hBdHRyaWJ1dGVQYXlsb2FkQ29udmVydGVyLCBvcHRpb25zLnNlYXJjaEF0dHJpYnV0ZXMpXG4gICAgICAgICAgOiB1bmRlZmluZWQsXG4gICAgICAgIG1lbW86IG9wdGlvbnMubWVtbyAmJiBtYXBUb1BheWxvYWRzKGFjdGl2YXRvci5wYXlsb2FkQ29udmVydGVyLCBvcHRpb25zLm1lbW8pLFxuICAgICAgICB2ZXJzaW9uaW5nSW50ZW50OiB2ZXJzaW9uaW5nSW50ZW50VG9Qcm90byhvcHRpb25zLnZlcnNpb25pbmdJbnRlbnQpLFxuICAgICAgfSxcbiAgICB9KTtcbiAgICBhY3RpdmF0b3IuY29tcGxldGlvbnMuY2hpbGRXb3JrZmxvd1N0YXJ0LnNldChzZXEsIHtcbiAgICAgIHJlc29sdmUsXG4gICAgICByZWplY3QsXG4gICAgfSk7XG4gIH0pO1xuXG4gIC8vIFdlIGNvbnN0cnVjdCBhIFByb21pc2UgZm9yIHRoZSBjb21wbGV0aW9uIG9mIHRoZSBjaGlsZCBXb3JrZmxvdyBiZWZvcmUgd2Uga25vd1xuICAvLyBpZiB0aGUgV29ya2Zsb3cgY29kZSB3aWxsIGF3YWl0IGl0IHRvIGNhcHR1cmUgdGhlIHJlc3VsdCBpbiBjYXNlIGl0IGRvZXMuXG4gIGNvbnN0IGNvbXBsZXRlUHJvbWlzZSA9IG5ldyBQcm9taXNlKChyZXNvbHZlLCByZWplY3QpID0+IHtcbiAgICAvLyBDaGFpbiBzdGFydCBQcm9taXNlIHJlamVjdGlvbiB0byB0aGUgY29tcGxldGUgUHJvbWlzZS5cbiAgICB1bnRyYWNrUHJvbWlzZShzdGFydFByb21pc2UuY2F0Y2gocmVqZWN0KSk7XG4gICAgYWN0aXZhdG9yLmNvbXBsZXRpb25zLmNoaWxkV29ya2Zsb3dDb21wbGV0ZS5zZXQoc2VxLCB7XG4gICAgICByZXNvbHZlLFxuICAgICAgcmVqZWN0LFxuICAgIH0pO1xuICB9KTtcbiAgdW50cmFja1Byb21pc2Uoc3RhcnRQcm9taXNlKTtcbiAgdW50cmFja1Byb21pc2UoY29tcGxldGVQcm9taXNlKTtcbiAgLy8gUHJldmVudCB1bmhhbmRsZWQgcmVqZWN0aW9uIGJlY2F1c2UgdGhlIGNvbXBsZXRpb24gbWlnaHQgbm90IGJlIGF3YWl0ZWRcbiAgdW50cmFja1Byb21pc2UoY29tcGxldGVQcm9taXNlLmNhdGNoKCgpID0+IHVuZGVmaW5lZCkpO1xuICBjb25zdCByZXQgPSBuZXcgUHJvbWlzZTxbUHJvbWlzZTxzdHJpbmc+LCBQcm9taXNlPHVua25vd24+XT4oKHJlc29sdmUpID0+IHJlc29sdmUoW3N0YXJ0UHJvbWlzZSwgY29tcGxldGVQcm9taXNlXSkpO1xuICB1bnRyYWNrUHJvbWlzZShyZXQpO1xuICByZXR1cm4gcmV0O1xufVxuXG5mdW5jdGlvbiBzaWduYWxXb3JrZmxvd05leHRIYW5kbGVyKHsgc2VxLCBzaWduYWxOYW1lLCBhcmdzLCB0YXJnZXQsIGhlYWRlcnMgfTogU2lnbmFsV29ya2Zsb3dJbnB1dCkge1xuICBjb25zdCBhY3RpdmF0b3IgPSBnZXRBY3RpdmF0b3IoKTtcbiAgcmV0dXJuIG5ldyBQcm9taXNlPGFueT4oKHJlc29sdmUsIHJlamVjdCkgPT4ge1xuICAgIGNvbnN0IHNjb3BlID0gQ2FuY2VsbGF0aW9uU2NvcGUuY3VycmVudCgpO1xuICAgIGlmIChzY29wZS5jb25zaWRlcmVkQ2FuY2VsbGVkKSB7XG4gICAgICB1bnRyYWNrUHJvbWlzZShzY29wZS5jYW5jZWxSZXF1ZXN0ZWQuY2F0Y2gocmVqZWN0KSk7XG4gICAgICByZXR1cm47XG4gICAgfVxuXG4gICAgaWYgKHNjb3BlLmNhbmNlbGxhYmxlKSB7XG4gICAgICB1bnRyYWNrUHJvbWlzZShcbiAgICAgICAgc2NvcGUuY2FuY2VsUmVxdWVzdGVkLmNhdGNoKCgpID0+IHtcbiAgICAgICAgICBpZiAoIWFjdGl2YXRvci5jb21wbGV0aW9ucy5zaWduYWxXb3JrZmxvdy5oYXMoc2VxKSkge1xuICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICAgIH1cbiAgICAgICAgICBhY3RpdmF0b3IucHVzaENvbW1hbmQoeyBjYW5jZWxTaWduYWxXb3JrZmxvdzogeyBzZXEgfSB9KTtcbiAgICAgICAgfSlcbiAgICAgICk7XG4gICAgfVxuICAgIGFjdGl2YXRvci5wdXNoQ29tbWFuZCh7XG4gICAgICBzaWduYWxFeHRlcm5hbFdvcmtmbG93RXhlY3V0aW9uOiB7XG4gICAgICAgIHNlcSxcbiAgICAgICAgYXJnczogdG9QYXlsb2FkcyhhY3RpdmF0b3IucGF5bG9hZENvbnZlcnRlciwgLi4uYXJncyksXG4gICAgICAgIGhlYWRlcnMsXG4gICAgICAgIHNpZ25hbE5hbWUsXG4gICAgICAgIC4uLih0YXJnZXQudHlwZSA9PT0gJ2V4dGVybmFsJ1xuICAgICAgICAgID8ge1xuICAgICAgICAgICAgICB3b3JrZmxvd0V4ZWN1dGlvbjoge1xuICAgICAgICAgICAgICAgIG5hbWVzcGFjZTogYWN0aXZhdG9yLmluZm8ubmFtZXNwYWNlLFxuICAgICAgICAgICAgICAgIC4uLnRhcmdldC53b3JrZmxvd0V4ZWN1dGlvbixcbiAgICAgICAgICAgICAgfSxcbiAgICAgICAgICAgIH1cbiAgICAgICAgICA6IHtcbiAgICAgICAgICAgICAgY2hpbGRXb3JrZmxvd0lkOiB0YXJnZXQuY2hpbGRXb3JrZmxvd0lkLFxuICAgICAgICAgICAgfSksXG4gICAgICB9LFxuICAgIH0pO1xuXG4gICAgYWN0aXZhdG9yLmNvbXBsZXRpb25zLnNpZ25hbFdvcmtmbG93LnNldChzZXEsIHsgcmVzb2x2ZSwgcmVqZWN0IH0pO1xuICB9KTtcbn1cblxuLyoqXG4gKiBTeW1ib2wgdXNlZCBpbiB0aGUgcmV0dXJuIHR5cGUgb2YgcHJveHkgbWV0aG9kcyB0byBtYXJrIHRoYXQgYW4gYXR0cmlidXRlIG9uIHRoZSBzb3VyY2UgdHlwZSBpcyBub3QgYSBtZXRob2QuXG4gKlxuICogQHNlZSB7QGxpbmsgQWN0aXZpdHlJbnRlcmZhY2VGb3J9XG4gKiBAc2VlIHtAbGluayBwcm94eUFjdGl2aXRpZXN9XG4gKiBAc2VlIHtAbGluayBwcm94eUxvY2FsQWN0aXZpdGllc31cbiAqL1xuZXhwb3J0IGNvbnN0IE5vdEFuQWN0aXZpdHlNZXRob2QgPSBTeW1ib2wuZm9yKCdfX1RFTVBPUkFMX05PVF9BTl9BQ1RJVklUWV9NRVRIT0QnKTtcblxuLyoqXG4gKiBUeXBlIGhlbHBlciB0aGF0IHRha2VzIGEgdHlwZSBgVGAgYW5kIHRyYW5zZm9ybXMgYXR0cmlidXRlcyB0aGF0IGFyZSBub3Qge0BsaW5rIEFjdGl2aXR5RnVuY3Rpb259IHRvXG4gKiB7QGxpbmsgTm90QW5BY3Rpdml0eU1ldGhvZH0uXG4gKlxuICogQGV4YW1wbGVcbiAqXG4gKiBVc2VkIGJ5IHtAbGluayBwcm94eUFjdGl2aXRpZXN9IHRvIGdldCB0aGlzIGNvbXBpbGUtdGltZSBlcnJvcjpcbiAqXG4gKiBgYGB0c1xuICogaW50ZXJmYWNlIE15QWN0aXZpdGllcyB7XG4gKiAgIHZhbGlkKGlucHV0OiBudW1iZXIpOiBQcm9taXNlPG51bWJlcj47XG4gKiAgIGludmFsaWQoaW5wdXQ6IG51bWJlcik6IG51bWJlcjtcbiAqIH1cbiAqXG4gKiBjb25zdCBhY3QgPSBwcm94eUFjdGl2aXRpZXM8TXlBY3Rpdml0aWVzPih7IHN0YXJ0VG9DbG9zZVRpbWVvdXQ6ICc1bScgfSk7XG4gKlxuICogYXdhaXQgYWN0LnZhbGlkKHRydWUpO1xuICogYXdhaXQgYWN0LmludmFsaWQoKTtcbiAqIC8vIF4gVFMgY29tcGxhaW5zIHdpdGg6XG4gKiAvLyAocHJvcGVydHkpIGludmFsaWREZWZpbml0aW9uOiB0eXBlb2YgTm90QW5BY3Rpdml0eU1ldGhvZFxuICogLy8gVGhpcyBleHByZXNzaW9uIGlzIG5vdCBjYWxsYWJsZS5cbiAqIC8vIFR5cGUgJ1N5bWJvbCcgaGFzIG5vIGNhbGwgc2lnbmF0dXJlcy4oMjM0OSlcbiAqIGBgYFxuICovXG5leHBvcnQgdHlwZSBBY3Rpdml0eUludGVyZmFjZUZvcjxUPiA9IHtcbiAgW0sgaW4ga2V5b2YgVF06IFRbS10gZXh0ZW5kcyBBY3Rpdml0eUZ1bmN0aW9uID8gVFtLXSA6IHR5cGVvZiBOb3RBbkFjdGl2aXR5TWV0aG9kO1xufTtcblxuLyoqXG4gKiBDb25maWd1cmUgQWN0aXZpdHkgZnVuY3Rpb25zIHdpdGggZ2l2ZW4ge0BsaW5rIEFjdGl2aXR5T3B0aW9uc30uXG4gKlxuICogVGhpcyBtZXRob2QgbWF5IGJlIGNhbGxlZCBtdWx0aXBsZSB0aW1lcyB0byBzZXR1cCBBY3Rpdml0aWVzIHdpdGggZGlmZmVyZW50IG9wdGlvbnMuXG4gKlxuICogQHJldHVybiBhIHtAbGluayBodHRwczovL2RldmVsb3Blci5tb3ppbGxhLm9yZy9lbi1VUy9kb2NzL1dlYi9KYXZhU2NyaXB0L1JlZmVyZW5jZS9HbG9iYWxfT2JqZWN0cy9Qcm94eSB8IFByb3h5fSBmb3JcbiAqICAgICAgICAgd2hpY2ggZWFjaCBhdHRyaWJ1dGUgaXMgYSBjYWxsYWJsZSBBY3Rpdml0eSBmdW5jdGlvblxuICpcbiAqIEBleGFtcGxlXG4gKiBgYGB0c1xuICogaW1wb3J0IHsgcHJveHlBY3Rpdml0aWVzIH0gZnJvbSAnQHRlbXBvcmFsaW8vd29ya2Zsb3cnO1xuICogaW1wb3J0ICogYXMgYWN0aXZpdGllcyBmcm9tICcuLi9hY3Rpdml0aWVzJztcbiAqXG4gKiAvLyBTZXR1cCBBY3Rpdml0aWVzIGZyb20gbW9kdWxlIGV4cG9ydHNcbiAqIGNvbnN0IHsgaHR0cEdldCwgb3RoZXJBY3Rpdml0eSB9ID0gcHJveHlBY3Rpdml0aWVzPHR5cGVvZiBhY3Rpdml0aWVzPih7XG4gKiAgIHN0YXJ0VG9DbG9zZVRpbWVvdXQ6ICczMCBtaW51dGVzJyxcbiAqIH0pO1xuICpcbiAqIC8vIFNldHVwIEFjdGl2aXRpZXMgZnJvbSBhbiBleHBsaWNpdCBpbnRlcmZhY2UgKGUuZy4gd2hlbiBkZWZpbmVkIGJ5IGFub3RoZXIgU0RLKVxuICogaW50ZXJmYWNlIEphdmFBY3Rpdml0aWVzIHtcbiAqICAgaHR0cEdldEZyb21KYXZhKHVybDogc3RyaW5nKTogUHJvbWlzZTxzdHJpbmc+XG4gKiAgIHNvbWVPdGhlckphdmFBY3Rpdml0eShhcmcxOiBudW1iZXIsIGFyZzI6IHN0cmluZyk6IFByb21pc2U8c3RyaW5nPjtcbiAqIH1cbiAqXG4gKiBjb25zdCB7XG4gKiAgIGh0dHBHZXRGcm9tSmF2YSxcbiAqICAgc29tZU90aGVySmF2YUFjdGl2aXR5XG4gKiB9ID0gcHJveHlBY3Rpdml0aWVzPEphdmFBY3Rpdml0aWVzPih7XG4gKiAgIHRhc2tRdWV1ZTogJ2phdmEtd29ya2VyLXRhc2tRdWV1ZScsXG4gKiAgIHN0YXJ0VG9DbG9zZVRpbWVvdXQ6ICc1bScsXG4gKiB9KTtcbiAqXG4gKiBleHBvcnQgZnVuY3Rpb24gZXhlY3V0ZSgpOiBQcm9taXNlPHZvaWQ+IHtcbiAqICAgY29uc3QgcmVzcG9uc2UgPSBhd2FpdCBodHRwR2V0KFwiaHR0cDovL2V4YW1wbGUuY29tXCIpO1xuICogICAvLyAuLi5cbiAqIH1cbiAqIGBgYFxuICovXG5leHBvcnQgZnVuY3Rpb24gcHJveHlBY3Rpdml0aWVzPEEgPSBVbnR5cGVkQWN0aXZpdGllcz4ob3B0aW9uczogQWN0aXZpdHlPcHRpb25zKTogQWN0aXZpdHlJbnRlcmZhY2VGb3I8QT4ge1xuICBpZiAob3B0aW9ucyA9PT0gdW5kZWZpbmVkKSB7XG4gICAgdGhyb3cgbmV3IFR5cGVFcnJvcignb3B0aW9ucyBtdXN0IGJlIGRlZmluZWQnKTtcbiAgfVxuICAvLyBWYWxpZGF0ZSBhcyBlYXJseSBhcyBwb3NzaWJsZSBmb3IgaW1tZWRpYXRlIHVzZXIgZmVlZGJhY2tcbiAgdmFsaWRhdGVBY3Rpdml0eU9wdGlvbnMob3B0aW9ucyk7XG4gIHJldHVybiBuZXcgUHJveHkoXG4gICAge30sXG4gICAge1xuICAgICAgZ2V0KF8sIGFjdGl2aXR5VHlwZSkge1xuICAgICAgICBpZiAodHlwZW9mIGFjdGl2aXR5VHlwZSAhPT0gJ3N0cmluZycpIHtcbiAgICAgICAgICB0aHJvdyBuZXcgVHlwZUVycm9yKGBPbmx5IHN0cmluZ3MgYXJlIHN1cHBvcnRlZCBmb3IgQWN0aXZpdHkgdHlwZXMsIGdvdDogJHtTdHJpbmcoYWN0aXZpdHlUeXBlKX1gKTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gZnVuY3Rpb24gYWN0aXZpdHlQcm94eUZ1bmN0aW9uKC4uLmFyZ3M6IHVua25vd25bXSk6IFByb21pc2U8dW5rbm93bj4ge1xuICAgICAgICAgIHJldHVybiBzY2hlZHVsZUFjdGl2aXR5KGFjdGl2aXR5VHlwZSwgYXJncywgb3B0aW9ucyk7XG4gICAgICAgIH07XG4gICAgICB9LFxuICAgIH1cbiAgKSBhcyBhbnk7XG59XG5cbi8qKlxuICogQ29uZmlndXJlIExvY2FsIEFjdGl2aXR5IGZ1bmN0aW9ucyB3aXRoIGdpdmVuIHtAbGluayBMb2NhbEFjdGl2aXR5T3B0aW9uc30uXG4gKlxuICogVGhpcyBtZXRob2QgbWF5IGJlIGNhbGxlZCBtdWx0aXBsZSB0aW1lcyB0byBzZXR1cCBBY3Rpdml0aWVzIHdpdGggZGlmZmVyZW50IG9wdGlvbnMuXG4gKlxuICogQHJldHVybiBhIHtAbGluayBodHRwczovL2RldmVsb3Blci5tb3ppbGxhLm9yZy9lbi1VUy9kb2NzL1dlYi9KYXZhU2NyaXB0L1JlZmVyZW5jZS9HbG9iYWxfT2JqZWN0cy9Qcm94eSB8IFByb3h5fVxuICogICAgICAgICBmb3Igd2hpY2ggZWFjaCBhdHRyaWJ1dGUgaXMgYSBjYWxsYWJsZSBBY3Rpdml0eSBmdW5jdGlvblxuICpcbiAqIEBzZWUge0BsaW5rIHByb3h5QWN0aXZpdGllc30gZm9yIGV4YW1wbGVzXG4gKi9cbmV4cG9ydCBmdW5jdGlvbiBwcm94eUxvY2FsQWN0aXZpdGllczxBID0gVW50eXBlZEFjdGl2aXRpZXM+KG9wdGlvbnM6IExvY2FsQWN0aXZpdHlPcHRpb25zKTogQWN0aXZpdHlJbnRlcmZhY2VGb3I8QT4ge1xuICBpZiAob3B0aW9ucyA9PT0gdW5kZWZpbmVkKSB7XG4gICAgdGhyb3cgbmV3IFR5cGVFcnJvcignb3B0aW9ucyBtdXN0IGJlIGRlZmluZWQnKTtcbiAgfVxuICAvLyBWYWxpZGF0ZSBhcyBlYXJseSBhcyBwb3NzaWJsZSBmb3IgaW1tZWRpYXRlIHVzZXIgZmVlZGJhY2tcbiAgdmFsaWRhdGVMb2NhbEFjdGl2aXR5T3B0aW9ucyhvcHRpb25zKTtcbiAgcmV0dXJuIG5ldyBQcm94eShcbiAgICB7fSxcbiAgICB7XG4gICAgICBnZXQoXywgYWN0aXZpdHlUeXBlKSB7XG4gICAgICAgIGlmICh0eXBlb2YgYWN0aXZpdHlUeXBlICE9PSAnc3RyaW5nJykge1xuICAgICAgICAgIHRocm93IG5ldyBUeXBlRXJyb3IoYE9ubHkgc3RyaW5ncyBhcmUgc3VwcG9ydGVkIGZvciBBY3Rpdml0eSB0eXBlcywgZ290OiAke1N0cmluZyhhY3Rpdml0eVR5cGUpfWApO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiBmdW5jdGlvbiBsb2NhbEFjdGl2aXR5UHJveHlGdW5jdGlvbiguLi5hcmdzOiB1bmtub3duW10pIHtcbiAgICAgICAgICByZXR1cm4gc2NoZWR1bGVMb2NhbEFjdGl2aXR5KGFjdGl2aXR5VHlwZSwgYXJncywgb3B0aW9ucyk7XG4gICAgICAgIH07XG4gICAgICB9LFxuICAgIH1cbiAgKSBhcyBhbnk7XG59XG5cbi8vIFRPRE86IGRlcHJlY2F0ZSB0aGlzIHBhdGNoIGFmdGVyIFwiZW5vdWdoXCIgdGltZSBoYXMgcGFzc2VkXG5jb25zdCBFWFRFUk5BTF9XRl9DQU5DRUxfUEFUQ0ggPSAnX190ZW1wb3JhbF9pbnRlcm5hbF9jb25uZWN0X2V4dGVybmFsX2hhbmRsZV9jYW5jZWxfdG9fc2NvcGUnO1xuLy8gVGhlIG5hbWUgb2YgdGhpcyBwYXRjaCBjb21lcyBmcm9tIGFuIGF0dGVtcHQgdG8gYnVpbGQgYSBnZW5lcmljIGludGVybmFsIHBhdGNoaW5nIG1lY2hhbmlzbS5cbi8vIFRoYXQgZWZmb3J0IGhhcyBiZWVuIGFiYW5kb25lZCBpbiBmYXZvciBvZiBhIG5ld2VyIFdvcmtmbG93VGFza0NvbXBsZXRlZE1ldGFkYXRhIGJhc2VkIG1lY2hhbmlzbS5cbmNvbnN0IENPTkRJVElPTl8wX1BBVENIID0gJ19fc2RrX2ludGVybmFsX3BhdGNoX251bWJlcjoxJztcblxuLyoqXG4gKiBSZXR1cm5zIGEgY2xpZW50LXNpZGUgaGFuZGxlIHRoYXQgY2FuIGJlIHVzZWQgdG8gc2lnbmFsIGFuZCBjYW5jZWwgYW4gZXhpc3RpbmcgV29ya2Zsb3cgZXhlY3V0aW9uLlxuICogSXQgdGFrZXMgYSBXb3JrZmxvdyBJRCBhbmQgb3B0aW9uYWwgcnVuIElELlxuICovXG5leHBvcnQgZnVuY3Rpb24gZ2V0RXh0ZXJuYWxXb3JrZmxvd0hhbmRsZSh3b3JrZmxvd0lkOiBzdHJpbmcsIHJ1bklkPzogc3RyaW5nKTogRXh0ZXJuYWxXb3JrZmxvd0hhbmRsZSB7XG4gIGNvbnN0IGFjdGl2YXRvciA9IGFzc2VydEluV29ya2Zsb3dDb250ZXh0KFxuICAgICdXb3JrZmxvdy5nZXRFeHRlcm5hbFdvcmtmbG93SGFuZGxlKC4uLikgbWF5IG9ubHkgYmUgdXNlZCBmcm9tIGEgV29ya2Zsb3cgRXhlY3V0aW9uLiBDb25zaWRlciB1c2luZyBDbGllbnQud29ya2Zsb3cuZ2V0SGFuZGxlKC4uLikgaW5zdGVhZC4pJ1xuICApO1xuICByZXR1cm4ge1xuICAgIHdvcmtmbG93SWQsXG4gICAgcnVuSWQsXG4gICAgY2FuY2VsKCkge1xuICAgICAgcmV0dXJuIG5ldyBQcm9taXNlPHZvaWQ+KChyZXNvbHZlLCByZWplY3QpID0+IHtcbiAgICAgICAgLy8gQ29ubmVjdCB0aGlzIGNhbmNlbCBvcGVyYXRpb24gdG8gdGhlIGN1cnJlbnQgY2FuY2VsbGF0aW9uIHNjb3BlLlxuICAgICAgICAvLyBUaGlzIGlzIGJlaGF2aW9yIHdhcyBpbnRyb2R1Y2VkIGFmdGVyIHYwLjIyLjAgYW5kIGlzIGluY29tcGF0aWJsZVxuICAgICAgICAvLyB3aXRoIGhpc3RvcmllcyBnZW5lcmF0ZWQgd2l0aCBwcmV2aW91cyBTREsgdmVyc2lvbnMgYW5kIHRodXMgcmVxdWlyZXNcbiAgICAgICAgLy8gcGF0Y2hpbmcuXG4gICAgICAgIC8vXG4gICAgICAgIC8vIFdlIHRyeSB0byBkZWxheSBwYXRjaGluZyBhcyBtdWNoIGFzIHBvc3NpYmxlIHRvIGF2b2lkIHBvbGx1dGluZ1xuICAgICAgICAvLyBoaXN0b3JpZXMgdW5sZXNzIHN0cmljdGx5IHJlcXVpcmVkLlxuICAgICAgICBjb25zdCBzY29wZSA9IENhbmNlbGxhdGlvblNjb3BlLmN1cnJlbnQoKTtcbiAgICAgICAgaWYgKHNjb3BlLmNhbmNlbGxhYmxlKSB7XG4gICAgICAgICAgdW50cmFja1Byb21pc2UoXG4gICAgICAgICAgICBzY29wZS5jYW5jZWxSZXF1ZXN0ZWQuY2F0Y2goKGVycikgPT4ge1xuICAgICAgICAgICAgICBpZiAocGF0Y2hlZChFWFRFUk5BTF9XRl9DQU5DRUxfUEFUQ0gpKSB7XG4gICAgICAgICAgICAgICAgcmVqZWN0KGVycik7XG4gICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH0pXG4gICAgICAgICAgKTtcbiAgICAgICAgfVxuICAgICAgICBpZiAoc2NvcGUuY29uc2lkZXJlZENhbmNlbGxlZCkge1xuICAgICAgICAgIGlmIChwYXRjaGVkKEVYVEVSTkFMX1dGX0NBTkNFTF9QQVRDSCkpIHtcbiAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgICB9XG4gICAgICAgIH1cblxuICAgICAgICBjb25zdCBzZXEgPSBhY3RpdmF0b3IubmV4dFNlcXMuY2FuY2VsV29ya2Zsb3crKztcbiAgICAgICAgYWN0aXZhdG9yLnB1c2hDb21tYW5kKHtcbiAgICAgICAgICByZXF1ZXN0Q2FuY2VsRXh0ZXJuYWxXb3JrZmxvd0V4ZWN1dGlvbjoge1xuICAgICAgICAgICAgc2VxLFxuICAgICAgICAgICAgd29ya2Zsb3dFeGVjdXRpb246IHtcbiAgICAgICAgICAgICAgbmFtZXNwYWNlOiBhY3RpdmF0b3IuaW5mby5uYW1lc3BhY2UsXG4gICAgICAgICAgICAgIHdvcmtmbG93SWQsXG4gICAgICAgICAgICAgIHJ1bklkLFxuICAgICAgICAgICAgfSxcbiAgICAgICAgICB9LFxuICAgICAgICB9KTtcbiAgICAgICAgYWN0aXZhdG9yLmNvbXBsZXRpb25zLmNhbmNlbFdvcmtmbG93LnNldChzZXEsIHsgcmVzb2x2ZSwgcmVqZWN0IH0pO1xuICAgICAgfSk7XG4gICAgfSxcbiAgICBzaWduYWw8QXJncyBleHRlbmRzIGFueVtdPihkZWY6IFNpZ25hbERlZmluaXRpb248QXJncz4gfCBzdHJpbmcsIC4uLmFyZ3M6IEFyZ3MpOiBQcm9taXNlPHZvaWQ+IHtcbiAgICAgIHJldHVybiBjb21wb3NlSW50ZXJjZXB0b3JzKFxuICAgICAgICBhY3RpdmF0b3IuaW50ZXJjZXB0b3JzLm91dGJvdW5kLFxuICAgICAgICAnc2lnbmFsV29ya2Zsb3cnLFxuICAgICAgICBzaWduYWxXb3JrZmxvd05leHRIYW5kbGVyXG4gICAgICApKHtcbiAgICAgICAgc2VxOiBhY3RpdmF0b3IubmV4dFNlcXMuc2lnbmFsV29ya2Zsb3crKyxcbiAgICAgICAgc2lnbmFsTmFtZTogdHlwZW9mIGRlZiA9PT0gJ3N0cmluZycgPyBkZWYgOiBkZWYubmFtZSxcbiAgICAgICAgYXJncyxcbiAgICAgICAgdGFyZ2V0OiB7XG4gICAgICAgICAgdHlwZTogJ2V4dGVybmFsJyxcbiAgICAgICAgICB3b3JrZmxvd0V4ZWN1dGlvbjogeyB3b3JrZmxvd0lkLCBydW5JZCB9LFxuICAgICAgICB9LFxuICAgICAgICBoZWFkZXJzOiB7fSxcbiAgICAgIH0pO1xuICAgIH0sXG4gIH07XG59XG5cbi8qKlxuICogU3RhcnQgYSBjaGlsZCBXb3JrZmxvdyBleGVjdXRpb25cbiAqXG4gKiAtIFJldHVybnMgYSBjbGllbnQtc2lkZSBoYW5kbGUgdGhhdCBpbXBsZW1lbnRzIGEgY2hpbGQgV29ya2Zsb3cgaW50ZXJmYWNlLlxuICogLSBCeSBkZWZhdWx0LCBhIGNoaWxkIHdpbGwgYmUgc2NoZWR1bGVkIG9uIHRoZSBzYW1lIHRhc2sgcXVldWUgYXMgaXRzIHBhcmVudC5cbiAqXG4gKiBBIGNoaWxkIFdvcmtmbG93IGhhbmRsZSBzdXBwb3J0cyBhd2FpdGluZyBjb21wbGV0aW9uLCBzaWduYWxpbmcgYW5kIGNhbmNlbGxhdGlvbiB2aWEge0BsaW5rIENhbmNlbGxhdGlvblNjb3BlfXMuXG4gKiBJbiBvcmRlciB0byBxdWVyeSB0aGUgY2hpbGQsIHVzZSBhIHtAbGluayBXb3JrZmxvd0NsaWVudH0gZnJvbSBhbiBBY3Rpdml0eS5cbiAqL1xuZXhwb3J0IGFzeW5jIGZ1bmN0aW9uIHN0YXJ0Q2hpbGQ8VCBleHRlbmRzIFdvcmtmbG93PihcbiAgd29ya2Zsb3dUeXBlOiBzdHJpbmcsXG4gIG9wdGlvbnM6IFdpdGhXb3JrZmxvd0FyZ3M8VCwgQ2hpbGRXb3JrZmxvd09wdGlvbnM+XG4pOiBQcm9taXNlPENoaWxkV29ya2Zsb3dIYW5kbGU8VD4+O1xuXG4vKipcbiAqIFN0YXJ0IGEgY2hpbGQgV29ya2Zsb3cgZXhlY3V0aW9uXG4gKlxuICogLSBSZXR1cm5zIGEgY2xpZW50LXNpZGUgaGFuZGxlIHRoYXQgaW1wbGVtZW50cyBhIGNoaWxkIFdvcmtmbG93IGludGVyZmFjZS5cbiAqIC0gRGVkdWNlcyB0aGUgV29ya2Zsb3cgdHlwZSBhbmQgc2lnbmF0dXJlIGZyb20gcHJvdmlkZWQgV29ya2Zsb3cgZnVuY3Rpb24uXG4gKiAtIEJ5IGRlZmF1bHQsIGEgY2hpbGQgd2lsbCBiZSBzY2hlZHVsZWQgb24gdGhlIHNhbWUgdGFzayBxdWV1ZSBhcyBpdHMgcGFyZW50LlxuICpcbiAqIEEgY2hpbGQgV29ya2Zsb3cgaGFuZGxlIHN1cHBvcnRzIGF3YWl0aW5nIGNvbXBsZXRpb24sIHNpZ25hbGluZyBhbmQgY2FuY2VsbGF0aW9uIHZpYSB7QGxpbmsgQ2FuY2VsbGF0aW9uU2NvcGV9cy5cbiAqIEluIG9yZGVyIHRvIHF1ZXJ5IHRoZSBjaGlsZCwgdXNlIGEge0BsaW5rIFdvcmtmbG93Q2xpZW50fSBmcm9tIGFuIEFjdGl2aXR5LlxuICovXG5leHBvcnQgYXN5bmMgZnVuY3Rpb24gc3RhcnRDaGlsZDxUIGV4dGVuZHMgV29ya2Zsb3c+KFxuICB3b3JrZmxvd0Z1bmM6IFQsXG4gIG9wdGlvbnM6IFdpdGhXb3JrZmxvd0FyZ3M8VCwgQ2hpbGRXb3JrZmxvd09wdGlvbnM+XG4pOiBQcm9taXNlPENoaWxkV29ya2Zsb3dIYW5kbGU8VD4+O1xuXG4vKipcbiAqIFN0YXJ0IGEgY2hpbGQgV29ya2Zsb3cgZXhlY3V0aW9uXG4gKlxuICogKipPdmVycmlkZSBmb3IgV29ya2Zsb3dzIHRoYXQgYWNjZXB0IG5vIGFyZ3VtZW50cyoqLlxuICpcbiAqIC0gUmV0dXJucyBhIGNsaWVudC1zaWRlIGhhbmRsZSB0aGF0IGltcGxlbWVudHMgYSBjaGlsZCBXb3JrZmxvdyBpbnRlcmZhY2UuXG4gKiAtIFRoZSBjaGlsZCB3aWxsIGJlIHNjaGVkdWxlZCBvbiB0aGUgc2FtZSB0YXNrIHF1ZXVlIGFzIGl0cyBwYXJlbnQuXG4gKlxuICogQSBjaGlsZCBXb3JrZmxvdyBoYW5kbGUgc3VwcG9ydHMgYXdhaXRpbmcgY29tcGxldGlvbiwgc2lnbmFsaW5nIGFuZCBjYW5jZWxsYXRpb24gdmlhIHtAbGluayBDYW5jZWxsYXRpb25TY29wZX1zLlxuICogSW4gb3JkZXIgdG8gcXVlcnkgdGhlIGNoaWxkLCB1c2UgYSB7QGxpbmsgV29ya2Zsb3dDbGllbnR9IGZyb20gYW4gQWN0aXZpdHkuXG4gKi9cbmV4cG9ydCBhc3luYyBmdW5jdGlvbiBzdGFydENoaWxkPFQgZXh0ZW5kcyAoKSA9PiBQcm9taXNlPGFueT4+KHdvcmtmbG93VHlwZTogc3RyaW5nKTogUHJvbWlzZTxDaGlsZFdvcmtmbG93SGFuZGxlPFQ+PjtcblxuLyoqXG4gKiBTdGFydCBhIGNoaWxkIFdvcmtmbG93IGV4ZWN1dGlvblxuICpcbiAqICoqT3ZlcnJpZGUgZm9yIFdvcmtmbG93cyB0aGF0IGFjY2VwdCBubyBhcmd1bWVudHMqKi5cbiAqXG4gKiAtIFJldHVybnMgYSBjbGllbnQtc2lkZSBoYW5kbGUgdGhhdCBpbXBsZW1lbnRzIGEgY2hpbGQgV29ya2Zsb3cgaW50ZXJmYWNlLlxuICogLSBEZWR1Y2VzIHRoZSBXb3JrZmxvdyB0eXBlIGFuZCBzaWduYXR1cmUgZnJvbSBwcm92aWRlZCBXb3JrZmxvdyBmdW5jdGlvbi5cbiAqIC0gVGhlIGNoaWxkIHdpbGwgYmUgc2NoZWR1bGVkIG9uIHRoZSBzYW1lIHRhc2sgcXVldWUgYXMgaXRzIHBhcmVudC5cbiAqXG4gKiBBIGNoaWxkIFdvcmtmbG93IGhhbmRsZSBzdXBwb3J0cyBhd2FpdGluZyBjb21wbGV0aW9uLCBzaWduYWxpbmcgYW5kIGNhbmNlbGxhdGlvbiB2aWEge0BsaW5rIENhbmNlbGxhdGlvblNjb3BlfXMuXG4gKiBJbiBvcmRlciB0byBxdWVyeSB0aGUgY2hpbGQsIHVzZSBhIHtAbGluayBXb3JrZmxvd0NsaWVudH0gZnJvbSBhbiBBY3Rpdml0eS5cbiAqL1xuZXhwb3J0IGFzeW5jIGZ1bmN0aW9uIHN0YXJ0Q2hpbGQ8VCBleHRlbmRzICgpID0+IFByb21pc2U8YW55Pj4od29ya2Zsb3dGdW5jOiBUKTogUHJvbWlzZTxDaGlsZFdvcmtmbG93SGFuZGxlPFQ+PjtcblxuZXhwb3J0IGFzeW5jIGZ1bmN0aW9uIHN0YXJ0Q2hpbGQ8VCBleHRlbmRzIFdvcmtmbG93PihcbiAgd29ya2Zsb3dUeXBlT3JGdW5jOiBzdHJpbmcgfCBULFxuICBvcHRpb25zPzogV2l0aFdvcmtmbG93QXJnczxULCBDaGlsZFdvcmtmbG93T3B0aW9ucz5cbik6IFByb21pc2U8Q2hpbGRXb3JrZmxvd0hhbmRsZTxUPj4ge1xuICBjb25zdCBhY3RpdmF0b3IgPSBhc3NlcnRJbldvcmtmbG93Q29udGV4dChcbiAgICAnV29ya2Zsb3cuc3RhcnRDaGlsZCguLi4pIG1heSBvbmx5IGJlIHVzZWQgZnJvbSBhIFdvcmtmbG93IEV4ZWN1dGlvbi4gQ29uc2lkZXIgdXNpbmcgQ2xpZW50LndvcmtmbG93LnN0YXJ0KC4uLikgaW5zdGVhZC4pJ1xuICApO1xuICBjb25zdCBvcHRpb25zV2l0aERlZmF1bHRzID0gYWRkRGVmYXVsdFdvcmtmbG93T3B0aW9ucyhvcHRpb25zID8/ICh7fSBhcyBhbnkpKTtcbiAgY29uc3Qgd29ya2Zsb3dUeXBlID0gZXh0cmFjdFdvcmtmbG93VHlwZSh3b3JrZmxvd1R5cGVPckZ1bmMpO1xuICBjb25zdCBleGVjdXRlID0gY29tcG9zZUludGVyY2VwdG9ycyhcbiAgICBhY3RpdmF0b3IuaW50ZXJjZXB0b3JzLm91dGJvdW5kLFxuICAgICdzdGFydENoaWxkV29ya2Zsb3dFeGVjdXRpb24nLFxuICAgIHN0YXJ0Q2hpbGRXb3JrZmxvd0V4ZWN1dGlvbk5leHRIYW5kbGVyXG4gICk7XG4gIGNvbnN0IFtzdGFydGVkLCBjb21wbGV0ZWRdID0gYXdhaXQgZXhlY3V0ZSh7XG4gICAgc2VxOiBhY3RpdmF0b3IubmV4dFNlcXMuY2hpbGRXb3JrZmxvdysrLFxuICAgIG9wdGlvbnM6IG9wdGlvbnNXaXRoRGVmYXVsdHMsXG4gICAgaGVhZGVyczoge30sXG4gICAgd29ya2Zsb3dUeXBlLFxuICB9KTtcbiAgY29uc3QgZmlyc3RFeGVjdXRpb25SdW5JZCA9IGF3YWl0IHN0YXJ0ZWQ7XG5cbiAgcmV0dXJuIHtcbiAgICB3b3JrZmxvd0lkOiBvcHRpb25zV2l0aERlZmF1bHRzLndvcmtmbG93SWQsXG4gICAgZmlyc3RFeGVjdXRpb25SdW5JZCxcbiAgICBhc3luYyByZXN1bHQoKTogUHJvbWlzZTxXb3JrZmxvd1Jlc3VsdFR5cGU8VD4+IHtcbiAgICAgIHJldHVybiAoYXdhaXQgY29tcGxldGVkKSBhcyBhbnk7XG4gICAgfSxcbiAgICBhc3luYyBzaWduYWw8QXJncyBleHRlbmRzIGFueVtdPihkZWY6IFNpZ25hbERlZmluaXRpb248QXJncz4gfCBzdHJpbmcsIC4uLmFyZ3M6IEFyZ3MpOiBQcm9taXNlPHZvaWQ+IHtcbiAgICAgIHJldHVybiBjb21wb3NlSW50ZXJjZXB0b3JzKFxuICAgICAgICBhY3RpdmF0b3IuaW50ZXJjZXB0b3JzLm91dGJvdW5kLFxuICAgICAgICAnc2lnbmFsV29ya2Zsb3cnLFxuICAgICAgICBzaWduYWxXb3JrZmxvd05leHRIYW5kbGVyXG4gICAgICApKHtcbiAgICAgICAgc2VxOiBhY3RpdmF0b3IubmV4dFNlcXMuc2lnbmFsV29ya2Zsb3crKyxcbiAgICAgICAgc2lnbmFsTmFtZTogdHlwZW9mIGRlZiA9PT0gJ3N0cmluZycgPyBkZWYgOiBkZWYubmFtZSxcbiAgICAgICAgYXJncyxcbiAgICAgICAgdGFyZ2V0OiB7XG4gICAgICAgICAgdHlwZTogJ2NoaWxkJyxcbiAgICAgICAgICBjaGlsZFdvcmtmbG93SWQ6IG9wdGlvbnNXaXRoRGVmYXVsdHMud29ya2Zsb3dJZCxcbiAgICAgICAgfSxcbiAgICAgICAgaGVhZGVyczoge30sXG4gICAgICB9KTtcbiAgICB9LFxuICB9O1xufVxuXG4vKipcbiAqIFN0YXJ0IGEgY2hpbGQgV29ya2Zsb3cgZXhlY3V0aW9uIGFuZCBhd2FpdCBpdHMgY29tcGxldGlvbi5cbiAqXG4gKiAtIEJ5IGRlZmF1bHQsIGEgY2hpbGQgd2lsbCBiZSBzY2hlZHVsZWQgb24gdGhlIHNhbWUgdGFzayBxdWV1ZSBhcyBpdHMgcGFyZW50LlxuICogLSBUaGlzIG9wZXJhdGlvbiBpcyBjYW5jZWxsYWJsZSB1c2luZyB7QGxpbmsgQ2FuY2VsbGF0aW9uU2NvcGV9cy5cbiAqXG4gKiBAcmV0dXJuIFRoZSByZXN1bHQgb2YgdGhlIGNoaWxkIFdvcmtmbG93LlxuICovXG5leHBvcnQgYXN5bmMgZnVuY3Rpb24gZXhlY3V0ZUNoaWxkPFQgZXh0ZW5kcyBXb3JrZmxvdz4oXG4gIHdvcmtmbG93VHlwZTogc3RyaW5nLFxuICBvcHRpb25zOiBXaXRoV29ya2Zsb3dBcmdzPFQsIENoaWxkV29ya2Zsb3dPcHRpb25zPlxuKTogUHJvbWlzZTxXb3JrZmxvd1Jlc3VsdFR5cGU8VD4+O1xuXG4vKipcbiAqIFN0YXJ0IGEgY2hpbGQgV29ya2Zsb3cgZXhlY3V0aW9uIGFuZCBhd2FpdCBpdHMgY29tcGxldGlvbi5cbiAqXG4gKiAtIEJ5IGRlZmF1bHQsIGEgY2hpbGQgd2lsbCBiZSBzY2hlZHVsZWQgb24gdGhlIHNhbWUgdGFzayBxdWV1ZSBhcyBpdHMgcGFyZW50LlxuICogLSBEZWR1Y2VzIHRoZSBXb3JrZmxvdyB0eXBlIGFuZCBzaWduYXR1cmUgZnJvbSBwcm92aWRlZCBXb3JrZmxvdyBmdW5jdGlvbi5cbiAqIC0gVGhpcyBvcGVyYXRpb24gaXMgY2FuY2VsbGFibGUgdXNpbmcge0BsaW5rIENhbmNlbGxhdGlvblNjb3BlfXMuXG4gKlxuICogQHJldHVybiBUaGUgcmVzdWx0IG9mIHRoZSBjaGlsZCBXb3JrZmxvdy5cbiAqL1xuZXhwb3J0IGFzeW5jIGZ1bmN0aW9uIGV4ZWN1dGVDaGlsZDxUIGV4dGVuZHMgV29ya2Zsb3c+KFxuICB3b3JrZmxvd0Z1bmM6IFQsXG4gIG9wdGlvbnM6IFdpdGhXb3JrZmxvd0FyZ3M8VCwgQ2hpbGRXb3JrZmxvd09wdGlvbnM+XG4pOiBQcm9taXNlPFdvcmtmbG93UmVzdWx0VHlwZTxUPj47XG5cbi8qKlxuICogU3RhcnQgYSBjaGlsZCBXb3JrZmxvdyBleGVjdXRpb24gYW5kIGF3YWl0IGl0cyBjb21wbGV0aW9uLlxuICpcbiAqICoqT3ZlcnJpZGUgZm9yIFdvcmtmbG93cyB0aGF0IGFjY2VwdCBubyBhcmd1bWVudHMqKi5cbiAqXG4gKiAtIFRoZSBjaGlsZCB3aWxsIGJlIHNjaGVkdWxlZCBvbiB0aGUgc2FtZSB0YXNrIHF1ZXVlIGFzIGl0cyBwYXJlbnQuXG4gKiAtIFRoaXMgb3BlcmF0aW9uIGlzIGNhbmNlbGxhYmxlIHVzaW5nIHtAbGluayBDYW5jZWxsYXRpb25TY29wZX1zLlxuICpcbiAqIEByZXR1cm4gVGhlIHJlc3VsdCBvZiB0aGUgY2hpbGQgV29ya2Zsb3cuXG4gKi9cbmV4cG9ydCBhc3luYyBmdW5jdGlvbiBleGVjdXRlQ2hpbGQ8VCBleHRlbmRzICgpID0+IFdvcmtmbG93UmV0dXJuVHlwZT4oXG4gIHdvcmtmbG93VHlwZTogc3RyaW5nXG4pOiBQcm9taXNlPFdvcmtmbG93UmVzdWx0VHlwZTxUPj47XG5cbi8qKlxuICogU3RhcnQgYSBjaGlsZCBXb3JrZmxvdyBleGVjdXRpb24gYW5kIGF3YWl0IGl0cyBjb21wbGV0aW9uLlxuICpcbiAqICoqT3ZlcnJpZGUgZm9yIFdvcmtmbG93cyB0aGF0IGFjY2VwdCBubyBhcmd1bWVudHMqKi5cbiAqXG4gKiAtIFRoZSBjaGlsZCB3aWxsIGJlIHNjaGVkdWxlZCBvbiB0aGUgc2FtZSB0YXNrIHF1ZXVlIGFzIGl0cyBwYXJlbnQuXG4gKiAtIERlZHVjZXMgdGhlIFdvcmtmbG93IHR5cGUgYW5kIHNpZ25hdHVyZSBmcm9tIHByb3ZpZGVkIFdvcmtmbG93IGZ1bmN0aW9uLlxuICogLSBUaGlzIG9wZXJhdGlvbiBpcyBjYW5jZWxsYWJsZSB1c2luZyB7QGxpbmsgQ2FuY2VsbGF0aW9uU2NvcGV9cy5cbiAqXG4gKiBAcmV0dXJuIFRoZSByZXN1bHQgb2YgdGhlIGNoaWxkIFdvcmtmbG93LlxuICovXG5leHBvcnQgYXN5bmMgZnVuY3Rpb24gZXhlY3V0ZUNoaWxkPFQgZXh0ZW5kcyAoKSA9PiBXb3JrZmxvd1JldHVyblR5cGU+KHdvcmtmbG93RnVuYzogVCk6IFByb21pc2U8V29ya2Zsb3dSZXN1bHRUeXBlPFQ+PjtcblxuZXhwb3J0IGFzeW5jIGZ1bmN0aW9uIGV4ZWN1dGVDaGlsZDxUIGV4dGVuZHMgV29ya2Zsb3c+KFxuICB3b3JrZmxvd1R5cGVPckZ1bmM6IHN0cmluZyB8IFQsXG4gIG9wdGlvbnM/OiBXaXRoV29ya2Zsb3dBcmdzPFQsIENoaWxkV29ya2Zsb3dPcHRpb25zPlxuKTogUHJvbWlzZTxXb3JrZmxvd1Jlc3VsdFR5cGU8VD4+IHtcbiAgY29uc3QgYWN0aXZhdG9yID0gYXNzZXJ0SW5Xb3JrZmxvd0NvbnRleHQoXG4gICAgJ1dvcmtmbG93LmV4ZWN1dGVDaGlsZCguLi4pIG1heSBvbmx5IGJlIHVzZWQgZnJvbSBhIFdvcmtmbG93IEV4ZWN1dGlvbi4gQ29uc2lkZXIgdXNpbmcgQ2xpZW50LndvcmtmbG93LmV4ZWN1dGUoLi4uKSBpbnN0ZWFkLidcbiAgKTtcbiAgY29uc3Qgb3B0aW9uc1dpdGhEZWZhdWx0cyA9IGFkZERlZmF1bHRXb3JrZmxvd09wdGlvbnMob3B0aW9ucyA/PyAoe30gYXMgYW55KSk7XG4gIGNvbnN0IHdvcmtmbG93VHlwZSA9IGV4dHJhY3RXb3JrZmxvd1R5cGUod29ya2Zsb3dUeXBlT3JGdW5jKTtcbiAgY29uc3QgZXhlY3V0ZSA9IGNvbXBvc2VJbnRlcmNlcHRvcnMoXG4gICAgYWN0aXZhdG9yLmludGVyY2VwdG9ycy5vdXRib3VuZCxcbiAgICAnc3RhcnRDaGlsZFdvcmtmbG93RXhlY3V0aW9uJyxcbiAgICBzdGFydENoaWxkV29ya2Zsb3dFeGVjdXRpb25OZXh0SGFuZGxlclxuICApO1xuICBjb25zdCBleGVjUHJvbWlzZSA9IGV4ZWN1dGUoe1xuICAgIHNlcTogYWN0aXZhdG9yLm5leHRTZXFzLmNoaWxkV29ya2Zsb3crKyxcbiAgICBvcHRpb25zOiBvcHRpb25zV2l0aERlZmF1bHRzLFxuICAgIGhlYWRlcnM6IHt9LFxuICAgIHdvcmtmbG93VHlwZSxcbiAgfSk7XG4gIHVudHJhY2tQcm9taXNlKGV4ZWNQcm9taXNlKTtcbiAgY29uc3QgY29tcGxldGVkUHJvbWlzZSA9IGV4ZWNQcm9taXNlLnRoZW4oKFtfc3RhcnRlZCwgY29tcGxldGVkXSkgPT4gY29tcGxldGVkKTtcbiAgdW50cmFja1Byb21pc2UoY29tcGxldGVkUHJvbWlzZSk7XG4gIHJldHVybiBjb21wbGV0ZWRQcm9taXNlIGFzIFByb21pc2U8YW55Pjtcbn1cblxuLyoqXG4gKiBHZXQgaW5mb3JtYXRpb24gYWJvdXQgdGhlIGN1cnJlbnQgV29ya2Zsb3cuXG4gKlxuICogV0FSTklORzogVGhpcyBmdW5jdGlvbiByZXR1cm5zIGEgZnJvemVuIGNvcHkgb2YgV29ya2Zsb3dJbmZvLCBhdCB0aGUgcG9pbnQgd2hlcmUgdGhpcyBtZXRob2QgaGFzIGJlZW4gY2FsbGVkLlxuICogQ2hhbmdlcyBoYXBwZW5pbmcgYXQgbGF0ZXIgcG9pbnQgaW4gd29ya2Zsb3cgZXhlY3V0aW9uIHdpbGwgbm90IGJlIHJlZmxlY3RlZCBpbiB0aGUgcmV0dXJuZWQgb2JqZWN0LlxuICpcbiAqIEZvciB0aGlzIHJlYXNvbiwgd2UgcmVjb21tZW5kIGNhbGxpbmcgYHdvcmtmbG93SW5mbygpYCBvbiBldmVyeSBhY2Nlc3MgdG8ge0BsaW5rIFdvcmtmbG93SW5mb30ncyBmaWVsZHMsXG4gKiByYXRoZXIgdGhhbiBjYWNoaW5nIHRoZSBgV29ya2Zsb3dJbmZvYCBvYmplY3QgKG9yIHBhcnQgb2YgaXQpIGluIGEgbG9jYWwgdmFyaWFibGUuIEZvciBleGFtcGxlOlxuICpcbiAqIGBgYHRzXG4gKiAvLyBHT09EXG4gKiBmdW5jdGlvbiBteVdvcmtmbG93KCkge1xuICogICBkb1NvbWV0aGluZyh3b3JrZmxvd0luZm8oKS5zZWFyY2hBdHRyaWJ1dGVzKVxuICogICAuLi5cbiAqICAgZG9Tb21ldGhpbmdFbHNlKHdvcmtmbG93SW5mbygpLnNlYXJjaEF0dHJpYnV0ZXMpXG4gKiB9XG4gKiBgYGBcbiAqXG4gKiB2c1xuICpcbiAqIGBgYHRzXG4gKiAvLyBCQURcbiAqIGZ1bmN0aW9uIG15V29ya2Zsb3coKSB7XG4gKiAgIGNvbnN0IGF0dHJpYnV0ZXMgPSB3b3JrZmxvd0luZm8oKS5zZWFyY2hBdHRyaWJ1dGVzXG4gKiAgIGRvU29tZXRoaW5nKGF0dHJpYnV0ZXMpXG4gKiAgIC4uLlxuICogICBkb1NvbWV0aGluZ0Vsc2UoYXR0cmlidXRlcylcbiAqIH1cbiAqIGBgYFxuICovXG5leHBvcnQgZnVuY3Rpb24gd29ya2Zsb3dJbmZvKCk6IFdvcmtmbG93SW5mbyB7XG4gIGNvbnN0IGFjdGl2YXRvciA9IGFzc2VydEluV29ya2Zsb3dDb250ZXh0KCdXb3JrZmxvdy53b3JrZmxvd0luZm8oLi4uKSBtYXkgb25seSBiZSB1c2VkIGZyb20gYSBXb3JrZmxvdyBFeGVjdXRpb24uJyk7XG4gIHJldHVybiBhY3RpdmF0b3IuaW5mbztcbn1cblxuLyoqXG4gKiBSZXR1cm5zIHdoZXRoZXIgb3Igbm90IGNvZGUgaXMgZXhlY3V0aW5nIGluIHdvcmtmbG93IGNvbnRleHRcbiAqL1xuZXhwb3J0IGZ1bmN0aW9uIGluV29ya2Zsb3dDb250ZXh0KCk6IGJvb2xlYW4ge1xuICByZXR1cm4gbWF5YmVHZXRBY3RpdmF0b3IoKSAhPT0gdW5kZWZpbmVkO1xufVxuXG4vKipcbiAqIFJldHVybnMgYSBmdW5jdGlvbiBgZmAgdGhhdCB3aWxsIGNhdXNlIHRoZSBjdXJyZW50IFdvcmtmbG93IHRvIENvbnRpbnVlQXNOZXcgd2hlbiBjYWxsZWQuXG4gKlxuICogYGZgIHRha2VzIHRoZSBzYW1lIGFyZ3VtZW50cyBhcyB0aGUgV29ya2Zsb3cgZnVuY3Rpb24gc3VwcGxpZWQgdG8gdHlwZXBhcmFtIGBGYC5cbiAqXG4gKiBPbmNlIGBmYCBpcyBjYWxsZWQsIFdvcmtmbG93IEV4ZWN1dGlvbiBpbW1lZGlhdGVseSBjb21wbGV0ZXMuXG4gKi9cbmV4cG9ydCBmdW5jdGlvbiBtYWtlQ29udGludWVBc05ld0Z1bmM8RiBleHRlbmRzIFdvcmtmbG93PihcbiAgb3B0aW9ucz86IENvbnRpbnVlQXNOZXdPcHRpb25zXG4pOiAoLi4uYXJnczogUGFyYW1ldGVyczxGPikgPT4gUHJvbWlzZTxuZXZlcj4ge1xuICBjb25zdCBhY3RpdmF0b3IgPSBhc3NlcnRJbldvcmtmbG93Q29udGV4dChcbiAgICAnV29ya2Zsb3cuY29udGludWVBc05ldyguLi4pIGFuZCBXb3JrZmxvdy5tYWtlQ29udGludWVBc05ld0Z1bmMoLi4uKSBtYXkgb25seSBiZSB1c2VkIGZyb20gYSBXb3JrZmxvdyBFeGVjdXRpb24uJ1xuICApO1xuICBjb25zdCBpbmZvID0gYWN0aXZhdG9yLmluZm87XG4gIGNvbnN0IHsgd29ya2Zsb3dUeXBlLCB0YXNrUXVldWUsIC4uLnJlc3QgfSA9IG9wdGlvbnMgPz8ge307XG4gIGNvbnN0IHJlcXVpcmVkT3B0aW9ucyA9IHtcbiAgICB3b3JrZmxvd1R5cGU6IHdvcmtmbG93VHlwZSA/PyBpbmZvLndvcmtmbG93VHlwZSxcbiAgICB0YXNrUXVldWU6IHRhc2tRdWV1ZSA/PyBpbmZvLnRhc2tRdWV1ZSxcbiAgICAuLi5yZXN0LFxuICB9O1xuXG4gIHJldHVybiAoLi4uYXJnczogUGFyYW1ldGVyczxGPik6IFByb21pc2U8bmV2ZXI+ID0+IHtcbiAgICBjb25zdCBmbiA9IGNvbXBvc2VJbnRlcmNlcHRvcnMoYWN0aXZhdG9yLmludGVyY2VwdG9ycy5vdXRib3VuZCwgJ2NvbnRpbnVlQXNOZXcnLCBhc3luYyAoaW5wdXQpID0+IHtcbiAgICAgIGNvbnN0IHsgaGVhZGVycywgYXJncywgb3B0aW9ucyB9ID0gaW5wdXQ7XG4gICAgICB0aHJvdyBuZXcgQ29udGludWVBc05ldyh7XG4gICAgICAgIHdvcmtmbG93VHlwZTogb3B0aW9ucy53b3JrZmxvd1R5cGUsXG4gICAgICAgIGFyZ3VtZW50czogdG9QYXlsb2FkcyhhY3RpdmF0b3IucGF5bG9hZENvbnZlcnRlciwgLi4uYXJncyksXG4gICAgICAgIGhlYWRlcnMsXG4gICAgICAgIHRhc2tRdWV1ZTogb3B0aW9ucy50YXNrUXVldWUsXG4gICAgICAgIG1lbW86IG9wdGlvbnMubWVtbyAmJiBtYXBUb1BheWxvYWRzKGFjdGl2YXRvci5wYXlsb2FkQ29udmVydGVyLCBvcHRpb25zLm1lbW8pLFxuICAgICAgICBzZWFyY2hBdHRyaWJ1dGVzOiBvcHRpb25zLnNlYXJjaEF0dHJpYnV0ZXNcbiAgICAgICAgICA/IG1hcFRvUGF5bG9hZHMoc2VhcmNoQXR0cmlidXRlUGF5bG9hZENvbnZlcnRlciwgb3B0aW9ucy5zZWFyY2hBdHRyaWJ1dGVzKVxuICAgICAgICAgIDogdW5kZWZpbmVkLFxuICAgICAgICB3b3JrZmxvd1J1blRpbWVvdXQ6IG1zT3B0aW9uYWxUb1RzKG9wdGlvbnMud29ya2Zsb3dSdW5UaW1lb3V0KSxcbiAgICAgICAgd29ya2Zsb3dUYXNrVGltZW91dDogbXNPcHRpb25hbFRvVHMob3B0aW9ucy53b3JrZmxvd1Rhc2tUaW1lb3V0KSxcbiAgICAgICAgdmVyc2lvbmluZ0ludGVudDogdmVyc2lvbmluZ0ludGVudFRvUHJvdG8ob3B0aW9ucy52ZXJzaW9uaW5nSW50ZW50KSxcbiAgICAgIH0pO1xuICAgIH0pO1xuICAgIHJldHVybiBmbih7XG4gICAgICBhcmdzLFxuICAgICAgaGVhZGVyczoge30sXG4gICAgICBvcHRpb25zOiByZXF1aXJlZE9wdGlvbnMsXG4gICAgfSk7XG4gIH07XG59XG5cbi8qKlxuICoge0BsaW5rIGh0dHBzOi8vZG9jcy50ZW1wb3JhbC5pby9jb25jZXB0cy93aGF0LWlzLWNvbnRpbnVlLWFzLW5ldy8gfCBDb250aW51ZXMtQXMtTmV3fSB0aGUgY3VycmVudCBXb3JrZmxvdyBFeGVjdXRpb25cbiAqIHdpdGggZGVmYXVsdCBvcHRpb25zLlxuICpcbiAqIFNob3J0aGFuZCBmb3IgYG1ha2VDb250aW51ZUFzTmV3RnVuYzxGPigpKC4uLmFyZ3MpYC4gKFNlZToge0BsaW5rIG1ha2VDb250aW51ZUFzTmV3RnVuY30uKVxuICpcbiAqIEBleGFtcGxlXG4gKlxuICpgYGB0c1xuICppbXBvcnQgeyBjb250aW51ZUFzTmV3IH0gZnJvbSAnQHRlbXBvcmFsaW8vd29ya2Zsb3cnO1xuICpcbiAqZXhwb3J0IGFzeW5jIGZ1bmN0aW9uIG15V29ya2Zsb3cobjogbnVtYmVyKTogUHJvbWlzZTx2b2lkPiB7XG4gKiAgLy8gLi4uIFdvcmtmbG93IGxvZ2ljXG4gKiAgYXdhaXQgY29udGludWVBc05ldzx0eXBlb2YgbXlXb3JrZmxvdz4obiArIDEpO1xuICp9XG4gKmBgYFxuICovXG5leHBvcnQgZnVuY3Rpb24gY29udGludWVBc05ldzxGIGV4dGVuZHMgV29ya2Zsb3c+KC4uLmFyZ3M6IFBhcmFtZXRlcnM8Rj4pOiBQcm9taXNlPG5ldmVyPiB7XG4gIHJldHVybiBtYWtlQ29udGludWVBc05ld0Z1bmMoKSguLi5hcmdzKTtcbn1cblxuLyoqXG4gKiBHZW5lcmF0ZSBhbiBSRkMgY29tcGxpYW50IFY0IHV1aWQuXG4gKiBVc2VzIHRoZSB3b3JrZmxvdydzIGRldGVybWluaXN0aWMgUFJORyBtYWtpbmcgaXQgc2FmZSBmb3IgdXNlIHdpdGhpbiBhIHdvcmtmbG93LlxuICogVGhpcyBmdW5jdGlvbiBpcyBjcnlwdG9ncmFwaGljYWxseSBpbnNlY3VyZS5cbiAqIFNlZSB0aGUge0BsaW5rIGh0dHBzOi8vc3RhY2tvdmVyZmxvdy5jb20vcXVlc3Rpb25zLzEwNTAzNC9ob3ctdG8tY3JlYXRlLWEtZ3VpZC11dWlkIHwgc3RhY2tvdmVyZmxvdyBkaXNjdXNzaW9ufS5cbiAqL1xuZXhwb3J0IGZ1bmN0aW9uIHV1aWQ0KCk6IHN0cmluZyB7XG4gIC8vIFJldHVybiB0aGUgaGV4YWRlY2ltYWwgdGV4dCByZXByZXNlbnRhdGlvbiBvZiBudW1iZXIgYG5gLCBwYWRkZWQgd2l0aCB6ZXJvZXMgdG8gYmUgb2YgbGVuZ3RoIGBwYFxuICBjb25zdCBobyA9IChuOiBudW1iZXIsIHA6IG51bWJlcikgPT4gbi50b1N0cmluZygxNikucGFkU3RhcnQocCwgJzAnKTtcbiAgLy8gQ3JlYXRlIGEgdmlldyBiYWNrZWQgYnkgYSAxNi1ieXRlIGJ1ZmZlclxuICBjb25zdCB2aWV3ID0gbmV3IERhdGFWaWV3KG5ldyBBcnJheUJ1ZmZlcigxNikpO1xuICAvLyBGaWxsIGJ1ZmZlciB3aXRoIHJhbmRvbSB2YWx1ZXNcbiAgdmlldy5zZXRVaW50MzIoMCwgKE1hdGgucmFuZG9tKCkgKiAweDEwMDAwMDAwMCkgPj4+IDApO1xuICB2aWV3LnNldFVpbnQzMig0LCAoTWF0aC5yYW5kb20oKSAqIDB4MTAwMDAwMDAwKSA+Pj4gMCk7XG4gIHZpZXcuc2V0VWludDMyKDgsIChNYXRoLnJhbmRvbSgpICogMHgxMDAwMDAwMDApID4+PiAwKTtcbiAgdmlldy5zZXRVaW50MzIoMTIsIChNYXRoLnJhbmRvbSgpICogMHgxMDAwMDAwMDApID4+PiAwKTtcbiAgLy8gUGF0Y2ggdGhlIDZ0aCBieXRlIHRvIHJlZmxlY3QgYSB2ZXJzaW9uIDQgVVVJRFxuICB2aWV3LnNldFVpbnQ4KDYsICh2aWV3LmdldFVpbnQ4KDYpICYgMHhmKSB8IDB4NDApO1xuICAvLyBQYXRjaCB0aGUgOHRoIGJ5dGUgdG8gcmVmbGVjdCBhIHZhcmlhbnQgMSBVVUlEICh2ZXJzaW9uIDQgVVVJRHMgYXJlKVxuICB2aWV3LnNldFVpbnQ4KDgsICh2aWV3LmdldFVpbnQ4KDgpICYgMHgzZikgfCAweDgwKTtcbiAgLy8gQ29tcGlsZSB0aGUgY2Fub25pY2FsIHRleHR1YWwgZm9ybSBmcm9tIHRoZSBhcnJheSBkYXRhXG4gIHJldHVybiBgJHtobyh2aWV3LmdldFVpbnQzMigwKSwgOCl9LSR7aG8odmlldy5nZXRVaW50MTYoNCksIDQpfS0ke2hvKHZpZXcuZ2V0VWludDE2KDYpLCA0KX0tJHtobyhcbiAgICB2aWV3LmdldFVpbnQxNig4KSxcbiAgICA0XG4gICl9LSR7aG8odmlldy5nZXRVaW50MzIoMTApLCA4KX0ke2hvKHZpZXcuZ2V0VWludDE2KDE0KSwgNCl9YDtcbn1cblxuLyoqXG4gKiBQYXRjaCBvciB1cGdyYWRlIHdvcmtmbG93IGNvZGUgYnkgY2hlY2tpbmcgb3Igc3RhdGluZyB0aGF0IHRoaXMgd29ya2Zsb3cgaGFzIGEgY2VydGFpbiBwYXRjaC5cbiAqXG4gKiBTZWUge0BsaW5rIGh0dHBzOi8vZG9jcy50ZW1wb3JhbC5pby90eXBlc2NyaXB0L3ZlcnNpb25pbmcgfCBkb2NzIHBhZ2V9IGZvciBpbmZvLlxuICpcbiAqIElmIHRoZSB3b3JrZmxvdyBpcyByZXBsYXlpbmcgYW4gZXhpc3RpbmcgaGlzdG9yeSwgdGhlbiB0aGlzIGZ1bmN0aW9uIHJldHVybnMgdHJ1ZSBpZiB0aGF0XG4gKiBoaXN0b3J5IHdhcyBwcm9kdWNlZCBieSBhIHdvcmtlciB3aGljaCBhbHNvIGhhZCBhIGBwYXRjaGVkYCBjYWxsIHdpdGggdGhlIHNhbWUgYHBhdGNoSWRgLlxuICogSWYgdGhlIGhpc3Rvcnkgd2FzIHByb2R1Y2VkIGJ5IGEgd29ya2VyICp3aXRob3V0KiBzdWNoIGEgY2FsbCwgdGhlbiBpdCB3aWxsIHJldHVybiBmYWxzZS5cbiAqXG4gKiBJZiB0aGUgd29ya2Zsb3cgaXMgbm90IGN1cnJlbnRseSByZXBsYXlpbmcsIHRoZW4gdGhpcyBjYWxsICphbHdheXMqIHJldHVybnMgdHJ1ZS5cbiAqXG4gKiBZb3VyIHdvcmtmbG93IGNvZGUgc2hvdWxkIHJ1biB0aGUgXCJuZXdcIiBjb2RlIGlmIHRoaXMgcmV0dXJucyB0cnVlLCBpZiBpdCByZXR1cm5zIGZhbHNlLCB5b3VcbiAqIHNob3VsZCBydW4gdGhlIFwib2xkXCIgY29kZS4gQnkgZG9pbmcgdGhpcywgeW91IGNhbiBtYWludGFpbiBkZXRlcm1pbmlzbS5cbiAqXG4gKiBAcGFyYW0gcGF0Y2hJZCBBbiBpZGVudGlmaWVyIHRoYXQgc2hvdWxkIGJlIHVuaXF1ZSB0byB0aGlzIHBhdGNoLiBJdCBpcyBPSyB0byB1c2UgbXVsdGlwbGVcbiAqIGNhbGxzIHdpdGggdGhlIHNhbWUgSUQsIHdoaWNoIG1lYW5zIGFsbCBzdWNoIGNhbGxzIHdpbGwgYWx3YXlzIHJldHVybiB0aGUgc2FtZSB2YWx1ZS5cbiAqL1xuZXhwb3J0IGZ1bmN0aW9uIHBhdGNoZWQocGF0Y2hJZDogc3RyaW5nKTogYm9vbGVhbiB7XG4gIHJldHVybiBwYXRjaEludGVybmFsKHBhdGNoSWQsIGZhbHNlKTtcbn1cblxuLyoqXG4gKiBJbmRpY2F0ZSB0aGF0IGEgcGF0Y2ggaXMgYmVpbmcgcGhhc2VkIG91dC5cbiAqXG4gKiBTZWUge0BsaW5rIGh0dHBzOi8vZG9jcy50ZW1wb3JhbC5pby90eXBlc2NyaXB0L3ZlcnNpb25pbmcgfCBkb2NzIHBhZ2V9IGZvciBpbmZvLlxuICpcbiAqIFdvcmtmbG93cyB3aXRoIHRoaXMgY2FsbCBtYXkgYmUgZGVwbG95ZWQgYWxvbmdzaWRlIHdvcmtmbG93cyB3aXRoIGEge0BsaW5rIHBhdGNoZWR9IGNhbGwsIGJ1dFxuICogdGhleSBtdXN0ICpub3QqIGJlIGRlcGxveWVkIHdoaWxlIGFueSB3b3JrZXJzIHN0aWxsIGV4aXN0IHJ1bm5pbmcgb2xkIGNvZGUgd2l0aG91dCBhXG4gKiB7QGxpbmsgcGF0Y2hlZH0gY2FsbCwgb3IgYW55IHJ1bnMgd2l0aCBoaXN0b3JpZXMgcHJvZHVjZWQgYnkgc3VjaCB3b3JrZXJzIGV4aXN0LiBJZiBlaXRoZXIga2luZFxuICogb2Ygd29ya2VyIGVuY291bnRlcnMgYSBoaXN0b3J5IHByb2R1Y2VkIGJ5IHRoZSBvdGhlciwgdGhlaXIgYmVoYXZpb3IgaXMgdW5kZWZpbmVkLlxuICpcbiAqIE9uY2UgYWxsIGxpdmUgd29ya2Zsb3cgcnVucyBoYXZlIGJlZW4gcHJvZHVjZWQgYnkgd29ya2VycyB3aXRoIHRoaXMgY2FsbCwgeW91IGNhbiBkZXBsb3kgd29ya2Vyc1xuICogd2hpY2ggYXJlIGZyZWUgb2YgZWl0aGVyIGtpbmQgb2YgcGF0Y2ggY2FsbCBmb3IgdGhpcyBJRC4gV29ya2VycyB3aXRoIGFuZCB3aXRob3V0IHRoaXMgY2FsbFxuICogbWF5IGNvZXhpc3QsIGFzIGxvbmcgYXMgdGhleSBhcmUgYm90aCBydW5uaW5nIHRoZSBcIm5ld1wiIGNvZGUuXG4gKlxuICogQHBhcmFtIHBhdGNoSWQgQW4gaWRlbnRpZmllciB0aGF0IHNob3VsZCBiZSB1bmlxdWUgdG8gdGhpcyBwYXRjaC4gSXQgaXMgT0sgdG8gdXNlIG11bHRpcGxlXG4gKiBjYWxscyB3aXRoIHRoZSBzYW1lIElELCB3aGljaCBtZWFucyBhbGwgc3VjaCBjYWxscyB3aWxsIGFsd2F5cyByZXR1cm4gdGhlIHNhbWUgdmFsdWUuXG4gKi9cbmV4cG9ydCBmdW5jdGlvbiBkZXByZWNhdGVQYXRjaChwYXRjaElkOiBzdHJpbmcpOiB2b2lkIHtcbiAgcGF0Y2hJbnRlcm5hbChwYXRjaElkLCB0cnVlKTtcbn1cblxuZnVuY3Rpb24gcGF0Y2hJbnRlcm5hbChwYXRjaElkOiBzdHJpbmcsIGRlcHJlY2F0ZWQ6IGJvb2xlYW4pOiBib29sZWFuIHtcbiAgY29uc3QgYWN0aXZhdG9yID0gYXNzZXJ0SW5Xb3JrZmxvd0NvbnRleHQoXG4gICAgJ1dvcmtmbG93LnBhdGNoKC4uLikgYW5kIFdvcmtmbG93LmRlcHJlY2F0ZVBhdGNoIG1heSBvbmx5IGJlIHVzZWQgZnJvbSBhIFdvcmtmbG93IEV4ZWN1dGlvbi4nXG4gICk7XG4gIC8vIFBhdGNoIG9wZXJhdGlvbiBkb2VzIG5vdCBzdXBwb3J0IGludGVyY2VwdGlvbiBhdCB0aGUgbW9tZW50LCBpZiBpdCBkaWQsXG4gIC8vIHRoaXMgd291bGQgYmUgdGhlIHBsYWNlIHRvIHN0YXJ0IHRoZSBpbnRlcmNlcHRpb24gY2hhaW5cblxuICBpZiAoYWN0aXZhdG9yLndvcmtmbG93ID09PSB1bmRlZmluZWQpIHtcbiAgICB0aHJvdyBuZXcgSWxsZWdhbFN0YXRlRXJyb3IoJ1BhdGNoZXMgY2Fubm90IGJlIHVzZWQgYmVmb3JlIFdvcmtmbG93IHN0YXJ0cycpO1xuICB9XG4gIGNvbnN0IHVzZVBhdGNoID0gIWFjdGl2YXRvci5pbmZvLnVuc2FmZS5pc1JlcGxheWluZyB8fCBhY3RpdmF0b3Iua25vd25QcmVzZW50UGF0Y2hlcy5oYXMocGF0Y2hJZCk7XG4gIC8vIEF2b2lkIHNlbmRpbmcgY29tbWFuZHMgZm9yIHBhdGNoZXMgY29yZSBhbHJlYWR5IGtub3dzIGFib3V0LlxuICAvLyBUaGlzIG9wdGltaXphdGlvbiBlbmFibGVzIGRldmVsb3BtZW50IG9mIGF1dG9tYXRpYyBwYXRjaGluZyB0b29scy5cbiAgaWYgKHVzZVBhdGNoICYmICFhY3RpdmF0b3Iuc2VudFBhdGNoZXMuaGFzKHBhdGNoSWQpKSB7XG4gICAgYWN0aXZhdG9yLnB1c2hDb21tYW5kKHtcbiAgICAgIHNldFBhdGNoTWFya2VyOiB7IHBhdGNoSWQsIGRlcHJlY2F0ZWQgfSxcbiAgICB9KTtcbiAgICBhY3RpdmF0b3Iuc2VudFBhdGNoZXMuYWRkKHBhdGNoSWQpO1xuICB9XG4gIHJldHVybiB1c2VQYXRjaDtcbn1cblxuLyoqXG4gKiBSZXR1cm5zIGEgUHJvbWlzZSB0aGF0IHJlc29sdmVzIHdoZW4gYGZuYCBldmFsdWF0ZXMgdG8gYHRydWVgIG9yIGB0aW1lb3V0YCBleHBpcmVzLlxuICpcbiAqIEBwYXJhbSB0aW1lb3V0IG51bWJlciBvZiBtaWxsaXNlY29uZHMgb3Ige0BsaW5rIGh0dHBzOi8vd3d3Lm5wbWpzLmNvbS9wYWNrYWdlL21zIHwgbXMtZm9ybWF0dGVkIHN0cmluZ31cbiAqXG4gKiBAcmV0dXJucyBhIGJvb2xlYW4gaW5kaWNhdGluZyB3aGV0aGVyIHRoZSBjb25kaXRpb24gd2FzIHRydWUgYmVmb3JlIHRoZSB0aW1lb3V0IGV4cGlyZXNcbiAqL1xuZXhwb3J0IGZ1bmN0aW9uIGNvbmRpdGlvbihmbjogKCkgPT4gYm9vbGVhbiwgdGltZW91dDogRHVyYXRpb24pOiBQcm9taXNlPGJvb2xlYW4+O1xuXG4vKipcbiAqIFJldHVybnMgYSBQcm9taXNlIHRoYXQgcmVzb2x2ZXMgd2hlbiBgZm5gIGV2YWx1YXRlcyB0byBgdHJ1ZWAuXG4gKi9cbmV4cG9ydCBmdW5jdGlvbiBjb25kaXRpb24oZm46ICgpID0+IGJvb2xlYW4pOiBQcm9taXNlPHZvaWQ+O1xuXG5leHBvcnQgYXN5bmMgZnVuY3Rpb24gY29uZGl0aW9uKGZuOiAoKSA9PiBib29sZWFuLCB0aW1lb3V0PzogRHVyYXRpb24pOiBQcm9taXNlPHZvaWQgfCBib29sZWFuPiB7XG4gIGFzc2VydEluV29ya2Zsb3dDb250ZXh0KCdXb3JrZmxvdy5jb25kaXRpb24oLi4uKSBtYXkgb25seSBiZSB1c2VkIGZyb20gYSBXb3JrZmxvdyBFeGVjdXRpb24uJyk7XG4gIC8vIFByaW9yIHRvIDEuNS4wLCBgY29uZGl0aW9uKGZuLCAwKWAgd2FzIHRyZWF0ZWQgYXMgZXF1aXZhbGVudCB0byBgY29uZGl0aW9uKGZuLCB1bmRlZmluZWQpYFxuICBpZiAodGltZW91dCA9PT0gMCAmJiAhcGF0Y2hlZChDT05ESVRJT05fMF9QQVRDSCkpIHtcbiAgICByZXR1cm4gY29uZGl0aW9uSW5uZXIoZm4pO1xuICB9XG4gIGlmICh0eXBlb2YgdGltZW91dCA9PT0gJ251bWJlcicgfHwgdHlwZW9mIHRpbWVvdXQgPT09ICdzdHJpbmcnKSB7XG4gICAgcmV0dXJuIENhbmNlbGxhdGlvblNjb3BlLmNhbmNlbGxhYmxlKGFzeW5jICgpID0+IHtcbiAgICAgIHRyeSB7XG4gICAgICAgIHJldHVybiBhd2FpdCBQcm9taXNlLnJhY2UoW3NsZWVwKHRpbWVvdXQpLnRoZW4oKCkgPT4gZmFsc2UpLCBjb25kaXRpb25Jbm5lcihmbikudGhlbigoKSA9PiB0cnVlKV0pO1xuICAgICAgfSBmaW5hbGx5IHtcbiAgICAgICAgQ2FuY2VsbGF0aW9uU2NvcGUuY3VycmVudCgpLmNhbmNlbCgpO1xuICAgICAgfVxuICAgIH0pO1xuICB9XG4gIHJldHVybiBjb25kaXRpb25Jbm5lcihmbik7XG59XG5cbmZ1bmN0aW9uIGNvbmRpdGlvbklubmVyKGZuOiAoKSA9PiBib29sZWFuKTogUHJvbWlzZTx2b2lkPiB7XG4gIGNvbnN0IGFjdGl2YXRvciA9IGdldEFjdGl2YXRvcigpO1xuICByZXR1cm4gbmV3IFByb21pc2UoKHJlc29sdmUsIHJlamVjdCkgPT4ge1xuICAgIGNvbnN0IHNjb3BlID0gQ2FuY2VsbGF0aW9uU2NvcGUuY3VycmVudCgpO1xuICAgIGlmIChzY29wZS5jb25zaWRlcmVkQ2FuY2VsbGVkKSB7XG4gICAgICB1bnRyYWNrUHJvbWlzZShzY29wZS5jYW5jZWxSZXF1ZXN0ZWQuY2F0Y2gocmVqZWN0KSk7XG4gICAgICByZXR1cm47XG4gICAgfVxuXG4gICAgY29uc3Qgc2VxID0gYWN0aXZhdG9yLm5leHRTZXFzLmNvbmRpdGlvbisrO1xuICAgIGlmIChzY29wZS5jYW5jZWxsYWJsZSkge1xuICAgICAgdW50cmFja1Byb21pc2UoXG4gICAgICAgIHNjb3BlLmNhbmNlbFJlcXVlc3RlZC5jYXRjaCgoZXJyKSA9PiB7XG4gICAgICAgICAgYWN0aXZhdG9yLmJsb2NrZWRDb25kaXRpb25zLmRlbGV0ZShzZXEpO1xuICAgICAgICAgIHJlamVjdChlcnIpO1xuICAgICAgICB9KVxuICAgICAgKTtcbiAgICB9XG5cbiAgICAvLyBFYWdlciBldmFsdWF0aW9uXG4gICAgaWYgKGZuKCkpIHtcbiAgICAgIHJlc29sdmUoKTtcbiAgICAgIHJldHVybjtcbiAgICB9XG5cbiAgICBhY3RpdmF0b3IuYmxvY2tlZENvbmRpdGlvbnMuc2V0KHNlcSwgeyBmbiwgcmVzb2x2ZSB9KTtcbiAgfSk7XG59XG5cbi8qKlxuICogRGVmaW5lIGFuIHVwZGF0ZSBtZXRob2QgZm9yIGEgV29ya2Zsb3cuXG4gKlxuICogRGVmaW5pdGlvbnMgYXJlIHVzZWQgdG8gcmVnaXN0ZXIgaGFuZGxlciBpbiB0aGUgV29ya2Zsb3cgdmlhIHtAbGluayBzZXRIYW5kbGVyfSBhbmQgdG8gdXBkYXRlIFdvcmtmbG93cyB1c2luZyBhIHtAbGluayBXb3JrZmxvd0hhbmRsZX0sIHtAbGluayBDaGlsZFdvcmtmbG93SGFuZGxlfSBvciB7QGxpbmsgRXh0ZXJuYWxXb3JrZmxvd0hhbmRsZX0uXG4gKiBEZWZpbml0aW9ucyBjYW4gYmUgcmV1c2VkIGluIG11bHRpcGxlIFdvcmtmbG93cy5cbiAqL1xuZXhwb3J0IGZ1bmN0aW9uIGRlZmluZVVwZGF0ZTxSZXQsIEFyZ3MgZXh0ZW5kcyBhbnlbXSA9IFtdLCBOYW1lIGV4dGVuZHMgc3RyaW5nID0gc3RyaW5nPihcbiAgbmFtZTogTmFtZVxuKTogVXBkYXRlRGVmaW5pdGlvbjxSZXQsIEFyZ3MsIE5hbWU+IHtcbiAgcmV0dXJuIHtcbiAgICB0eXBlOiAndXBkYXRlJyxcbiAgICBuYW1lLFxuICB9IGFzIFVwZGF0ZURlZmluaXRpb248UmV0LCBBcmdzLCBOYW1lPjtcbn1cblxuLyoqXG4gKiBEZWZpbmUgYSBzaWduYWwgbWV0aG9kIGZvciBhIFdvcmtmbG93LlxuICpcbiAqIERlZmluaXRpb25zIGFyZSB1c2VkIHRvIHJlZ2lzdGVyIGhhbmRsZXIgaW4gdGhlIFdvcmtmbG93IHZpYSB7QGxpbmsgc2V0SGFuZGxlcn0gYW5kIHRvIHNpZ25hbCBXb3JrZmxvd3MgdXNpbmcgYSB7QGxpbmsgV29ya2Zsb3dIYW5kbGV9LCB7QGxpbmsgQ2hpbGRXb3JrZmxvd0hhbmRsZX0gb3Ige0BsaW5rIEV4dGVybmFsV29ya2Zsb3dIYW5kbGV9LlxuICogRGVmaW5pdGlvbnMgY2FuIGJlIHJldXNlZCBpbiBtdWx0aXBsZSBXb3JrZmxvd3MuXG4gKi9cbmV4cG9ydCBmdW5jdGlvbiBkZWZpbmVTaWduYWw8QXJncyBleHRlbmRzIGFueVtdID0gW10sIE5hbWUgZXh0ZW5kcyBzdHJpbmcgPSBzdHJpbmc+KFxuICBuYW1lOiBOYW1lXG4pOiBTaWduYWxEZWZpbml0aW9uPEFyZ3MsIE5hbWU+IHtcbiAgcmV0dXJuIHtcbiAgICB0eXBlOiAnc2lnbmFsJyxcbiAgICBuYW1lLFxuICB9IGFzIFNpZ25hbERlZmluaXRpb248QXJncywgTmFtZT47XG59XG5cbi8qKlxuICogRGVmaW5lIGEgcXVlcnkgbWV0aG9kIGZvciBhIFdvcmtmbG93LlxuICpcbiAqIERlZmluaXRpb25zIGFyZSB1c2VkIHRvIHJlZ2lzdGVyIGhhbmRsZXIgaW4gdGhlIFdvcmtmbG93IHZpYSB7QGxpbmsgc2V0SGFuZGxlcn0gYW5kIHRvIHF1ZXJ5IFdvcmtmbG93cyB1c2luZyBhIHtAbGluayBXb3JrZmxvd0hhbmRsZX0uXG4gKiBEZWZpbml0aW9ucyBjYW4gYmUgcmV1c2VkIGluIG11bHRpcGxlIFdvcmtmbG93cy5cbiAqL1xuZXhwb3J0IGZ1bmN0aW9uIGRlZmluZVF1ZXJ5PFJldCwgQXJncyBleHRlbmRzIGFueVtdID0gW10sIE5hbWUgZXh0ZW5kcyBzdHJpbmcgPSBzdHJpbmc+KFxuICBuYW1lOiBOYW1lXG4pOiBRdWVyeURlZmluaXRpb248UmV0LCBBcmdzLCBOYW1lPiB7XG4gIHJldHVybiB7XG4gICAgdHlwZTogJ3F1ZXJ5JyxcbiAgICBuYW1lLFxuICB9IGFzIFF1ZXJ5RGVmaW5pdGlvbjxSZXQsIEFyZ3MsIE5hbWU+O1xufVxuXG4vKipcbiAqIFNldCBhIGhhbmRsZXIgZnVuY3Rpb24gZm9yIGEgV29ya2Zsb3cgdXBkYXRlLCBzaWduYWwsIG9yIHF1ZXJ5LlxuICpcbiAqIElmIHRoaXMgZnVuY3Rpb24gaXMgY2FsbGVkIG11bHRpcGxlIHRpbWVzIGZvciBhIGdpdmVuIHVwZGF0ZSwgc2lnbmFsLCBvciBxdWVyeSBuYW1lIHRoZSBsYXN0IGhhbmRsZXIgd2lsbCBvdmVyd3JpdGUgYW55IHByZXZpb3VzIGNhbGxzLlxuICpcbiAqIEBwYXJhbSBkZWYgYW4ge0BsaW5rIFVwZGF0ZURlZmluaXRpb259LCB7QGxpbmsgU2lnbmFsRGVmaW5pdGlvbn0sIG9yIHtAbGluayBRdWVyeURlZmluaXRpb259IGFzIHJldHVybmVkIGJ5IHtAbGluayBkZWZpbmVVcGRhdGV9LCB7QGxpbmsgZGVmaW5lU2lnbmFsfSwgb3Ige0BsaW5rIGRlZmluZVF1ZXJ5fSByZXNwZWN0aXZlbHkuXG4gKiBAcGFyYW0gaGFuZGxlciBhIGNvbXBhdGlibGUgaGFuZGxlciBmdW5jdGlvbiBmb3IgdGhlIGdpdmVuIGRlZmluaXRpb24gb3IgYHVuZGVmaW5lZGAgdG8gdW5zZXQgdGhlIGhhbmRsZXIuXG4gKiBAcGFyYW0gb3B0aW9ucyBhbiBvcHRpb25hbCBgZGVzY3JpcHRpb25gIG9mIHRoZSBoYW5kbGVyIGFuZCBhbiBvcHRpb25hbCB1cGRhdGUgYHZhbGlkYXRvcmAgZnVuY3Rpb24uXG4gKi9cbmV4cG9ydCBmdW5jdGlvbiBzZXRIYW5kbGVyPFJldCwgQXJncyBleHRlbmRzIGFueVtdLCBUIGV4dGVuZHMgUXVlcnlEZWZpbml0aW9uPFJldCwgQXJncz4+KFxuICBkZWY6IFQsXG4gIGhhbmRsZXI6IEhhbmRsZXI8UmV0LCBBcmdzLCBUPiB8IHVuZGVmaW5lZCxcbiAgb3B0aW9ucz86IFF1ZXJ5SGFuZGxlck9wdGlvbnNcbik6IHZvaWQ7XG5leHBvcnQgZnVuY3Rpb24gc2V0SGFuZGxlcjxSZXQsIEFyZ3MgZXh0ZW5kcyBhbnlbXSwgVCBleHRlbmRzIFNpZ25hbERlZmluaXRpb248QXJncz4+KFxuICBkZWY6IFQsXG4gIGhhbmRsZXI6IEhhbmRsZXI8UmV0LCBBcmdzLCBUPiB8IHVuZGVmaW5lZCxcbiAgb3B0aW9ucz86IFNpZ25hbEhhbmRsZXJPcHRpb25zXG4pOiB2b2lkO1xuZXhwb3J0IGZ1bmN0aW9uIHNldEhhbmRsZXI8UmV0LCBBcmdzIGV4dGVuZHMgYW55W10sIFQgZXh0ZW5kcyBVcGRhdGVEZWZpbml0aW9uPFJldCwgQXJncz4+KFxuICBkZWY6IFQsXG4gIGhhbmRsZXI6IEhhbmRsZXI8UmV0LCBBcmdzLCBUPiB8IHVuZGVmaW5lZCxcbiAgb3B0aW9ucz86IFVwZGF0ZUhhbmRsZXJPcHRpb25zPEFyZ3M+XG4pOiB2b2lkO1xuXG4vLyBGb3IgVXBkYXRlcyBhbmQgU2lnbmFscyB3ZSB3YW50IHRvIG1ha2UgYSBwdWJsaWMgZ3VhcmFudGVlIHNvbWV0aGluZyBsaWtlIHRoZVxuLy8gZm9sbG93aW5nOlxuLy9cbi8vICAgXCJJZiBhIFdGVCBjb250YWlucyBhIFNpZ25hbC9VcGRhdGUsIGFuZCBpZiBhIGhhbmRsZXIgaXMgYXZhaWxhYmxlIGZvciB0aGF0XG4vLyAgIFNpZ25hbC9VcGRhdGUsIHRoZW4gdGhlIGhhbmRsZXIgd2lsbCBiZSBleGVjdXRlZC5cIlwiXG4vL1xuLy8gSG93ZXZlciwgdGhhdCBzdGF0ZW1lbnQgaXMgbm90IHdlbGwtZGVmaW5lZCwgbGVhdmluZyBzZXZlcmFsIHF1ZXN0aW9ucyBvcGVuOlxuLy9cbi8vIDEuIFdoYXQgZG9lcyBpdCBtZWFuIGZvciBhIGhhbmRsZXIgdG8gYmUgXCJhdmFpbGFibGVcIj8gV2hhdCBoYXBwZW5zIGlmIHRoZVxuLy8gICAgaGFuZGxlciBpcyBub3QgcHJlc2VudCBpbml0aWFsbHkgYnV0IGlzIHNldCBhdCBzb21lIHBvaW50IGR1cmluZyB0aGVcbi8vICAgIFdvcmtmbG93IGNvZGUgdGhhdCBpcyBleGVjdXRlZCBpbiB0aGF0IFdGVD8gV2hhdCBoYXBwZW5zIGlmIHRoZSBoYW5kbGVyIGlzXG4vLyAgICBzZXQgYW5kIHRoZW4gZGVsZXRlZCwgb3IgcmVwbGFjZWQgd2l0aCBhIGRpZmZlcmVudCBoYW5kbGVyP1xuLy9cbi8vIDIuIFdoZW4gaXMgdGhlIGhhbmRsZXIgZXhlY3V0ZWQ/IChXaGVuIGl0IGZpcnN0IGJlY29tZXMgYXZhaWxhYmxlPyBBdCB0aGUgZW5kXG4vLyAgICBvZiB0aGUgYWN0aXZhdGlvbj8pIFdoYXQgYXJlIHRoZSBleGVjdXRpb24gc2VtYW50aWNzIG9mIFdvcmtmbG93IGFuZFxuLy8gICAgU2lnbmFsL1VwZGF0ZSBoYW5kbGVyIGNvZGUgZ2l2ZW4gdGhhdCB0aGV5IGFyZSBjb25jdXJyZW50PyBDYW4gdGhlIHVzZXJcbi8vICAgIHJlbHkgb24gU2lnbmFsL1VwZGF0ZSBzaWRlIGVmZmVjdHMgYmVpbmcgcmVmbGVjdGVkIGluIHRoZSBXb3JrZmxvdyByZXR1cm5cbi8vICAgIHZhbHVlLCBvciBpbiB0aGUgdmFsdWUgcGFzc2VkIHRvIENvbnRpbnVlLUFzLU5ldz8gSWYgdGhlIGhhbmRsZXIgaXMgYW5cbi8vICAgIGFzeW5jIGZ1bmN0aW9uIC8gY29yb3V0aW5lLCBob3cgbXVjaCBvZiBpdCBpcyBleGVjdXRlZCBhbmQgd2hlbiBpcyB0aGVcbi8vICAgIHJlc3QgZXhlY3V0ZWQ/XG4vL1xuLy8gMy4gV2hhdCBoYXBwZW5zIGlmIHRoZSBoYW5kbGVyIGlzIG5vdCBleGVjdXRlZD8gKGkuZS4gYmVjYXVzZSBpdCB3YXNuJ3Rcbi8vICAgIGF2YWlsYWJsZSBpbiB0aGUgc2Vuc2UgZGVmaW5lZCBieSAoMSkpXG4vL1xuLy8gNC4gSW4gdGhlIGNhc2Ugb2YgVXBkYXRlLCB3aGVuIGlzIHRoZSB2YWxpZGF0aW9uIGZ1bmN0aW9uIGV4ZWN1dGVkP1xuLy9cbi8vIFRoZSBpbXBsZW1lbnRhdGlvbiBmb3IgVHlwZXNjcmlwdCBpcyBhcyBmb2xsb3dzOlxuLy9cbi8vIDEuIHNkay1jb3JlIHNvcnRzIFNpZ25hbCBhbmQgVXBkYXRlIGpvYnMgKGFuZCBQYXRjaGVzKSBhaGVhZCBvZiBhbGwgb3RoZXJcbi8vICAgIGpvYnMuIFRodXMgaWYgdGhlIGhhbmRsZXIgaXMgYXZhaWxhYmxlIGF0IHRoZSBzdGFydCBvZiB0aGUgQWN0aXZhdGlvbiB0aGVuXG4vLyAgICB0aGUgU2lnbmFsL1VwZGF0ZSB3aWxsIGJlIGV4ZWN1dGVkIGJlZm9yZSBXb3JrZmxvdyBjb2RlIGlzIGV4ZWN1dGVkLiBJZiBpdFxuLy8gICAgaXMgbm90LCB0aGVuIHRoZSBTaWduYWwvVXBkYXRlIGNhbGxzIGlzIHB1c2hlZCB0byBhIGJ1ZmZlci5cbi8vXG4vLyAyLiBPbiBlYWNoIGNhbGwgdG8gc2V0SGFuZGxlciBmb3IgYSBnaXZlbiBTaWduYWwvVXBkYXRlLCB3ZSBtYWtlIGEgcGFzc1xuLy8gICAgdGhyb3VnaCB0aGUgYnVmZmVyIGxpc3QuIElmIGEgYnVmZmVyZWQgam9iIGlzIGFzc29jaWF0ZWQgd2l0aCB0aGUganVzdC1zZXRcbi8vICAgIGhhbmRsZXIsIHRoZW4gdGhlIGpvYiBpcyByZW1vdmVkIGZyb20gdGhlIGJ1ZmZlciBhbmQgdGhlIGluaXRpYWxcbi8vICAgIHN5bmNocm9ub3VzIHBvcnRpb24gb2YgdGhlIGhhbmRsZXIgaXMgaW52b2tlZCBvbiB0aGF0IGlucHV0IChpLmUuXG4vLyAgICBwcmVlbXB0aW5nIHdvcmtmbG93IGNvZGUpLlxuLy9cbi8vIFRodXMgaW4gdGhlIGNhc2Ugb2YgVHlwZXNjcmlwdCB0aGUgcXVlc3Rpb25zIGFib3ZlIGFyZSBhbnN3ZXJlZCBhcyBmb2xsb3dzOlxuLy9cbi8vIDEuIEEgaGFuZGxlciBpcyBcImF2YWlsYWJsZVwiIGlmIGl0IGlzIHNldCBhdCB0aGUgc3RhcnQgb2YgdGhlIEFjdGl2YXRpb24gb3Jcbi8vICAgIGJlY29tZXMgc2V0IGF0IGFueSBwb2ludCBkdXJpbmcgdGhlIEFjdGl2YXRpb24uIElmIHRoZSBoYW5kbGVyIGlzIG5vdCBzZXRcbi8vICAgIGluaXRpYWxseSB0aGVuIGl0IGlzIGV4ZWN1dGVkIGFzIHNvb24gYXMgaXQgaXMgc2V0LiBTdWJzZXF1ZW50IGRlbGV0aW9uIG9yXG4vLyAgICByZXBsYWNlbWVudCBieSBhIGRpZmZlcmVudCBoYW5kbGVyIGhhcyBubyBpbXBhY3QgYmVjYXVzZSB0aGUgam9icyBpdCB3YXNcbi8vICAgIGhhbmRsaW5nIGhhdmUgYWxyZWFkeSBiZWVuIGhhbmRsZWQgYW5kIGFyZSBubyBsb25nZXIgaW4gdGhlIGJ1ZmZlci5cbi8vXG4vLyAyLiBUaGUgaGFuZGxlciBpcyBleGVjdXRlZCBhcyBzb29uIGFzIGl0IGJlY29tZXMgYXZhaWxhYmxlLiBJLmUuIGlmIHRoZVxuLy8gICAgaGFuZGxlciBpcyBzZXQgYXQgdGhlIHN0YXJ0IG9mIHRoZSBBY3RpdmF0aW9uIHRoZW4gaXQgaXMgZXhlY3V0ZWQgd2hlblxuLy8gICAgZmlyc3QgYXR0ZW1wdGluZyB0byBwcm9jZXNzIHRoZSBTaWduYWwvVXBkYXRlIGpvYjsgYWx0ZXJuYXRpdmVseSwgaWYgaXQgaXNcbi8vICAgIHNldCBieSBhIHNldEhhbmRsZXIgY2FsbCBtYWRlIGJ5IFdvcmtmbG93IGNvZGUsIHRoZW4gaXQgaXMgZXhlY3V0ZWQgYXNcbi8vICAgIHBhcnQgb2YgdGhhdCBjYWxsIChwcmVlbXB0aW5nIFdvcmtmbG93IGNvZGUpLiBUaGVyZWZvcmUsIGEgdXNlciBjYW4gcmVseVxuLy8gICAgb24gU2lnbmFsL1VwZGF0ZSBzaWRlIGVmZmVjdHMgYmVpbmcgcmVmbGVjdGVkIGluIGUuZy4gdGhlIFdvcmtmbG93IHJldHVyblxuLy8gICAgdmFsdWUsIGFuZCBpbiB0aGUgdmFsdWUgcGFzc2VkIHRvIENvbnRpbnVlLUFzLU5ldy4gQWN0aXZhdGlvbiBqb2JzIGFyZVxuLy8gICAgcHJvY2Vzc2VkIGluIHRoZSBvcmRlciBzdXBwbGllZCBieSBzZGstY29yZSwgaS5lLiBTaWduYWxzLCB0aGVuIFVwZGF0ZXMsXG4vLyAgICB0aGVuIG90aGVyIGpvYnMuIFdpdGhpbiBlYWNoIGdyb3VwLCB0aGUgb3JkZXIgc2VudCBieSB0aGUgc2VydmVyIGlzXG4vLyAgICBwcmVzZXJ2ZWQuIElmIHRoZSBoYW5kbGVyIGlzIGFzeW5jLCBpdCBpcyBleGVjdXRlZCB1cCB0byBpdHMgZmlyc3QgeWllbGRcbi8vICAgIHBvaW50LlxuLy9cbi8vIDMuIFNpZ25hbCBjYXNlOiBJZiBhIGhhbmRsZXIgZG9lcyBub3QgYmVjb21lIGF2YWlsYWJsZSBmb3IgYSBTaWduYWwgam9iIHRoZW5cbi8vICAgIHRoZSBqb2IgcmVtYWlucyBpbiB0aGUgYnVmZmVyLiBJZiBhIGhhbmRsZXIgZm9yIHRoZSBTaWduYWwgYmVjb21lc1xuLy8gICAgYXZhaWxhYmxlIGluIGEgc3Vic2VxdWVudCBBY3RpdmF0aW9uIChvZiB0aGUgc2FtZSBvciBhIHN1YnNlcXVlbnQgV0ZUKVxuLy8gICAgdGhlbiB0aGUgaGFuZGxlciB3aWxsIGJlIGV4ZWN1dGVkLiBJZiBub3QsIHRoZW4gdGhlIFNpZ25hbCB3aWxsIG5ldmVyIGJlXG4vLyAgICByZXNwb25kZWQgdG8gYW5kIHRoaXMgY2F1c2VzIG5vIGVycm9yLlxuLy9cbi8vICAgIFVwZGF0ZSBjYXNlOiBJZiBhIGhhbmRsZXIgZG9lcyBub3QgYmVjb21lIGF2YWlsYWJsZSBmb3IgYW4gVXBkYXRlIGpvYiB0aGVuXG4vLyAgICB0aGUgVXBkYXRlIGlzIHJlamVjdGVkIGF0IHRoZSBlbmQgb2YgdGhlIEFjdGl2YXRpb24uIFRodXMsIGlmIGEgdXNlciBkb2VzXG4vLyAgICBub3Qgd2FudCBhbiBVcGRhdGUgdG8gYmUgcmVqZWN0ZWQgZm9yIHRoaXMgcmVhc29uLCB0aGVuIGl0IGlzIHRoZWlyXG4vLyAgICByZXNwb25zaWJpbGl0eSB0byBlbnN1cmUgdGhhdCB0aGVpciBhcHBsaWNhdGlvbiBhbmQgd29ya2Zsb3cgY29kZSBpbnRlcmFjdFxuLy8gICAgc3VjaCB0aGF0IGEgaGFuZGxlciBpcyBhdmFpbGFibGUgZm9yIHRoZSBVcGRhdGUgZHVyaW5nIGFueSBBY3RpdmF0aW9uXG4vLyAgICB3aGljaCBtaWdodCBjb250YWluIHRoZWlyIFVwZGF0ZSBqb2IuIChOb3RlIHRoYXQgdGhlIHVzZXIgb2Z0ZW4gaGFzXG4vLyAgICB1bmNlcnRhaW50eSBhYm91dCB3aGljaCBXRlQgdGhlaXIgU2lnbmFsL1VwZGF0ZSB3aWxsIGFwcGVhciBpbi4gRm9yXG4vLyAgICBleGFtcGxlLCBpZiB0aGV5IGNhbGwgc3RhcnRXb3JrZmxvdygpIGZvbGxvd2VkIGJ5IHN0YXJ0VXBkYXRlKCksIHRoZW4gdGhleVxuLy8gICAgd2lsbCB0eXBpY2FsbHkgbm90IGtub3cgd2hldGhlciB0aGVzZSB3aWxsIGJlIGRlbGl2ZXJlZCBpbiBvbmUgb3IgdHdvXG4vLyAgICBXRlRzLiBPbiB0aGUgb3RoZXIgaGFuZCB0aGVyZSBhcmUgc2l0dWF0aW9ucyB3aGVyZSB0aGV5IHdvdWxkIGhhdmUgcmVhc29uXG4vLyAgICB0byBiZWxpZXZlIHRoZXkgYXJlIGluIHRoZSBzYW1lIFdGVCwgZm9yIGV4YW1wbGUgaWYgdGhleSBkbyBub3Qgc3RhcnRcbi8vICAgIFdvcmtlciBwb2xsaW5nIHVudGlsIGFmdGVyIHRoZXkgaGF2ZSB2ZXJpZmllZCB0aGF0IGJvdGggcmVxdWVzdHMgaGF2ZVxuLy8gICAgc3VjY2VlZGVkLilcbi8vXG4vLyA1LiBJZiBhbiBVcGRhdGUgaGFzIGEgdmFsaWRhdGlvbiBmdW5jdGlvbiB0aGVuIGl0IGlzIGV4ZWN1dGVkIGltbWVkaWF0ZWx5XG4vLyAgICBwcmlvciB0byB0aGUgaGFuZGxlci4gKE5vdGUgdGhhdCB0aGUgdmFsaWRhdGlvbiBmdW5jdGlvbiBpcyByZXF1aXJlZCB0byBiZVxuLy8gICAgc3luY2hyb25vdXMpLlxuZXhwb3J0IGZ1bmN0aW9uIHNldEhhbmRsZXI8XG4gIFJldCxcbiAgQXJncyBleHRlbmRzIGFueVtdLFxuICBUIGV4dGVuZHMgVXBkYXRlRGVmaW5pdGlvbjxSZXQsIEFyZ3M+IHwgU2lnbmFsRGVmaW5pdGlvbjxBcmdzPiB8IFF1ZXJ5RGVmaW5pdGlvbjxSZXQsIEFyZ3M+LFxuPihcbiAgZGVmOiBULFxuICBoYW5kbGVyOiBIYW5kbGVyPFJldCwgQXJncywgVD4gfCB1bmRlZmluZWQsXG4gIG9wdGlvbnM/OiBRdWVyeUhhbmRsZXJPcHRpb25zIHwgU2lnbmFsSGFuZGxlck9wdGlvbnMgfCBVcGRhdGVIYW5kbGVyT3B0aW9uczxBcmdzPlxuKTogdm9pZCB7XG4gIGNvbnN0IGFjdGl2YXRvciA9IGFzc2VydEluV29ya2Zsb3dDb250ZXh0KCdXb3JrZmxvdy5zZXRIYW5kbGVyKC4uLikgbWF5IG9ubHkgYmUgdXNlZCBmcm9tIGEgV29ya2Zsb3cgRXhlY3V0aW9uLicpO1xuICBjb25zdCBkZXNjcmlwdGlvbiA9IG9wdGlvbnM/LmRlc2NyaXB0aW9uO1xuICBpZiAoZGVmLnR5cGUgPT09ICd1cGRhdGUnKSB7XG4gICAgaWYgKHR5cGVvZiBoYW5kbGVyID09PSAnZnVuY3Rpb24nKSB7XG4gICAgICBjb25zdCB1cGRhdGVPcHRpb25zID0gb3B0aW9ucyBhcyBVcGRhdGVIYW5kbGVyT3B0aW9uczxBcmdzPiB8IHVuZGVmaW5lZDtcbiAgICAgIGNvbnN0IHZhbGlkYXRvciA9IHVwZGF0ZU9wdGlvbnM/LnZhbGlkYXRvciBhcyBXb3JrZmxvd1VwZGF0ZVZhbGlkYXRvclR5cGUgfCB1bmRlZmluZWQ7XG4gICAgICBhY3RpdmF0b3IudXBkYXRlSGFuZGxlcnMuc2V0KGRlZi5uYW1lLCB7IGhhbmRsZXIsIHZhbGlkYXRvciwgZGVzY3JpcHRpb24gfSk7XG4gICAgICBhY3RpdmF0b3IuZGlzcGF0Y2hCdWZmZXJlZFVwZGF0ZXMoKTtcbiAgICB9IGVsc2UgaWYgKGhhbmRsZXIgPT0gbnVsbCkge1xuICAgICAgYWN0aXZhdG9yLnVwZGF0ZUhhbmRsZXJzLmRlbGV0ZShkZWYubmFtZSk7XG4gICAgfSBlbHNlIHtcbiAgICAgIHRocm93IG5ldyBUeXBlRXJyb3IoYEV4cGVjdGVkIGhhbmRsZXIgdG8gYmUgZWl0aGVyIGEgZnVuY3Rpb24gb3IgJ3VuZGVmaW5lZCcuIEdvdDogJyR7dHlwZW9mIGhhbmRsZXJ9J2ApO1xuICAgIH1cbiAgfSBlbHNlIGlmIChkZWYudHlwZSA9PT0gJ3NpZ25hbCcpIHtcbiAgICBpZiAodHlwZW9mIGhhbmRsZXIgPT09ICdmdW5jdGlvbicpIHtcbiAgICAgIGFjdGl2YXRvci5zaWduYWxIYW5kbGVycy5zZXQoZGVmLm5hbWUsIHsgaGFuZGxlcjogaGFuZGxlciBhcyBhbnksIGRlc2NyaXB0aW9uIH0pO1xuICAgICAgYWN0aXZhdG9yLmRpc3BhdGNoQnVmZmVyZWRTaWduYWxzKCk7XG4gICAgfSBlbHNlIGlmIChoYW5kbGVyID09IG51bGwpIHtcbiAgICAgIGFjdGl2YXRvci5zaWduYWxIYW5kbGVycy5kZWxldGUoZGVmLm5hbWUpO1xuICAgIH0gZWxzZSB7XG4gICAgICB0aHJvdyBuZXcgVHlwZUVycm9yKGBFeHBlY3RlZCBoYW5kbGVyIHRvIGJlIGVpdGhlciBhIGZ1bmN0aW9uIG9yICd1bmRlZmluZWQnLiBHb3Q6ICcke3R5cGVvZiBoYW5kbGVyfSdgKTtcbiAgICB9XG4gIH0gZWxzZSBpZiAoZGVmLnR5cGUgPT09ICdxdWVyeScpIHtcbiAgICBpZiAodHlwZW9mIGhhbmRsZXIgPT09ICdmdW5jdGlvbicpIHtcbiAgICAgIGFjdGl2YXRvci5xdWVyeUhhbmRsZXJzLnNldChkZWYubmFtZSwgeyBoYW5kbGVyOiBoYW5kbGVyIGFzIGFueSwgZGVzY3JpcHRpb24gfSk7XG4gICAgfSBlbHNlIGlmIChoYW5kbGVyID09IG51bGwpIHtcbiAgICAgIGFjdGl2YXRvci5xdWVyeUhhbmRsZXJzLmRlbGV0ZShkZWYubmFtZSk7XG4gICAgfSBlbHNlIHtcbiAgICAgIHRocm93IG5ldyBUeXBlRXJyb3IoYEV4cGVjdGVkIGhhbmRsZXIgdG8gYmUgZWl0aGVyIGEgZnVuY3Rpb24gb3IgJ3VuZGVmaW5lZCcuIEdvdDogJyR7dHlwZW9mIGhhbmRsZXJ9J2ApO1xuICAgIH1cbiAgfSBlbHNlIHtcbiAgICB0aHJvdyBuZXcgVHlwZUVycm9yKGBJbnZhbGlkIGRlZmluaXRpb24gdHlwZTogJHsoZGVmIGFzIGFueSkudHlwZX1gKTtcbiAgfVxufVxuXG4vKipcbiAqIFNldCBhIHNpZ25hbCBoYW5kbGVyIGZ1bmN0aW9uIHRoYXQgd2lsbCBoYW5kbGUgc2lnbmFscyBjYWxscyBmb3Igbm9uLXJlZ2lzdGVyZWQgc2lnbmFsIG5hbWVzLlxuICpcbiAqIFNpZ25hbHMgYXJlIGRpc3BhdGNoZWQgdG8gdGhlIGRlZmF1bHQgc2lnbmFsIGhhbmRsZXIgaW4gdGhlIG9yZGVyIHRoYXQgdGhleSB3ZXJlIGFjY2VwdGVkIGJ5IHRoZSBzZXJ2ZXIuXG4gKlxuICogSWYgdGhpcyBmdW5jdGlvbiBpcyBjYWxsZWQgbXVsdGlwbGUgdGltZXMgZm9yIGEgZ2l2ZW4gc2lnbmFsIG9yIHF1ZXJ5IG5hbWUgdGhlIGxhc3QgaGFuZGxlciB3aWxsIG92ZXJ3cml0ZSBhbnkgcHJldmlvdXMgY2FsbHMuXG4gKlxuICogQHBhcmFtIGhhbmRsZXIgYSBmdW5jdGlvbiB0aGF0IHdpbGwgaGFuZGxlIHNpZ25hbHMgZm9yIG5vbi1yZWdpc3RlcmVkIHNpZ25hbCBuYW1lcywgb3IgYHVuZGVmaW5lZGAgdG8gdW5zZXQgdGhlIGhhbmRsZXIuXG4gKi9cbmV4cG9ydCBmdW5jdGlvbiBzZXREZWZhdWx0U2lnbmFsSGFuZGxlcihoYW5kbGVyOiBEZWZhdWx0U2lnbmFsSGFuZGxlciB8IHVuZGVmaW5lZCk6IHZvaWQge1xuICBjb25zdCBhY3RpdmF0b3IgPSBhc3NlcnRJbldvcmtmbG93Q29udGV4dChcbiAgICAnV29ya2Zsb3cuc2V0RGVmYXVsdFNpZ25hbEhhbmRsZXIoLi4uKSBtYXkgb25seSBiZSB1c2VkIGZyb20gYSBXb3JrZmxvdyBFeGVjdXRpb24uJ1xuICApO1xuICBpZiAodHlwZW9mIGhhbmRsZXIgPT09ICdmdW5jdGlvbicpIHtcbiAgICBhY3RpdmF0b3IuZGVmYXVsdFNpZ25hbEhhbmRsZXIgPSBoYW5kbGVyO1xuICAgIGFjdGl2YXRvci5kaXNwYXRjaEJ1ZmZlcmVkU2lnbmFscygpO1xuICB9IGVsc2UgaWYgKGhhbmRsZXIgPT0gbnVsbCkge1xuICAgIGFjdGl2YXRvci5kZWZhdWx0U2lnbmFsSGFuZGxlciA9IHVuZGVmaW5lZDtcbiAgfSBlbHNlIHtcbiAgICB0aHJvdyBuZXcgVHlwZUVycm9yKGBFeHBlY3RlZCBoYW5kbGVyIHRvIGJlIGVpdGhlciBhIGZ1bmN0aW9uIG9yICd1bmRlZmluZWQnLiBHb3Q6ICcke3R5cGVvZiBoYW5kbGVyfSdgKTtcbiAgfVxufVxuXG4vKipcbiAqIFVwZGF0ZXMgdGhpcyBXb3JrZmxvdydzIFNlYXJjaCBBdHRyaWJ1dGVzIGJ5IG1lcmdpbmcgdGhlIHByb3ZpZGVkIGBzZWFyY2hBdHRyaWJ1dGVzYCB3aXRoIHRoZSBleGlzdGluZyBTZWFyY2hcbiAqIEF0dHJpYnV0ZXMsIGB3b3JrZmxvd0luZm8oKS5zZWFyY2hBdHRyaWJ1dGVzYC5cbiAqXG4gKiBGb3IgZXhhbXBsZSwgdGhpcyBXb3JrZmxvdyBjb2RlOlxuICpcbiAqIGBgYHRzXG4gKiB1cHNlcnRTZWFyY2hBdHRyaWJ1dGVzKHtcbiAqICAgQ3VzdG9tSW50RmllbGQ6IFsxXSxcbiAqICAgQ3VzdG9tQm9vbEZpZWxkOiBbdHJ1ZV1cbiAqIH0pO1xuICogdXBzZXJ0U2VhcmNoQXR0cmlidXRlcyh7XG4gKiAgIEN1c3RvbUludEZpZWxkOiBbNDJdLFxuICogICBDdXN0b21LZXl3b3JkRmllbGQ6IFsnZHVyYWJsZSBjb2RlJywgJ2lzIGdyZWF0J11cbiAqIH0pO1xuICogYGBgXG4gKlxuICogd291bGQgcmVzdWx0IGluIHRoZSBXb3JrZmxvdyBoYXZpbmcgdGhlc2UgU2VhcmNoIEF0dHJpYnV0ZXM6XG4gKlxuICogYGBgdHNcbiAqIHtcbiAqICAgQ3VzdG9tSW50RmllbGQ6IFs0Ml0sXG4gKiAgIEN1c3RvbUJvb2xGaWVsZDogW3RydWVdLFxuICogICBDdXN0b21LZXl3b3JkRmllbGQ6IFsnZHVyYWJsZSBjb2RlJywgJ2lzIGdyZWF0J11cbiAqIH1cbiAqIGBgYFxuICpcbiAqIEBwYXJhbSBzZWFyY2hBdHRyaWJ1dGVzIFRoZSBSZWNvcmQgdG8gbWVyZ2UuIFVzZSBhIHZhbHVlIG9mIGBbXWAgdG8gY2xlYXIgYSBTZWFyY2ggQXR0cmlidXRlLlxuICovXG5leHBvcnQgZnVuY3Rpb24gdXBzZXJ0U2VhcmNoQXR0cmlidXRlcyhzZWFyY2hBdHRyaWJ1dGVzOiBTZWFyY2hBdHRyaWJ1dGVzKTogdm9pZCB7XG4gIGNvbnN0IGFjdGl2YXRvciA9IGFzc2VydEluV29ya2Zsb3dDb250ZXh0KFxuICAgICdXb3JrZmxvdy51cHNlcnRTZWFyY2hBdHRyaWJ1dGVzKC4uLikgbWF5IG9ubHkgYmUgdXNlZCBmcm9tIGEgV29ya2Zsb3cgRXhlY3V0aW9uLidcbiAgKTtcblxuICBpZiAoc2VhcmNoQXR0cmlidXRlcyA9PSBudWxsKSB7XG4gICAgdGhyb3cgbmV3IEVycm9yKCdzZWFyY2hBdHRyaWJ1dGVzIG11c3QgYmUgYSBub24tbnVsbCBTZWFyY2hBdHRyaWJ1dGVzJyk7XG4gIH1cblxuICBhY3RpdmF0b3IucHVzaENvbW1hbmQoe1xuICAgIHVwc2VydFdvcmtmbG93U2VhcmNoQXR0cmlidXRlczoge1xuICAgICAgc2VhcmNoQXR0cmlidXRlczogbWFwVG9QYXlsb2FkcyhzZWFyY2hBdHRyaWJ1dGVQYXlsb2FkQ29udmVydGVyLCBzZWFyY2hBdHRyaWJ1dGVzKSxcbiAgICB9LFxuICB9KTtcblxuICBhY3RpdmF0b3IubXV0YXRlV29ya2Zsb3dJbmZvKChpbmZvOiBXb3JrZmxvd0luZm8pOiBXb3JrZmxvd0luZm8gPT4ge1xuICAgIHJldHVybiB7XG4gICAgICAuLi5pbmZvLFxuICAgICAgc2VhcmNoQXR0cmlidXRlczoge1xuICAgICAgICAuLi5pbmZvLnNlYXJjaEF0dHJpYnV0ZXMsXG4gICAgICAgIC4uLnNlYXJjaEF0dHJpYnV0ZXMsXG4gICAgICB9LFxuICAgIH07XG4gIH0pO1xufVxuXG5leHBvcnQgY29uc3Qgc3RhY2tUcmFjZVF1ZXJ5ID0gZGVmaW5lUXVlcnk8c3RyaW5nPignX19zdGFja190cmFjZScpO1xuZXhwb3J0IGNvbnN0IGVuaGFuY2VkU3RhY2tUcmFjZVF1ZXJ5ID0gZGVmaW5lUXVlcnk8RW5oYW5jZWRTdGFja1RyYWNlPignX19lbmhhbmNlZF9zdGFja190cmFjZScpO1xuZXhwb3J0IGNvbnN0IHdvcmtmbG93TWV0YWRhdGFRdWVyeSA9IGRlZmluZVF1ZXJ5PHRlbXBvcmFsLmFwaS5zZGsudjEuSVdvcmtmbG93TWV0YWRhdGE+KCdfX3RlbXBvcmFsX3dvcmtmbG93X21ldGFkYXRhJyk7XG4iLCJpbXBvcnQgdHlwZSB7IGNvcmVzZGsgfSBmcm9tICdAdGVtcG9yYWxpby9wcm90byc7XG5pbXBvcnQgeyBSZXRyeVBvbGljeSB9IGZyb20gJy4vcmV0cnktcG9saWN5JztcbmltcG9ydCB7IGNoZWNrRXh0ZW5kcyB9IGZyb20gJy4vdHlwZS1oZWxwZXJzJztcbmltcG9ydCB7IER1cmF0aW9uIH0gZnJvbSAnLi90aW1lJztcbmltcG9ydCB7IFZlcnNpb25pbmdJbnRlbnQgfSBmcm9tICcuL3ZlcnNpb25pbmctaW50ZW50JztcblxuLy8gQXZvaWQgaW1wb3J0aW5nIHRoZSBwcm90byBpbXBsZW1lbnRhdGlvbiB0byByZWR1Y2Ugd29ya2Zsb3cgYnVuZGxlIHNpemVcbi8vIENvcGllZCBmcm9tIGNvcmVzZGsud29ya2Zsb3dfY29tbWFuZHMuQWN0aXZpdHlDYW5jZWxsYXRpb25UeXBlXG5leHBvcnQgZW51bSBBY3Rpdml0eUNhbmNlbGxhdGlvblR5cGUge1xuICBUUllfQ0FOQ0VMID0gMCxcbiAgV0FJVF9DQU5DRUxMQVRJT05fQ09NUExFVEVEID0gMSxcbiAgQUJBTkRPTiA9IDIsXG59XG5cbmNoZWNrRXh0ZW5kczxjb3Jlc2RrLndvcmtmbG93X2NvbW1hbmRzLkFjdGl2aXR5Q2FuY2VsbGF0aW9uVHlwZSwgQWN0aXZpdHlDYW5jZWxsYXRpb25UeXBlPigpO1xuY2hlY2tFeHRlbmRzPEFjdGl2aXR5Q2FuY2VsbGF0aW9uVHlwZSwgY29yZXNkay53b3JrZmxvd19jb21tYW5kcy5BY3Rpdml0eUNhbmNlbGxhdGlvblR5cGU+KCk7XG5cbi8qKlxuICogT3B0aW9ucyBmb3IgcmVtb3RlIGFjdGl2aXR5IGludm9jYXRpb25cbiAqL1xuZXhwb3J0IGludGVyZmFjZSBBY3Rpdml0eU9wdGlvbnMge1xuICAvKipcbiAgICogSWRlbnRpZmllciB0byB1c2UgZm9yIHRyYWNraW5nIHRoZSBhY3Rpdml0eSBpbiBXb3JrZmxvdyBoaXN0b3J5LlxuICAgKiBUaGUgYGFjdGl2aXR5SWRgIGNhbiBiZSBhY2Nlc3NlZCBieSB0aGUgYWN0aXZpdHkgZnVuY3Rpb24uXG4gICAqIERvZXMgbm90IG5lZWQgdG8gYmUgdW5pcXVlLlxuICAgKlxuICAgKiBAZGVmYXVsdCBhbiBpbmNyZW1lbnRhbCBzZXF1ZW5jZSBudW1iZXJcbiAgICovXG4gIGFjdGl2aXR5SWQ/OiBzdHJpbmc7XG5cbiAgLyoqXG4gICAqIFRhc2sgcXVldWUgbmFtZS5cbiAgICpcbiAgICogQGRlZmF1bHQgY3VycmVudCB3b3JrZXIgdGFzayBxdWV1ZVxuICAgKi9cbiAgdGFza1F1ZXVlPzogc3RyaW5nO1xuXG4gIC8qKlxuICAgKiBIZWFydGJlYXQgaW50ZXJ2YWwuIEFjdGl2aXR5IG11c3QgaGVhcnRiZWF0IGJlZm9yZSB0aGlzIGludGVydmFsIHBhc3NlcyBhZnRlciBhIGxhc3QgaGVhcnRiZWF0IG9yIGFjdGl2aXR5IHN0YXJ0LlxuICAgKiBAZm9ybWF0IG51bWJlciBvZiBtaWxsaXNlY29uZHMgb3Ige0BsaW5rIGh0dHBzOi8vd3d3Lm5wbWpzLmNvbS9wYWNrYWdlL21zIHwgbXMtZm9ybWF0dGVkIHN0cmluZ31cbiAgICovXG4gIGhlYXJ0YmVhdFRpbWVvdXQ/OiBEdXJhdGlvbjtcblxuICAvKipcbiAgICogUmV0cnlQb2xpY3kgdGhhdCBkZWZpbmUgaG93IGFjdGl2aXR5IGlzIHJldHJpZWQgaW4gY2FzZSBvZiBmYWlsdXJlLiBJZiB0aGlzIGlzIG5vdCBzZXQsIHRoZW4gdGhlIHNlcnZlci1kZWZpbmVkIGRlZmF1bHQgYWN0aXZpdHkgcmV0cnkgcG9saWN5IHdpbGwgYmUgdXNlZC4gVG8gZW5zdXJlIHplcm8gcmV0cmllcywgc2V0IG1heGltdW0gYXR0ZW1wdHMgdG8gMS5cbiAgICovXG4gIHJldHJ5PzogUmV0cnlQb2xpY3k7XG5cbiAgLyoqXG4gICAqIE1heGltdW0gdGltZSBvZiBhIHNpbmdsZSBBY3Rpdml0eSBleGVjdXRpb24gYXR0ZW1wdC4gTm90ZSB0aGF0IHRoZSBUZW1wb3JhbCBTZXJ2ZXIgZG9lc24ndCBkZXRlY3QgV29ya2VyIHByb2Nlc3NcbiAgICogZmFpbHVyZXMgZGlyZWN0bHkuIEl0IHJlbGllcyBvbiB0aGlzIHRpbWVvdXQgdG8gZGV0ZWN0IHRoYXQgYW4gQWN0aXZpdHkgdGhhdCBkaWRuJ3QgY29tcGxldGUgb24gdGltZS4gU28gdGhpc1xuICAgKiB0aW1lb3V0IHNob3VsZCBiZSBhcyBzaG9ydCBhcyB0aGUgbG9uZ2VzdCBwb3NzaWJsZSBleGVjdXRpb24gb2YgdGhlIEFjdGl2aXR5IGJvZHkuIFBvdGVudGlhbGx5IGxvbmcgcnVubmluZ1xuICAgKiBBY3Rpdml0aWVzIG11c3Qgc3BlY2lmeSB7QGxpbmsgaGVhcnRiZWF0VGltZW91dH0gYW5kIGNhbGwge0BsaW5rIGFjdGl2aXR5LkNvbnRleHQuaGVhcnRiZWF0fSBwZXJpb2RpY2FsbHkgZm9yXG4gICAqIHRpbWVseSBmYWlsdXJlIGRldGVjdGlvbi5cbiAgICpcbiAgICogRWl0aGVyIHRoaXMgb3B0aW9uIG9yIHtAbGluayBzY2hlZHVsZVRvQ2xvc2VUaW1lb3V0fSBpcyByZXF1aXJlZC5cbiAgICpcbiAgICogQGRlZmF1bHQgYHNjaGVkdWxlVG9DbG9zZVRpbWVvdXRgIG9yIHVubGltaXRlZFxuICAgKiBAZm9ybWF0IG51bWJlciBvZiBtaWxsaXNlY29uZHMgb3Ige0BsaW5rIGh0dHBzOi8vd3d3Lm5wbWpzLmNvbS9wYWNrYWdlL21zIHwgbXMtZm9ybWF0dGVkIHN0cmluZ31cbiAgICovXG4gIHN0YXJ0VG9DbG9zZVRpbWVvdXQ/OiBEdXJhdGlvbjtcblxuICAvKipcbiAgICogVGltZSB0aGF0IHRoZSBBY3Rpdml0eSBUYXNrIGNhbiBzdGF5IGluIHRoZSBUYXNrIFF1ZXVlIGJlZm9yZSBpdCBpcyBwaWNrZWQgdXAgYnkgYSBXb3JrZXIuIERvIG5vdCBzcGVjaWZ5IHRoaXMgdGltZW91dCB1bmxlc3MgdXNpbmcgaG9zdCBzcGVjaWZpYyBUYXNrIFF1ZXVlcyBmb3IgQWN0aXZpdHkgVGFza3MgYXJlIGJlaW5nIHVzZWQgZm9yIHJvdXRpbmcuXG4gICAqIGBzY2hlZHVsZVRvU3RhcnRUaW1lb3V0YCBpcyBhbHdheXMgbm9uLXJldHJ5YWJsZS4gUmV0cnlpbmcgYWZ0ZXIgdGhpcyB0aW1lb3V0IGRvZXNuJ3QgbWFrZSBzZW5zZSBhcyBpdCB3b3VsZCBqdXN0IHB1dCB0aGUgQWN0aXZpdHkgVGFzayBiYWNrIGludG8gdGhlIHNhbWUgVGFzayBRdWV1ZS5cbiAgICpcbiAgICogQGRlZmF1bHQgYHNjaGVkdWxlVG9DbG9zZVRpbWVvdXRgIG9yIHVubGltaXRlZFxuICAgKiBAZm9ybWF0IG51bWJlciBvZiBtaWxsaXNlY29uZHMgb3Ige0BsaW5rIGh0dHBzOi8vd3d3Lm5wbWpzLmNvbS9wYWNrYWdlL21zIHwgbXMtZm9ybWF0dGVkIHN0cmluZ31cbiAgICovXG4gIHNjaGVkdWxlVG9TdGFydFRpbWVvdXQ/OiBEdXJhdGlvbjtcblxuICAvKipcbiAgICogVG90YWwgdGltZSB0aGF0IGEgd29ya2Zsb3cgaXMgd2lsbGluZyB0byB3YWl0IGZvciBBY3Rpdml0eSB0byBjb21wbGV0ZS5cbiAgICogYHNjaGVkdWxlVG9DbG9zZVRpbWVvdXRgIGxpbWl0cyB0aGUgdG90YWwgdGltZSBvZiBhbiBBY3Rpdml0eSdzIGV4ZWN1dGlvbiBpbmNsdWRpbmcgcmV0cmllcyAodXNlIHtAbGluayBzdGFydFRvQ2xvc2VUaW1lb3V0fSB0byBsaW1pdCB0aGUgdGltZSBvZiBhIHNpbmdsZSBhdHRlbXB0KS5cbiAgICpcbiAgICogRWl0aGVyIHRoaXMgb3B0aW9uIG9yIHtAbGluayBzdGFydFRvQ2xvc2VUaW1lb3V0fSBpcyByZXF1aXJlZC5cbiAgICpcbiAgICogQGRlZmF1bHQgdW5saW1pdGVkXG4gICAqIEBmb3JtYXQgbnVtYmVyIG9mIG1pbGxpc2Vjb25kcyBvciB7QGxpbmsgaHR0cHM6Ly93d3cubnBtanMuY29tL3BhY2thZ2UvbXMgfCBtcy1mb3JtYXR0ZWQgc3RyaW5nfVxuICAgKi9cbiAgc2NoZWR1bGVUb0Nsb3NlVGltZW91dD86IER1cmF0aW9uO1xuXG4gIC8qKlxuICAgKiBEZXRlcm1pbmVzIHdoYXQgdGhlIFNESyBkb2VzIHdoZW4gdGhlIEFjdGl2aXR5IGlzIGNhbmNlbGxlZC5cbiAgICogLSBgVFJZX0NBTkNFTGAgLSBJbml0aWF0ZSBhIGNhbmNlbGxhdGlvbiByZXF1ZXN0IGFuZCBpbW1lZGlhdGVseSByZXBvcnQgY2FuY2VsbGF0aW9uIHRvIHRoZSB3b3JrZmxvdy5cbiAgICogLSBgV0FJVF9DQU5DRUxMQVRJT05fQ09NUExFVEVEYCAtIFdhaXQgZm9yIGFjdGl2aXR5IGNhbmNlbGxhdGlvbiBjb21wbGV0aW9uLiBOb3RlIHRoYXQgYWN0aXZpdHkgbXVzdCBoZWFydGJlYXQgdG8gcmVjZWl2ZSBhXG4gICAqICAgY2FuY2VsbGF0aW9uIG5vdGlmaWNhdGlvbi4gVGhpcyBjYW4gYmxvY2sgdGhlIGNhbmNlbGxhdGlvbiBmb3IgYSBsb25nIHRpbWUgaWYgYWN0aXZpdHkgZG9lc24ndFxuICAgKiAgIGhlYXJ0YmVhdCBvciBjaG9vc2VzIHRvIGlnbm9yZSB0aGUgY2FuY2VsbGF0aW9uIHJlcXVlc3QuXG4gICAqIC0gYEFCQU5ET05gIC0gRG8gbm90IHJlcXVlc3QgY2FuY2VsbGF0aW9uIG9mIHRoZSBhY3Rpdml0eSBhbmQgaW1tZWRpYXRlbHkgcmVwb3J0IGNhbmNlbGxhdGlvbiB0byB0aGUgd29ya2Zsb3cuXG4gICAqL1xuICBjYW5jZWxsYXRpb25UeXBlPzogQWN0aXZpdHlDYW5jZWxsYXRpb25UeXBlO1xuXG4gIC8qKlxuICAgKiBFYWdlciBkaXNwYXRjaCBpcyBhbiBvcHRpbWl6YXRpb24gdGhhdCBpbXByb3ZlcyB0aGUgdGhyb3VnaHB1dCBhbmQgbG9hZCBvbiB0aGUgc2VydmVyIGZvciBzY2hlZHVsaW5nIEFjdGl2aXRpZXMuXG4gICAqIFdoZW4gdXNlZCwgdGhlIHNlcnZlciB3aWxsIGhhbmQgb3V0IEFjdGl2aXR5IHRhc2tzIGJhY2sgdG8gdGhlIFdvcmtlciB3aGVuIGl0IGNvbXBsZXRlcyBhIFdvcmtmbG93IHRhc2suXG4gICAqIEl0IGlzIGF2YWlsYWJsZSBmcm9tIHNlcnZlciB2ZXJzaW9uIDEuMTcgYmVoaW5kIHRoZSBgc3lzdGVtLmVuYWJsZUFjdGl2aXR5RWFnZXJFeGVjdXRpb25gIGZlYXR1cmUgZmxhZy5cbiAgICpcbiAgICogRWFnZXIgZGlzcGF0Y2ggd2lsbCBvbmx5IGJlIHVzZWQgaWYgYGFsbG93RWFnZXJEaXNwYXRjaGAgaXMgZW5hYmxlZCAodGhlIGRlZmF1bHQpIGFuZCB7QGxpbmsgdGFza1F1ZXVlfSBpcyBlaXRoZXJcbiAgICogb21pdHRlZCBvciB0aGUgc2FtZSBhcyB0aGUgY3VycmVudCBXb3JrZmxvdy5cbiAgICpcbiAgICogQGRlZmF1bHQgdHJ1ZVxuICAgKi9cbiAgYWxsb3dFYWdlckRpc3BhdGNoPzogYm9vbGVhbjtcblxuICAvKipcbiAgICogV2hlbiB1c2luZyB0aGUgV29ya2VyIFZlcnNpb25pbmcgZmVhdHVyZSwgc3BlY2lmaWVzIHdoZXRoZXIgdGhpcyBBY3Rpdml0eSBzaG91bGQgcnVuIG9uIGFcbiAgICogd29ya2VyIHdpdGggYSBjb21wYXRpYmxlIEJ1aWxkIElkIG9yIG5vdC4gU2VlIHtAbGluayBWZXJzaW9uaW5nSW50ZW50fS5cbiAgICpcbiAgICogQGRlZmF1bHQgJ0NPTVBBVElCTEUnXG4gICAqXG4gICAqIEBleHBlcmltZW50YWxcbiAgICovXG4gIHZlcnNpb25pbmdJbnRlbnQ/OiBWZXJzaW9uaW5nSW50ZW50O1xufVxuXG4vKipcbiAqIE9wdGlvbnMgZm9yIGxvY2FsIGFjdGl2aXR5IGludm9jYXRpb25cbiAqL1xuZXhwb3J0IGludGVyZmFjZSBMb2NhbEFjdGl2aXR5T3B0aW9ucyB7XG4gIC8qKlxuICAgKiBSZXRyeVBvbGljeSB0aGF0IGRlZmluZXMgaG93IGFuIGFjdGl2aXR5IGlzIHJldHJpZWQgaW4gY2FzZSBvZiBmYWlsdXJlLiBJZiB0aGlzIGlzIG5vdCBzZXQsIHRoZW4gdGhlIFNESy1kZWZpbmVkIGRlZmF1bHQgYWN0aXZpdHkgcmV0cnkgcG9saWN5IHdpbGwgYmUgdXNlZC5cbiAgICogTm90ZSB0aGF0IGxvY2FsIGFjdGl2aXRpZXMgYXJlIGFsd2F5cyBleGVjdXRlZCBhdCBsZWFzdCBvbmNlLCBldmVuIGlmIG1heGltdW0gYXR0ZW1wdHMgaXMgc2V0IHRvIDEgZHVlIHRvIFdvcmtmbG93IHRhc2sgcmV0cmllcy5cbiAgICovXG4gIHJldHJ5PzogUmV0cnlQb2xpY3k7XG5cbiAgLyoqXG4gICAqIE1heGltdW0gdGltZSB0aGUgbG9jYWwgYWN0aXZpdHkgaXMgYWxsb3dlZCB0byBleGVjdXRlIGFmdGVyIHRoZSB0YXNrIGlzIGRpc3BhdGNoZWQuIFRoaXNcbiAgICogdGltZW91dCBpcyBhbHdheXMgcmV0cnlhYmxlLlxuICAgKlxuICAgKiBFaXRoZXIgdGhpcyBvcHRpb24gb3Ige0BsaW5rIHNjaGVkdWxlVG9DbG9zZVRpbWVvdXR9IGlzIHJlcXVpcmVkLlxuICAgKiBJZiBzZXQsIHRoaXMgbXVzdCBiZSA8PSB7QGxpbmsgc2NoZWR1bGVUb0Nsb3NlVGltZW91dH0sIG90aGVyd2lzZSwgaXQgd2lsbCBiZSBjbGFtcGVkIGRvd24uXG4gICAqXG4gICAqIEBmb3JtYXQgbnVtYmVyIG9mIG1pbGxpc2Vjb25kcyBvciB7QGxpbmsgaHR0cHM6Ly93d3cubnBtanMuY29tL3BhY2thZ2UvbXMgfCBtcy1mb3JtYXR0ZWQgc3RyaW5nfVxuICAgKi9cbiAgc3RhcnRUb0Nsb3NlVGltZW91dD86IER1cmF0aW9uO1xuXG4gIC8qKlxuICAgKiBMaW1pdHMgdGltZSB0aGUgbG9jYWwgYWN0aXZpdHkgY2FuIGlkbGUgaW50ZXJuYWxseSBiZWZvcmUgYmVpbmcgZXhlY3V0ZWQuIFRoYXQgY2FuIGhhcHBlbiBpZlxuICAgKiB0aGUgd29ya2VyIGlzIGN1cnJlbnRseSBhdCBtYXggY29uY3VycmVudCBsb2NhbCBhY3Rpdml0eSBleGVjdXRpb25zLiBUaGlzIHRpbWVvdXQgaXMgYWx3YXlzXG4gICAqIG5vbiByZXRyeWFibGUgYXMgYWxsIGEgcmV0cnkgd291bGQgYWNoaWV2ZSBpcyB0byBwdXQgaXQgYmFjayBpbnRvIHRoZSBzYW1lIHF1ZXVlLiBEZWZhdWx0c1xuICAgKiB0byB7QGxpbmsgc2NoZWR1bGVUb0Nsb3NlVGltZW91dH0gaWYgbm90IHNwZWNpZmllZCBhbmQgdGhhdCBpcyBzZXQuIE11c3QgYmUgPD1cbiAgICoge0BsaW5rIHNjaGVkdWxlVG9DbG9zZVRpbWVvdXR9IHdoZW4gc2V0LCBvdGhlcndpc2UsIGl0IHdpbGwgYmUgY2xhbXBlZCBkb3duLlxuICAgKlxuICAgKiBAZGVmYXVsdCB1bmxpbWl0ZWRcbiAgICogQGZvcm1hdCBudW1iZXIgb2YgbWlsbGlzZWNvbmRzIG9yIHtAbGluayBodHRwczovL3d3dy5ucG1qcy5jb20vcGFja2FnZS9tcyB8IG1zLWZvcm1hdHRlZCBzdHJpbmd9XG4gICAqL1xuICBzY2hlZHVsZVRvU3RhcnRUaW1lb3V0PzogRHVyYXRpb247XG5cbiAgLyoqXG4gICAqIEluZGljYXRlcyBob3cgbG9uZyB0aGUgY2FsbGVyIGlzIHdpbGxpbmcgdG8gd2FpdCBmb3IgbG9jYWwgYWN0aXZpdHkgY29tcGxldGlvbi4gTGltaXRzIGhvd1xuICAgKiBsb25nIHJldHJpZXMgd2lsbCBiZSBhdHRlbXB0ZWQuXG4gICAqXG4gICAqIEVpdGhlciB0aGlzIG9wdGlvbiBvciB7QGxpbmsgc3RhcnRUb0Nsb3NlVGltZW91dH0gaXMgcmVxdWlyZWQuXG4gICAqXG4gICAqIEBkZWZhdWx0IHVubGltaXRlZFxuICAgKiBAZm9ybWF0IG51bWJlciBvZiBtaWxsaXNlY29uZHMgb3Ige0BsaW5rIGh0dHBzOi8vd3d3Lm5wbWpzLmNvbS9wYWNrYWdlL21zIHwgbXMtZm9ybWF0dGVkIHN0cmluZ31cbiAgICovXG4gIHNjaGVkdWxlVG9DbG9zZVRpbWVvdXQ/OiBEdXJhdGlvbjtcblxuICAvKipcbiAgICogSWYgdGhlIGFjdGl2aXR5IGlzIHJldHJ5aW5nIGFuZCBiYWNrb2ZmIHdvdWxkIGV4Y2VlZCB0aGlzIHZhbHVlLCBhIHNlcnZlciBzaWRlIHRpbWVyIHdpbGwgYmUgc2NoZWR1bGVkIGZvciB0aGUgbmV4dCBhdHRlbXB0LlxuICAgKiBPdGhlcndpc2UsIGJhY2tvZmYgd2lsbCBoYXBwZW4gaW50ZXJuYWxseSBpbiB0aGUgU0RLLlxuICAgKlxuICAgKiBAZGVmYXVsdCAxIG1pbnV0ZVxuICAgKiBAZm9ybWF0IG51bWJlciBvZiBtaWxsaXNlY29uZHMgb3Ige0BsaW5rIGh0dHBzOi8vd3d3Lm5wbWpzLmNvbS9wYWNrYWdlL21zIHwgbXMtZm9ybWF0dGVkIHN0cmluZ31cbiAgICoqL1xuICBsb2NhbFJldHJ5VGhyZXNob2xkPzogRHVyYXRpb247XG5cbiAgLyoqXG4gICAqIERldGVybWluZXMgd2hhdCB0aGUgU0RLIGRvZXMgd2hlbiB0aGUgQWN0aXZpdHkgaXMgY2FuY2VsbGVkLlxuICAgKiAtIGBUUllfQ0FOQ0VMYCAtIEluaXRpYXRlIGEgY2FuY2VsbGF0aW9uIHJlcXVlc3QgYW5kIGltbWVkaWF0ZWx5IHJlcG9ydCBjYW5jZWxsYXRpb24gdG8gdGhlIHdvcmtmbG93LlxuICAgKiAtIGBXQUlUX0NBTkNFTExBVElPTl9DT01QTEVURURgIC0gV2FpdCBmb3IgYWN0aXZpdHkgY2FuY2VsbGF0aW9uIGNvbXBsZXRpb24uIE5vdGUgdGhhdCBhY3Rpdml0eSBtdXN0IGhlYXJ0YmVhdCB0byByZWNlaXZlIGFcbiAgICogICBjYW5jZWxsYXRpb24gbm90aWZpY2F0aW9uLiBUaGlzIGNhbiBibG9jayB0aGUgY2FuY2VsbGF0aW9uIGZvciBhIGxvbmcgdGltZSBpZiBhY3Rpdml0eSBkb2Vzbid0XG4gICAqICAgaGVhcnRiZWF0IG9yIGNob29zZXMgdG8gaWdub3JlIHRoZSBjYW5jZWxsYXRpb24gcmVxdWVzdC5cbiAgICogLSBgQUJBTkRPTmAgLSBEbyBub3QgcmVxdWVzdCBjYW5jZWxsYXRpb24gb2YgdGhlIGFjdGl2aXR5IGFuZCBpbW1lZGlhdGVseSByZXBvcnQgY2FuY2VsbGF0aW9uIHRvIHRoZSB3b3JrZmxvdy5cbiAgICovXG4gIGNhbmNlbGxhdGlvblR5cGU/OiBjb3Jlc2RrLndvcmtmbG93X2NvbW1hbmRzLkFjdGl2aXR5Q2FuY2VsbGF0aW9uVHlwZTtcbn1cbiIsImltcG9ydCB7IERlZmF1bHRGYWlsdXJlQ29udmVydGVyLCBGYWlsdXJlQ29udmVydGVyIH0gZnJvbSAnLi9mYWlsdXJlLWNvbnZlcnRlcic7XG5pbXBvcnQgeyBQYXlsb2FkQ29kZWMgfSBmcm9tICcuL3BheWxvYWQtY29kZWMnO1xuaW1wb3J0IHsgZGVmYXVsdFBheWxvYWRDb252ZXJ0ZXIsIFBheWxvYWRDb252ZXJ0ZXIgfSBmcm9tICcuL3BheWxvYWQtY29udmVydGVyJztcblxuLyoqXG4gKiBXaGVuIHlvdXIgZGF0YSAoYXJndW1lbnRzIGFuZCByZXR1cm4gdmFsdWVzKSBpcyBzZW50IG92ZXIgdGhlIHdpcmUgYW5kIHN0b3JlZCBieSBUZW1wb3JhbCBTZXJ2ZXIsIGl0IGlzIGVuY29kZWQgaW5cbiAqIGJpbmFyeSBpbiBhIHtAbGluayBQYXlsb2FkfSBQcm90b2J1ZiBtZXNzYWdlLlxuICpcbiAqIFRoZSBkZWZhdWx0IGBEYXRhQ29udmVydGVyYCBzdXBwb3J0cyBgdW5kZWZpbmVkYCwgYFVpbnQ4QXJyYXlgLCBhbmQgSlNPTiBzZXJpYWxpemFibGVzIChzbyBpZlxuICoge0BsaW5rIGh0dHBzOi8vZGV2ZWxvcGVyLm1vemlsbGEub3JnL2VuLVVTL2RvY3MvV2ViL0phdmFTY3JpcHQvUmVmZXJlbmNlL0dsb2JhbF9PYmplY3RzL0pTT04vc3RyaW5naWZ5I2Rlc2NyaXB0aW9uIHwgYEpTT04uc3RyaW5naWZ5KHlvdXJBcmdPclJldHZhbClgfVxuICogd29ya3MsIHRoZSBkZWZhdWx0IGRhdGEgY29udmVydGVyIHdpbGwgd29yaykuIFByb3RvYnVmcyBhcmUgc3VwcG9ydGVkIHZpYVxuICoge0BsaW5rIGh0dHBzOi8vZG9jcy50ZW1wb3JhbC5pby90eXBlc2NyaXB0L2RhdGEtY29udmVydGVycyNwcm90b2J1ZnMgfCB0aGlzIEFQSX0uXG4gKlxuICogVXNlIGEgY3VzdG9tIGBEYXRhQ29udmVydGVyYCB0byBjb250cm9sIHRoZSBjb250ZW50cyBvZiB5b3VyIHtAbGluayBQYXlsb2FkfXMuIENvbW1vbiByZWFzb25zIGZvciB1c2luZyBhIGN1c3RvbVxuICogYERhdGFDb252ZXJ0ZXJgIGFyZTpcbiAqIC0gQ29udmVydGluZyB2YWx1ZXMgdGhhdCBhcmUgbm90IHN1cHBvcnRlZCBieSB0aGUgZGVmYXVsdCBgRGF0YUNvbnZlcnRlcmAgKGZvciBleGFtcGxlLCBgSlNPTi5zdHJpbmdpZnkoKWAgZG9lc24ndFxuICogICBoYW5kbGUgYEJpZ0ludGBzLCBzbyBpZiB5b3Ugd2FudCB0byByZXR1cm4gYHsgdG90YWw6IDEwMDBuIH1gIGZyb20gYSBXb3JrZmxvdywgU2lnbmFsLCBvciBBY3Rpdml0eSwgeW91IG5lZWQgeW91clxuICogICBvd24gYERhdGFDb252ZXJ0ZXJgKS5cbiAqIC0gRW5jcnlwdGluZyB2YWx1ZXMgdGhhdCBtYXkgY29udGFpbiBwcml2YXRlIGluZm9ybWF0aW9uIHRoYXQgeW91IGRvbid0IHdhbnQgc3RvcmVkIGluIHBsYWludGV4dCBpbiBUZW1wb3JhbCBTZXJ2ZXInc1xuICogICBkYXRhYmFzZS5cbiAqIC0gQ29tcHJlc3NpbmcgdmFsdWVzIHRvIHJlZHVjZSBkaXNrIG9yIG5ldHdvcmsgdXNhZ2UuXG4gKlxuICogVG8gdXNlIHlvdXIgY3VzdG9tIGBEYXRhQ29udmVydGVyYCwgcHJvdmlkZSBpdCB0byB0aGUge0BsaW5rIFdvcmtmbG93Q2xpZW50fSwge0BsaW5rIFdvcmtlcn0sIGFuZFxuICoge0BsaW5rIGJ1bmRsZVdvcmtmbG93Q29kZX0gKGlmIHlvdSB1c2UgaXQpOlxuICogLSBgbmV3IFdvcmtmbG93Q2xpZW50KHsgLi4uLCBkYXRhQ29udmVydGVyIH0pYFxuICogLSBgV29ya2VyLmNyZWF0ZSh7IC4uLiwgZGF0YUNvbnZlcnRlciB9KWBcbiAqIC0gYGJ1bmRsZVdvcmtmbG93Q29kZSh7IC4uLiwgcGF5bG9hZENvbnZlcnRlclBhdGggfSlgXG4gKi9cbmV4cG9ydCBpbnRlcmZhY2UgRGF0YUNvbnZlcnRlciB7XG4gIC8qKlxuICAgKiBQYXRoIG9mIGEgZmlsZSB0aGF0IGhhcyBhIGBwYXlsb2FkQ29udmVydGVyYCBuYW1lZCBleHBvcnQuXG4gICAqIGBwYXlsb2FkQ29udmVydGVyYCBzaG91bGQgYmUgYW4gb2JqZWN0IHRoYXQgaW1wbGVtZW50cyB7QGxpbmsgUGF5bG9hZENvbnZlcnRlcn0uXG4gICAqIElmIG5vIHBhdGggaXMgcHJvdmlkZWQsIHtAbGluayBkZWZhdWx0UGF5bG9hZENvbnZlcnRlcn0gaXMgdXNlZC5cbiAgICovXG4gIHBheWxvYWRDb252ZXJ0ZXJQYXRoPzogc3RyaW5nO1xuXG4gIC8qKlxuICAgKiBQYXRoIG9mIGEgZmlsZSB0aGF0IGhhcyBhIGBmYWlsdXJlQ29udmVydGVyYCBuYW1lZCBleHBvcnQuXG4gICAqIGBmYWlsdXJlQ29udmVydGVyYCBzaG91bGQgYmUgYW4gb2JqZWN0IHRoYXQgaW1wbGVtZW50cyB7QGxpbmsgRmFpbHVyZUNvbnZlcnRlcn0uXG4gICAqIElmIG5vIHBhdGggaXMgcHJvdmlkZWQsIHtAbGluayBkZWZhdWx0RmFpbHVyZUNvbnZlcnRlcn0gaXMgdXNlZC5cbiAgICovXG4gIGZhaWx1cmVDb252ZXJ0ZXJQYXRoPzogc3RyaW5nO1xuXG4gIC8qKlxuICAgKiBBbiBhcnJheSBvZiB7QGxpbmsgUGF5bG9hZENvZGVjfSBpbnN0YW5jZXMuXG4gICAqXG4gICAqIFBheWxvYWRzIGFyZSBlbmNvZGVkIGluIHRoZSBvcmRlciBvZiB0aGUgYXJyYXkgYW5kIGRlY29kZWQgaW4gdGhlIG9wcG9zaXRlIG9yZGVyLiBGb3IgZXhhbXBsZSwgaWYgeW91IGhhdmUgYVxuICAgKiBjb21wcmVzc2lvbiBjb2RlYyBhbmQgYW4gZW5jcnlwdGlvbiBjb2RlYywgdGhlbiB5b3Ugd2FudCBkYXRhIHRvIGJlIGVuY29kZWQgd2l0aCB0aGUgY29tcHJlc3Npb24gY29kZWMgZmlyc3QsIHNvXG4gICAqIHlvdSdkIGRvIGBwYXlsb2FkQ29kZWNzOiBbY29tcHJlc3Npb25Db2RlYywgZW5jcnlwdGlvbkNvZGVjXWAuXG4gICAqL1xuICBwYXlsb2FkQ29kZWNzPzogUGF5bG9hZENvZGVjW107XG59XG5cbi8qKlxuICogQSB7QGxpbmsgRGF0YUNvbnZlcnRlcn0gdGhhdCBoYXMgYmVlbiBsb2FkZWQgdmlhIHtAbGluayBsb2FkRGF0YUNvbnZlcnRlcn0uXG4gKi9cbmV4cG9ydCBpbnRlcmZhY2UgTG9hZGVkRGF0YUNvbnZlcnRlciB7XG4gIHBheWxvYWRDb252ZXJ0ZXI6IFBheWxvYWRDb252ZXJ0ZXI7XG4gIGZhaWx1cmVDb252ZXJ0ZXI6IEZhaWx1cmVDb252ZXJ0ZXI7XG4gIHBheWxvYWRDb2RlY3M6IFBheWxvYWRDb2RlY1tdO1xufVxuXG4vKipcbiAqIFRoZSBkZWZhdWx0IHtAbGluayBGYWlsdXJlQ29udmVydGVyfSB1c2VkIGJ5IHRoZSBTREsuXG4gKlxuICogRXJyb3IgbWVzc2FnZXMgYW5kIHN0YWNrIHRyYWNlcyBhcmUgc2VyaXphbGl6ZWQgYXMgcGxhaW4gdGV4dC5cbiAqL1xuZXhwb3J0IGNvbnN0IGRlZmF1bHRGYWlsdXJlQ29udmVydGVyOiBGYWlsdXJlQ29udmVydGVyID0gbmV3IERlZmF1bHRGYWlsdXJlQ29udmVydGVyKCk7XG5cbi8qKlxuICogQSBcImxvYWRlZFwiIGRhdGEgY29udmVydGVyIHRoYXQgdXNlcyB0aGUgZGVmYXVsdCBzZXQgb2YgZmFpbHVyZSBhbmQgcGF5bG9hZCBjb252ZXJ0ZXJzLlxuICovXG5leHBvcnQgY29uc3QgZGVmYXVsdERhdGFDb252ZXJ0ZXI6IExvYWRlZERhdGFDb252ZXJ0ZXIgPSB7XG4gIHBheWxvYWRDb252ZXJ0ZXI6IGRlZmF1bHRQYXlsb2FkQ29udmVydGVyLFxuICBmYWlsdXJlQ29udmVydGVyOiBkZWZhdWx0RmFpbHVyZUNvbnZlcnRlcixcbiAgcGF5bG9hZENvZGVjczogW10sXG59O1xuIiwiaW1wb3J0IHtcbiAgQWN0aXZpdHlGYWlsdXJlLFxuICBBcHBsaWNhdGlvbkZhaWx1cmUsXG4gIENhbmNlbGxlZEZhaWx1cmUsXG4gIENoaWxkV29ya2Zsb3dGYWlsdXJlLFxuICBGQUlMVVJFX1NPVVJDRSxcbiAgUHJvdG9GYWlsdXJlLFxuICBSZXRyeVN0YXRlLFxuICBTZXJ2ZXJGYWlsdXJlLFxuICBUZW1wb3JhbEZhaWx1cmUsXG4gIFRlcm1pbmF0ZWRGYWlsdXJlLFxuICBUaW1lb3V0RmFpbHVyZSxcbiAgVGltZW91dFR5cGUsXG59IGZyb20gJy4uL2ZhaWx1cmUnO1xuaW1wb3J0IHsgaXNFcnJvciB9IGZyb20gJy4uL3R5cGUtaGVscGVycyc7XG5pbXBvcnQgeyBhcnJheUZyb21QYXlsb2FkcywgZnJvbVBheWxvYWRzQXRJbmRleCwgUGF5bG9hZENvbnZlcnRlciwgdG9QYXlsb2FkcyB9IGZyb20gJy4vcGF5bG9hZC1jb252ZXJ0ZXInO1xuXG5mdW5jdGlvbiBjb21iaW5lUmVnRXhwKC4uLnJlZ2V4cHM6IFJlZ0V4cFtdKTogUmVnRXhwIHtcbiAgcmV0dXJuIG5ldyBSZWdFeHAocmVnZXhwcy5tYXAoKHgpID0+IGAoPzoke3guc291cmNlfSlgKS5qb2luKCd8JykpO1xufVxuXG4vKipcbiAqIFN0YWNrIHRyYWNlcyB3aWxsIGJlIGN1dG9mZiB3aGVuIG9uIG9mIHRoZXNlIHBhdHRlcm5zIGlzIG1hdGNoZWRcbiAqL1xuY29uc3QgQ1VUT0ZGX1NUQUNLX1BBVFRFUk5TID0gY29tYmluZVJlZ0V4cChcbiAgLyoqIEFjdGl2aXR5IGV4ZWN1dGlvbiAqL1xuICAvXFxzK2F0IEFjdGl2aXR5XFwuZXhlY3V0ZSBcXCguKltcXFxcL113b3JrZXJbXFxcXC9dKD86c3JjfGxpYilbXFxcXC9dYWN0aXZpdHlcXC5banRdczpcXGQrOlxcZCtcXCkvLFxuICAvKiogV29ya2Zsb3cgYWN0aXZhdGlvbiAqL1xuICAvXFxzK2F0IEFjdGl2YXRvclxcLlxcUytOZXh0SGFuZGxlciBcXCguKltcXFxcL113b3JrZmxvd1tcXFxcL10oPzpzcmN8bGliKVtcXFxcL11pbnRlcm5hbHNcXC5banRdczpcXGQrOlxcZCtcXCkvLFxuICAvKiogV29ya2Zsb3cgcnVuIGFueXRoaW5nIGluIGNvbnRleHQgKi9cbiAgL1xccythdCBTY3JpcHRcXC5ydW5JbkNvbnRleHQgXFwoKD86bm9kZTp2bXx2bVxcLmpzKTpcXGQrOlxcZCtcXCkvXG4pO1xuXG4vKipcbiAqIEFueSBzdGFjayB0cmFjZSBmcmFtZXMgdGhhdCBtYXRjaCBhbnkgb2YgdGhvc2Ugd2lsIGJlIGRvcHBlZC5cbiAqIFRoZSBcIm51bGwuXCIgcHJlZml4IG9uIHNvbWUgY2FzZXMgaXMgdG8gYXZvaWQgaHR0cHM6Ly9naXRodWIuY29tL25vZGVqcy9ub2RlL2lzc3Vlcy80MjQxN1xuICovXG5jb25zdCBEUk9QUEVEX1NUQUNLX0ZSQU1FU19QQVRURVJOUyA9IGNvbWJpbmVSZWdFeHAoXG4gIC8qKiBJbnRlcm5hbCBmdW5jdGlvbnMgdXNlZCB0byByZWN1cnNpdmVseSBjaGFpbiBpbnRlcmNlcHRvcnMgKi9cbiAgL1xccythdCAobnVsbFxcLik/bmV4dCBcXCguKltcXFxcL11jb21tb25bXFxcXC9dKD86c3JjfGxpYilbXFxcXC9daW50ZXJjZXB0b3JzXFwuW2p0XXM6XFxkKzpcXGQrXFwpLyxcbiAgLyoqIEludGVybmFsIGZ1bmN0aW9ucyB1c2VkIHRvIHJlY3Vyc2l2ZWx5IGNoYWluIGludGVyY2VwdG9ycyAqL1xuICAvXFxzK2F0IChudWxsXFwuKT9leGVjdXRlTmV4dEhhbmRsZXIgXFwoLipbXFxcXC9dd29ya2VyW1xcXFwvXSg/OnNyY3xsaWIpW1xcXFwvXWFjdGl2aXR5XFwuW2p0XXM6XFxkKzpcXGQrXFwpL1xuKTtcblxuLyoqXG4gKiBDdXRzIG91dCB0aGUgZnJhbWV3b3JrIHBhcnQgb2YgYSBzdGFjayB0cmFjZSwgbGVhdmluZyBvbmx5IHVzZXIgY29kZSBlbnRyaWVzXG4gKi9cbmV4cG9ydCBmdW5jdGlvbiBjdXRvZmZTdGFja1RyYWNlKHN0YWNrPzogc3RyaW5nKTogc3RyaW5nIHtcbiAgY29uc3QgbGluZXMgPSAoc3RhY2sgPz8gJycpLnNwbGl0KC9cXHI/XFxuLyk7XG4gIGNvbnN0IGFjYyA9IEFycmF5PHN0cmluZz4oKTtcbiAgZm9yIChjb25zdCBsaW5lIG9mIGxpbmVzKSB7XG4gICAgaWYgKENVVE9GRl9TVEFDS19QQVRURVJOUy50ZXN0KGxpbmUpKSBicmVhaztcbiAgICBpZiAoIURST1BQRURfU1RBQ0tfRlJBTUVTX1BBVFRFUk5TLnRlc3QobGluZSkpIGFjYy5wdXNoKGxpbmUpO1xuICB9XG4gIHJldHVybiBhY2Muam9pbignXFxuJyk7XG59XG5cbi8qKlxuICogQSBgRmFpbHVyZUNvbnZlcnRlcmAgaXMgcmVzcG9uc2libGUgZm9yIGNvbnZlcnRpbmcgZnJvbSBwcm90byBgRmFpbHVyZWAgaW5zdGFuY2VzIHRvIEpTIGBFcnJvcnNgIGFuZCBiYWNrLlxuICpcbiAqIFdlIHJlY29tbWVuZGVkIHVzaW5nIHRoZSB7QGxpbmsgRGVmYXVsdEZhaWx1cmVDb252ZXJ0ZXJ9IGluc3RlYWQgb2YgY3VzdG9taXppbmcgdGhlIGRlZmF1bHQgaW1wbGVtZW50YXRpb24gaW4gb3JkZXJcbiAqIHRvIG1haW50YWluIGNyb3NzLWxhbmd1YWdlIEZhaWx1cmUgc2VyaWFsaXphdGlvbiBjb21wYXRpYmlsaXR5LlxuICovXG5leHBvcnQgaW50ZXJmYWNlIEZhaWx1cmVDb252ZXJ0ZXIge1xuICAvKipcbiAgICogQ29udmVydHMgYSBjYXVnaHQgZXJyb3IgdG8gYSBGYWlsdXJlIHByb3RvIG1lc3NhZ2UuXG4gICAqL1xuICBlcnJvclRvRmFpbHVyZShlcnI6IHVua25vd24sIHBheWxvYWRDb252ZXJ0ZXI6IFBheWxvYWRDb252ZXJ0ZXIpOiBQcm90b0ZhaWx1cmU7XG4gIC8qKlxuICAgKiBDb252ZXJ0cyBhIEZhaWx1cmUgcHJvdG8gbWVzc2FnZSB0byBhIEpTIEVycm9yIG9iamVjdC5cbiAgICpcbiAgICogVGhlIHJldHVybmVkIGVycm9yIG11c3QgYmUgYW4gaW5zdGFuY2Ugb2YgYFRlbXBvcmFsRmFpbHVyZWAuXG4gICAqL1xuICBmYWlsdXJlVG9FcnJvcihlcnI6IFByb3RvRmFpbHVyZSwgcGF5bG9hZENvbnZlcnRlcjogUGF5bG9hZENvbnZlcnRlcik6IFRlbXBvcmFsRmFpbHVyZTtcbn1cblxuLyoqXG4gKiBUaGUgXCJzaGFwZVwiIG9mIHRoZSBhdHRyaWJ1dGVzIHNldCBhcyB0aGUge0BsaW5rIFByb3RvRmFpbHVyZS5lbmNvZGVkQXR0cmlidXRlc30gcGF5bG9hZCBpbiBjYXNlXG4gKiB7QGxpbmsgRGVmYXVsdEVuY29kZWRGYWlsdXJlQXR0cmlidXRlcy5lbmNvZGVDb21tb25BdHRyaWJ1dGVzfSBpcyBzZXQgdG8gYHRydWVgLlxuICovXG5leHBvcnQgaW50ZXJmYWNlIERlZmF1bHRFbmNvZGVkRmFpbHVyZUF0dHJpYnV0ZXMge1xuICBtZXNzYWdlOiBzdHJpbmc7XG4gIHN0YWNrX3RyYWNlOiBzdHJpbmc7XG59XG5cbi8qKlxuICogT3B0aW9ucyBmb3IgdGhlIHtAbGluayBEZWZhdWx0RmFpbHVyZUNvbnZlcnRlcn0gY29uc3RydWN0b3IuXG4gKi9cbmV4cG9ydCBpbnRlcmZhY2UgRGVmYXVsdEZhaWx1cmVDb252ZXJ0ZXJPcHRpb25zIHtcbiAgLyoqXG4gICAqIFdoZXRoZXIgdG8gZW5jb2RlIGVycm9yIG1lc3NhZ2VzIGFuZCBzdGFjayB0cmFjZXMgKGZvciBlbmNyeXB0aW5nIHRoZXNlIGF0dHJpYnV0ZXMgdXNlIGEge0BsaW5rIFBheWxvYWRDb2RlY30pLlxuICAgKi9cbiAgZW5jb2RlQ29tbW9uQXR0cmlidXRlczogYm9vbGVhbjtcbn1cblxuLyoqXG4gKiBEZWZhdWx0LCBjcm9zcy1sYW5ndWFnZS1jb21wYXRpYmxlIEZhaWx1cmUgY29udmVydGVyLlxuICpcbiAqIEJ5IGRlZmF1bHQsIGl0IHdpbGwgbGVhdmUgZXJyb3IgbWVzc2FnZXMgYW5kIHN0YWNrIHRyYWNlcyBhcyBwbGFpbiB0ZXh0LiBJbiBvcmRlciB0byBlbmNyeXB0IHRoZW0sIHNldFxuICogYGVuY29kZUNvbW1vbkF0dHJpYnV0ZXNgIHRvIGB0cnVlYCBpbiB0aGUgY29uc3RydWN0b3Igb3B0aW9ucyBhbmQgdXNlIGEge0BsaW5rIFBheWxvYWRDb2RlY30gdGhhdCBjYW4gZW5jcnlwdCAvXG4gKiBkZWNyeXB0IFBheWxvYWRzIGluIHlvdXIge0BsaW5rIFdvcmtlck9wdGlvbnMuZGF0YUNvbnZlcnRlciB8IFdvcmtlcn0gYW5kXG4gKiB7QGxpbmsgQ2xpZW50T3B0aW9ucy5kYXRhQ29udmVydGVyIHwgQ2xpZW50IG9wdGlvbnN9LlxuICovXG5leHBvcnQgY2xhc3MgRGVmYXVsdEZhaWx1cmVDb252ZXJ0ZXIgaW1wbGVtZW50cyBGYWlsdXJlQ29udmVydGVyIHtcbiAgcHVibGljIHJlYWRvbmx5IG9wdGlvbnM6IERlZmF1bHRGYWlsdXJlQ29udmVydGVyT3B0aW9ucztcblxuICBjb25zdHJ1Y3RvcihvcHRpb25zPzogUGFydGlhbDxEZWZhdWx0RmFpbHVyZUNvbnZlcnRlck9wdGlvbnM+KSB7XG4gICAgY29uc3QgeyBlbmNvZGVDb21tb25BdHRyaWJ1dGVzIH0gPSBvcHRpb25zID8/IHt9O1xuICAgIHRoaXMub3B0aW9ucyA9IHtcbiAgICAgIGVuY29kZUNvbW1vbkF0dHJpYnV0ZXM6IGVuY29kZUNvbW1vbkF0dHJpYnV0ZXMgPz8gZmFsc2UsXG4gICAgfTtcbiAgfVxuXG4gIC8qKlxuICAgKiBDb252ZXJ0cyBhIEZhaWx1cmUgcHJvdG8gbWVzc2FnZSB0byBhIEpTIEVycm9yIG9iamVjdC5cbiAgICpcbiAgICogRG9lcyBub3Qgc2V0IGNvbW1vbiBwcm9wZXJ0aWVzLCB0aGF0IGlzIGRvbmUgaW4ge0BsaW5rIGZhaWx1cmVUb0Vycm9yfS5cbiAgICovXG4gIGZhaWx1cmVUb0Vycm9ySW5uZXIoZmFpbHVyZTogUHJvdG9GYWlsdXJlLCBwYXlsb2FkQ29udmVydGVyOiBQYXlsb2FkQ29udmVydGVyKTogVGVtcG9yYWxGYWlsdXJlIHtcbiAgICBpZiAoZmFpbHVyZS5hcHBsaWNhdGlvbkZhaWx1cmVJbmZvKSB7XG4gICAgICByZXR1cm4gbmV3IEFwcGxpY2F0aW9uRmFpbHVyZShcbiAgICAgICAgZmFpbHVyZS5tZXNzYWdlID8/IHVuZGVmaW5lZCxcbiAgICAgICAgZmFpbHVyZS5hcHBsaWNhdGlvbkZhaWx1cmVJbmZvLnR5cGUsXG4gICAgICAgIEJvb2xlYW4oZmFpbHVyZS5hcHBsaWNhdGlvbkZhaWx1cmVJbmZvLm5vblJldHJ5YWJsZSksXG4gICAgICAgIGFycmF5RnJvbVBheWxvYWRzKHBheWxvYWRDb252ZXJ0ZXIsIGZhaWx1cmUuYXBwbGljYXRpb25GYWlsdXJlSW5mby5kZXRhaWxzPy5wYXlsb2FkcyksXG4gICAgICAgIHRoaXMub3B0aW9uYWxGYWlsdXJlVG9PcHRpb25hbEVycm9yKGZhaWx1cmUuY2F1c2UsIHBheWxvYWRDb252ZXJ0ZXIpXG4gICAgICApO1xuICAgIH1cbiAgICBpZiAoZmFpbHVyZS5zZXJ2ZXJGYWlsdXJlSW5mbykge1xuICAgICAgcmV0dXJuIG5ldyBTZXJ2ZXJGYWlsdXJlKFxuICAgICAgICBmYWlsdXJlLm1lc3NhZ2UgPz8gdW5kZWZpbmVkLFxuICAgICAgICBCb29sZWFuKGZhaWx1cmUuc2VydmVyRmFpbHVyZUluZm8ubm9uUmV0cnlhYmxlKSxcbiAgICAgICAgdGhpcy5vcHRpb25hbEZhaWx1cmVUb09wdGlvbmFsRXJyb3IoZmFpbHVyZS5jYXVzZSwgcGF5bG9hZENvbnZlcnRlcilcbiAgICAgICk7XG4gICAgfVxuICAgIGlmIChmYWlsdXJlLnRpbWVvdXRGYWlsdXJlSW5mbykge1xuICAgICAgcmV0dXJuIG5ldyBUaW1lb3V0RmFpbHVyZShcbiAgICAgICAgZmFpbHVyZS5tZXNzYWdlID8/IHVuZGVmaW5lZCxcbiAgICAgICAgZnJvbVBheWxvYWRzQXRJbmRleChwYXlsb2FkQ29udmVydGVyLCAwLCBmYWlsdXJlLnRpbWVvdXRGYWlsdXJlSW5mby5sYXN0SGVhcnRiZWF0RGV0YWlscz8ucGF5bG9hZHMpLFxuICAgICAgICBmYWlsdXJlLnRpbWVvdXRGYWlsdXJlSW5mby50aW1lb3V0VHlwZSA/PyBUaW1lb3V0VHlwZS5USU1FT1VUX1RZUEVfVU5TUEVDSUZJRURcbiAgICAgICk7XG4gICAgfVxuICAgIGlmIChmYWlsdXJlLnRlcm1pbmF0ZWRGYWlsdXJlSW5mbykge1xuICAgICAgcmV0dXJuIG5ldyBUZXJtaW5hdGVkRmFpbHVyZShcbiAgICAgICAgZmFpbHVyZS5tZXNzYWdlID8/IHVuZGVmaW5lZCxcbiAgICAgICAgdGhpcy5vcHRpb25hbEZhaWx1cmVUb09wdGlvbmFsRXJyb3IoZmFpbHVyZS5jYXVzZSwgcGF5bG9hZENvbnZlcnRlcilcbiAgICAgICk7XG4gICAgfVxuICAgIGlmIChmYWlsdXJlLmNhbmNlbGVkRmFpbHVyZUluZm8pIHtcbiAgICAgIHJldHVybiBuZXcgQ2FuY2VsbGVkRmFpbHVyZShcbiAgICAgICAgZmFpbHVyZS5tZXNzYWdlID8/IHVuZGVmaW5lZCxcbiAgICAgICAgYXJyYXlGcm9tUGF5bG9hZHMocGF5bG9hZENvbnZlcnRlciwgZmFpbHVyZS5jYW5jZWxlZEZhaWx1cmVJbmZvLmRldGFpbHM/LnBheWxvYWRzKSxcbiAgICAgICAgdGhpcy5vcHRpb25hbEZhaWx1cmVUb09wdGlvbmFsRXJyb3IoZmFpbHVyZS5jYXVzZSwgcGF5bG9hZENvbnZlcnRlcilcbiAgICAgICk7XG4gICAgfVxuICAgIGlmIChmYWlsdXJlLnJlc2V0V29ya2Zsb3dGYWlsdXJlSW5mbykge1xuICAgICAgcmV0dXJuIG5ldyBBcHBsaWNhdGlvbkZhaWx1cmUoXG4gICAgICAgIGZhaWx1cmUubWVzc2FnZSA/PyB1bmRlZmluZWQsXG4gICAgICAgICdSZXNldFdvcmtmbG93JyxcbiAgICAgICAgZmFsc2UsXG4gICAgICAgIGFycmF5RnJvbVBheWxvYWRzKHBheWxvYWRDb252ZXJ0ZXIsIGZhaWx1cmUucmVzZXRXb3JrZmxvd0ZhaWx1cmVJbmZvLmxhc3RIZWFydGJlYXREZXRhaWxzPy5wYXlsb2FkcyksXG4gICAgICAgIHRoaXMub3B0aW9uYWxGYWlsdXJlVG9PcHRpb25hbEVycm9yKGZhaWx1cmUuY2F1c2UsIHBheWxvYWRDb252ZXJ0ZXIpXG4gICAgICApO1xuICAgIH1cbiAgICBpZiAoZmFpbHVyZS5jaGlsZFdvcmtmbG93RXhlY3V0aW9uRmFpbHVyZUluZm8pIHtcbiAgICAgIGNvbnN0IHsgbmFtZXNwYWNlLCB3b3JrZmxvd1R5cGUsIHdvcmtmbG93RXhlY3V0aW9uLCByZXRyeVN0YXRlIH0gPSBmYWlsdXJlLmNoaWxkV29ya2Zsb3dFeGVjdXRpb25GYWlsdXJlSW5mbztcbiAgICAgIGlmICghKHdvcmtmbG93VHlwZT8ubmFtZSAmJiB3b3JrZmxvd0V4ZWN1dGlvbikpIHtcbiAgICAgICAgdGhyb3cgbmV3IFR5cGVFcnJvcignTWlzc2luZyBhdHRyaWJ1dGVzIG9uIGNoaWxkV29ya2Zsb3dFeGVjdXRpb25GYWlsdXJlSW5mbycpO1xuICAgICAgfVxuICAgICAgcmV0dXJuIG5ldyBDaGlsZFdvcmtmbG93RmFpbHVyZShcbiAgICAgICAgbmFtZXNwYWNlID8/IHVuZGVmaW5lZCxcbiAgICAgICAgd29ya2Zsb3dFeGVjdXRpb24sXG4gICAgICAgIHdvcmtmbG93VHlwZS5uYW1lLFxuICAgICAgICByZXRyeVN0YXRlID8/IFJldHJ5U3RhdGUuUkVUUllfU1RBVEVfVU5TUEVDSUZJRUQsXG4gICAgICAgIHRoaXMub3B0aW9uYWxGYWlsdXJlVG9PcHRpb25hbEVycm9yKGZhaWx1cmUuY2F1c2UsIHBheWxvYWRDb252ZXJ0ZXIpXG4gICAgICApO1xuICAgIH1cbiAgICBpZiAoZmFpbHVyZS5hY3Rpdml0eUZhaWx1cmVJbmZvKSB7XG4gICAgICBpZiAoIWZhaWx1cmUuYWN0aXZpdHlGYWlsdXJlSW5mby5hY3Rpdml0eVR5cGU/Lm5hbWUpIHtcbiAgICAgICAgdGhyb3cgbmV3IFR5cGVFcnJvcignTWlzc2luZyBhY3Rpdml0eVR5cGU/Lm5hbWUgb24gYWN0aXZpdHlGYWlsdXJlSW5mbycpO1xuICAgICAgfVxuICAgICAgcmV0dXJuIG5ldyBBY3Rpdml0eUZhaWx1cmUoXG4gICAgICAgIGZhaWx1cmUubWVzc2FnZSA/PyB1bmRlZmluZWQsXG4gICAgICAgIGZhaWx1cmUuYWN0aXZpdHlGYWlsdXJlSW5mby5hY3Rpdml0eVR5cGUubmFtZSxcbiAgICAgICAgZmFpbHVyZS5hY3Rpdml0eUZhaWx1cmVJbmZvLmFjdGl2aXR5SWQgPz8gdW5kZWZpbmVkLFxuICAgICAgICBmYWlsdXJlLmFjdGl2aXR5RmFpbHVyZUluZm8ucmV0cnlTdGF0ZSA/PyBSZXRyeVN0YXRlLlJFVFJZX1NUQVRFX1VOU1BFQ0lGSUVELFxuICAgICAgICBmYWlsdXJlLmFjdGl2aXR5RmFpbHVyZUluZm8uaWRlbnRpdHkgPz8gdW5kZWZpbmVkLFxuICAgICAgICB0aGlzLm9wdGlvbmFsRmFpbHVyZVRvT3B0aW9uYWxFcnJvcihmYWlsdXJlLmNhdXNlLCBwYXlsb2FkQ29udmVydGVyKVxuICAgICAgKTtcbiAgICB9XG4gICAgcmV0dXJuIG5ldyBUZW1wb3JhbEZhaWx1cmUoXG4gICAgICBmYWlsdXJlLm1lc3NhZ2UgPz8gdW5kZWZpbmVkLFxuICAgICAgdGhpcy5vcHRpb25hbEZhaWx1cmVUb09wdGlvbmFsRXJyb3IoZmFpbHVyZS5jYXVzZSwgcGF5bG9hZENvbnZlcnRlcilcbiAgICApO1xuICB9XG5cbiAgZmFpbHVyZVRvRXJyb3IoZmFpbHVyZTogUHJvdG9GYWlsdXJlLCBwYXlsb2FkQ29udmVydGVyOiBQYXlsb2FkQ29udmVydGVyKTogVGVtcG9yYWxGYWlsdXJlIHtcbiAgICBpZiAoZmFpbHVyZS5lbmNvZGVkQXR0cmlidXRlcykge1xuICAgICAgY29uc3QgYXR0cnMgPSBwYXlsb2FkQ29udmVydGVyLmZyb21QYXlsb2FkPERlZmF1bHRFbmNvZGVkRmFpbHVyZUF0dHJpYnV0ZXM+KGZhaWx1cmUuZW5jb2RlZEF0dHJpYnV0ZXMpO1xuICAgICAgLy8gRG9uJ3QgYXBwbHkgZW5jb2RlZEF0dHJpYnV0ZXMgdW5sZXNzIHRoZXkgY29uZm9ybSB0byBhbiBleHBlY3RlZCBzY2hlbWFcbiAgICAgIGlmICh0eXBlb2YgYXR0cnMgPT09ICdvYmplY3QnICYmIGF0dHJzICE9PSBudWxsKSB7XG4gICAgICAgIGNvbnN0IHsgbWVzc2FnZSwgc3RhY2tfdHJhY2UgfSA9IGF0dHJzO1xuICAgICAgICAvLyBBdm9pZCBtdXRhdGluZyB0aGUgYXJndW1lbnRcbiAgICAgICAgZmFpbHVyZSA9IHsgLi4uZmFpbHVyZSB9O1xuICAgICAgICBpZiAodHlwZW9mIG1lc3NhZ2UgPT09ICdzdHJpbmcnKSB7XG4gICAgICAgICAgZmFpbHVyZS5tZXNzYWdlID0gbWVzc2FnZTtcbiAgICAgICAgfVxuICAgICAgICBpZiAodHlwZW9mIHN0YWNrX3RyYWNlID09PSAnc3RyaW5nJykge1xuICAgICAgICAgIGZhaWx1cmUuc3RhY2tUcmFjZSA9IHN0YWNrX3RyYWNlO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgfVxuICAgIGNvbnN0IGVyciA9IHRoaXMuZmFpbHVyZVRvRXJyb3JJbm5lcihmYWlsdXJlLCBwYXlsb2FkQ29udmVydGVyKTtcbiAgICBlcnIuc3RhY2sgPSBmYWlsdXJlLnN0YWNrVHJhY2UgPz8gJyc7XG4gICAgZXJyLmZhaWx1cmUgPSBmYWlsdXJlO1xuICAgIHJldHVybiBlcnI7XG4gIH1cblxuICBlcnJvclRvRmFpbHVyZShlcnI6IHVua25vd24sIHBheWxvYWRDb252ZXJ0ZXI6IFBheWxvYWRDb252ZXJ0ZXIpOiBQcm90b0ZhaWx1cmUge1xuICAgIGNvbnN0IGZhaWx1cmUgPSB0aGlzLmVycm9yVG9GYWlsdXJlSW5uZXIoZXJyLCBwYXlsb2FkQ29udmVydGVyKTtcbiAgICBpZiAodGhpcy5vcHRpb25zLmVuY29kZUNvbW1vbkF0dHJpYnV0ZXMpIHtcbiAgICAgIGNvbnN0IHsgbWVzc2FnZSwgc3RhY2tUcmFjZSB9ID0gZmFpbHVyZTtcbiAgICAgIGZhaWx1cmUubWVzc2FnZSA9ICdFbmNvZGVkIGZhaWx1cmUnO1xuICAgICAgZmFpbHVyZS5zdGFja1RyYWNlID0gJyc7XG4gICAgICBmYWlsdXJlLmVuY29kZWRBdHRyaWJ1dGVzID0gcGF5bG9hZENvbnZlcnRlci50b1BheWxvYWQoeyBtZXNzYWdlLCBzdGFja190cmFjZTogc3RhY2tUcmFjZSB9KTtcbiAgICB9XG4gICAgcmV0dXJuIGZhaWx1cmU7XG4gIH1cblxuICBlcnJvclRvRmFpbHVyZUlubmVyKGVycjogdW5rbm93biwgcGF5bG9hZENvbnZlcnRlcjogUGF5bG9hZENvbnZlcnRlcik6IFByb3RvRmFpbHVyZSB7XG4gICAgaWYgKGVyciBpbnN0YW5jZW9mIFRlbXBvcmFsRmFpbHVyZSkge1xuICAgICAgaWYgKGVyci5mYWlsdXJlKSByZXR1cm4gZXJyLmZhaWx1cmU7XG4gICAgICBjb25zdCBiYXNlID0ge1xuICAgICAgICBtZXNzYWdlOiBlcnIubWVzc2FnZSxcbiAgICAgICAgc3RhY2tUcmFjZTogY3V0b2ZmU3RhY2tUcmFjZShlcnIuc3RhY2spLFxuICAgICAgICBjYXVzZTogdGhpcy5vcHRpb25hbEVycm9yVG9PcHRpb25hbEZhaWx1cmUoZXJyLmNhdXNlLCBwYXlsb2FkQ29udmVydGVyKSxcbiAgICAgICAgc291cmNlOiBGQUlMVVJFX1NPVVJDRSxcbiAgICAgIH07XG5cbiAgICAgIGlmIChlcnIgaW5zdGFuY2VvZiBBY3Rpdml0eUZhaWx1cmUpIHtcbiAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICAuLi5iYXNlLFxuICAgICAgICAgIGFjdGl2aXR5RmFpbHVyZUluZm86IHtcbiAgICAgICAgICAgIC4uLmVycixcbiAgICAgICAgICAgIGFjdGl2aXR5VHlwZTogeyBuYW1lOiBlcnIuYWN0aXZpdHlUeXBlIH0sXG4gICAgICAgICAgfSxcbiAgICAgICAgfTtcbiAgICAgIH1cbiAgICAgIGlmIChlcnIgaW5zdGFuY2VvZiBDaGlsZFdvcmtmbG93RmFpbHVyZSkge1xuICAgICAgICByZXR1cm4ge1xuICAgICAgICAgIC4uLmJhc2UsXG4gICAgICAgICAgY2hpbGRXb3JrZmxvd0V4ZWN1dGlvbkZhaWx1cmVJbmZvOiB7XG4gICAgICAgICAgICAuLi5lcnIsXG4gICAgICAgICAgICB3b3JrZmxvd0V4ZWN1dGlvbjogZXJyLmV4ZWN1dGlvbixcbiAgICAgICAgICAgIHdvcmtmbG93VHlwZTogeyBuYW1lOiBlcnIud29ya2Zsb3dUeXBlIH0sXG4gICAgICAgICAgfSxcbiAgICAgICAgfTtcbiAgICAgIH1cbiAgICAgIGlmIChlcnIgaW5zdGFuY2VvZiBBcHBsaWNhdGlvbkZhaWx1cmUpIHtcbiAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICAuLi5iYXNlLFxuICAgICAgICAgIGFwcGxpY2F0aW9uRmFpbHVyZUluZm86IHtcbiAgICAgICAgICAgIHR5cGU6IGVyci50eXBlLFxuICAgICAgICAgICAgbm9uUmV0cnlhYmxlOiBlcnIubm9uUmV0cnlhYmxlLFxuICAgICAgICAgICAgZGV0YWlsczpcbiAgICAgICAgICAgICAgZXJyLmRldGFpbHMgJiYgZXJyLmRldGFpbHMubGVuZ3RoXG4gICAgICAgICAgICAgICAgPyB7IHBheWxvYWRzOiB0b1BheWxvYWRzKHBheWxvYWRDb252ZXJ0ZXIsIC4uLmVyci5kZXRhaWxzKSB9XG4gICAgICAgICAgICAgICAgOiB1bmRlZmluZWQsXG4gICAgICAgICAgfSxcbiAgICAgICAgfTtcbiAgICAgIH1cbiAgICAgIGlmIChlcnIgaW5zdGFuY2VvZiBDYW5jZWxsZWRGYWlsdXJlKSB7XG4gICAgICAgIHJldHVybiB7XG4gICAgICAgICAgLi4uYmFzZSxcbiAgICAgICAgICBjYW5jZWxlZEZhaWx1cmVJbmZvOiB7XG4gICAgICAgICAgICBkZXRhaWxzOlxuICAgICAgICAgICAgICBlcnIuZGV0YWlscyAmJiBlcnIuZGV0YWlscy5sZW5ndGhcbiAgICAgICAgICAgICAgICA/IHsgcGF5bG9hZHM6IHRvUGF5bG9hZHMocGF5bG9hZENvbnZlcnRlciwgLi4uZXJyLmRldGFpbHMpIH1cbiAgICAgICAgICAgICAgICA6IHVuZGVmaW5lZCxcbiAgICAgICAgICB9LFxuICAgICAgICB9O1xuICAgICAgfVxuICAgICAgaWYgKGVyciBpbnN0YW5jZW9mIFRpbWVvdXRGYWlsdXJlKSB7XG4gICAgICAgIHJldHVybiB7XG4gICAgICAgICAgLi4uYmFzZSxcbiAgICAgICAgICB0aW1lb3V0RmFpbHVyZUluZm86IHtcbiAgICAgICAgICAgIHRpbWVvdXRUeXBlOiBlcnIudGltZW91dFR5cGUsXG4gICAgICAgICAgICBsYXN0SGVhcnRiZWF0RGV0YWlsczogZXJyLmxhc3RIZWFydGJlYXREZXRhaWxzXG4gICAgICAgICAgICAgID8geyBwYXlsb2FkczogdG9QYXlsb2FkcyhwYXlsb2FkQ29udmVydGVyLCBlcnIubGFzdEhlYXJ0YmVhdERldGFpbHMpIH1cbiAgICAgICAgICAgICAgOiB1bmRlZmluZWQsXG4gICAgICAgICAgfSxcbiAgICAgICAgfTtcbiAgICAgIH1cbiAgICAgIGlmIChlcnIgaW5zdGFuY2VvZiBTZXJ2ZXJGYWlsdXJlKSB7XG4gICAgICAgIHJldHVybiB7XG4gICAgICAgICAgLi4uYmFzZSxcbiAgICAgICAgICBzZXJ2ZXJGYWlsdXJlSW5mbzogeyBub25SZXRyeWFibGU6IGVyci5ub25SZXRyeWFibGUgfSxcbiAgICAgICAgfTtcbiAgICAgIH1cbiAgICAgIGlmIChlcnIgaW5zdGFuY2VvZiBUZXJtaW5hdGVkRmFpbHVyZSkge1xuICAgICAgICByZXR1cm4ge1xuICAgICAgICAgIC4uLmJhc2UsXG4gICAgICAgICAgdGVybWluYXRlZEZhaWx1cmVJbmZvOiB7fSxcbiAgICAgICAgfTtcbiAgICAgIH1cbiAgICAgIC8vIEp1c3QgYSBUZW1wb3JhbEZhaWx1cmVcbiAgICAgIHJldHVybiBiYXNlO1xuICAgIH1cblxuICAgIGNvbnN0IGJhc2UgPSB7XG4gICAgICBzb3VyY2U6IEZBSUxVUkVfU09VUkNFLFxuICAgIH07XG5cbiAgICBpZiAoaXNFcnJvcihlcnIpKSB7XG4gICAgICByZXR1cm4ge1xuICAgICAgICAuLi5iYXNlLFxuICAgICAgICBtZXNzYWdlOiBTdHJpbmcoZXJyLm1lc3NhZ2UpID8/ICcnLFxuICAgICAgICBzdGFja1RyYWNlOiBjdXRvZmZTdGFja1RyYWNlKGVyci5zdGFjayksXG4gICAgICAgIGNhdXNlOiB0aGlzLm9wdGlvbmFsRXJyb3JUb09wdGlvbmFsRmFpbHVyZSgoZXJyIGFzIGFueSkuY2F1c2UsIHBheWxvYWRDb252ZXJ0ZXIpLFxuICAgICAgfTtcbiAgICB9XG5cbiAgICBjb25zdCByZWNvbW1lbmRhdGlvbiA9IGAgW0Egbm9uLUVycm9yIHZhbHVlIHdhcyB0aHJvd24gZnJvbSB5b3VyIGNvZGUuIFdlIHJlY29tbWVuZCB0aHJvd2luZyBFcnJvciBvYmplY3RzIHNvIHRoYXQgd2UgY2FuIHByb3ZpZGUgYSBzdGFjayB0cmFjZV1gO1xuXG4gICAgaWYgKHR5cGVvZiBlcnIgPT09ICdzdHJpbmcnKSB7XG4gICAgICByZXR1cm4geyAuLi5iYXNlLCBtZXNzYWdlOiBlcnIgKyByZWNvbW1lbmRhdGlvbiB9O1xuICAgIH1cbiAgICBpZiAodHlwZW9mIGVyciA9PT0gJ29iamVjdCcpIHtcbiAgICAgIGxldCBtZXNzYWdlID0gJyc7XG4gICAgICB0cnkge1xuICAgICAgICBtZXNzYWdlID0gSlNPTi5zdHJpbmdpZnkoZXJyKTtcbiAgICAgIH0gY2F0Y2ggKF9lcnIpIHtcbiAgICAgICAgbWVzc2FnZSA9IFN0cmluZyhlcnIpO1xuICAgICAgfVxuICAgICAgcmV0dXJuIHsgLi4uYmFzZSwgbWVzc2FnZTogbWVzc2FnZSArIHJlY29tbWVuZGF0aW9uIH07XG4gICAgfVxuXG4gICAgcmV0dXJuIHsgLi4uYmFzZSwgbWVzc2FnZTogU3RyaW5nKGVycikgKyByZWNvbW1lbmRhdGlvbiB9O1xuICB9XG5cbiAgLyoqXG4gICAqIENvbnZlcnRzIGEgRmFpbHVyZSBwcm90byBtZXNzYWdlIHRvIGEgSlMgRXJyb3Igb2JqZWN0IGlmIGRlZmluZWQgb3IgcmV0dXJucyB1bmRlZmluZWQuXG4gICAqL1xuICBvcHRpb25hbEZhaWx1cmVUb09wdGlvbmFsRXJyb3IoXG4gICAgZmFpbHVyZTogUHJvdG9GYWlsdXJlIHwgdW5kZWZpbmVkIHwgbnVsbCxcbiAgICBwYXlsb2FkQ29udmVydGVyOiBQYXlsb2FkQ29udmVydGVyXG4gICk6IFRlbXBvcmFsRmFpbHVyZSB8IHVuZGVmaW5lZCB7XG4gICAgcmV0dXJuIGZhaWx1cmUgPyB0aGlzLmZhaWx1cmVUb0Vycm9yKGZhaWx1cmUsIHBheWxvYWRDb252ZXJ0ZXIpIDogdW5kZWZpbmVkO1xuICB9XG5cbiAgLyoqXG4gICAqIENvbnZlcnRzIGFuIGVycm9yIHRvIGEgRmFpbHVyZSBwcm90byBtZXNzYWdlIGlmIGRlZmluZWQgb3IgcmV0dXJucyB1bmRlZmluZWRcbiAgICovXG4gIG9wdGlvbmFsRXJyb3JUb09wdGlvbmFsRmFpbHVyZShlcnI6IHVua25vd24sIHBheWxvYWRDb252ZXJ0ZXI6IFBheWxvYWRDb252ZXJ0ZXIpOiBQcm90b0ZhaWx1cmUgfCB1bmRlZmluZWQge1xuICAgIHJldHVybiBlcnIgPyB0aGlzLmVycm9yVG9GYWlsdXJlKGVyciwgcGF5bG9hZENvbnZlcnRlcikgOiB1bmRlZmluZWQ7XG4gIH1cbn1cbiIsImltcG9ydCB7IFBheWxvYWQgfSBmcm9tICcuLi9pbnRlcmZhY2VzJztcblxuLyoqXG4gKiBgUGF5bG9hZENvZGVjYCBpcyBhbiBvcHRpb25hbCBzdGVwIHRoYXQgaGFwcGVucyBiZXR3ZWVuIHRoZSB3aXJlIGFuZCB0aGUge0BsaW5rIFBheWxvYWRDb252ZXJ0ZXJ9OlxuICpcbiAqIFRlbXBvcmFsIFNlcnZlciA8LS0+IFdpcmUgPC0tPiBgUGF5bG9hZENvZGVjYCA8LS0+IGBQYXlsb2FkQ29udmVydGVyYCA8LS0+IFVzZXIgY29kZVxuICpcbiAqIEltcGxlbWVudCB0aGlzIHRvIHRyYW5zZm9ybSBhbiBhcnJheSBvZiB7QGxpbmsgUGF5bG9hZH1zIHRvL2Zyb20gdGhlIGZvcm1hdCBzZW50IG92ZXIgdGhlIHdpcmUgYW5kIHN0b3JlZCBieSBUZW1wb3JhbCBTZXJ2ZXIuXG4gKiBDb21tb24gdHJhbnNmb3JtYXRpb25zIGFyZSBlbmNyeXB0aW9uIGFuZCBjb21wcmVzc2lvbi5cbiAqL1xuZXhwb3J0IGludGVyZmFjZSBQYXlsb2FkQ29kZWMge1xuICAvKipcbiAgICogRW5jb2RlIGFuIGFycmF5IG9mIHtAbGluayBQYXlsb2FkfXMgZm9yIHNlbmRpbmcgb3ZlciB0aGUgd2lyZS5cbiAgICogQHBhcmFtIHBheWxvYWRzIE1heSBoYXZlIGxlbmd0aCAwLlxuICAgKi9cbiAgZW5jb2RlKHBheWxvYWRzOiBQYXlsb2FkW10pOiBQcm9taXNlPFBheWxvYWRbXT47XG5cbiAgLyoqXG4gICAqIERlY29kZSBhbiBhcnJheSBvZiB7QGxpbmsgUGF5bG9hZH1zIHJlY2VpdmVkIGZyb20gdGhlIHdpcmUuXG4gICAqL1xuICBkZWNvZGUocGF5bG9hZHM6IFBheWxvYWRbXSk6IFByb21pc2U8UGF5bG9hZFtdPjtcbn1cbiIsImltcG9ydCB7IGRlY29kZSwgZW5jb2RlIH0gZnJvbSAnLi4vZW5jb2RpbmcnO1xuaW1wb3J0IHsgUGF5bG9hZENvbnZlcnRlckVycm9yLCBWYWx1ZUVycm9yIH0gZnJvbSAnLi4vZXJyb3JzJztcbmltcG9ydCB7IFBheWxvYWQgfSBmcm9tICcuLi9pbnRlcmZhY2VzJztcbmltcG9ydCB7IGVuY29kaW5nS2V5cywgZW5jb2RpbmdUeXBlcywgTUVUQURBVEFfRU5DT0RJTkdfS0VZIH0gZnJvbSAnLi90eXBlcyc7XG5cbi8qKlxuICogVXNlZCBieSB0aGUgZnJhbWV3b3JrIHRvIHNlcmlhbGl6ZS9kZXNlcmlhbGl6ZSBkYXRhIGxpa2UgcGFyYW1ldGVycyBhbmQgcmV0dXJuIHZhbHVlcy5cbiAqXG4gKiBUaGlzIGlzIGNhbGxlZCBpbnNpZGUgdGhlIHtAbGluayBodHRwczovL2RvY3MudGVtcG9yYWwuaW8vdHlwZXNjcmlwdC9kZXRlcm1pbmlzbSB8IFdvcmtmbG93IGlzb2xhdGV9LlxuICogVG8gd3JpdGUgYXN5bmMgY29kZSBvciB1c2UgTm9kZSBBUElzIChvciB1c2UgcGFja2FnZXMgdGhhdCB1c2UgTm9kZSBBUElzKSwgdXNlIGEge0BsaW5rIFBheWxvYWRDb2RlY30uXG4gKi9cbmV4cG9ydCBpbnRlcmZhY2UgUGF5bG9hZENvbnZlcnRlciB7XG4gIC8qKlxuICAgKiBDb252ZXJ0cyBhIHZhbHVlIHRvIGEge0BsaW5rIFBheWxvYWR9LlxuICAgKlxuICAgKiBAcGFyYW0gdmFsdWUgVGhlIHZhbHVlIHRvIGNvbnZlcnQuIEV4YW1wbGUgdmFsdWVzIGluY2x1ZGUgdGhlIFdvcmtmbG93IGFyZ3Mgc2VudCBmcm9tIHRoZSBDbGllbnQgYW5kIHRoZSB2YWx1ZXMgcmV0dXJuZWQgYnkgYSBXb3JrZmxvdyBvciBBY3Rpdml0eS5cbiAgICpcbiAgICogQHJldHVybnMgVGhlIHtAbGluayBQYXlsb2FkfS5cbiAgICpcbiAgICogU2hvdWxkIHRocm93IHtAbGluayBWYWx1ZUVycm9yfSBpZiB1bmFibGUgdG8gY29udmVydC5cbiAgICovXG4gIHRvUGF5bG9hZDxUPih2YWx1ZTogVCk6IFBheWxvYWQ7XG5cbiAgLyoqXG4gICAqIENvbnZlcnRzIGEge0BsaW5rIFBheWxvYWR9IGJhY2sgdG8gYSB2YWx1ZS5cbiAgICovXG4gIGZyb21QYXlsb2FkPFQ+KHBheWxvYWQ6IFBheWxvYWQpOiBUO1xufVxuXG4vKipcbiAqIEltcGxlbWVudHMgY29udmVyc2lvbiBvZiBhIGxpc3Qgb2YgdmFsdWVzLlxuICpcbiAqIEBwYXJhbSBjb252ZXJ0ZXJcbiAqIEBwYXJhbSB2YWx1ZXMgSlMgdmFsdWVzIHRvIGNvbnZlcnQgdG8gUGF5bG9hZHNcbiAqIEByZXR1cm4gbGlzdCBvZiB7QGxpbmsgUGF5bG9hZH1zXG4gKiBAdGhyb3dzIHtAbGluayBWYWx1ZUVycm9yfSBpZiBjb252ZXJzaW9uIG9mIHRoZSB2YWx1ZSBwYXNzZWQgYXMgcGFyYW1ldGVyIGZhaWxlZCBmb3IgYW55XG4gKiAgICAgcmVhc29uLlxuICovXG5leHBvcnQgZnVuY3Rpb24gdG9QYXlsb2Fkcyhjb252ZXJ0ZXI6IFBheWxvYWRDb252ZXJ0ZXIsIC4uLnZhbHVlczogdW5rbm93bltdKTogUGF5bG9hZFtdIHwgdW5kZWZpbmVkIHtcbiAgaWYgKHZhbHVlcy5sZW5ndGggPT09IDApIHtcbiAgICByZXR1cm4gdW5kZWZpbmVkO1xuICB9XG5cbiAgcmV0dXJuIHZhbHVlcy5tYXAoKHZhbHVlKSA9PiBjb252ZXJ0ZXIudG9QYXlsb2FkKHZhbHVlKSk7XG59XG5cbi8qKlxuICogUnVuIHtAbGluayBQYXlsb2FkQ29udmVydGVyLnRvUGF5bG9hZH0gb24gZWFjaCB2YWx1ZSBpbiB0aGUgbWFwLlxuICpcbiAqIEB0aHJvd3Mge0BsaW5rIFZhbHVlRXJyb3J9IGlmIGNvbnZlcnNpb24gb2YgYW55IHZhbHVlIGluIHRoZSBtYXAgZmFpbHNcbiAqL1xuZXhwb3J0IGZ1bmN0aW9uIG1hcFRvUGF5bG9hZHM8SyBleHRlbmRzIHN0cmluZz4oY29udmVydGVyOiBQYXlsb2FkQ29udmVydGVyLCBtYXA6IFJlY29yZDxLLCBhbnk+KTogUmVjb3JkPEssIFBheWxvYWQ+IHtcbiAgcmV0dXJuIE9iamVjdC5mcm9tRW50cmllcyhcbiAgICBPYmplY3QuZW50cmllcyhtYXApLm1hcCgoW2ssIHZdKTogW0ssIFBheWxvYWRdID0+IFtrIGFzIEssIGNvbnZlcnRlci50b1BheWxvYWQodildKVxuICApIGFzIFJlY29yZDxLLCBQYXlsb2FkPjtcbn1cblxuLyoqXG4gKiBJbXBsZW1lbnRzIGNvbnZlcnNpb24gb2YgYW4gYXJyYXkgb2YgdmFsdWVzIG9mIGRpZmZlcmVudCB0eXBlcy4gVXNlZnVsIGZvciBkZXNlcmlhbGl6aW5nXG4gKiBhcmd1bWVudHMgb2YgZnVuY3Rpb24gaW52b2NhdGlvbnMuXG4gKlxuICogQHBhcmFtIGNvbnZlcnRlclxuICogQHBhcmFtIGluZGV4IGluZGV4IG9mIHRoZSB2YWx1ZSBpbiB0aGUgcGF5bG9hZHNcbiAqIEBwYXJhbSBwYXlsb2FkcyBzZXJpYWxpemVkIHZhbHVlIHRvIGNvbnZlcnQgdG8gSlMgdmFsdWVzLlxuICogQHJldHVybiBjb252ZXJ0ZWQgSlMgdmFsdWVcbiAqIEB0aHJvd3Mge0BsaW5rIFBheWxvYWRDb252ZXJ0ZXJFcnJvcn0gaWYgY29udmVyc2lvbiBvZiB0aGUgZGF0YSBwYXNzZWQgYXMgcGFyYW1ldGVyIGZhaWxlZCBmb3IgYW55XG4gKiAgICAgcmVhc29uLlxuICovXG5leHBvcnQgZnVuY3Rpb24gZnJvbVBheWxvYWRzQXRJbmRleDxUPihjb252ZXJ0ZXI6IFBheWxvYWRDb252ZXJ0ZXIsIGluZGV4OiBudW1iZXIsIHBheWxvYWRzPzogUGF5bG9hZFtdIHwgbnVsbCk6IFQge1xuICAvLyBUbyBtYWtlIGFkZGluZyBhcmd1bWVudHMgYSBiYWNrd2FyZHMgY29tcGF0aWJsZSBjaGFuZ2VcbiAgaWYgKHBheWxvYWRzID09PSB1bmRlZmluZWQgfHwgcGF5bG9hZHMgPT09IG51bGwgfHwgaW5kZXggPj0gcGF5bG9hZHMubGVuZ3RoKSB7XG4gICAgcmV0dXJuIHVuZGVmaW5lZCBhcyBhbnk7XG4gIH1cbiAgcmV0dXJuIGNvbnZlcnRlci5mcm9tUGF5bG9hZChwYXlsb2Fkc1tpbmRleF0pO1xufVxuXG4vKipcbiAqIFJ1biB7QGxpbmsgUGF5bG9hZENvbnZlcnRlci5mcm9tUGF5bG9hZH0gb24gZWFjaCB2YWx1ZSBpbiB0aGUgYXJyYXkuXG4gKi9cbmV4cG9ydCBmdW5jdGlvbiBhcnJheUZyb21QYXlsb2Fkcyhjb252ZXJ0ZXI6IFBheWxvYWRDb252ZXJ0ZXIsIHBheWxvYWRzPzogUGF5bG9hZFtdIHwgbnVsbCk6IHVua25vd25bXSB7XG4gIGlmICghcGF5bG9hZHMpIHtcbiAgICByZXR1cm4gW107XG4gIH1cbiAgcmV0dXJuIHBheWxvYWRzLm1hcCgocGF5bG9hZDogUGF5bG9hZCkgPT4gY29udmVydGVyLmZyb21QYXlsb2FkKHBheWxvYWQpKTtcbn1cblxuZXhwb3J0IGZ1bmN0aW9uIG1hcEZyb21QYXlsb2FkczxLIGV4dGVuZHMgc3RyaW5nPihcbiAgY29udmVydGVyOiBQYXlsb2FkQ29udmVydGVyLFxuICBtYXA/OiBSZWNvcmQ8SywgUGF5bG9hZD4gfCBudWxsIHwgdW5kZWZpbmVkXG4pOiBSZWNvcmQ8SywgdW5rbm93bj4gfCB1bmRlZmluZWQgfCBudWxsIHtcbiAgaWYgKG1hcCA9PSBudWxsKSByZXR1cm4gbWFwO1xuICByZXR1cm4gT2JqZWN0LmZyb21FbnRyaWVzKFxuICAgIE9iamVjdC5lbnRyaWVzKG1hcCkubWFwKChbaywgcGF5bG9hZF0pOiBbSywgdW5rbm93bl0gPT4ge1xuICAgICAgY29uc3QgdmFsdWUgPSBjb252ZXJ0ZXIuZnJvbVBheWxvYWQocGF5bG9hZCBhcyBQYXlsb2FkKTtcbiAgICAgIHJldHVybiBbayBhcyBLLCB2YWx1ZV07XG4gICAgfSlcbiAgKSBhcyBSZWNvcmQ8SywgdW5rbm93bj47XG59XG5cbmV4cG9ydCBpbnRlcmZhY2UgUGF5bG9hZENvbnZlcnRlcldpdGhFbmNvZGluZyB7XG4gIC8qKlxuICAgKiBDb252ZXJ0cyBhIHZhbHVlIHRvIGEge0BsaW5rIFBheWxvYWR9LlxuICAgKlxuICAgKiBAcGFyYW0gdmFsdWUgVGhlIHZhbHVlIHRvIGNvbnZlcnQuIEV4YW1wbGUgdmFsdWVzIGluY2x1ZGUgdGhlIFdvcmtmbG93IGFyZ3Mgc2VudCBmcm9tIHRoZSBDbGllbnQgYW5kIHRoZSB2YWx1ZXMgcmV0dXJuZWQgYnkgYSBXb3JrZmxvdyBvciBBY3Rpdml0eS5cbiAgICogQHJldHVybnMgVGhlIHtAbGluayBQYXlsb2FkfSwgb3IgYHVuZGVmaW5lZGAgaWYgdW5hYmxlIHRvIGNvbnZlcnQuXG4gICAqL1xuICB0b1BheWxvYWQ8VD4odmFsdWU6IFQpOiBQYXlsb2FkIHwgdW5kZWZpbmVkO1xuXG4gIC8qKlxuICAgKiBDb252ZXJ0cyBhIHtAbGluayBQYXlsb2FkfSBiYWNrIHRvIGEgdmFsdWUuXG4gICAqL1xuICBmcm9tUGF5bG9hZDxUPihwYXlsb2FkOiBQYXlsb2FkKTogVDtcblxuICByZWFkb25seSBlbmNvZGluZ1R5cGU6IHN0cmluZztcbn1cblxuLyoqXG4gKiBUcmllcyB0byBjb252ZXJ0IHZhbHVlcyB0byB7QGxpbmsgUGF5bG9hZH1zIHVzaW5nIHRoZSB7QGxpbmsgUGF5bG9hZENvbnZlcnRlcldpdGhFbmNvZGluZ31zIHByb3ZpZGVkIHRvIHRoZSBjb25zdHJ1Y3RvciwgaW4gdGhlIG9yZGVyIHByb3ZpZGVkLlxuICpcbiAqIENvbnZlcnRzIFBheWxvYWRzIHRvIHZhbHVlcyBiYXNlZCBvbiB0aGUgYFBheWxvYWQubWV0YWRhdGEuZW5jb2RpbmdgIGZpZWxkLCB3aGljaCBtYXRjaGVzIHRoZSB7QGxpbmsgUGF5bG9hZENvbnZlcnRlcldpdGhFbmNvZGluZy5lbmNvZGluZ1R5cGV9XG4gKiBvZiB0aGUgY29udmVydGVyIHRoYXQgY3JlYXRlZCB0aGUgUGF5bG9hZC5cbiAqL1xuZXhwb3J0IGNsYXNzIENvbXBvc2l0ZVBheWxvYWRDb252ZXJ0ZXIgaW1wbGVtZW50cyBQYXlsb2FkQ29udmVydGVyIHtcbiAgcmVhZG9ubHkgY29udmVydGVyczogUGF5bG9hZENvbnZlcnRlcldpdGhFbmNvZGluZ1tdO1xuICByZWFkb25seSBjb252ZXJ0ZXJCeUVuY29kaW5nOiBNYXA8c3RyaW5nLCBQYXlsb2FkQ29udmVydGVyV2l0aEVuY29kaW5nPiA9IG5ldyBNYXAoKTtcblxuICBjb25zdHJ1Y3RvciguLi5jb252ZXJ0ZXJzOiBQYXlsb2FkQ29udmVydGVyV2l0aEVuY29kaW5nW10pIHtcbiAgICBpZiAoY29udmVydGVycy5sZW5ndGggPT09IDApIHtcbiAgICAgIHRocm93IG5ldyBQYXlsb2FkQ29udmVydGVyRXJyb3IoJ011c3QgcHJvdmlkZSBhdCBsZWFzdCBvbmUgUGF5bG9hZENvbnZlcnRlcldpdGhFbmNvZGluZycpO1xuICAgIH1cblxuICAgIHRoaXMuY29udmVydGVycyA9IGNvbnZlcnRlcnM7XG4gICAgZm9yIChjb25zdCBjb252ZXJ0ZXIgb2YgY29udmVydGVycykge1xuICAgICAgdGhpcy5jb252ZXJ0ZXJCeUVuY29kaW5nLnNldChjb252ZXJ0ZXIuZW5jb2RpbmdUeXBlLCBjb252ZXJ0ZXIpO1xuICAgIH1cbiAgfVxuXG4gIC8qKlxuICAgKiBUcmllcyB0byBydW4gYC50b1BheWxvYWQodmFsdWUpYCBvbiBlYWNoIGNvbnZlcnRlciBpbiB0aGUgb3JkZXIgcHJvdmlkZWQgYXQgY29uc3RydWN0aW9uLlxuICAgKiBSZXR1cm5zIHRoZSBmaXJzdCBzdWNjZXNzZnVsIHJlc3VsdCwgdGhyb3dzIHtAbGluayBWYWx1ZUVycm9yfSBpZiB0aGVyZSBpcyBubyBjb252ZXJ0ZXIgdGhhdCBjYW4gaGFuZGxlIHRoZSB2YWx1ZS5cbiAgICovXG4gIHB1YmxpYyB0b1BheWxvYWQ8VD4odmFsdWU6IFQpOiBQYXlsb2FkIHtcbiAgICBmb3IgKGNvbnN0IGNvbnZlcnRlciBvZiB0aGlzLmNvbnZlcnRlcnMpIHtcbiAgICAgIGNvbnN0IHJlc3VsdCA9IGNvbnZlcnRlci50b1BheWxvYWQodmFsdWUpO1xuICAgICAgaWYgKHJlc3VsdCAhPT0gdW5kZWZpbmVkKSB7XG4gICAgICAgIHJldHVybiByZXN1bHQ7XG4gICAgICB9XG4gICAgfVxuXG4gICAgdGhyb3cgbmV3IFZhbHVlRXJyb3IoYFVuYWJsZSB0byBjb252ZXJ0ICR7dmFsdWV9IHRvIHBheWxvYWRgKTtcbiAgfVxuXG4gIC8qKlxuICAgKiBSdW4ge0BsaW5rIFBheWxvYWRDb252ZXJ0ZXJXaXRoRW5jb2RpbmcuZnJvbVBheWxvYWR9IGJhc2VkIG9uIHRoZSBgZW5jb2RpbmdgIG1ldGFkYXRhIG9mIHRoZSB7QGxpbmsgUGF5bG9hZH0uXG4gICAqL1xuICBwdWJsaWMgZnJvbVBheWxvYWQ8VD4ocGF5bG9hZDogUGF5bG9hZCk6IFQge1xuICAgIGlmIChwYXlsb2FkLm1ldGFkYXRhID09PSB1bmRlZmluZWQgfHwgcGF5bG9hZC5tZXRhZGF0YSA9PT0gbnVsbCkge1xuICAgICAgdGhyb3cgbmV3IFZhbHVlRXJyb3IoJ01pc3NpbmcgcGF5bG9hZCBtZXRhZGF0YScpO1xuICAgIH1cbiAgICBjb25zdCBlbmNvZGluZyA9IGRlY29kZShwYXlsb2FkLm1ldGFkYXRhW01FVEFEQVRBX0VOQ09ESU5HX0tFWV0pO1xuICAgIGNvbnN0IGNvbnZlcnRlciA9IHRoaXMuY29udmVydGVyQnlFbmNvZGluZy5nZXQoZW5jb2RpbmcpO1xuICAgIGlmIChjb252ZXJ0ZXIgPT09IHVuZGVmaW5lZCkge1xuICAgICAgdGhyb3cgbmV3IFZhbHVlRXJyb3IoYFVua25vd24gZW5jb2Rpbmc6ICR7ZW5jb2Rpbmd9YCk7XG4gICAgfVxuICAgIHJldHVybiBjb252ZXJ0ZXIuZnJvbVBheWxvYWQocGF5bG9hZCk7XG4gIH1cbn1cblxuLyoqXG4gKiBDb252ZXJ0cyBiZXR3ZWVuIEpTIHVuZGVmaW5lZCBhbmQgTlVMTCBQYXlsb2FkXG4gKi9cbmV4cG9ydCBjbGFzcyBVbmRlZmluZWRQYXlsb2FkQ29udmVydGVyIGltcGxlbWVudHMgUGF5bG9hZENvbnZlcnRlcldpdGhFbmNvZGluZyB7XG4gIHB1YmxpYyBlbmNvZGluZ1R5cGUgPSBlbmNvZGluZ1R5cGVzLk1FVEFEQVRBX0VOQ09ESU5HX05VTEw7XG5cbiAgcHVibGljIHRvUGF5bG9hZCh2YWx1ZTogdW5rbm93bik6IFBheWxvYWQgfCB1bmRlZmluZWQge1xuICAgIGlmICh2YWx1ZSAhPT0gdW5kZWZpbmVkKSB7XG4gICAgICByZXR1cm4gdW5kZWZpbmVkO1xuICAgIH1cblxuICAgIHJldHVybiB7XG4gICAgICBtZXRhZGF0YToge1xuICAgICAgICBbTUVUQURBVEFfRU5DT0RJTkdfS0VZXTogZW5jb2RpbmdLZXlzLk1FVEFEQVRBX0VOQ09ESU5HX05VTEwsXG4gICAgICB9LFxuICAgIH07XG4gIH1cblxuICBwdWJsaWMgZnJvbVBheWxvYWQ8VD4oX2NvbnRlbnQ6IFBheWxvYWQpOiBUIHtcbiAgICByZXR1cm4gdW5kZWZpbmVkIGFzIGFueTsgLy8gSnVzdCByZXR1cm4gdW5kZWZpbmVkXG4gIH1cbn1cblxuLyoqXG4gKiBDb252ZXJ0cyBiZXR3ZWVuIGJpbmFyeSBkYXRhIHR5cGVzIGFuZCBSQVcgUGF5bG9hZFxuICovXG5leHBvcnQgY2xhc3MgQmluYXJ5UGF5bG9hZENvbnZlcnRlciBpbXBsZW1lbnRzIFBheWxvYWRDb252ZXJ0ZXJXaXRoRW5jb2Rpbmcge1xuICBwdWJsaWMgZW5jb2RpbmdUeXBlID0gZW5jb2RpbmdUeXBlcy5NRVRBREFUQV9FTkNPRElOR19SQVc7XG5cbiAgcHVibGljIHRvUGF5bG9hZCh2YWx1ZTogdW5rbm93bik6IFBheWxvYWQgfCB1bmRlZmluZWQge1xuICAgIGlmICghKHZhbHVlIGluc3RhbmNlb2YgVWludDhBcnJheSkpIHtcbiAgICAgIHJldHVybiB1bmRlZmluZWQ7XG4gICAgfVxuXG4gICAgcmV0dXJuIHtcbiAgICAgIG1ldGFkYXRhOiB7XG4gICAgICAgIFtNRVRBREFUQV9FTkNPRElOR19LRVldOiBlbmNvZGluZ0tleXMuTUVUQURBVEFfRU5DT0RJTkdfUkFXLFxuICAgICAgfSxcbiAgICAgIGRhdGE6IHZhbHVlLFxuICAgIH07XG4gIH1cblxuICBwdWJsaWMgZnJvbVBheWxvYWQ8VD4oY29udGVudDogUGF5bG9hZCk6IFQge1xuICAgIHJldHVybiAoXG4gICAgICAvLyBXcmFwIHdpdGggVWludDhBcnJheSBmcm9tIHRoaXMgY29udGV4dCB0byBlbnN1cmUgYGluc3RhbmNlb2ZgIHdvcmtzXG4gICAgICAoXG4gICAgICAgIGNvbnRlbnQuZGF0YSA/IG5ldyBVaW50OEFycmF5KGNvbnRlbnQuZGF0YS5idWZmZXIsIGNvbnRlbnQuZGF0YS5ieXRlT2Zmc2V0LCBjb250ZW50LmRhdGEubGVuZ3RoKSA6IGNvbnRlbnQuZGF0YVxuICAgICAgKSBhcyBhbnlcbiAgICApO1xuICB9XG59XG5cbi8qKlxuICogQ29udmVydHMgYmV0d2VlbiBub24tdW5kZWZpbmVkIHZhbHVlcyBhbmQgc2VyaWFsaXplZCBKU09OIFBheWxvYWRcbiAqL1xuZXhwb3J0IGNsYXNzIEpzb25QYXlsb2FkQ29udmVydGVyIGltcGxlbWVudHMgUGF5bG9hZENvbnZlcnRlcldpdGhFbmNvZGluZyB7XG4gIHB1YmxpYyBlbmNvZGluZ1R5cGUgPSBlbmNvZGluZ1R5cGVzLk1FVEFEQVRBX0VOQ09ESU5HX0pTT047XG5cbiAgcHVibGljIHRvUGF5bG9hZCh2YWx1ZTogdW5rbm93bik6IFBheWxvYWQgfCB1bmRlZmluZWQge1xuICAgIGlmICh2YWx1ZSA9PT0gdW5kZWZpbmVkKSB7XG4gICAgICByZXR1cm4gdW5kZWZpbmVkO1xuICAgIH1cblxuICAgIGxldCBqc29uO1xuICAgIHRyeSB7XG4gICAgICBqc29uID0gSlNPTi5zdHJpbmdpZnkodmFsdWUpO1xuICAgIH0gY2F0Y2ggKGVycikge1xuICAgICAgcmV0dXJuIHVuZGVmaW5lZDtcbiAgICB9XG5cbiAgICByZXR1cm4ge1xuICAgICAgbWV0YWRhdGE6IHtcbiAgICAgICAgW01FVEFEQVRBX0VOQ09ESU5HX0tFWV06IGVuY29kaW5nS2V5cy5NRVRBREFUQV9FTkNPRElOR19KU09OLFxuICAgICAgfSxcbiAgICAgIGRhdGE6IGVuY29kZShqc29uKSxcbiAgICB9O1xuICB9XG5cbiAgcHVibGljIGZyb21QYXlsb2FkPFQ+KGNvbnRlbnQ6IFBheWxvYWQpOiBUIHtcbiAgICBpZiAoY29udGVudC5kYXRhID09PSB1bmRlZmluZWQgfHwgY29udGVudC5kYXRhID09PSBudWxsKSB7XG4gICAgICB0aHJvdyBuZXcgVmFsdWVFcnJvcignR290IHBheWxvYWQgd2l0aCBubyBkYXRhJyk7XG4gICAgfVxuICAgIHJldHVybiBKU09OLnBhcnNlKGRlY29kZShjb250ZW50LmRhdGEpKTtcbiAgfVxufVxuXG4vKipcbiAqIENvbnZlcnRzIFNlYXJjaCBBdHRyaWJ1dGUgdmFsdWVzIHVzaW5nIEpzb25QYXlsb2FkQ29udmVydGVyXG4gKi9cbmV4cG9ydCBjbGFzcyBTZWFyY2hBdHRyaWJ1dGVQYXlsb2FkQ29udmVydGVyIGltcGxlbWVudHMgUGF5bG9hZENvbnZlcnRlciB7XG4gIGpzb25Db252ZXJ0ZXIgPSBuZXcgSnNvblBheWxvYWRDb252ZXJ0ZXIoKTtcbiAgdmFsaWROb25EYXRlVHlwZXMgPSBbJ3N0cmluZycsICdudW1iZXInLCAnYm9vbGVhbiddO1xuXG4gIHB1YmxpYyB0b1BheWxvYWQodmFsdWVzOiB1bmtub3duKTogUGF5bG9hZCB7XG4gICAgaWYgKCFBcnJheS5pc0FycmF5KHZhbHVlcykpIHtcbiAgICAgIHRocm93IG5ldyBWYWx1ZUVycm9yKGBTZWFyY2hBdHRyaWJ1dGUgdmFsdWUgbXVzdCBiZSBhbiBhcnJheWApO1xuICAgIH1cblxuICAgIGlmICh2YWx1ZXMubGVuZ3RoID4gMCkge1xuICAgICAgY29uc3QgZmlyc3RWYWx1ZSA9IHZhbHVlc1swXTtcbiAgICAgIGNvbnN0IGZpcnN0VHlwZSA9IHR5cGVvZiBmaXJzdFZhbHVlO1xuICAgICAgaWYgKGZpcnN0VHlwZSA9PT0gJ29iamVjdCcpIHtcbiAgICAgICAgZm9yIChjb25zdCBbaWR4LCB2YWx1ZV0gb2YgdmFsdWVzLmVudHJpZXMoKSkge1xuICAgICAgICAgIGlmICghKHZhbHVlIGluc3RhbmNlb2YgRGF0ZSkpIHtcbiAgICAgICAgICAgIHRocm93IG5ldyBWYWx1ZUVycm9yKFxuICAgICAgICAgICAgICBgU2VhcmNoQXR0cmlidXRlIHZhbHVlcyBtdXN0IGFycmF5cyBvZiBzdHJpbmdzLCBudW1iZXJzLCBib29sZWFucywgb3IgRGF0ZXMuIFRoZSB2YWx1ZSAke3ZhbHVlfSBhdCBpbmRleCAke2lkeH0gaXMgb2YgdHlwZSAke3R5cGVvZiB2YWx1ZX1gXG4gICAgICAgICAgICApO1xuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgfSBlbHNlIHtcbiAgICAgICAgaWYgKCF0aGlzLnZhbGlkTm9uRGF0ZVR5cGVzLmluY2x1ZGVzKGZpcnN0VHlwZSkpIHtcbiAgICAgICAgICB0aHJvdyBuZXcgVmFsdWVFcnJvcihgU2VhcmNoQXR0cmlidXRlIGFycmF5IHZhbHVlcyBtdXN0IGJlOiBzdHJpbmcgfCBudW1iZXIgfCBib29sZWFuIHwgRGF0ZWApO1xuICAgICAgICB9XG5cbiAgICAgICAgZm9yIChjb25zdCBbaWR4LCB2YWx1ZV0gb2YgdmFsdWVzLmVudHJpZXMoKSkge1xuICAgICAgICAgIGlmICh0eXBlb2YgdmFsdWUgIT09IGZpcnN0VHlwZSkge1xuICAgICAgICAgICAgdGhyb3cgbmV3IFZhbHVlRXJyb3IoXG4gICAgICAgICAgICAgIGBBbGwgU2VhcmNoQXR0cmlidXRlIGFycmF5IHZhbHVlcyBtdXN0IGJlIG9mIHRoZSBzYW1lIHR5cGUuIFRoZSBmaXJzdCB2YWx1ZSAke2ZpcnN0VmFsdWV9IG9mIHR5cGUgJHtmaXJzdFR5cGV9IGRvZXNuJ3QgbWF0Y2ggdmFsdWUgJHt2YWx1ZX0gb2YgdHlwZSAke3R5cGVvZiB2YWx1ZX0gYXQgaW5kZXggJHtpZHh9YFxuICAgICAgICAgICAgKTtcbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9XG5cbiAgICAvLyBKU09OLnN0cmluZ2lmeSB0YWtlcyBjYXJlIG9mIGNvbnZlcnRpbmcgRGF0ZXMgdG8gSVNPIHN0cmluZ3NcbiAgICBjb25zdCByZXQgPSB0aGlzLmpzb25Db252ZXJ0ZXIudG9QYXlsb2FkKHZhbHVlcyk7XG4gICAgaWYgKHJldCA9PT0gdW5kZWZpbmVkKSB7XG4gICAgICB0aHJvdyBuZXcgVmFsdWVFcnJvcignQ291bGQgbm90IGNvbnZlcnQgc2VhcmNoIGF0dHJpYnV0ZXMgdG8gcGF5bG9hZHMnKTtcbiAgICB9XG4gICAgcmV0dXJuIHJldDtcbiAgfVxuXG4gIC8qKlxuICAgKiBEYXRldGltZSBTZWFyY2ggQXR0cmlidXRlIHZhbHVlcyBhcmUgY29udmVydGVkIHRvIGBEYXRlYHNcbiAgICovXG4gIHB1YmxpYyBmcm9tUGF5bG9hZDxUPihwYXlsb2FkOiBQYXlsb2FkKTogVCB7XG4gICAgaWYgKHBheWxvYWQubWV0YWRhdGEgPT09IHVuZGVmaW5lZCB8fCBwYXlsb2FkLm1ldGFkYXRhID09PSBudWxsKSB7XG4gICAgICB0aHJvdyBuZXcgVmFsdWVFcnJvcignTWlzc2luZyBwYXlsb2FkIG1ldGFkYXRhJyk7XG4gICAgfVxuXG4gICAgY29uc3QgdmFsdWUgPSB0aGlzLmpzb25Db252ZXJ0ZXIuZnJvbVBheWxvYWQocGF5bG9hZCk7XG4gICAgbGV0IGFycmF5V3JhcHBlZFZhbHVlID0gQXJyYXkuaXNBcnJheSh2YWx1ZSkgPyB2YWx1ZSA6IFt2YWx1ZV07XG5cbiAgICBjb25zdCBzZWFyY2hBdHRyaWJ1dGVUeXBlID0gZGVjb2RlKHBheWxvYWQubWV0YWRhdGEudHlwZSk7XG4gICAgaWYgKHNlYXJjaEF0dHJpYnV0ZVR5cGUgPT09ICdEYXRldGltZScpIHtcbiAgICAgIGFycmF5V3JhcHBlZFZhbHVlID0gYXJyYXlXcmFwcGVkVmFsdWUubWFwKChkYXRlU3RyaW5nKSA9PiBuZXcgRGF0ZShkYXRlU3RyaW5nKSk7XG4gICAgfVxuICAgIHJldHVybiBhcnJheVdyYXBwZWRWYWx1ZSBhcyB1bmtub3duIGFzIFQ7XG4gIH1cbn1cblxuZXhwb3J0IGNvbnN0IHNlYXJjaEF0dHJpYnV0ZVBheWxvYWRDb252ZXJ0ZXIgPSBuZXcgU2VhcmNoQXR0cmlidXRlUGF5bG9hZENvbnZlcnRlcigpO1xuXG5leHBvcnQgY2xhc3MgRGVmYXVsdFBheWxvYWRDb252ZXJ0ZXIgZXh0ZW5kcyBDb21wb3NpdGVQYXlsb2FkQ29udmVydGVyIHtcbiAgLy8gTWF0Y2ggdGhlIG9yZGVyIHVzZWQgaW4gb3RoZXIgU0RLcywgYnV0IGV4Y2x1ZGUgUHJvdG9idWYgY29udmVydGVycyBzbyB0aGF0IHRoZSBjb2RlLCBpbmNsdWRpbmdcbiAgLy8gYHByb3RvMy1qc29uLXNlcmlhbGl6ZXJgLCBkb2Vzbid0IHRha2Ugc3BhY2UgaW4gV29ya2Zsb3cgYnVuZGxlcyB0aGF0IGRvbid0IHVzZSBQcm90b2J1ZnMuIFRvIHVzZSBQcm90b2J1ZnMsIHVzZVxuICAvLyB7QGxpbmsgRGVmYXVsdFBheWxvYWRDb252ZXJ0ZXJXaXRoUHJvdG9idWZzfS5cbiAgLy9cbiAgLy8gR28gU0RLOlxuICAvLyBodHRwczovL2dpdGh1Yi5jb20vdGVtcG9yYWxpby9zZGstZ28vYmxvYi81ZTU2NDVmMGM1NTBkY2Y3MTdjMDk1YWUzMmM3NmE3MDg3ZDJlOTg1L2NvbnZlcnRlci9kZWZhdWx0X2RhdGFfY29udmVydGVyLmdvI0wyOFxuICBjb25zdHJ1Y3RvcigpIHtcbiAgICBzdXBlcihuZXcgVW5kZWZpbmVkUGF5bG9hZENvbnZlcnRlcigpLCBuZXcgQmluYXJ5UGF5bG9hZENvbnZlcnRlcigpLCBuZXcgSnNvblBheWxvYWRDb252ZXJ0ZXIoKSk7XG4gIH1cbn1cblxuLyoqXG4gKiBUaGUgZGVmYXVsdCB7QGxpbmsgUGF5bG9hZENvbnZlcnRlcn0gdXNlZCBieSB0aGUgU0RLLiBTdXBwb3J0cyBgVWludDhBcnJheWAgYW5kIEpTT04gc2VyaWFsaXphYmxlcyAoc28gaWZcbiAqIHtAbGluayBodHRwczovL2RldmVsb3Blci5tb3ppbGxhLm9yZy9lbi1VUy9kb2NzL1dlYi9KYXZhU2NyaXB0L1JlZmVyZW5jZS9HbG9iYWxfT2JqZWN0cy9KU09OL3N0cmluZ2lmeSNkZXNjcmlwdGlvbiB8IGBKU09OLnN0cmluZ2lmeSh5b3VyQXJnT3JSZXR2YWwpYH1cbiAqIHdvcmtzLCB0aGUgZGVmYXVsdCBwYXlsb2FkIGNvbnZlcnRlciB3aWxsIHdvcmspLlxuICpcbiAqIFRvIGFsc28gc3VwcG9ydCBQcm90b2J1ZnMsIGNyZWF0ZSBhIGN1c3RvbSBwYXlsb2FkIGNvbnZlcnRlciB3aXRoIHtAbGluayBEZWZhdWx0UGF5bG9hZENvbnZlcnRlcn06XG4gKlxuICogYGNvbnN0IG15Q29udmVydGVyID0gbmV3IERlZmF1bHRQYXlsb2FkQ29udmVydGVyKHsgcHJvdG9idWZSb290IH0pYFxuICovXG5leHBvcnQgY29uc3QgZGVmYXVsdFBheWxvYWRDb252ZXJ0ZXIgPSBuZXcgRGVmYXVsdFBheWxvYWRDb252ZXJ0ZXIoKTtcbiIsImltcG9ydCB7IGVuY29kZSB9IGZyb20gJy4uL2VuY29kaW5nJztcblxuZXhwb3J0IGNvbnN0IE1FVEFEQVRBX0VOQ09ESU5HX0tFWSA9ICdlbmNvZGluZyc7XG5leHBvcnQgY29uc3QgZW5jb2RpbmdUeXBlcyA9IHtcbiAgTUVUQURBVEFfRU5DT0RJTkdfTlVMTDogJ2JpbmFyeS9udWxsJyxcbiAgTUVUQURBVEFfRU5DT0RJTkdfUkFXOiAnYmluYXJ5L3BsYWluJyxcbiAgTUVUQURBVEFfRU5DT0RJTkdfSlNPTjogJ2pzb24vcGxhaW4nLFxuICBNRVRBREFUQV9FTkNPRElOR19QUk9UT0JVRl9KU09OOiAnanNvbi9wcm90b2J1ZicsXG4gIE1FVEFEQVRBX0VOQ09ESU5HX1BST1RPQlVGOiAnYmluYXJ5L3Byb3RvYnVmJyxcbn0gYXMgY29uc3Q7XG5leHBvcnQgdHlwZSBFbmNvZGluZ1R5cGUgPSAodHlwZW9mIGVuY29kaW5nVHlwZXMpW2tleW9mIHR5cGVvZiBlbmNvZGluZ1R5cGVzXTtcblxuZXhwb3J0IGNvbnN0IGVuY29kaW5nS2V5cyA9IHtcbiAgTUVUQURBVEFfRU5DT0RJTkdfTlVMTDogZW5jb2RlKGVuY29kaW5nVHlwZXMuTUVUQURBVEFfRU5DT0RJTkdfTlVMTCksXG4gIE1FVEFEQVRBX0VOQ09ESU5HX1JBVzogZW5jb2RlKGVuY29kaW5nVHlwZXMuTUVUQURBVEFfRU5DT0RJTkdfUkFXKSxcbiAgTUVUQURBVEFfRU5DT0RJTkdfSlNPTjogZW5jb2RlKGVuY29kaW5nVHlwZXMuTUVUQURBVEFfRU5DT0RJTkdfSlNPTiksXG4gIE1FVEFEQVRBX0VOQ09ESU5HX1BST1RPQlVGX0pTT046IGVuY29kZShlbmNvZGluZ1R5cGVzLk1FVEFEQVRBX0VOQ09ESU5HX1BST1RPQlVGX0pTT04pLFxuICBNRVRBREFUQV9FTkNPRElOR19QUk9UT0JVRjogZW5jb2RlKGVuY29kaW5nVHlwZXMuTUVUQURBVEFfRU5DT0RJTkdfUFJPVE9CVUYpLFxufSBhcyBjb25zdDtcblxuZXhwb3J0IGNvbnN0IE1FVEFEQVRBX01FU1NBR0VfVFlQRV9LRVkgPSAnbWVzc2FnZVR5cGUnO1xuIiwiaW1wb3J0ICogYXMgdGltZSBmcm9tICcuL3RpbWUnO1xuaW1wb3J0IHsgdHlwZSBUaW1lc3RhbXAsIER1cmF0aW9uIH0gZnJvbSAnLi90aW1lJztcblxuLyoqXG4gKiBMb3NzeSBjb252ZXJzaW9uIGZ1bmN0aW9uIGZyb20gVGltZXN0YW1wIHRvIG51bWJlciBkdWUgdG8gcG9zc2libGUgb3ZlcmZsb3cuXG4gKiBJZiB0cyBpcyBudWxsIG9yIHVuZGVmaW5lZCByZXR1cm5zIHVuZGVmaW5lZC5cbiAqXG4gKiBAaGlkZGVuXG4gKiBAZGVwcmVjYXRlZCAtIG1lYW50IGZvciBpbnRlcm5hbCB1c2Ugb25seVxuICovXG5leHBvcnQgZnVuY3Rpb24gb3B0aW9uYWxUc1RvTXModHM6IFRpbWVzdGFtcCB8IG51bGwgfCB1bmRlZmluZWQpOiBudW1iZXIgfCB1bmRlZmluZWQge1xuICByZXR1cm4gdGltZS5vcHRpb25hbFRzVG9Ncyh0cyk7XG59XG5cbi8qKlxuICogTG9zc3kgY29udmVyc2lvbiBmdW5jdGlvbiBmcm9tIFRpbWVzdGFtcCB0byBudW1iZXIgZHVlIHRvIHBvc3NpYmxlIG92ZXJmbG93XG4gKlxuICogQGhpZGRlblxuICogQGRlcHJlY2F0ZWQgLSBtZWFudCBmb3IgaW50ZXJuYWwgdXNlIG9ubHlcbiAqIEBkZXByZWNhdGVkIC0gbWVhbnQgZm9yIGludGVybmFsIHVzZSBvbmx5XG4gKi9cbmV4cG9ydCBmdW5jdGlvbiB0c1RvTXModHM6IFRpbWVzdGFtcCB8IG51bGwgfCB1bmRlZmluZWQpOiBudW1iZXIge1xuICByZXR1cm4gdGltZS50c1RvTXModHMpO1xufVxuXG4vKipcbiAqIEBoaWRkZW5cbiAqIEBkZXByZWNhdGVkIC0gbWVhbnQgZm9yIGludGVybmFsIHVzZSBvbmx5XG4gKi9cbmV4cG9ydCBmdW5jdGlvbiBtc051bWJlclRvVHMobWlsbGlzOiBudW1iZXIpOiBUaW1lc3RhbXAge1xuICByZXR1cm4gdGltZS5tc051bWJlclRvVHMobWlsbGlzKTtcbn1cblxuLyoqXG4gKiBAaGlkZGVuXG4gKiBAZGVwcmVjYXRlZCAtIG1lYW50IGZvciBpbnRlcm5hbCB1c2Ugb25seVxuICovXG5leHBvcnQgZnVuY3Rpb24gbXNUb1RzKHN0cjogRHVyYXRpb24pOiBUaW1lc3RhbXAge1xuICByZXR1cm4gdGltZS5tc1RvVHMoc3RyKTtcbn1cblxuLyoqXG4gKiBAaGlkZGVuXG4gKiBAZGVwcmVjYXRlZCAtIG1lYW50IGZvciBpbnRlcm5hbCB1c2Ugb25seVxuICovXG5leHBvcnQgZnVuY3Rpb24gbXNPcHRpb25hbFRvVHMoc3RyOiBEdXJhdGlvbiB8IHVuZGVmaW5lZCk6IFRpbWVzdGFtcCB8IHVuZGVmaW5lZCB7XG4gIHJldHVybiB0aW1lLm1zT3B0aW9uYWxUb1RzKHN0cik7XG59XG5cbi8qKlxuICogQGhpZGRlblxuICogQGRlcHJlY2F0ZWQgLSBtZWFudCBmb3IgaW50ZXJuYWwgdXNlIG9ubHlcbiAqL1xuZXhwb3J0IGZ1bmN0aW9uIG1zT3B0aW9uYWxUb051bWJlcih2YWw6IER1cmF0aW9uIHwgdW5kZWZpbmVkKTogbnVtYmVyIHwgdW5kZWZpbmVkIHtcbiAgcmV0dXJuIHRpbWUubXNPcHRpb25hbFRvTnVtYmVyKHZhbCk7XG59XG5cbi8qKlxuICogQGhpZGRlblxuICogQGRlcHJlY2F0ZWQgLSBtZWFudCBmb3IgaW50ZXJuYWwgdXNlIG9ubHlcbiAqL1xuZXhwb3J0IGZ1bmN0aW9uIG1zVG9OdW1iZXIodmFsOiBEdXJhdGlvbik6IG51bWJlciB7XG4gIHJldHVybiB0aW1lLm1zVG9OdW1iZXIodmFsKTtcbn1cblxuLyoqXG4gKiBAaGlkZGVuXG4gKiBAZGVwcmVjYXRlZCAtIG1lYW50IGZvciBpbnRlcm5hbCB1c2Ugb25seVxuICovXG5leHBvcnQgZnVuY3Rpb24gdHNUb0RhdGUodHM6IFRpbWVzdGFtcCk6IERhdGUge1xuICByZXR1cm4gdGltZS50c1RvRGF0ZSh0cyk7XG59XG5cbi8qKlxuICogQGhpZGRlblxuICogQGRlcHJlY2F0ZWQgLSBtZWFudCBmb3IgaW50ZXJuYWwgdXNlIG9ubHlcbiAqL1xuZXhwb3J0IGZ1bmN0aW9uIG9wdGlvbmFsVHNUb0RhdGUodHM6IFRpbWVzdGFtcCB8IG51bGwgfCB1bmRlZmluZWQpOiBEYXRlIHwgdW5kZWZpbmVkIHtcbiAgcmV0dXJuIHRpbWUub3B0aW9uYWxUc1RvRGF0ZSh0cyk7XG59XG4iLCIvLyBQYXN0ZWQgd2l0aCBtb2RpZmljYXRpb25zIGZyb206IGh0dHBzOi8vcmF3LmdpdGh1YnVzZXJjb250ZW50LmNvbS9hbm9ueWNvL0Zhc3Rlc3RTbWFsbGVzdFRleHRFbmNvZGVyRGVjb2Rlci9tYXN0ZXIvRW5jb2RlckRlY29kZXJUb2dldGhlci5zcmMuanNcbi8qIGVzbGludCBuby1mYWxsdGhyb3VnaDogMCAqL1xuXG5jb25zdCBmcm9tQ2hhckNvZGUgPSBTdHJpbmcuZnJvbUNoYXJDb2RlO1xuY29uc3QgZW5jb2RlclJlZ2V4cCA9IC9bXFx4ODAtXFx1RDdmZlxcdURDMDAtXFx1RkZGRl18W1xcdUQ4MDAtXFx1REJGRl1bXFx1REMwMC1cXHVERkZGXT8vZztcbmNvbnN0IHRtcEJ1ZmZlclUxNiA9IG5ldyBVaW50MTZBcnJheSgzMik7XG5cbmV4cG9ydCBjbGFzcyBUZXh0RGVjb2RlciB7XG4gIGRlY29kZShpbnB1dEFycmF5T3JCdWZmZXI6IFVpbnQ4QXJyYXkgfCBBcnJheUJ1ZmZlciB8IFNoYXJlZEFycmF5QnVmZmVyKTogc3RyaW5nIHtcbiAgICBjb25zdCBpbnB1dEFzOCA9IGlucHV0QXJyYXlPckJ1ZmZlciBpbnN0YW5jZW9mIFVpbnQ4QXJyYXkgPyBpbnB1dEFycmF5T3JCdWZmZXIgOiBuZXcgVWludDhBcnJheShpbnB1dEFycmF5T3JCdWZmZXIpO1xuXG4gICAgbGV0IHJlc3VsdGluZ1N0cmluZyA9ICcnLFxuICAgICAgdG1wU3RyID0gJycsXG4gICAgICBpbmRleCA9IDAsXG4gICAgICBuZXh0RW5kID0gMCxcbiAgICAgIGNwMCA9IDAsXG4gICAgICBjb2RlUG9pbnQgPSAwLFxuICAgICAgbWluQml0cyA9IDAsXG4gICAgICBjcDEgPSAwLFxuICAgICAgcG9zID0gMCxcbiAgICAgIHRtcCA9IC0xO1xuICAgIGNvbnN0IGxlbiA9IGlucHV0QXM4Lmxlbmd0aCB8IDA7XG4gICAgY29uc3QgbGVuTWludXMzMiA9IChsZW4gLSAzMikgfCAwO1xuICAgIC8vIE5vdGUgdGhhdCB0bXAgcmVwcmVzZW50cyB0aGUgMm5kIGhhbGYgb2YgYSBzdXJyb2dhdGUgcGFpciBpbmNhc2UgYSBzdXJyb2dhdGUgZ2V0cyBkaXZpZGVkIGJldHdlZW4gYmxvY2tzXG4gICAgZm9yICg7IGluZGV4IDwgbGVuOyApIHtcbiAgICAgIG5leHRFbmQgPSBpbmRleCA8PSBsZW5NaW51czMyID8gMzIgOiAobGVuIC0gaW5kZXgpIHwgMDtcbiAgICAgIGZvciAoOyBwb3MgPCBuZXh0RW5kOyBpbmRleCA9IChpbmRleCArIDEpIHwgMCwgcG9zID0gKHBvcyArIDEpIHwgMCkge1xuICAgICAgICBjcDAgPSBpbnB1dEFzOFtpbmRleF0gJiAweGZmO1xuICAgICAgICBzd2l0Y2ggKGNwMCA+PiA0KSB7XG4gICAgICAgICAgY2FzZSAxNTpcbiAgICAgICAgICAgIGNwMSA9IGlucHV0QXM4WyhpbmRleCA9IChpbmRleCArIDEpIHwgMCldICYgMHhmZjtcbiAgICAgICAgICAgIGlmIChjcDEgPj4gNiAhPT0gMGIxMCB8fCAwYjExMTEwMTExIDwgY3AwKSB7XG4gICAgICAgICAgICAgIGluZGV4ID0gKGluZGV4IC0gMSkgfCAwO1xuICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGNvZGVQb2ludCA9ICgoY3AwICYgMGIxMTEpIDw8IDYpIHwgKGNwMSAmIDBiMDAxMTExMTEpO1xuICAgICAgICAgICAgbWluQml0cyA9IDU7IC8vIDIwIGVuc3VyZXMgaXQgbmV2ZXIgcGFzc2VzIC0+IGFsbCBpbnZhbGlkIHJlcGxhY2VtZW50c1xuICAgICAgICAgICAgY3AwID0gMHgxMDA7IC8vICBrZWVwIHRyYWNrIG9mIHRoIGJpdCBzaXplXG4gICAgICAgICAgY2FzZSAxNDpcbiAgICAgICAgICAgIGNwMSA9IGlucHV0QXM4WyhpbmRleCA9IChpbmRleCArIDEpIHwgMCldICYgMHhmZjtcbiAgICAgICAgICAgIGNvZGVQb2ludCA8PD0gNjtcbiAgICAgICAgICAgIGNvZGVQb2ludCB8PSAoKGNwMCAmIDBiMTExMSkgPDwgNikgfCAoY3AxICYgMGIwMDExMTExMSk7XG4gICAgICAgICAgICBtaW5CaXRzID0gY3AxID4+IDYgPT09IDBiMTAgPyAobWluQml0cyArIDQpIHwgMCA6IDI0OyAvLyAyNCBlbnN1cmVzIGl0IG5ldmVyIHBhc3NlcyAtPiBhbGwgaW52YWxpZCByZXBsYWNlbWVudHNcbiAgICAgICAgICAgIGNwMCA9IChjcDAgKyAweDEwMCkgJiAweDMwMDsgLy8ga2VlcCB0cmFjayBvZiB0aCBiaXQgc2l6ZVxuICAgICAgICAgIGNhc2UgMTM6XG4gICAgICAgICAgY2FzZSAxMjpcbiAgICAgICAgICAgIGNwMSA9IGlucHV0QXM4WyhpbmRleCA9IChpbmRleCArIDEpIHwgMCldICYgMHhmZjtcbiAgICAgICAgICAgIGNvZGVQb2ludCA8PD0gNjtcbiAgICAgICAgICAgIGNvZGVQb2ludCB8PSAoKGNwMCAmIDBiMTExMTEpIDw8IDYpIHwgKGNwMSAmIDBiMDAxMTExMTEpO1xuICAgICAgICAgICAgbWluQml0cyA9IChtaW5CaXRzICsgNykgfCAwO1xuXG4gICAgICAgICAgICAvLyBOb3csIHByb2Nlc3MgdGhlIGNvZGUgcG9pbnRcbiAgICAgICAgICAgIGlmIChpbmRleCA8IGxlbiAmJiBjcDEgPj4gNiA9PT0gMGIxMCAmJiBjb2RlUG9pbnQgPj4gbWluQml0cyAmJiBjb2RlUG9pbnQgPCAweDExMDAwMCkge1xuICAgICAgICAgICAgICBjcDAgPSBjb2RlUG9pbnQ7XG4gICAgICAgICAgICAgIGNvZGVQb2ludCA9IChjb2RlUG9pbnQgLSAweDEwMDAwKSB8IDA7XG4gICAgICAgICAgICAgIGlmICgwIDw9IGNvZGVQb2ludCAvKjB4ZmZmZiA8IGNvZGVQb2ludCovKSB7XG4gICAgICAgICAgICAgICAgLy8gQk1QIGNvZGUgcG9pbnRcbiAgICAgICAgICAgICAgICAvL25leHRFbmQgPSBuZXh0RW5kIC0gMXwwO1xuXG4gICAgICAgICAgICAgICAgdG1wID0gKChjb2RlUG9pbnQgPj4gMTApICsgMHhkODAwKSB8IDA7IC8vIGhpZ2hTdXJyb2dhdGVcbiAgICAgICAgICAgICAgICBjcDAgPSAoKGNvZGVQb2ludCAmIDB4M2ZmKSArIDB4ZGMwMCkgfCAwOyAvLyBsb3dTdXJyb2dhdGUgKHdpbGwgYmUgaW5zZXJ0ZWQgbGF0ZXIgaW4gdGhlIHN3aXRjaC1zdGF0ZW1lbnQpXG5cbiAgICAgICAgICAgICAgICBpZiAocG9zIDwgMzEpIHtcbiAgICAgICAgICAgICAgICAgIC8vIG5vdGljZSAzMSBpbnN0ZWFkIG9mIDMyXG4gICAgICAgICAgICAgICAgICB0bXBCdWZmZXJVMTZbcG9zXSA9IHRtcDtcbiAgICAgICAgICAgICAgICAgIHBvcyA9IChwb3MgKyAxKSB8IDA7XG4gICAgICAgICAgICAgICAgICB0bXAgPSAtMTtcbiAgICAgICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgICAgLy8gZWxzZSwgd2UgYXJlIGF0IHRoZSBlbmQgb2YgdGhlIGlucHV0QXM4IGFuZCBsZXQgdG1wMCBiZSBmaWxsZWQgaW4gbGF0ZXIgb25cbiAgICAgICAgICAgICAgICAgIC8vIE5PVEUgdGhhdCBjcDEgaXMgYmVpbmcgdXNlZCBhcyBhIHRlbXBvcmFyeSB2YXJpYWJsZSBmb3IgdGhlIHN3YXBwaW5nIG9mIHRtcCB3aXRoIGNwMFxuICAgICAgICAgICAgICAgICAgY3AxID0gdG1wO1xuICAgICAgICAgICAgICAgICAgdG1wID0gY3AwO1xuICAgICAgICAgICAgICAgICAgY3AwID0gY3AxO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgfSBlbHNlIG5leHRFbmQgPSAobmV4dEVuZCArIDEpIHwgMDsgLy8gYmVjYXVzZSB3ZSBhcmUgYWR2YW5jaW5nIGkgd2l0aG91dCBhZHZhbmNpbmcgcG9zXG4gICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAvLyBpbnZhbGlkIGNvZGUgcG9pbnQgbWVhbnMgcmVwbGFjaW5nIHRoZSB3aG9sZSB0aGluZyB3aXRoIG51bGwgcmVwbGFjZW1lbnQgY2hhcmFjdGVyc1xuICAgICAgICAgICAgICBjcDAgPj49IDg7XG4gICAgICAgICAgICAgIGluZGV4ID0gKGluZGV4IC0gY3AwIC0gMSkgfCAwOyAvLyByZXNldCBpbmRleCAgYmFjayB0byB3aGF0IGl0IHdhcyBiZWZvcmVcbiAgICAgICAgICAgICAgY3AwID0gMHhmZmZkO1xuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAvLyBGaW5hbGx5LCByZXNldCB0aGUgdmFyaWFibGVzIGZvciB0aGUgbmV4dCBnby1hcm91bmRcbiAgICAgICAgICAgIG1pbkJpdHMgPSAwO1xuICAgICAgICAgICAgY29kZVBvaW50ID0gMDtcbiAgICAgICAgICAgIG5leHRFbmQgPSBpbmRleCA8PSBsZW5NaW51czMyID8gMzIgOiAobGVuIC0gaW5kZXgpIHwgMDtcbiAgICAgICAgICAvKmNhc2UgMTE6XG4gICAgICAgIGNhc2UgMTA6XG4gICAgICAgIGNhc2UgOTpcbiAgICAgICAgY2FzZSA4OlxuICAgICAgICAgIGNvZGVQb2ludCA/IGNvZGVQb2ludCA9IDAgOiBjcDAgPSAweGZmZmQ7IC8vIGZpbGwgd2l0aCBpbnZhbGlkIHJlcGxhY2VtZW50IGNoYXJhY3RlclxuICAgICAgICBjYXNlIDc6XG4gICAgICAgIGNhc2UgNjpcbiAgICAgICAgY2FzZSA1OlxuICAgICAgICBjYXNlIDQ6XG4gICAgICAgIGNhc2UgMzpcbiAgICAgICAgY2FzZSAyOlxuICAgICAgICBjYXNlIDE6XG4gICAgICAgIGNhc2UgMDpcbiAgICAgICAgICB0bXBCdWZmZXJVMTZbcG9zXSA9IGNwMDtcbiAgICAgICAgICBjb250aW51ZTsqL1xuICAgICAgICAgIGRlZmF1bHQ6IC8vIGZpbGwgd2l0aCBpbnZhbGlkIHJlcGxhY2VtZW50IGNoYXJhY3RlclxuICAgICAgICAgICAgdG1wQnVmZmVyVTE2W3Bvc10gPSBjcDA7XG4gICAgICAgICAgICBjb250aW51ZTtcbiAgICAgICAgICBjYXNlIDExOlxuICAgICAgICAgIGNhc2UgMTA6XG4gICAgICAgICAgY2FzZSA5OlxuICAgICAgICAgIGNhc2UgODpcbiAgICAgICAgfVxuICAgICAgICB0bXBCdWZmZXJVMTZbcG9zXSA9IDB4ZmZmZDsgLy8gZmlsbCB3aXRoIGludmFsaWQgcmVwbGFjZW1lbnQgY2hhcmFjdGVyXG4gICAgICB9XG4gICAgICB0bXBTdHIgKz0gZnJvbUNoYXJDb2RlKFxuICAgICAgICB0bXBCdWZmZXJVMTZbMF0sXG4gICAgICAgIHRtcEJ1ZmZlclUxNlsxXSxcbiAgICAgICAgdG1wQnVmZmVyVTE2WzJdLFxuICAgICAgICB0bXBCdWZmZXJVMTZbM10sXG4gICAgICAgIHRtcEJ1ZmZlclUxNls0XSxcbiAgICAgICAgdG1wQnVmZmVyVTE2WzVdLFxuICAgICAgICB0bXBCdWZmZXJVMTZbNl0sXG4gICAgICAgIHRtcEJ1ZmZlclUxNls3XSxcbiAgICAgICAgdG1wQnVmZmVyVTE2WzhdLFxuICAgICAgICB0bXBCdWZmZXJVMTZbOV0sXG4gICAgICAgIHRtcEJ1ZmZlclUxNlsxMF0sXG4gICAgICAgIHRtcEJ1ZmZlclUxNlsxMV0sXG4gICAgICAgIHRtcEJ1ZmZlclUxNlsxMl0sXG4gICAgICAgIHRtcEJ1ZmZlclUxNlsxM10sXG4gICAgICAgIHRtcEJ1ZmZlclUxNlsxNF0sXG4gICAgICAgIHRtcEJ1ZmZlclUxNlsxNV0sXG4gICAgICAgIHRtcEJ1ZmZlclUxNlsxNl0sXG4gICAgICAgIHRtcEJ1ZmZlclUxNlsxN10sXG4gICAgICAgIHRtcEJ1ZmZlclUxNlsxOF0sXG4gICAgICAgIHRtcEJ1ZmZlclUxNlsxOV0sXG4gICAgICAgIHRtcEJ1ZmZlclUxNlsyMF0sXG4gICAgICAgIHRtcEJ1ZmZlclUxNlsyMV0sXG4gICAgICAgIHRtcEJ1ZmZlclUxNlsyMl0sXG4gICAgICAgIHRtcEJ1ZmZlclUxNlsyM10sXG4gICAgICAgIHRtcEJ1ZmZlclUxNlsyNF0sXG4gICAgICAgIHRtcEJ1ZmZlclUxNlsyNV0sXG4gICAgICAgIHRtcEJ1ZmZlclUxNlsyNl0sXG4gICAgICAgIHRtcEJ1ZmZlclUxNlsyN10sXG4gICAgICAgIHRtcEJ1ZmZlclUxNlsyOF0sXG4gICAgICAgIHRtcEJ1ZmZlclUxNlsyOV0sXG4gICAgICAgIHRtcEJ1ZmZlclUxNlszMF0sXG4gICAgICAgIHRtcEJ1ZmZlclUxNlszMV1cbiAgICAgICk7XG4gICAgICBpZiAocG9zIDwgMzIpIHRtcFN0ciA9IHRtcFN0ci5zbGljZSgwLCAocG9zIC0gMzIpIHwgMCk7IC8vLSgzMi1wb3MpKTtcbiAgICAgIGlmIChpbmRleCA8IGxlbikge1xuICAgICAgICAvL2Zyb21DaGFyQ29kZS5hcHBseSgwLCB0bXBCdWZmZXJVMTYgOiBVaW50OEFycmF5ID8gIHRtcEJ1ZmZlclUxNi5zdWJhcnJheSgwLHBvcykgOiB0bXBCdWZmZXJVMTYuc2xpY2UoMCxwb3MpKTtcbiAgICAgICAgdG1wQnVmZmVyVTE2WzBdID0gdG1wO1xuICAgICAgICBwb3MgPSB+dG1wID4+PiAzMTsgLy90bXAgIT09IC0xID8gMSA6IDA7XG4gICAgICAgIHRtcCA9IC0xO1xuXG4gICAgICAgIGlmICh0bXBTdHIubGVuZ3RoIDwgcmVzdWx0aW5nU3RyaW5nLmxlbmd0aCkgY29udGludWU7XG4gICAgICB9IGVsc2UgaWYgKHRtcCAhPT0gLTEpIHtcbiAgICAgICAgdG1wU3RyICs9IGZyb21DaGFyQ29kZSh0bXApO1xuICAgICAgfVxuXG4gICAgICByZXN1bHRpbmdTdHJpbmcgKz0gdG1wU3RyO1xuICAgICAgdG1wU3RyID0gJyc7XG4gICAgfVxuXG4gICAgcmV0dXJuIHJlc3VsdGluZ1N0cmluZztcbiAgfVxufVxuXG4vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vL1xuZnVuY3Rpb24gZW5jb2RlclJlcGxhY2VyKG5vbkFzY2lpQ2hhcnM6IHN0cmluZykge1xuICAvLyBtYWtlIHRoZSBVVEYgc3RyaW5nIGludG8gYSBiaW5hcnkgVVRGLTggZW5jb2RlZCBzdHJpbmdcbiAgbGV0IHBvaW50ID0gbm9uQXNjaWlDaGFycy5jaGFyQ29kZUF0KDApIHwgMDtcbiAgaWYgKDB4ZDgwMCA8PSBwb2ludCkge1xuICAgIGlmIChwb2ludCA8PSAweGRiZmYpIHtcbiAgICAgIGNvbnN0IG5leHRjb2RlID0gbm9uQXNjaWlDaGFycy5jaGFyQ29kZUF0KDEpIHwgMDsgLy8gZGVmYXVsdHMgdG8gMCB3aGVuIE5hTiwgY2F1c2luZyBudWxsIHJlcGxhY2VtZW50IGNoYXJhY3RlclxuXG4gICAgICBpZiAoMHhkYzAwIDw9IG5leHRjb2RlICYmIG5leHRjb2RlIDw9IDB4ZGZmZikge1xuICAgICAgICAvL3BvaW50ID0gKChwb2ludCAtIDB4RDgwMCk8PDEwKSArIG5leHRjb2RlIC0gMHhEQzAwICsgMHgxMDAwMHwwO1xuICAgICAgICBwb2ludCA9ICgocG9pbnQgPDwgMTApICsgbmV4dGNvZGUgLSAweDM1ZmRjMDApIHwgMDtcbiAgICAgICAgaWYgKHBvaW50ID4gMHhmZmZmKVxuICAgICAgICAgIHJldHVybiBmcm9tQ2hhckNvZGUoXG4gICAgICAgICAgICAoMHgxZSAvKjBiMTExMTAqLyA8PCAzKSB8IChwb2ludCA+PiAxOCksXG4gICAgICAgICAgICAoMHgyIC8qMGIxMCovIDw8IDYpIHwgKChwb2ludCA+PiAxMikgJiAweDNmKSAvKjBiMDAxMTExMTEqLyxcbiAgICAgICAgICAgICgweDIgLyowYjEwKi8gPDwgNikgfCAoKHBvaW50ID4+IDYpICYgMHgzZikgLyowYjAwMTExMTExKi8sXG4gICAgICAgICAgICAoMHgyIC8qMGIxMCovIDw8IDYpIHwgKHBvaW50ICYgMHgzZikgLyowYjAwMTExMTExKi9cbiAgICAgICAgICApO1xuICAgICAgfSBlbHNlIHBvaW50ID0gNjU1MzMgLyowYjExMTExMTExMTExMTExMDEqLzsgLy9yZXR1cm4gJ1xceEVGXFx4QkZcXHhCRCc7Ly9mcm9tQ2hhckNvZGUoMHhlZiwgMHhiZiwgMHhiZCk7XG4gICAgfSBlbHNlIGlmIChwb2ludCA8PSAweGRmZmYpIHtcbiAgICAgIHBvaW50ID0gNjU1MzMgLyowYjExMTExMTExMTExMTExMDEqLzsgLy9yZXR1cm4gJ1xceEVGXFx4QkZcXHhCRCc7Ly9mcm9tQ2hhckNvZGUoMHhlZiwgMHhiZiwgMHhiZCk7XG4gICAgfVxuICB9XG4gIC8qaWYgKHBvaW50IDw9IDB4MDA3ZikgcmV0dXJuIG5vbkFzY2lpQ2hhcnM7XG4gIGVsc2UgKi8gaWYgKHBvaW50IDw9IDB4MDdmZikge1xuICAgIHJldHVybiBmcm9tQ2hhckNvZGUoKDB4NiA8PCA1KSB8IChwb2ludCA+PiA2KSwgKDB4MiA8PCA2KSB8IChwb2ludCAmIDB4M2YpKTtcbiAgfSBlbHNlXG4gICAgcmV0dXJuIGZyb21DaGFyQ29kZShcbiAgICAgICgweGUgLyowYjExMTAqLyA8PCA0KSB8IChwb2ludCA+PiAxMiksXG4gICAgICAoMHgyIC8qMGIxMCovIDw8IDYpIHwgKChwb2ludCA+PiA2KSAmIDB4M2YpIC8qMGIwMDExMTExMSovLFxuICAgICAgKDB4MiAvKjBiMTAqLyA8PCA2KSB8IChwb2ludCAmIDB4M2YpIC8qMGIwMDExMTExMSovXG4gICAgKTtcbn1cblxuZXhwb3J0IGNsYXNzIFRleHRFbmNvZGVyIHtcbiAgcHVibGljIGVuY29kZShpbnB1dFN0cmluZzogc3RyaW5nKTogVWludDhBcnJheSB7XG4gICAgLy8gMHhjMCA9PiAwYjExMDAwMDAwOyAweGZmID0+IDBiMTExMTExMTE7IDB4YzAtMHhmZiA9PiAwYjExeHh4eHh4XG4gICAgLy8gMHg4MCA9PiAwYjEwMDAwMDAwOyAweGJmID0+IDBiMTAxMTExMTE7IDB4ODAtMHhiZiA9PiAwYjEweHh4eHh4XG4gICAgY29uc3QgZW5jb2RlZFN0cmluZyA9IGlucHV0U3RyaW5nID09PSB2b2lkIDAgPyAnJyA6ICcnICsgaW5wdXRTdHJpbmcsXG4gICAgICBsZW4gPSBlbmNvZGVkU3RyaW5nLmxlbmd0aCB8IDA7XG4gICAgbGV0IHJlc3VsdCA9IG5ldyBVaW50OEFycmF5KCgobGVuIDw8IDEpICsgOCkgfCAwKTtcbiAgICBsZXQgdG1wUmVzdWx0OiBVaW50OEFycmF5O1xuICAgIGxldCBpID0gMCxcbiAgICAgIHBvcyA9IDAsXG4gICAgICBwb2ludCA9IDAsXG4gICAgICBuZXh0Y29kZSA9IDA7XG4gICAgbGV0IHVwZ3JhZGVkZWRBcnJheVNpemUgPSAhVWludDhBcnJheTsgLy8gbm9ybWFsIGFycmF5cyBhcmUgYXV0by1leHBhbmRpbmdcbiAgICBmb3IgKGkgPSAwOyBpIDwgbGVuOyBpID0gKGkgKyAxKSB8IDAsIHBvcyA9IChwb3MgKyAxKSB8IDApIHtcbiAgICAgIHBvaW50ID0gZW5jb2RlZFN0cmluZy5jaGFyQ29kZUF0KGkpIHwgMDtcbiAgICAgIGlmIChwb2ludCA8PSAweDAwN2YpIHtcbiAgICAgICAgcmVzdWx0W3Bvc10gPSBwb2ludDtcbiAgICAgIH0gZWxzZSBpZiAocG9pbnQgPD0gMHgwN2ZmKSB7XG4gICAgICAgIHJlc3VsdFtwb3NdID0gKDB4NiA8PCA1KSB8IChwb2ludCA+PiA2KTtcbiAgICAgICAgcmVzdWx0Wyhwb3MgPSAocG9zICsgMSkgfCAwKV0gPSAoMHgyIDw8IDYpIHwgKHBvaW50ICYgMHgzZik7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICB3aWRlbkNoZWNrOiB7XG4gICAgICAgICAgaWYgKDB4ZDgwMCA8PSBwb2ludCkge1xuICAgICAgICAgICAgaWYgKHBvaW50IDw9IDB4ZGJmZikge1xuICAgICAgICAgICAgICBuZXh0Y29kZSA9IGVuY29kZWRTdHJpbmcuY2hhckNvZGVBdCgoaSA9IChpICsgMSkgfCAwKSkgfCAwOyAvLyBkZWZhdWx0cyB0byAwIHdoZW4gTmFOLCBjYXVzaW5nIG51bGwgcmVwbGFjZW1lbnQgY2hhcmFjdGVyXG5cbiAgICAgICAgICAgICAgaWYgKDB4ZGMwMCA8PSBuZXh0Y29kZSAmJiBuZXh0Y29kZSA8PSAweGRmZmYpIHtcbiAgICAgICAgICAgICAgICAvL3BvaW50ID0gKChwb2ludCAtIDB4RDgwMCk8PDEwKSArIG5leHRjb2RlIC0gMHhEQzAwICsgMHgxMDAwMHwwO1xuICAgICAgICAgICAgICAgIHBvaW50ID0gKChwb2ludCA8PCAxMCkgKyBuZXh0Y29kZSAtIDB4MzVmZGMwMCkgfCAwO1xuICAgICAgICAgICAgICAgIGlmIChwb2ludCA+IDB4ZmZmZikge1xuICAgICAgICAgICAgICAgICAgcmVzdWx0W3Bvc10gPSAoMHgxZSAvKjBiMTExMTAqLyA8PCAzKSB8IChwb2ludCA+PiAxOCk7XG4gICAgICAgICAgICAgICAgICByZXN1bHRbKHBvcyA9IChwb3MgKyAxKSB8IDApXSA9ICgweDIgLyowYjEwKi8gPDwgNikgfCAoKHBvaW50ID4+IDEyKSAmIDB4M2YpIC8qMGIwMDExMTExMSovO1xuICAgICAgICAgICAgICAgICAgcmVzdWx0Wyhwb3MgPSAocG9zICsgMSkgfCAwKV0gPSAoMHgyIC8qMGIxMCovIDw8IDYpIHwgKChwb2ludCA+PiA2KSAmIDB4M2YpIC8qMGIwMDExMTExMSovO1xuICAgICAgICAgICAgICAgICAgcmVzdWx0Wyhwb3MgPSAocG9zICsgMSkgfCAwKV0gPSAoMHgyIC8qMGIxMCovIDw8IDYpIHwgKHBvaW50ICYgMHgzZikgLyowYjAwMTExMTExKi87XG4gICAgICAgICAgICAgICAgICBjb250aW51ZTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgYnJlYWsgd2lkZW5DaGVjaztcbiAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICBwb2ludCA9IDY1NTMzIC8qMGIxMTExMTExMTExMTExMTAxKi87IC8vcmV0dXJuICdcXHhFRlxceEJGXFx4QkQnOy8vZnJvbUNoYXJDb2RlKDB4ZWYsIDB4YmYsIDB4YmQpO1xuICAgICAgICAgICAgfSBlbHNlIGlmIChwb2ludCA8PSAweGRmZmYpIHtcbiAgICAgICAgICAgICAgcG9pbnQgPSA2NTUzMyAvKjBiMTExMTExMTExMTExMTEwMSovOyAvL3JldHVybiAnXFx4RUZcXHhCRlxceEJEJzsvL2Zyb21DaGFyQ29kZSgweGVmLCAweGJmLCAweGJkKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9XG4gICAgICAgICAgaWYgKCF1cGdyYWRlZGVkQXJyYXlTaXplICYmIGkgPDwgMSA8IHBvcyAmJiBpIDw8IDEgPCAoKHBvcyAtIDcpIHwgMCkpIHtcbiAgICAgICAgICAgIHVwZ3JhZGVkZWRBcnJheVNpemUgPSB0cnVlO1xuICAgICAgICAgICAgdG1wUmVzdWx0ID0gbmV3IFVpbnQ4QXJyYXkobGVuICogMyk7XG4gICAgICAgICAgICB0bXBSZXN1bHQuc2V0KHJlc3VsdCk7XG4gICAgICAgICAgICByZXN1bHQgPSB0bXBSZXN1bHQ7XG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIHJlc3VsdFtwb3NdID0gKDB4ZSAvKjBiMTExMCovIDw8IDQpIHwgKHBvaW50ID4+IDEyKTtcbiAgICAgICAgcmVzdWx0Wyhwb3MgPSAocG9zICsgMSkgfCAwKV0gPSAoMHgyIC8qMGIxMCovIDw8IDYpIHwgKChwb2ludCA+PiA2KSAmIDB4M2YpIC8qMGIwMDExMTExMSovO1xuICAgICAgICByZXN1bHRbKHBvcyA9IChwb3MgKyAxKSB8IDApXSA9ICgweDIgLyowYjEwKi8gPDwgNikgfCAocG9pbnQgJiAweDNmKSAvKjBiMDAxMTExMTEqLztcbiAgICAgIH1cbiAgICB9XG4gICAgcmV0dXJuIFVpbnQ4QXJyYXkgPyByZXN1bHQuc3ViYXJyYXkoMCwgcG9zKSA6IHJlc3VsdC5zbGljZSgwLCBwb3MpO1xuICB9XG5cbiAgcHVibGljIGVuY29kZUludG8oaW5wdXRTdHJpbmc6IHN0cmluZywgdThBcnI6IFVpbnQ4QXJyYXkpOiB7IHdyaXR0ZW46IG51bWJlcjsgcmVhZDogbnVtYmVyIH0ge1xuICAgIGNvbnN0IGVuY29kZWRTdHJpbmcgPSBpbnB1dFN0cmluZyA9PT0gdm9pZCAwID8gJycgOiAoJycgKyBpbnB1dFN0cmluZykucmVwbGFjZShlbmNvZGVyUmVnZXhwLCBlbmNvZGVyUmVwbGFjZXIpO1xuICAgIGxldCBsZW4gPSBlbmNvZGVkU3RyaW5nLmxlbmd0aCB8IDAsXG4gICAgICBpID0gMCxcbiAgICAgIGNoYXIgPSAwLFxuICAgICAgcmVhZCA9IDA7XG4gICAgY29uc3QgdThBcnJMZW4gPSB1OEFyci5sZW5ndGggfCAwO1xuICAgIGNvbnN0IGlucHV0TGVuZ3RoID0gaW5wdXRTdHJpbmcubGVuZ3RoIHwgMDtcbiAgICBpZiAodThBcnJMZW4gPCBsZW4pIGxlbiA9IHU4QXJyTGVuO1xuICAgIHB1dENoYXJzOiB7XG4gICAgICBmb3IgKDsgaSA8IGxlbjsgaSA9IChpICsgMSkgfCAwKSB7XG4gICAgICAgIGNoYXIgPSBlbmNvZGVkU3RyaW5nLmNoYXJDb2RlQXQoaSkgfCAwO1xuICAgICAgICBzd2l0Y2ggKGNoYXIgPj4gNCkge1xuICAgICAgICAgIGNhc2UgMDpcbiAgICAgICAgICBjYXNlIDE6XG4gICAgICAgICAgY2FzZSAyOlxuICAgICAgICAgIGNhc2UgMzpcbiAgICAgICAgICBjYXNlIDQ6XG4gICAgICAgICAgY2FzZSA1OlxuICAgICAgICAgIGNhc2UgNjpcbiAgICAgICAgICBjYXNlIDc6XG4gICAgICAgICAgICByZWFkID0gKHJlYWQgKyAxKSB8IDA7XG4gICAgICAgICAgLy8gZXh0ZW5zaW9uIHBvaW50czpcbiAgICAgICAgICBjYXNlIDg6XG4gICAgICAgICAgY2FzZSA5OlxuICAgICAgICAgIGNhc2UgMTA6XG4gICAgICAgICAgY2FzZSAxMTpcbiAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgIGNhc2UgMTI6XG4gICAgICAgICAgY2FzZSAxMzpcbiAgICAgICAgICAgIGlmICgoKGkgKyAxKSB8IDApIDwgdThBcnJMZW4pIHtcbiAgICAgICAgICAgICAgcmVhZCA9IChyZWFkICsgMSkgfCAwO1xuICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgIH1cbiAgICAgICAgICBjYXNlIDE0OlxuICAgICAgICAgICAgaWYgKCgoaSArIDIpIHwgMCkgPCB1OEFyckxlbikge1xuICAgICAgICAgICAgICAvL2lmICghKGNoYXIgPT09IDB4RUYgJiYgZW5jb2RlZFN0cmluZy5zdWJzdHIoaSsxfDAsMikgPT09IFwiXFx4QkZcXHhCRFwiKSlcbiAgICAgICAgICAgICAgcmVhZCA9IChyZWFkICsgMSkgfCAwO1xuICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgIH1cbiAgICAgICAgICBjYXNlIDE1OlxuICAgICAgICAgICAgaWYgKCgoaSArIDMpIHwgMCkgPCB1OEFyckxlbikge1xuICAgICAgICAgICAgICByZWFkID0gKHJlYWQgKyAxKSB8IDA7XG4gICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgfVxuICAgICAgICAgIGRlZmF1bHQ6XG4gICAgICAgICAgICBicmVhayBwdXRDaGFycztcbiAgICAgICAgfVxuICAgICAgICAvL3JlYWQgPSByZWFkICsgKChjaGFyID4+IDYpICE9PSAyKSB8MDtcbiAgICAgICAgdThBcnJbaV0gPSBjaGFyO1xuICAgICAgfVxuICAgIH1cbiAgICByZXR1cm4geyB3cml0dGVuOiBpLCByZWFkOiBpbnB1dExlbmd0aCA8IHJlYWQgPyBpbnB1dExlbmd0aCA6IHJlYWQgfTtcbiAgfVxufVxuXG4vKipcbiAqIEVuY29kZSBhIFVURi04IHN0cmluZyBpbnRvIGEgVWludDhBcnJheVxuICovXG5leHBvcnQgZnVuY3Rpb24gZW5jb2RlKHM6IHN0cmluZyk6IFVpbnQ4QXJyYXkge1xuICByZXR1cm4gVGV4dEVuY29kZXIucHJvdG90eXBlLmVuY29kZShzKTtcbn1cblxuLyoqXG4gKiBEZWNvZGUgYSBVaW50OEFycmF5IGludG8gYSBVVEYtOCBzdHJpbmdcbiAqL1xuZXhwb3J0IGZ1bmN0aW9uIGRlY29kZShhOiBVaW50OEFycmF5KTogc3RyaW5nIHtcbiAgcmV0dXJuIFRleHREZWNvZGVyLnByb3RvdHlwZS5kZWNvZGUoYSk7XG59XG4iLCJpbXBvcnQgeyBUZW1wb3JhbEZhaWx1cmUgfSBmcm9tICcuL2ZhaWx1cmUnO1xuaW1wb3J0IHsgU3ltYm9sQmFzZWRJbnN0YW5jZU9mRXJyb3IgfSBmcm9tICcuL3R5cGUtaGVscGVycyc7XG5cbi8qKlxuICogVGhyb3duIGZyb20gY29kZSB0aGF0IHJlY2VpdmVzIGEgdmFsdWUgdGhhdCBpcyB1bmV4cGVjdGVkIG9yIHRoYXQgaXQncyB1bmFibGUgdG8gaGFuZGxlLlxuICovXG5AU3ltYm9sQmFzZWRJbnN0YW5jZU9mRXJyb3IoJ1ZhbHVlRXJyb3InKVxuZXhwb3J0IGNsYXNzIFZhbHVlRXJyb3IgZXh0ZW5kcyBFcnJvciB7XG4gIGNvbnN0cnVjdG9yKFxuICAgIG1lc3NhZ2U6IHN0cmluZyB8IHVuZGVmaW5lZCxcbiAgICBwdWJsaWMgcmVhZG9ubHkgY2F1c2U/OiB1bmtub3duXG4gICkge1xuICAgIHN1cGVyKG1lc3NhZ2UgPz8gdW5kZWZpbmVkKTtcbiAgfVxufVxuXG4vKipcbiAqIFRocm93biB3aGVuIGEgUGF5bG9hZCBDb252ZXJ0ZXIgaXMgbWlzY29uZmlndXJlZC5cbiAqL1xuQFN5bWJvbEJhc2VkSW5zdGFuY2VPZkVycm9yKCdQYXlsb2FkQ29udmVydGVyRXJyb3InKVxuZXhwb3J0IGNsYXNzIFBheWxvYWRDb252ZXJ0ZXJFcnJvciBleHRlbmRzIFZhbHVlRXJyb3Ige31cblxuLyoqXG4gKiBVc2VkIGluIGRpZmZlcmVudCBwYXJ0cyBvZiB0aGUgU0RLIHRvIG5vdGUgdGhhdCBzb21ldGhpbmcgdW5leHBlY3RlZCBoYXMgaGFwcGVuZWQuXG4gKi9cbkBTeW1ib2xCYXNlZEluc3RhbmNlT2ZFcnJvcignSWxsZWdhbFN0YXRlRXJyb3InKVxuZXhwb3J0IGNsYXNzIElsbGVnYWxTdGF0ZUVycm9yIGV4dGVuZHMgRXJyb3Ige31cblxuLyoqXG4gKiBUaGlzIGV4Y2VwdGlvbiBpcyB0aHJvd24gaW4gdGhlIGZvbGxvd2luZyBjYXNlczpcbiAqICAtIFdvcmtmbG93IHdpdGggdGhlIHNhbWUgV29ya2Zsb3cgSWQgaXMgY3VycmVudGx5IHJ1bm5pbmdcbiAqICAtIFRoZXJlIGlzIGEgY2xvc2VkIFdvcmtmbG93IHdpdGggdGhlIHNhbWUgV29ya2Zsb3cgSWQgYW5kIHRoZSB7QGxpbmsgV29ya2Zsb3dPcHRpb25zLndvcmtmbG93SWRSZXVzZVBvbGljeX1cbiAqICAgIGlzIGBXT1JLRkxPV19JRF9SRVVTRV9QT0xJQ1lfUkVKRUNUX0RVUExJQ0FURWBcbiAqICAtIFRoZXJlIGlzIGNsb3NlZCBXb3JrZmxvdyBpbiB0aGUgYENvbXBsZXRlZGAgc3RhdGUgd2l0aCB0aGUgc2FtZSBXb3JrZmxvdyBJZCBhbmQgdGhlIHtAbGluayBXb3JrZmxvd09wdGlvbnMud29ya2Zsb3dJZFJldXNlUG9saWN5fVxuICogICAgaXMgYFdPUktGTE9XX0lEX1JFVVNFX1BPTElDWV9BTExPV19EVVBMSUNBVEVfRkFJTEVEX09OTFlgXG4gKi9cbkBTeW1ib2xCYXNlZEluc3RhbmNlT2ZFcnJvcignV29ya2Zsb3dFeGVjdXRpb25BbHJlYWR5U3RhcnRlZEVycm9yJylcbmV4cG9ydCBjbGFzcyBXb3JrZmxvd0V4ZWN1dGlvbkFscmVhZHlTdGFydGVkRXJyb3IgZXh0ZW5kcyBUZW1wb3JhbEZhaWx1cmUge1xuICBjb25zdHJ1Y3RvcihcbiAgICBtZXNzYWdlOiBzdHJpbmcsXG4gICAgcHVibGljIHJlYWRvbmx5IHdvcmtmbG93SWQ6IHN0cmluZyxcbiAgICBwdWJsaWMgcmVhZG9ubHkgd29ya2Zsb3dUeXBlOiBzdHJpbmdcbiAgKSB7XG4gICAgc3VwZXIobWVzc2FnZSk7XG4gIH1cbn1cblxuLyoqXG4gKiBUaHJvd24gd2hlbiBhIFdvcmtmbG93IHdpdGggdGhlIGdpdmVuIElkIGlzIG5vdCBrbm93biB0byBUZW1wb3JhbCBTZXJ2ZXIuXG4gKiBJdCBjb3VsZCBiZSBiZWNhdXNlOlxuICogLSBJZCBwYXNzZWQgaXMgaW5jb3JyZWN0XG4gKiAtIFdvcmtmbG93IGlzIGNsb3NlZCAoZm9yIHNvbWUgY2FsbHMsIGUuZy4gYHRlcm1pbmF0ZWApXG4gKiAtIFdvcmtmbG93IHdhcyBkZWxldGVkIGZyb20gdGhlIFNlcnZlciBhZnRlciByZWFjaGluZyBpdHMgcmV0ZW50aW9uIGxpbWl0XG4gKi9cbkBTeW1ib2xCYXNlZEluc3RhbmNlT2ZFcnJvcignV29ya2Zsb3dOb3RGb3VuZEVycm9yJylcbmV4cG9ydCBjbGFzcyBXb3JrZmxvd05vdEZvdW5kRXJyb3IgZXh0ZW5kcyBFcnJvciB7XG4gIGNvbnN0cnVjdG9yKFxuICAgIG1lc3NhZ2U6IHN0cmluZyxcbiAgICBwdWJsaWMgcmVhZG9ubHkgd29ya2Zsb3dJZDogc3RyaW5nLFxuICAgIHB1YmxpYyByZWFkb25seSBydW5JZDogc3RyaW5nIHwgdW5kZWZpbmVkXG4gICkge1xuICAgIHN1cGVyKG1lc3NhZ2UpO1xuICB9XG59XG5cbi8qKlxuICogVGhyb3duIHdoZW4gdGhlIHNwZWNpZmllZCBuYW1lc3BhY2UgaXMgbm90IGtub3duIHRvIFRlbXBvcmFsIFNlcnZlci5cbiAqL1xuQFN5bWJvbEJhc2VkSW5zdGFuY2VPZkVycm9yKCdOYW1lc3BhY2VOb3RGb3VuZEVycm9yJylcbmV4cG9ydCBjbGFzcyBOYW1lc3BhY2VOb3RGb3VuZEVycm9yIGV4dGVuZHMgRXJyb3Ige1xuICBjb25zdHJ1Y3RvcihwdWJsaWMgcmVhZG9ubHkgbmFtZXNwYWNlOiBzdHJpbmcpIHtcbiAgICBzdXBlcihgTmFtZXNwYWNlIG5vdCBmb3VuZDogJyR7bmFtZXNwYWNlfSdgKTtcbiAgfVxufVxuIiwiaW1wb3J0IHR5cGUgeyB0ZW1wb3JhbCB9IGZyb20gJ0B0ZW1wb3JhbGlvL3Byb3RvJztcbmltcG9ydCB7IGNoZWNrRXh0ZW5kcywgZXJyb3JNZXNzYWdlLCBpc1JlY29yZCwgU3ltYm9sQmFzZWRJbnN0YW5jZU9mRXJyb3IgfSBmcm9tICcuL3R5cGUtaGVscGVycyc7XG5cbmV4cG9ydCBjb25zdCBGQUlMVVJFX1NPVVJDRSA9ICdUeXBlU2NyaXB0U0RLJztcbmV4cG9ydCB0eXBlIFByb3RvRmFpbHVyZSA9IHRlbXBvcmFsLmFwaS5mYWlsdXJlLnYxLklGYWlsdXJlO1xuXG4vLyBBdm9pZCBpbXBvcnRpbmcgdGhlIHByb3RvIGltcGxlbWVudGF0aW9uIHRvIHJlZHVjZSB3b3JrZmxvdyBidW5kbGUgc2l6ZVxuLy8gQ29waWVkIGZyb20gdGVtcG9yYWwuYXBpLmVudW1zLnYxLlRpbWVvdXRUeXBlXG5leHBvcnQgZW51bSBUaW1lb3V0VHlwZSB7XG4gIFRJTUVPVVRfVFlQRV9VTlNQRUNJRklFRCA9IDAsXG4gIFRJTUVPVVRfVFlQRV9TVEFSVF9UT19DTE9TRSA9IDEsXG4gIFRJTUVPVVRfVFlQRV9TQ0hFRFVMRV9UT19TVEFSVCA9IDIsXG4gIFRJTUVPVVRfVFlQRV9TQ0hFRFVMRV9UT19DTE9TRSA9IDMsXG4gIFRJTUVPVVRfVFlQRV9IRUFSVEJFQVQgPSA0LFxufVxuXG5jaGVja0V4dGVuZHM8dGVtcG9yYWwuYXBpLmVudW1zLnYxLlRpbWVvdXRUeXBlLCBUaW1lb3V0VHlwZT4oKTtcbmNoZWNrRXh0ZW5kczxUaW1lb3V0VHlwZSwgdGVtcG9yYWwuYXBpLmVudW1zLnYxLlRpbWVvdXRUeXBlPigpO1xuXG4vLyBBdm9pZCBpbXBvcnRpbmcgdGhlIHByb3RvIGltcGxlbWVudGF0aW9uIHRvIHJlZHVjZSB3b3JrZmxvdyBidW5kbGUgc2l6ZVxuLy8gQ29waWVkIGZyb20gdGVtcG9yYWwuYXBpLmVudW1zLnYxLlJldHJ5U3RhdGVcbmV4cG9ydCBlbnVtIFJldHJ5U3RhdGUge1xuICBSRVRSWV9TVEFURV9VTlNQRUNJRklFRCA9IDAsXG4gIFJFVFJZX1NUQVRFX0lOX1BST0dSRVNTID0gMSxcbiAgUkVUUllfU1RBVEVfTk9OX1JFVFJZQUJMRV9GQUlMVVJFID0gMixcbiAgUkVUUllfU1RBVEVfVElNRU9VVCA9IDMsXG4gIFJFVFJZX1NUQVRFX01BWElNVU1fQVRURU1QVFNfUkVBQ0hFRCA9IDQsXG4gIFJFVFJZX1NUQVRFX1JFVFJZX1BPTElDWV9OT1RfU0VUID0gNSxcbiAgUkVUUllfU1RBVEVfSU5URVJOQUxfU0VSVkVSX0VSUk9SID0gNixcbiAgUkVUUllfU1RBVEVfQ0FOQ0VMX1JFUVVFU1RFRCA9IDcsXG59XG5cbmNoZWNrRXh0ZW5kczx0ZW1wb3JhbC5hcGkuZW51bXMudjEuUmV0cnlTdGF0ZSwgUmV0cnlTdGF0ZT4oKTtcbmNoZWNrRXh0ZW5kczxSZXRyeVN0YXRlLCB0ZW1wb3JhbC5hcGkuZW51bXMudjEuUmV0cnlTdGF0ZT4oKTtcblxuZXhwb3J0IHR5cGUgV29ya2Zsb3dFeGVjdXRpb24gPSB0ZW1wb3JhbC5hcGkuY29tbW9uLnYxLklXb3JrZmxvd0V4ZWN1dGlvbjtcblxuLyoqXG4gKiBSZXByZXNlbnRzIGZhaWx1cmVzIHRoYXQgY2FuIGNyb3NzIFdvcmtmbG93IGFuZCBBY3Rpdml0eSBib3VuZGFyaWVzLlxuICpcbiAqICoqTmV2ZXIgZXh0ZW5kIHRoaXMgY2xhc3Mgb3IgYW55IG9mIGl0cyBjaGlsZHJlbi4qKlxuICpcbiAqIFRoZSBvbmx5IGNoaWxkIGNsYXNzIHlvdSBzaG91bGQgZXZlciB0aHJvdyBmcm9tIHlvdXIgY29kZSBpcyB7QGxpbmsgQXBwbGljYXRpb25GYWlsdXJlfS5cbiAqL1xuQFN5bWJvbEJhc2VkSW5zdGFuY2VPZkVycm9yKCdUZW1wb3JhbEZhaWx1cmUnKVxuZXhwb3J0IGNsYXNzIFRlbXBvcmFsRmFpbHVyZSBleHRlbmRzIEVycm9yIHtcbiAgLyoqXG4gICAqIFRoZSBvcmlnaW5hbCBmYWlsdXJlIHRoYXQgY29uc3RydWN0ZWQgdGhpcyBlcnJvci5cbiAgICpcbiAgICogT25seSBwcmVzZW50IGlmIHRoaXMgZXJyb3Igd2FzIGdlbmVyYXRlZCBmcm9tIGFuIGV4dGVybmFsIG9wZXJhdGlvbi5cbiAgICovXG4gIHB1YmxpYyBmYWlsdXJlPzogUHJvdG9GYWlsdXJlO1xuXG4gIGNvbnN0cnVjdG9yKFxuICAgIG1lc3NhZ2U/OiBzdHJpbmcgfCB1bmRlZmluZWQgfCBudWxsLFxuICAgIHB1YmxpYyByZWFkb25seSBjYXVzZT86IEVycm9yXG4gICkge1xuICAgIHN1cGVyKG1lc3NhZ2UgPz8gdW5kZWZpbmVkKTtcbiAgfVxufVxuXG4vKiogRXhjZXB0aW9ucyBvcmlnaW5hdGVkIGF0IHRoZSBUZW1wb3JhbCBzZXJ2aWNlLiAqL1xuQFN5bWJvbEJhc2VkSW5zdGFuY2VPZkVycm9yKCdTZXJ2ZXJGYWlsdXJlJylcbmV4cG9ydCBjbGFzcyBTZXJ2ZXJGYWlsdXJlIGV4dGVuZHMgVGVtcG9yYWxGYWlsdXJlIHtcbiAgY29uc3RydWN0b3IoXG4gICAgbWVzc2FnZTogc3RyaW5nIHwgdW5kZWZpbmVkLFxuICAgIHB1YmxpYyByZWFkb25seSBub25SZXRyeWFibGU6IGJvb2xlYW4sXG4gICAgY2F1c2U/OiBFcnJvclxuICApIHtcbiAgICBzdXBlcihtZXNzYWdlLCBjYXVzZSk7XG4gIH1cbn1cblxuLyoqXG4gKiBgQXBwbGljYXRpb25GYWlsdXJlYHMgYXJlIHVzZWQgdG8gY29tbXVuaWNhdGUgYXBwbGljYXRpb24tc3BlY2lmaWMgZmFpbHVyZXMgaW4gV29ya2Zsb3dzIGFuZCBBY3Rpdml0aWVzLlxuICpcbiAqIFRoZSB7QGxpbmsgdHlwZX0gcHJvcGVydHkgaXMgbWF0Y2hlZCBhZ2FpbnN0IHtAbGluayBSZXRyeVBvbGljeS5ub25SZXRyeWFibGVFcnJvclR5cGVzfSB0byBkZXRlcm1pbmUgaWYgYW4gaW5zdGFuY2VcbiAqIG9mIHRoaXMgZXJyb3IgaXMgcmV0cnlhYmxlLiBBbm90aGVyIHdheSB0byBhdm9pZCByZXRyeWluZyBpcyBieSBzZXR0aW5nIHRoZSB7QGxpbmsgbm9uUmV0cnlhYmxlfSBmbGFnIHRvIGB0cnVlYC5cbiAqXG4gKiBJbiBXb3JrZmxvd3MsIGlmIHlvdSB0aHJvdyBhIG5vbi1gQXBwbGljYXRpb25GYWlsdXJlYCwgdGhlIFdvcmtmbG93IFRhc2sgd2lsbCBmYWlsIGFuZCBiZSByZXRyaWVkLiBJZiB5b3UgdGhyb3cgYW5cbiAqIGBBcHBsaWNhdGlvbkZhaWx1cmVgLCB0aGUgV29ya2Zsb3cgRXhlY3V0aW9uIHdpbGwgZmFpbC5cbiAqXG4gKiBJbiBBY3Rpdml0aWVzLCB5b3UgY2FuIGVpdGhlciB0aHJvdyBhbiBgQXBwbGljYXRpb25GYWlsdXJlYCBvciBhbm90aGVyIGBFcnJvcmAgdG8gZmFpbCB0aGUgQWN0aXZpdHkgVGFzay4gSW4gdGhlXG4gKiBsYXR0ZXIgY2FzZSwgdGhlIGBFcnJvcmAgd2lsbCBiZSBjb252ZXJ0ZWQgdG8gYW4gYEFwcGxpY2F0aW9uRmFpbHVyZWAuIFRoZSBjb252ZXJzaW9uIGlzIGRvbmUgYXMgZm9sbG93aW5nOlxuICpcbiAqIC0gYHR5cGVgIGlzIHNldCB0byBgZXJyb3IuY29uc3RydWN0b3I/Lm5hbWUgPz8gZXJyb3IubmFtZWBcbiAqIC0gYG1lc3NhZ2VgIGlzIHNldCB0byBgZXJyb3IubWVzc2FnZWBcbiAqIC0gYG5vblJldHJ5YWJsZWAgaXMgc2V0IHRvIGZhbHNlXG4gKiAtIGBkZXRhaWxzYCBhcmUgc2V0IHRvIG51bGxcbiAqIC0gc3RhY2sgdHJhY2UgaXMgY29waWVkIGZyb20gdGhlIG9yaWdpbmFsIGVycm9yXG4gKlxuICogV2hlbiBhbiB7QGxpbmsgaHR0cHM6Ly9kb2NzLnRlbXBvcmFsLmlvL2NvbmNlcHRzL3doYXQtaXMtYW4tYWN0aXZpdHktZXhlY3V0aW9uIHwgQWN0aXZpdHkgRXhlY3V0aW9ufSBmYWlscywgdGhlXG4gKiBgQXBwbGljYXRpb25GYWlsdXJlYCBmcm9tIHRoZSBsYXN0IEFjdGl2aXR5IFRhc2sgd2lsbCBiZSB0aGUgYGNhdXNlYCBvZiB0aGUge0BsaW5rIEFjdGl2aXR5RmFpbHVyZX0gdGhyb3duIGluIHRoZVxuICogV29ya2Zsb3cuXG4gKi9cbkBTeW1ib2xCYXNlZEluc3RhbmNlT2ZFcnJvcignQXBwbGljYXRpb25GYWlsdXJlJylcbmV4cG9ydCBjbGFzcyBBcHBsaWNhdGlvbkZhaWx1cmUgZXh0ZW5kcyBUZW1wb3JhbEZhaWx1cmUge1xuICAvKipcbiAgICogQWx0ZXJuYXRpdmVseSwgdXNlIHtAbGluayBmcm9tRXJyb3J9IG9yIHtAbGluayBjcmVhdGV9LlxuICAgKi9cbiAgY29uc3RydWN0b3IoXG4gICAgbWVzc2FnZT86IHN0cmluZyB8IHVuZGVmaW5lZCB8IG51bGwsXG4gICAgcHVibGljIHJlYWRvbmx5IHR5cGU/OiBzdHJpbmcgfCB1bmRlZmluZWQgfCBudWxsLFxuICAgIHB1YmxpYyByZWFkb25seSBub25SZXRyeWFibGU/OiBib29sZWFuIHwgdW5kZWZpbmVkIHwgbnVsbCxcbiAgICBwdWJsaWMgcmVhZG9ubHkgZGV0YWlscz86IHVua25vd25bXSB8IHVuZGVmaW5lZCB8IG51bGwsXG4gICAgY2F1c2U/OiBFcnJvclxuICApIHtcbiAgICBzdXBlcihtZXNzYWdlLCBjYXVzZSk7XG4gIH1cblxuICAvKipcbiAgICogQ3JlYXRlIGEgbmV3IGBBcHBsaWNhdGlvbkZhaWx1cmVgIGZyb20gYW4gRXJyb3Igb2JqZWN0LlxuICAgKlxuICAgKiBGaXJzdCBjYWxscyB7QGxpbmsgZW5zdXJlQXBwbGljYXRpb25GYWlsdXJlIHwgYGVuc3VyZUFwcGxpY2F0aW9uRmFpbHVyZShlcnJvcilgfSBhbmQgdGhlbiBvdmVycmlkZXMgYW55IGZpZWxkc1xuICAgKiBwcm92aWRlZCBpbiBgb3ZlcnJpZGVzYC5cbiAgICovXG4gIHB1YmxpYyBzdGF0aWMgZnJvbUVycm9yKGVycm9yOiBFcnJvciB8IHVua25vd24sIG92ZXJyaWRlcz86IEFwcGxpY2F0aW9uRmFpbHVyZU9wdGlvbnMpOiBBcHBsaWNhdGlvbkZhaWx1cmUge1xuICAgIGNvbnN0IGZhaWx1cmUgPSBlbnN1cmVBcHBsaWNhdGlvbkZhaWx1cmUoZXJyb3IpO1xuICAgIE9iamVjdC5hc3NpZ24oZmFpbHVyZSwgb3ZlcnJpZGVzKTtcbiAgICByZXR1cm4gZmFpbHVyZTtcbiAgfVxuXG4gIC8qKlxuICAgKiBDcmVhdGUgYSBuZXcgYEFwcGxpY2F0aW9uRmFpbHVyZWAuXG4gICAqXG4gICAqIEJ5IGRlZmF1bHQsIHdpbGwgYmUgcmV0cnlhYmxlICh1bmxlc3MgaXRzIGB0eXBlYCBpcyBpbmNsdWRlZCBpbiB7QGxpbmsgUmV0cnlQb2xpY3kubm9uUmV0cnlhYmxlRXJyb3JUeXBlc30pLlxuICAgKi9cbiAgcHVibGljIHN0YXRpYyBjcmVhdGUob3B0aW9uczogQXBwbGljYXRpb25GYWlsdXJlT3B0aW9ucyk6IEFwcGxpY2F0aW9uRmFpbHVyZSB7XG4gICAgY29uc3QgeyBtZXNzYWdlLCB0eXBlLCBub25SZXRyeWFibGUgPSBmYWxzZSwgZGV0YWlscywgY2F1c2UgfSA9IG9wdGlvbnM7XG4gICAgcmV0dXJuIG5ldyB0aGlzKG1lc3NhZ2UsIHR5cGUsIG5vblJldHJ5YWJsZSwgZGV0YWlscywgY2F1c2UpO1xuICB9XG5cbiAgLyoqXG4gICAqIEdldCBhIG5ldyBgQXBwbGljYXRpb25GYWlsdXJlYCB3aXRoIHRoZSB7QGxpbmsgbm9uUmV0cnlhYmxlfSBmbGFnIHNldCB0byBmYWxzZS4gTm90ZSB0aGF0IHRoaXMgZXJyb3Igd2lsbCBzdGlsbFxuICAgKiBub3QgYmUgcmV0cmllZCBpZiBpdHMgYHR5cGVgIGlzIGluY2x1ZGVkIGluIHtAbGluayBSZXRyeVBvbGljeS5ub25SZXRyeWFibGVFcnJvclR5cGVzfS5cbiAgICpcbiAgICogQHBhcmFtIG1lc3NhZ2UgT3B0aW9uYWwgZXJyb3IgbWVzc2FnZVxuICAgKiBAcGFyYW0gdHlwZSBPcHRpb25hbCBlcnJvciB0eXBlICh1c2VkIGJ5IHtAbGluayBSZXRyeVBvbGljeS5ub25SZXRyeWFibGVFcnJvclR5cGVzfSlcbiAgICogQHBhcmFtIGRldGFpbHMgT3B0aW9uYWwgZGV0YWlscyBhYm91dCB0aGUgZmFpbHVyZS4gU2VyaWFsaXplZCBieSB0aGUgV29ya2VyJ3Mge0BsaW5rIFBheWxvYWRDb252ZXJ0ZXJ9LlxuICAgKi9cbiAgcHVibGljIHN0YXRpYyByZXRyeWFibGUobWVzc2FnZT86IHN0cmluZyB8IG51bGwsIHR5cGU/OiBzdHJpbmcgfCBudWxsLCAuLi5kZXRhaWxzOiB1bmtub3duW10pOiBBcHBsaWNhdGlvbkZhaWx1cmUge1xuICAgIHJldHVybiBuZXcgdGhpcyhtZXNzYWdlLCB0eXBlID8/ICdFcnJvcicsIGZhbHNlLCBkZXRhaWxzKTtcbiAgfVxuXG4gIC8qKlxuICAgKiBHZXQgYSBuZXcgYEFwcGxpY2F0aW9uRmFpbHVyZWAgd2l0aCB0aGUge0BsaW5rIG5vblJldHJ5YWJsZX0gZmxhZyBzZXQgdG8gdHJ1ZS5cbiAgICpcbiAgICogV2hlbiB0aHJvd24gZnJvbSBhbiBBY3Rpdml0eSBvciBXb3JrZmxvdywgdGhlIEFjdGl2aXR5IG9yIFdvcmtmbG93IHdpbGwgbm90IGJlIHJldHJpZWQgKGV2ZW4gaWYgYHR5cGVgIGlzIG5vdFxuICAgKiBsaXN0ZWQgaW4ge0BsaW5rIFJldHJ5UG9saWN5Lm5vblJldHJ5YWJsZUVycm9yVHlwZXN9KS5cbiAgICpcbiAgICogQHBhcmFtIG1lc3NhZ2UgT3B0aW9uYWwgZXJyb3IgbWVzc2FnZVxuICAgKiBAcGFyYW0gdHlwZSBPcHRpb25hbCBlcnJvciB0eXBlXG4gICAqIEBwYXJhbSBkZXRhaWxzIE9wdGlvbmFsIGRldGFpbHMgYWJvdXQgdGhlIGZhaWx1cmUuIFNlcmlhbGl6ZWQgYnkgdGhlIFdvcmtlcidzIHtAbGluayBQYXlsb2FkQ29udmVydGVyfS5cbiAgICovXG4gIHB1YmxpYyBzdGF0aWMgbm9uUmV0cnlhYmxlKG1lc3NhZ2U/OiBzdHJpbmcgfCBudWxsLCB0eXBlPzogc3RyaW5nIHwgbnVsbCwgLi4uZGV0YWlsczogdW5rbm93bltdKTogQXBwbGljYXRpb25GYWlsdXJlIHtcbiAgICByZXR1cm4gbmV3IHRoaXMobWVzc2FnZSwgdHlwZSA/PyAnRXJyb3InLCB0cnVlLCBkZXRhaWxzKTtcbiAgfVxufVxuXG5leHBvcnQgaW50ZXJmYWNlIEFwcGxpY2F0aW9uRmFpbHVyZU9wdGlvbnMge1xuICAvKipcbiAgICogRXJyb3IgbWVzc2FnZVxuICAgKi9cbiAgbWVzc2FnZT86IHN0cmluZztcblxuICAvKipcbiAgICogRXJyb3IgdHlwZSAodXNlZCBieSB7QGxpbmsgUmV0cnlQb2xpY3kubm9uUmV0cnlhYmxlRXJyb3JUeXBlc30pXG4gICAqL1xuICB0eXBlPzogc3RyaW5nO1xuXG4gIC8qKlxuICAgKiBXaGV0aGVyIHRoZSBjdXJyZW50IEFjdGl2aXR5IG9yIFdvcmtmbG93IGNhbiBiZSByZXRyaWVkXG4gICAqXG4gICAqIEBkZWZhdWx0IGZhbHNlXG4gICAqL1xuICBub25SZXRyeWFibGU/OiBib29sZWFuO1xuXG4gIC8qKlxuICAgKiBEZXRhaWxzIGFib3V0IHRoZSBmYWlsdXJlLiBTZXJpYWxpemVkIGJ5IHRoZSBXb3JrZXIncyB7QGxpbmsgUGF5bG9hZENvbnZlcnRlcn0uXG4gICAqL1xuICBkZXRhaWxzPzogdW5rbm93bltdO1xuXG4gIC8qKlxuICAgKiBDYXVzZSBvZiB0aGUgZmFpbHVyZVxuICAgKi9cbiAgY2F1c2U/OiBFcnJvcjtcbn1cblxuLyoqXG4gKiBUaGlzIGVycm9yIGlzIHRocm93biB3aGVuIENhbmNlbGxhdGlvbiBoYXMgYmVlbiByZXF1ZXN0ZWQuIFRvIGFsbG93IENhbmNlbGxhdGlvbiB0byBoYXBwZW4sIGxldCBpdCBwcm9wYWdhdGUuIFRvXG4gKiBpZ25vcmUgQ2FuY2VsbGF0aW9uLCBjYXRjaCBpdCBhbmQgY29udGludWUgZXhlY3V0aW5nLiBOb3RlIHRoYXQgQ2FuY2VsbGF0aW9uIGNhbiBvbmx5IGJlIHJlcXVlc3RlZCBhIHNpbmdsZSB0aW1lLCBzb1xuICogeW91ciBXb3JrZmxvdy9BY3Rpdml0eSBFeGVjdXRpb24gd2lsbCBub3QgcmVjZWl2ZSBmdXJ0aGVyIENhbmNlbGxhdGlvbiByZXF1ZXN0cy5cbiAqXG4gKiBXaGVuIGEgV29ya2Zsb3cgb3IgQWN0aXZpdHkgaGFzIGJlZW4gc3VjY2Vzc2Z1bGx5IGNhbmNlbGxlZCwgYSBgQ2FuY2VsbGVkRmFpbHVyZWAgd2lsbCBiZSB0aGUgYGNhdXNlYC5cbiAqL1xuQFN5bWJvbEJhc2VkSW5zdGFuY2VPZkVycm9yKCdDYW5jZWxsZWRGYWlsdXJlJylcbmV4cG9ydCBjbGFzcyBDYW5jZWxsZWRGYWlsdXJlIGV4dGVuZHMgVGVtcG9yYWxGYWlsdXJlIHtcbiAgY29uc3RydWN0b3IoXG4gICAgbWVzc2FnZTogc3RyaW5nIHwgdW5kZWZpbmVkLFxuICAgIHB1YmxpYyByZWFkb25seSBkZXRhaWxzOiB1bmtub3duW10gPSBbXSxcbiAgICBjYXVzZT86IEVycm9yXG4gICkge1xuICAgIHN1cGVyKG1lc3NhZ2UsIGNhdXNlKTtcbiAgfVxufVxuXG4vKipcbiAqIFVzZWQgYXMgdGhlIGBjYXVzZWAgd2hlbiBhIFdvcmtmbG93IGhhcyBiZWVuIHRlcm1pbmF0ZWRcbiAqL1xuQFN5bWJvbEJhc2VkSW5zdGFuY2VPZkVycm9yKCdUZXJtaW5hdGVkRmFpbHVyZScpXG5leHBvcnQgY2xhc3MgVGVybWluYXRlZEZhaWx1cmUgZXh0ZW5kcyBUZW1wb3JhbEZhaWx1cmUge1xuICBjb25zdHJ1Y3RvcihtZXNzYWdlOiBzdHJpbmcgfCB1bmRlZmluZWQsIGNhdXNlPzogRXJyb3IpIHtcbiAgICBzdXBlcihtZXNzYWdlLCBjYXVzZSk7XG4gIH1cbn1cblxuLyoqXG4gKiBVc2VkIHRvIHJlcHJlc2VudCB0aW1lb3V0cyBvZiBBY3Rpdml0aWVzIGFuZCBXb3JrZmxvd3NcbiAqL1xuQFN5bWJvbEJhc2VkSW5zdGFuY2VPZkVycm9yKCdUaW1lb3V0RmFpbHVyZScpXG5leHBvcnQgY2xhc3MgVGltZW91dEZhaWx1cmUgZXh0ZW5kcyBUZW1wb3JhbEZhaWx1cmUge1xuICBjb25zdHJ1Y3RvcihcbiAgICBtZXNzYWdlOiBzdHJpbmcgfCB1bmRlZmluZWQsXG4gICAgcHVibGljIHJlYWRvbmx5IGxhc3RIZWFydGJlYXREZXRhaWxzOiB1bmtub3duLFxuICAgIHB1YmxpYyByZWFkb25seSB0aW1lb3V0VHlwZTogVGltZW91dFR5cGVcbiAgKSB7XG4gICAgc3VwZXIobWVzc2FnZSk7XG4gIH1cbn1cblxuLyoqXG4gKiBDb250YWlucyBpbmZvcm1hdGlvbiBhYm91dCBhbiBBY3Rpdml0eSBmYWlsdXJlLiBBbHdheXMgY29udGFpbnMgdGhlIG9yaWdpbmFsIHJlYXNvbiBmb3IgdGhlIGZhaWx1cmUgYXMgaXRzIGBjYXVzZWAuXG4gKiBGb3IgZXhhbXBsZSwgaWYgYW4gQWN0aXZpdHkgdGltZWQgb3V0LCB0aGUgY2F1c2Ugd2lsbCBiZSBhIHtAbGluayBUaW1lb3V0RmFpbHVyZX0uXG4gKlxuICogVGhpcyBleGNlcHRpb24gaXMgZXhwZWN0ZWQgdG8gYmUgdGhyb3duIG9ubHkgYnkgdGhlIGZyYW1ld29yayBjb2RlLlxuICovXG5AU3ltYm9sQmFzZWRJbnN0YW5jZU9mRXJyb3IoJ0FjdGl2aXR5RmFpbHVyZScpXG5leHBvcnQgY2xhc3MgQWN0aXZpdHlGYWlsdXJlIGV4dGVuZHMgVGVtcG9yYWxGYWlsdXJlIHtcbiAgcHVibGljIGNvbnN0cnVjdG9yKFxuICAgIG1lc3NhZ2U6IHN0cmluZyB8IHVuZGVmaW5lZCxcbiAgICBwdWJsaWMgcmVhZG9ubHkgYWN0aXZpdHlUeXBlOiBzdHJpbmcsXG4gICAgcHVibGljIHJlYWRvbmx5IGFjdGl2aXR5SWQ6IHN0cmluZyB8IHVuZGVmaW5lZCxcbiAgICBwdWJsaWMgcmVhZG9ubHkgcmV0cnlTdGF0ZTogUmV0cnlTdGF0ZSxcbiAgICBwdWJsaWMgcmVhZG9ubHkgaWRlbnRpdHk6IHN0cmluZyB8IHVuZGVmaW5lZCxcbiAgICBjYXVzZT86IEVycm9yXG4gICkge1xuICAgIHN1cGVyKG1lc3NhZ2UsIGNhdXNlKTtcbiAgfVxufVxuXG4vKipcbiAqIENvbnRhaW5zIGluZm9ybWF0aW9uIGFib3V0IGEgQ2hpbGQgV29ya2Zsb3cgZmFpbHVyZS4gQWx3YXlzIGNvbnRhaW5zIHRoZSByZWFzb24gZm9yIHRoZSBmYWlsdXJlIGFzIGl0cyB7QGxpbmsgY2F1c2V9LlxuICogRm9yIGV4YW1wbGUsIGlmIHRoZSBDaGlsZCB3YXMgVGVybWluYXRlZCwgdGhlIGBjYXVzZWAgaXMgYSB7QGxpbmsgVGVybWluYXRlZEZhaWx1cmV9LlxuICpcbiAqIFRoaXMgZXhjZXB0aW9uIGlzIGV4cGVjdGVkIHRvIGJlIHRocm93biBvbmx5IGJ5IHRoZSBmcmFtZXdvcmsgY29kZS5cbiAqL1xuQFN5bWJvbEJhc2VkSW5zdGFuY2VPZkVycm9yKCdDaGlsZFdvcmtmbG93RmFpbHVyZScpXG5leHBvcnQgY2xhc3MgQ2hpbGRXb3JrZmxvd0ZhaWx1cmUgZXh0ZW5kcyBUZW1wb3JhbEZhaWx1cmUge1xuICBwdWJsaWMgY29uc3RydWN0b3IoXG4gICAgcHVibGljIHJlYWRvbmx5IG5hbWVzcGFjZTogc3RyaW5nIHwgdW5kZWZpbmVkLFxuICAgIHB1YmxpYyByZWFkb25seSBleGVjdXRpb246IFdvcmtmbG93RXhlY3V0aW9uLFxuICAgIHB1YmxpYyByZWFkb25seSB3b3JrZmxvd1R5cGU6IHN0cmluZyxcbiAgICBwdWJsaWMgcmVhZG9ubHkgcmV0cnlTdGF0ZTogUmV0cnlTdGF0ZSxcbiAgICBjYXVzZT86IEVycm9yXG4gICkge1xuICAgIHN1cGVyKCdDaGlsZCBXb3JrZmxvdyBleGVjdXRpb24gZmFpbGVkJywgY2F1c2UpO1xuICB9XG59XG5cbi8qKlxuICogSWYgYGVycm9yYCBpcyBhbHJlYWR5IGFuIGBBcHBsaWNhdGlvbkZhaWx1cmVgLCByZXR1cm5zIGBlcnJvcmAuXG4gKlxuICogT3RoZXJ3aXNlLCBjb252ZXJ0cyBgZXJyb3JgIGludG8gYW4gYEFwcGxpY2F0aW9uRmFpbHVyZWAgd2l0aDpcbiAqXG4gKiAtIGBtZXNzYWdlYDogYGVycm9yLm1lc3NhZ2VgIG9yIGBTdHJpbmcoZXJyb3IpYFxuICogLSBgdHlwZWA6IGBlcnJvci5jb25zdHJ1Y3Rvci5uYW1lYCBvciBgZXJyb3IubmFtZWBcbiAqIC0gYHN0YWNrYDogYGVycm9yLnN0YWNrYCBvciBgJydgXG4gKi9cbmV4cG9ydCBmdW5jdGlvbiBlbnN1cmVBcHBsaWNhdGlvbkZhaWx1cmUoZXJyb3I6IHVua25vd24pOiBBcHBsaWNhdGlvbkZhaWx1cmUge1xuICBpZiAoZXJyb3IgaW5zdGFuY2VvZiBBcHBsaWNhdGlvbkZhaWx1cmUpIHtcbiAgICByZXR1cm4gZXJyb3I7XG4gIH1cblxuICBjb25zdCBtZXNzYWdlID0gKGlzUmVjb3JkKGVycm9yKSAmJiBTdHJpbmcoZXJyb3IubWVzc2FnZSkpIHx8IFN0cmluZyhlcnJvcik7XG4gIGNvbnN0IHR5cGUgPSAoaXNSZWNvcmQoZXJyb3IpICYmIChlcnJvci5jb25zdHJ1Y3Rvcj8ubmFtZSA/PyBlcnJvci5uYW1lKSkgfHwgdW5kZWZpbmVkO1xuICBjb25zdCBmYWlsdXJlID0gQXBwbGljYXRpb25GYWlsdXJlLmNyZWF0ZSh7IG1lc3NhZ2UsIHR5cGUsIG5vblJldHJ5YWJsZTogZmFsc2UgfSk7XG4gIGZhaWx1cmUuc3RhY2sgPSAoaXNSZWNvcmQoZXJyb3IpICYmIFN0cmluZyhlcnJvci5zdGFjaykpIHx8ICcnO1xuICByZXR1cm4gZmFpbHVyZTtcbn1cblxuLyoqXG4gKiBJZiBgZXJyYCBpcyBhbiBFcnJvciBpdCBpcyB0dXJuZWQgaW50byBhbiBgQXBwbGljYXRpb25GYWlsdXJlYC5cbiAqXG4gKiBJZiBgZXJyYCB3YXMgYWxyZWFkeSBhIGBUZW1wb3JhbEZhaWx1cmVgLCByZXR1cm5zIHRoZSBvcmlnaW5hbCBlcnJvci5cbiAqXG4gKiBPdGhlcndpc2UgcmV0dXJucyBhbiBgQXBwbGljYXRpb25GYWlsdXJlYCB3aXRoIGBTdHJpbmcoZXJyKWAgYXMgdGhlIG1lc3NhZ2UuXG4gKi9cbmV4cG9ydCBmdW5jdGlvbiBlbnN1cmVUZW1wb3JhbEZhaWx1cmUoZXJyOiB1bmtub3duKTogVGVtcG9yYWxGYWlsdXJlIHtcbiAgaWYgKGVyciBpbnN0YW5jZW9mIFRlbXBvcmFsRmFpbHVyZSkge1xuICAgIHJldHVybiBlcnI7XG4gIH1cbiAgcmV0dXJuIGVuc3VyZUFwcGxpY2F0aW9uRmFpbHVyZShlcnIpO1xufVxuXG4vKipcbiAqIEdldCB0aGUgcm9vdCBjYXVzZSBtZXNzYWdlIG9mIGdpdmVuIGBlcnJvcmAuXG4gKlxuICogSW4gY2FzZSBgZXJyb3JgIGlzIGEge0BsaW5rIFRlbXBvcmFsRmFpbHVyZX0sIHJlY3Vyc2UgdGhlIGBjYXVzZWAgY2hhaW4gYW5kIHJldHVybiB0aGUgcm9vdCBgY2F1c2UubWVzc2FnZWAuXG4gKiBPdGhlcndpc2UsIHJldHVybiBgZXJyb3IubWVzc2FnZWAuXG4gKi9cbmV4cG9ydCBmdW5jdGlvbiByb290Q2F1c2UoZXJyb3I6IHVua25vd24pOiBzdHJpbmcgfCB1bmRlZmluZWQge1xuICBpZiAoZXJyb3IgaW5zdGFuY2VvZiBUZW1wb3JhbEZhaWx1cmUpIHtcbiAgICByZXR1cm4gZXJyb3IuY2F1c2UgPyByb290Q2F1c2UoZXJyb3IuY2F1c2UpIDogZXJyb3IubWVzc2FnZTtcbiAgfVxuICByZXR1cm4gZXJyb3JNZXNzYWdlKGVycm9yKTtcbn1cbiIsIi8qKlxuICogQ29tbW9uIGxpYnJhcnkgZm9yIGNvZGUgdGhhdCdzIHVzZWQgYWNyb3NzIHRoZSBDbGllbnQsIFdvcmtlciwgYW5kL29yIFdvcmtmbG93XG4gKlxuICogQG1vZHVsZVxuICovXG5cbmltcG9ydCAqIGFzIGVuY29kaW5nIGZyb20gJy4vZW5jb2RpbmcnO1xuaW1wb3J0ICogYXMgaGVscGVycyBmcm9tICcuL3R5cGUtaGVscGVycyc7XG5cbmV4cG9ydCAqIGZyb20gJy4vYWN0aXZpdHktb3B0aW9ucyc7XG5leHBvcnQgKiBmcm9tICcuL2NvbnZlcnRlci9kYXRhLWNvbnZlcnRlcic7XG5leHBvcnQgKiBmcm9tICcuL2NvbnZlcnRlci9mYWlsdXJlLWNvbnZlcnRlcic7XG5leHBvcnQgKiBmcm9tICcuL2NvbnZlcnRlci9wYXlsb2FkLWNvZGVjJztcbmV4cG9ydCAqIGZyb20gJy4vY29udmVydGVyL3BheWxvYWQtY29udmVydGVyJztcbmV4cG9ydCAqIGZyb20gJy4vY29udmVydGVyL3R5cGVzJztcbmV4cG9ydCAqIGZyb20gJy4vZGVwcmVjYXRlZC10aW1lJztcbmV4cG9ydCAqIGZyb20gJy4vZXJyb3JzJztcbmV4cG9ydCAqIGZyb20gJy4vZmFpbHVyZSc7XG5leHBvcnQgeyBIZWFkZXJzLCBOZXh0IH0gZnJvbSAnLi9pbnRlcmNlcHRvcnMnO1xuZXhwb3J0ICogZnJvbSAnLi9pbnRlcmZhY2VzJztcbmV4cG9ydCAqIGZyb20gJy4vbG9nZ2VyJztcbmV4cG9ydCAqIGZyb20gJy4vcmV0cnktcG9saWN5JztcbmV4cG9ydCB0eXBlIHsgVGltZXN0YW1wLCBEdXJhdGlvbiwgU3RyaW5nVmFsdWUgfSBmcm9tICcuL3RpbWUnO1xuZXhwb3J0ICogZnJvbSAnLi93b3JrZmxvdy1oYW5kbGUnO1xuZXhwb3J0ICogZnJvbSAnLi93b3JrZmxvdy1vcHRpb25zJztcbmV4cG9ydCAqIGZyb20gJy4vdmVyc2lvbmluZy1pbnRlbnQnO1xuXG4vKipcbiAqIEVuY29kZSBhIFVURi04IHN0cmluZyBpbnRvIGEgVWludDhBcnJheVxuICpcbiAqIEBoaWRkZW5cbiAqIEBkZXByZWNhdGVkIC0gbWVhbnQgZm9yIGludGVybmFsIHVzZSBvbmx5XG4gKi9cbmV4cG9ydCBmdW5jdGlvbiB1OChzOiBzdHJpbmcpOiBVaW50OEFycmF5IHtcbiAgcmV0dXJuIGVuY29kaW5nLmVuY29kZShzKTtcbn1cblxuLyoqXG4gKiBEZWNvZGUgYSBVaW50OEFycmF5IGludG8gYSBVVEYtOCBzdHJpbmdcbiAqXG4gKiBAaGlkZGVuXG4gKiBAZGVwcmVjYXRlZCAtIG1lYW50IGZvciBpbnRlcm5hbCB1c2Ugb25seVxuICovXG5leHBvcnQgZnVuY3Rpb24gc3RyKGFycjogVWludDhBcnJheSk6IHN0cmluZyB7XG4gIHJldHVybiBlbmNvZGluZy5kZWNvZGUoYXJyKTtcbn1cblxuLyoqXG4gKiBHZXQgYGVycm9yLm1lc3NhZ2VgIChvciBgdW5kZWZpbmVkYCBpZiBub3QgcHJlc2VudClcbiAqXG4gKiBAaGlkZGVuXG4gKiBAZGVwcmVjYXRlZCAtIG1lYW50IGZvciBpbnRlcm5hbCB1c2Ugb25seVxuICovXG5leHBvcnQgZnVuY3Rpb24gZXJyb3JNZXNzYWdlKGVycm9yOiB1bmtub3duKTogc3RyaW5nIHwgdW5kZWZpbmVkIHtcbiAgcmV0dXJuIGhlbHBlcnMuZXJyb3JNZXNzYWdlKGVycm9yKTtcbn1cblxuLyoqXG4gKiBHZXQgYGVycm9yLmNvZGVgIChvciBgdW5kZWZpbmVkYCBpZiBub3QgcHJlc2VudClcbiAqXG4gKiBAaGlkZGVuXG4gKiBAZGVwcmVjYXRlZCAtIG1lYW50IGZvciBpbnRlcm5hbCB1c2Ugb25seVxuICovXG5leHBvcnQgZnVuY3Rpb24gZXJyb3JDb2RlKGVycm9yOiB1bmtub3duKTogc3RyaW5nIHwgdW5kZWZpbmVkIHtcbiAgcmV0dXJuIGhlbHBlcnMuZXJyb3JDb2RlKGVycm9yKTtcbn1cbiIsImltcG9ydCB7IEFueUZ1bmMsIE9taXRMYXN0UGFyYW0gfSBmcm9tICcuL3R5cGUtaGVscGVycyc7XG5pbXBvcnQgeyBQYXlsb2FkIH0gZnJvbSAnLi9pbnRlcmZhY2VzJztcblxuLyoqXG4gKiBUeXBlIG9mIHRoZSBuZXh0IGZ1bmN0aW9uIGZvciBhIGdpdmVuIGludGVyY2VwdG9yIGZ1bmN0aW9uXG4gKlxuICogQ2FsbGVkIGZyb20gYW4gaW50ZXJjZXB0b3IgdG8gY29udGludWUgdGhlIGludGVyY2VwdGlvbiBjaGFpblxuICovXG5leHBvcnQgdHlwZSBOZXh0PElGLCBGTiBleHRlbmRzIGtleW9mIElGPiA9IFJlcXVpcmVkPElGPltGTl0gZXh0ZW5kcyBBbnlGdW5jID8gT21pdExhc3RQYXJhbTxSZXF1aXJlZDxJRj5bRk5dPiA6IG5ldmVyO1xuXG4vKiogSGVhZGVycyBhcmUganVzdCBhIG1hcHBpbmcgb2YgaGVhZGVyIG5hbWUgdG8gUGF5bG9hZCAqL1xuZXhwb3J0IHR5cGUgSGVhZGVycyA9IFJlY29yZDxzdHJpbmcsIFBheWxvYWQ+O1xuXG4vKipcbiAqIENvbXBvc2UgYWxsIGludGVyY2VwdG9yIG1ldGhvZHMgaW50byBhIHNpbmdsZSBmdW5jdGlvbi5cbiAqXG4gKiBDYWxsaW5nIHRoZSBjb21wb3NlZCBmdW5jdGlvbiByZXN1bHRzIGluIGNhbGxpbmcgZWFjaCBvZiB0aGUgcHJvdmlkZWQgaW50ZXJjZXB0b3IsIGluIG9yZGVyIChmcm9tIHRoZSBmaXJzdCB0b1xuICogdGhlIGxhc3QpLCBmb2xsb3dlZCBieSB0aGUgb3JpZ2luYWwgZnVuY3Rpb24gcHJvdmlkZWQgYXMgYXJndW1lbnQgdG8gYGNvbXBvc2VJbnRlcmNlcHRvcnMoKWAuXG4gKlxuICogQHBhcmFtIGludGVyY2VwdG9ycyBhIGxpc3Qgb2YgaW50ZXJjZXB0b3JzXG4gKiBAcGFyYW0gbWV0aG9kIHRoZSBuYW1lIG9mIHRoZSBpbnRlcmNlcHRvciBtZXRob2QgdG8gY29tcG9zZVxuICogQHBhcmFtIG5leHQgdGhlIG9yaWdpbmFsIGZ1bmN0aW9uIHRvIGJlIGV4ZWN1dGVkIGF0IHRoZSBlbmQgb2YgdGhlIGludGVyY2VwdGlvbiBjaGFpblxuICovXG4vLyB0cy1wcnVuZS1pZ25vcmUtbmV4dCAoaW1wb3J0ZWQgdmlhIGxpYi9pbnRlcmNlcHRvcnMpXG5leHBvcnQgZnVuY3Rpb24gY29tcG9zZUludGVyY2VwdG9yczxJLCBNIGV4dGVuZHMga2V5b2YgST4oaW50ZXJjZXB0b3JzOiBJW10sIG1ldGhvZDogTSwgbmV4dDogTmV4dDxJLCBNPik6IE5leHQ8SSwgTT4ge1xuICBmb3IgKGxldCBpID0gaW50ZXJjZXB0b3JzLmxlbmd0aCAtIDE7IGkgPj0gMDsgLS1pKSB7XG4gICAgY29uc3QgaW50ZXJjZXB0b3IgPSBpbnRlcmNlcHRvcnNbaV07XG4gICAgaWYgKGludGVyY2VwdG9yW21ldGhvZF0gIT09IHVuZGVmaW5lZCkge1xuICAgICAgY29uc3QgcHJldiA9IG5leHQ7XG4gICAgICAvLyBXZSBsb3NlIHR5cGUgc2FmZXR5IGhlcmUgYmVjYXVzZSBUeXBlc2NyaXB0IGNhbid0IGRlZHVjZSB0aGF0IGludGVyY2VwdG9yW21ldGhvZF0gaXMgYSBmdW5jdGlvbiB0aGF0IHJldHVybnNcbiAgICAgIC8vIHRoZSBzYW1lIHR5cGUgYXMgTmV4dDxJLCBNPlxuICAgICAgbmV4dCA9ICgoaW5wdXQ6IGFueSkgPT4gKGludGVyY2VwdG9yW21ldGhvZF0gYXMgYW55KShpbnB1dCwgcHJldikpIGFzIGFueTtcbiAgICB9XG4gIH1cbiAgcmV0dXJuIG5leHQ7XG59XG4iLCJpbXBvcnQgdHlwZSB7IHRlbXBvcmFsIH0gZnJvbSAnQHRlbXBvcmFsaW8vcHJvdG8nO1xuXG5leHBvcnQgdHlwZSBQYXlsb2FkID0gdGVtcG9yYWwuYXBpLmNvbW1vbi52MS5JUGF5bG9hZDtcblxuLyoqIFR5cGUgdGhhdCBjYW4gYmUgcmV0dXJuZWQgZnJvbSBhIFdvcmtmbG93IGBleGVjdXRlYCBmdW5jdGlvbiAqL1xuZXhwb3J0IHR5cGUgV29ya2Zsb3dSZXR1cm5UeXBlID0gUHJvbWlzZTxhbnk+O1xuZXhwb3J0IHR5cGUgV29ya2Zsb3dVcGRhdGVUeXBlID0gKC4uLmFyZ3M6IGFueVtdKSA9PiBQcm9taXNlPGFueT4gfCBhbnk7XG5leHBvcnQgdHlwZSBXb3JrZmxvd1VwZGF0ZVZhbGlkYXRvclR5cGUgPSAoLi4uYXJnczogYW55W10pID0+IHZvaWQ7XG5leHBvcnQgdHlwZSBXb3JrZmxvd1VwZGF0ZUFubm90YXRlZFR5cGUgPSB7XG4gIGhhbmRsZXI6IFdvcmtmbG93VXBkYXRlVHlwZTtcbiAgdmFsaWRhdG9yPzogV29ya2Zsb3dVcGRhdGVWYWxpZGF0b3JUeXBlO1xuICBkZXNjcmlwdGlvbj86IHN0cmluZztcbn07XG5leHBvcnQgdHlwZSBXb3JrZmxvd1NpZ25hbFR5cGUgPSAoLi4uYXJnczogYW55W10pID0+IFByb21pc2U8dm9pZD4gfCB2b2lkO1xuZXhwb3J0IHR5cGUgV29ya2Zsb3dTaWduYWxBbm5vdGF0ZWRUeXBlID0geyBoYW5kbGVyOiBXb3JrZmxvd1NpZ25hbFR5cGU7IGRlc2NyaXB0aW9uPzogc3RyaW5nIH07XG5leHBvcnQgdHlwZSBXb3JrZmxvd1F1ZXJ5VHlwZSA9ICguLi5hcmdzOiBhbnlbXSkgPT4gYW55O1xuZXhwb3J0IHR5cGUgV29ya2Zsb3dRdWVyeUFubm90YXRlZFR5cGUgPSB7IGhhbmRsZXI6IFdvcmtmbG93UXVlcnlUeXBlOyBkZXNjcmlwdGlvbj86IHN0cmluZyB9O1xuXG4vKipcbiAqIEJyb2FkIFdvcmtmbG93IGZ1bmN0aW9uIGRlZmluaXRpb24sIHNwZWNpZmljIFdvcmtmbG93cyB3aWxsIHR5cGljYWxseSB1c2UgYSBuYXJyb3dlciB0eXBlIGRlZmluaXRpb24sIGUuZzpcbiAqIGBgYHRzXG4gKiBleHBvcnQgYXN5bmMgZnVuY3Rpb24gbXlXb3JrZmxvdyhhcmcxOiBudW1iZXIsIGFyZzI6IHN0cmluZyk6IFByb21pc2U8c3RyaW5nPjtcbiAqIGBgYFxuICovXG5leHBvcnQgdHlwZSBXb3JrZmxvdyA9ICguLi5hcmdzOiBhbnlbXSkgPT4gV29ya2Zsb3dSZXR1cm5UeXBlO1xuXG5kZWNsYXJlIGNvbnN0IGFyZ3NCcmFuZDogdW5pcXVlIHN5bWJvbDtcbmRlY2xhcmUgY29uc3QgcmV0QnJhbmQ6IHVuaXF1ZSBzeW1ib2w7XG5cbi8qKlxuICogQW4gaW50ZXJmYWNlIHJlcHJlc2VudGluZyBhIFdvcmtmbG93IHVwZGF0ZSBkZWZpbml0aW9uLCBhcyByZXR1cm5lZCBmcm9tIHtAbGluayBkZWZpbmVVcGRhdGV9XG4gKlxuICogQHJlbWFya3MgYEFyZ3NgIGNhbiBiZSB1c2VkIGZvciBwYXJhbWV0ZXIgdHlwZSBpbmZlcmVuY2UgaW4gaGFuZGxlciBmdW5jdGlvbnMgYW5kIFdvcmtmbG93SGFuZGxlIG1ldGhvZHMuXG4gKiBgTmFtZWAgY2FuIG9wdGlvbmFsbHkgYmUgc3BlY2lmaWVkIHdpdGggYSBzdHJpbmcgbGl0ZXJhbCB0eXBlIHRvIHByZXNlcnZlIHR5cGUtbGV2ZWwga25vd2xlZGdlIG9mIHRoZSB1cGRhdGUgbmFtZS5cbiAqL1xuZXhwb3J0IGludGVyZmFjZSBVcGRhdGVEZWZpbml0aW9uPFJldCwgQXJncyBleHRlbmRzIGFueVtdID0gW10sIE5hbWUgZXh0ZW5kcyBzdHJpbmcgPSBzdHJpbmc+IHtcbiAgdHlwZTogJ3VwZGF0ZSc7XG4gIG5hbWU6IE5hbWU7XG4gIC8qKlxuICAgKiBWaXJ0dWFsIHR5cGUgYnJhbmQgdG8gbWFpbnRhaW4gYSBkaXN0aW5jdGlvbiBiZXR3ZWVuIHtAbGluayBVcGRhdGVEZWZpbml0aW9ufSB0eXBlcyB3aXRoIGRpZmZlcmVudCBhcmdzLlxuICAgKiBUaGlzIGZpZWxkIGlzIG5vdCBwcmVzZW50IGF0IHJ1bi10aW1lLlxuICAgKi9cbiAgW2FyZ3NCcmFuZF06IEFyZ3M7XG4gIC8qKlxuICAgKiBWaXJ0dWFsIHR5cGUgYnJhbmQgdG8gbWFpbnRhaW4gYSBkaXN0aW5jdGlvbiBiZXR3ZWVuIHtAbGluayBVcGRhdGVEZWZpbml0aW9ufSB0eXBlcyB3aXRoIGRpZmZlcmVudCByZXR1cm4gdHlwZXMuXG4gICAqIFRoaXMgZmllbGQgaXMgbm90IHByZXNlbnQgYXQgcnVuLXRpbWUuXG4gICAqL1xuICBbcmV0QnJhbmRdOiBSZXQ7XG59XG5cbi8qKlxuICogQW4gaW50ZXJmYWNlIHJlcHJlc2VudGluZyBhIFdvcmtmbG93IHNpZ25hbCBkZWZpbml0aW9uLCBhcyByZXR1cm5lZCBmcm9tIHtAbGluayBkZWZpbmVTaWduYWx9XG4gKlxuICogQHJlbWFya3MgYEFyZ3NgIGNhbiBiZSB1c2VkIGZvciBwYXJhbWV0ZXIgdHlwZSBpbmZlcmVuY2UgaW4gaGFuZGxlciBmdW5jdGlvbnMgYW5kIFdvcmtmbG93SGFuZGxlIG1ldGhvZHMuXG4gKiBgTmFtZWAgY2FuIG9wdGlvbmFsbHkgYmUgc3BlY2lmaWVkIHdpdGggYSBzdHJpbmcgbGl0ZXJhbCB0eXBlIHRvIHByZXNlcnZlIHR5cGUtbGV2ZWwga25vd2xlZGdlIG9mIHRoZSBzaWduYWwgbmFtZS5cbiAqL1xuZXhwb3J0IGludGVyZmFjZSBTaWduYWxEZWZpbml0aW9uPEFyZ3MgZXh0ZW5kcyBhbnlbXSA9IFtdLCBOYW1lIGV4dGVuZHMgc3RyaW5nID0gc3RyaW5nPiB7XG4gIHR5cGU6ICdzaWduYWwnO1xuICBuYW1lOiBOYW1lO1xuICAvKipcbiAgICogVmlydHVhbCB0eXBlIGJyYW5kIHRvIG1haW50YWluIGEgZGlzdGluY3Rpb24gYmV0d2VlbiB7QGxpbmsgU2lnbmFsRGVmaW5pdGlvbn0gdHlwZXMgd2l0aCBkaWZmZXJlbnQgYXJncy5cbiAgICogVGhpcyBmaWVsZCBpcyBub3QgcHJlc2VudCBhdCBydW4tdGltZS5cbiAgICovXG4gIFthcmdzQnJhbmRdOiBBcmdzO1xufVxuXG4vKipcbiAqIEFuIGludGVyZmFjZSByZXByZXNlbnRpbmcgYSBXb3JrZmxvdyBxdWVyeSBkZWZpbml0aW9uIGFzIHJldHVybmVkIGZyb20ge0BsaW5rIGRlZmluZVF1ZXJ5fVxuICpcbiAqIEByZW1hcmtzIGBBcmdzYCBhbmQgYFJldGAgY2FuIGJlIHVzZWQgZm9yIHBhcmFtZXRlciB0eXBlIGluZmVyZW5jZSBpbiBoYW5kbGVyIGZ1bmN0aW9ucyBhbmQgV29ya2Zsb3dIYW5kbGUgbWV0aG9kcy5cbiAqIGBOYW1lYCBjYW4gb3B0aW9uYWxseSBiZSBzcGVjaWZpZWQgd2l0aCBhIHN0cmluZyBsaXRlcmFsIHR5cGUgdG8gcHJlc2VydmUgdHlwZS1sZXZlbCBrbm93bGVkZ2Ugb2YgdGhlIHF1ZXJ5IG5hbWUuXG4gKi9cbmV4cG9ydCBpbnRlcmZhY2UgUXVlcnlEZWZpbml0aW9uPFJldCwgQXJncyBleHRlbmRzIGFueVtdID0gW10sIE5hbWUgZXh0ZW5kcyBzdHJpbmcgPSBzdHJpbmc+IHtcbiAgdHlwZTogJ3F1ZXJ5JztcbiAgbmFtZTogTmFtZTtcbiAgLyoqXG4gICAqIFZpcnR1YWwgdHlwZSBicmFuZCB0byBtYWludGFpbiBhIGRpc3RpbmN0aW9uIGJldHdlZW4ge0BsaW5rIFF1ZXJ5RGVmaW5pdGlvbn0gdHlwZXMgd2l0aCBkaWZmZXJlbnQgYXJncy5cbiAgICogVGhpcyBmaWVsZCBpcyBub3QgcHJlc2VudCBhdCBydW4tdGltZS5cbiAgICovXG4gIFthcmdzQnJhbmRdOiBBcmdzO1xuICAvKipcbiAgICogVmlydHVhbCB0eXBlIGJyYW5kIHRvIG1haW50YWluIGEgZGlzdGluY3Rpb24gYmV0d2VlbiB7QGxpbmsgUXVlcnlEZWZpbml0aW9ufSB0eXBlcyB3aXRoIGRpZmZlcmVudCByZXR1cm4gdHlwZXMuXG4gICAqIFRoaXMgZmllbGQgaXMgbm90IHByZXNlbnQgYXQgcnVuLXRpbWUuXG4gICAqL1xuICBbcmV0QnJhbmRdOiBSZXQ7XG59XG5cbi8qKiBHZXQgdGhlIFwidW53cmFwcGVkXCIgcmV0dXJuIHR5cGUgKHdpdGhvdXQgUHJvbWlzZSkgb2YgdGhlIGV4ZWN1dGUgaGFuZGxlciBmcm9tIFdvcmtmbG93IHR5cGUgYFdgICovXG5leHBvcnQgdHlwZSBXb3JrZmxvd1Jlc3VsdFR5cGU8VyBleHRlbmRzIFdvcmtmbG93PiA9IFJldHVyblR5cGU8Vz4gZXh0ZW5kcyBQcm9taXNlPGluZmVyIFI+ID8gUiA6IG5ldmVyO1xuXG4vKipcbiAqIElmIGFub3RoZXIgU0RLIGNyZWF0ZXMgYSBTZWFyY2ggQXR0cmlidXRlIHRoYXQncyBub3QgYW4gYXJyYXksIHdlIHdyYXAgaXQgaW4gYW4gYXJyYXkuXG4gKlxuICogRGF0ZXMgYXJlIHNlcmlhbGl6ZWQgYXMgSVNPIHN0cmluZ3MuXG4gKi9cbmV4cG9ydCB0eXBlIFNlYXJjaEF0dHJpYnV0ZXMgPSBSZWNvcmQ8c3RyaW5nLCBTZWFyY2hBdHRyaWJ1dGVWYWx1ZSB8IFJlYWRvbmx5PFNlYXJjaEF0dHJpYnV0ZVZhbHVlPiB8IHVuZGVmaW5lZD47XG5leHBvcnQgdHlwZSBTZWFyY2hBdHRyaWJ1dGVWYWx1ZSA9IHN0cmluZ1tdIHwgbnVtYmVyW10gfCBib29sZWFuW10gfCBEYXRlW107XG5cbmV4cG9ydCBpbnRlcmZhY2UgQWN0aXZpdHlGdW5jdGlvbjxQIGV4dGVuZHMgYW55W10gPSBhbnlbXSwgUiA9IGFueT4ge1xuICAoLi4uYXJnczogUCk6IFByb21pc2U8Uj47XG59XG5cbi8qKlxuICogTWFwcGluZyBvZiBBY3Rpdml0eSBuYW1lIHRvIGZ1bmN0aW9uXG4gKiBAZGVwcmVjYXRlZCBub3QgcmVxdWlyZWQgYW55bW9yZSwgZm9yIHVudHlwZWQgYWN0aXZpdGllcyB1c2Uge0BsaW5rIFVudHlwZWRBY3Rpdml0aWVzfVxuICovXG5leHBvcnQgdHlwZSBBY3Rpdml0eUludGVyZmFjZSA9IFJlY29yZDxzdHJpbmcsIEFjdGl2aXR5RnVuY3Rpb24+O1xuXG4vKipcbiAqIE1hcHBpbmcgb2YgQWN0aXZpdHkgbmFtZSB0byBmdW5jdGlvblxuICovXG5leHBvcnQgdHlwZSBVbnR5cGVkQWN0aXZpdGllcyA9IFJlY29yZDxzdHJpbmcsIEFjdGl2aXR5RnVuY3Rpb24+O1xuXG4vKipcbiAqIEEgd29ya2Zsb3cncyBoaXN0b3J5IGFuZCBJRC4gVXNlZnVsIGZvciByZXBsYXkuXG4gKi9cbmV4cG9ydCBpbnRlcmZhY2UgSGlzdG9yeUFuZFdvcmtmbG93SWQge1xuICB3b3JrZmxvd0lkOiBzdHJpbmc7XG4gIGhpc3Rvcnk6IHRlbXBvcmFsLmFwaS5oaXN0b3J5LnYxLkhpc3RvcnkgfCB1bmtub3duIHwgdW5kZWZpbmVkO1xufVxuIiwiZXhwb3J0IHR5cGUgTG9nTGV2ZWwgPSAnVFJBQ0UnIHwgJ0RFQlVHJyB8ICdJTkZPJyB8ICdXQVJOJyB8ICdFUlJPUic7XG5cbmV4cG9ydCB0eXBlIExvZ01ldGFkYXRhID0gUmVjb3JkPHN0cmluZyB8IHN5bWJvbCwgYW55PjtcblxuLyoqXG4gKiBJbXBsZW1lbnQgdGhpcyBpbnRlcmZhY2UgaW4gb3JkZXIgdG8gY3VzdG9taXplIHdvcmtlciBsb2dnaW5nXG4gKi9cbmV4cG9ydCBpbnRlcmZhY2UgTG9nZ2VyIHtcbiAgbG9nKGxldmVsOiBMb2dMZXZlbCwgbWVzc2FnZTogc3RyaW5nLCBtZXRhPzogTG9nTWV0YWRhdGEpOiBhbnk7XG4gIHRyYWNlKG1lc3NhZ2U6IHN0cmluZywgbWV0YT86IExvZ01ldGFkYXRhKTogYW55O1xuICBkZWJ1ZyhtZXNzYWdlOiBzdHJpbmcsIG1ldGE/OiBMb2dNZXRhZGF0YSk6IGFueTtcbiAgaW5mbyhtZXNzYWdlOiBzdHJpbmcsIG1ldGE/OiBMb2dNZXRhZGF0YSk6IGFueTtcbiAgd2FybihtZXNzYWdlOiBzdHJpbmcsIG1ldGE/OiBMb2dNZXRhZGF0YSk6IGFueTtcbiAgZXJyb3IobWVzc2FnZTogc3RyaW5nLCBtZXRhPzogTG9nTWV0YWRhdGEpOiBhbnk7XG59XG5cbi8qKlxuICogUG9zc2libGUgdmFsdWVzIG9mIHRoZSBgc2RrQ29tcG9uZW50YCBtZXRhIGF0dHJpYnV0ZXMgb24gbG9nIG1lc3NhZ2VzLiBUaGlzXG4gKiBhdHRyaWJ1dGUgaW5kaWNhdGVzIHdoaWNoIHN1YnN5c3RlbSBlbWl0dGVkIHRoZSBsb2cgbWVzc2FnZTsgdGhpcyBtYXkgZm9yXG4gKiBleGFtcGxlIGJlIHVzZWQgdG8gaW1wbGVtZW50IGZpbmUtZ3JhaW5lZCBmaWx0ZXJpbmcgb2YgbG9nIG1lc3NhZ2VzLlxuICpcbiAqIE5vdGUgdGhhdCB0aGVyZSBpcyBubyBndWFyYW50ZWUgdGhhdCB0aGlzIGxpc3Qgd2lsbCByZW1haW4gc3RhYmxlIGluIHRoZVxuICogZnV0dXJlOyB2YWx1ZXMgbWF5IGJlIGFkZGVkIG9yIHJlbW92ZWQsIGFuZCBtZXNzYWdlcyB0aGF0IGFyZSBjdXJyZW50bHlcbiAqIGVtaXR0ZWQgd2l0aCBzb21lIGBzZGtDb21wb25lbnRgIHZhbHVlIG1heSB1c2UgYSBkaWZmZXJlbnQgdmFsdWUgaW4gdGhlIGZ1dHVyZS5cbiAqL1xuZXhwb3J0IGVudW0gU2RrQ29tcG9uZW50IHtcbiAgLyoqXG4gICAqIENvbXBvbmVudCBuYW1lIGZvciBtZXNzYWdlcyBlbWl0ZWQgZnJvbSBXb3JrZmxvdyBjb2RlLCB1c2luZyB0aGUge0BsaW5rIFdvcmtmbG93IGNvbnRleHQgbG9nZ2VyfHdvcmtmbG93LmxvZ30uXG4gICAqIFRoZSBTREsgaXRzZWxmIG5ldmVyIHB1Ymxpc2hlcyBtZXNzYWdlcyB3aXRoIHRoaXMgY29tcG9uZW50IG5hbWUuXG4gICAqL1xuICB3b3JrZmxvdyA9ICd3b3JrZmxvdycsXG5cbiAgLyoqXG4gICAqIENvbXBvbmVudCBuYW1lIGZvciBtZXNzYWdlcyBlbWl0ZWQgZnJvbSBhbiBhY3Rpdml0eSwgdXNpbmcgdGhlIHtAbGluayBhY3Rpdml0eSBjb250ZXh0IGxvZ2dlcnxDb250ZXh0LmxvZ30uXG4gICAqIFRoZSBTREsgaXRzZWxmIG5ldmVyIHB1Ymxpc2hlcyBtZXNzYWdlcyB3aXRoIHRoaXMgY29tcG9uZW50IG5hbWUuXG4gICAqL1xuICBhY3Rpdml0eSA9ICdhY3Rpdml0eScsXG5cbiAgLyoqXG4gICAqIENvbXBvbmVudCBuYW1lIGZvciBtZXNzYWdlcyBlbWl0ZWQgZnJvbSBhIFRlbXBvcmFsIFdvcmtlciBpbnN0YW5jZS5cbiAgICpcbiAgICogVGhpcyBub3RhYmx5IGluY2x1ZGVzOlxuICAgKiAtIElzc3VlcyB3aXRoIFdvcmtlciBvciBydW50aW1lIGNvbmZpZ3VyYXRpb24sIG9yIHRoZSBKUyBleGVjdXRpb24gZW52aXJvbm1lbnQ7XG4gICAqIC0gV29ya2VyJ3MsIEFjdGl2aXR5J3MsIGFuZCBXb3JrZmxvdydzIGxpZmVjeWNsZSBldmVudHM7XG4gICAqIC0gV29ya2Zsb3cgQWN0aXZhdGlvbiBhbmQgQWN0aXZpdHkgVGFzayBwcm9jZXNzaW5nIGV2ZW50cztcbiAgICogLSBXb3JrZmxvdyBidW5kbGluZyBtZXNzYWdlcztcbiAgICogLSBTaW5rIHByb2Nlc3NpbmcgaXNzdWVzLlxuICAgKi9cbiAgd29ya2VyID0gJ3dvcmtlcicsXG5cbiAgLyoqXG4gICAqIENvbXBvbmVudCBuYW1lIGZvciBhbGwgbWVzc2FnZXMgZW1pdHRlZCBieSB0aGUgUnVzdCBDb3JlIFNESyBsaWJyYXJ5LlxuICAgKi9cbiAgY29yZSA9ICdjb3JlJyxcbn1cbiIsImltcG9ydCB0eXBlIHsgdGVtcG9yYWwgfSBmcm9tICdAdGVtcG9yYWxpby9wcm90byc7XG5pbXBvcnQgeyBWYWx1ZUVycm9yIH0gZnJvbSAnLi9lcnJvcnMnO1xuaW1wb3J0IHsgRHVyYXRpb24sIG1zT3B0aW9uYWxUb051bWJlciwgbXNPcHRpb25hbFRvVHMsIG1zVG9OdW1iZXIsIG1zVG9Ucywgb3B0aW9uYWxUc1RvTXMgfSBmcm9tICcuL3RpbWUnO1xuXG4vKipcbiAqIE9wdGlvbnMgZm9yIHJldHJ5aW5nIFdvcmtmbG93cyBhbmQgQWN0aXZpdGllc1xuICovXG5leHBvcnQgaW50ZXJmYWNlIFJldHJ5UG9saWN5IHtcbiAgLyoqXG4gICAqIENvZWZmaWNpZW50IHVzZWQgdG8gY2FsY3VsYXRlIHRoZSBuZXh0IHJldHJ5IGludGVydmFsLlxuICAgKiBUaGUgbmV4dCByZXRyeSBpbnRlcnZhbCBpcyBwcmV2aW91cyBpbnRlcnZhbCBtdWx0aXBsaWVkIGJ5IHRoaXMgY29lZmZpY2llbnQuXG4gICAqIEBtaW5pbXVtIDFcbiAgICogQGRlZmF1bHQgMlxuICAgKi9cbiAgYmFja29mZkNvZWZmaWNpZW50PzogbnVtYmVyO1xuICAvKipcbiAgICogSW50ZXJ2YWwgb2YgdGhlIGZpcnN0IHJldHJ5LlxuICAgKiBJZiBjb2VmZmljaWVudCBpcyAxIHRoZW4gaXQgaXMgdXNlZCBmb3IgYWxsIHJldHJpZXNcbiAgICogQGZvcm1hdCBudW1iZXIgb2YgbWlsbGlzZWNvbmRzIG9yIHtAbGluayBodHRwczovL3d3dy5ucG1qcy5jb20vcGFja2FnZS9tcyB8IG1zLWZvcm1hdHRlZCBzdHJpbmd9XG4gICAqIEBkZWZhdWx0IDEgc2Vjb25kXG4gICAqL1xuICBpbml0aWFsSW50ZXJ2YWw/OiBEdXJhdGlvbjtcbiAgLyoqXG4gICAqIE1heGltdW0gbnVtYmVyIG9mIGF0dGVtcHRzLiBXaGVuIGV4Y2VlZGVkLCByZXRyaWVzIHN0b3AgKGV2ZW4gaWYge0BsaW5rIEFjdGl2aXR5T3B0aW9ucy5zY2hlZHVsZVRvQ2xvc2VUaW1lb3V0fVxuICAgKiBoYXNuJ3QgYmVlbiByZWFjaGVkKS5cbiAgICpcbiAgICogQGRlZmF1bHQgSW5maW5pdHlcbiAgICovXG4gIG1heGltdW1BdHRlbXB0cz86IG51bWJlcjtcbiAgLyoqXG4gICAqIE1heGltdW0gaW50ZXJ2YWwgYmV0d2VlbiByZXRyaWVzLlxuICAgKiBFeHBvbmVudGlhbCBiYWNrb2ZmIGxlYWRzIHRvIGludGVydmFsIGluY3JlYXNlLlxuICAgKiBUaGlzIHZhbHVlIGlzIHRoZSBjYXAgb2YgdGhlIGluY3JlYXNlLlxuICAgKlxuICAgKiBAZGVmYXVsdCAxMDB4IG9mIHtAbGluayBpbml0aWFsSW50ZXJ2YWx9XG4gICAqIEBmb3JtYXQgbnVtYmVyIG9mIG1pbGxpc2Vjb25kcyBvciB7QGxpbmsgaHR0cHM6Ly93d3cubnBtanMuY29tL3BhY2thZ2UvbXMgfCBtcy1mb3JtYXR0ZWQgc3RyaW5nfVxuICAgKi9cbiAgbWF4aW11bUludGVydmFsPzogRHVyYXRpb247XG5cbiAgLyoqXG4gICAqIExpc3Qgb2YgYXBwbGljYXRpb24gZmFpbHVyZXMgdHlwZXMgdG8gbm90IHJldHJ5LlxuICAgKi9cbiAgbm9uUmV0cnlhYmxlRXJyb3JUeXBlcz86IHN0cmluZ1tdO1xufVxuXG4vKipcbiAqIFR1cm4gYSBUUyBSZXRyeVBvbGljeSBpbnRvIGEgcHJvdG8gY29tcGF0aWJsZSBSZXRyeVBvbGljeVxuICovXG5leHBvcnQgZnVuY3Rpb24gY29tcGlsZVJldHJ5UG9saWN5KHJldHJ5UG9saWN5OiBSZXRyeVBvbGljeSk6IHRlbXBvcmFsLmFwaS5jb21tb24udjEuSVJldHJ5UG9saWN5IHtcbiAgaWYgKHJldHJ5UG9saWN5LmJhY2tvZmZDb2VmZmljaWVudCAhPSBudWxsICYmIHJldHJ5UG9saWN5LmJhY2tvZmZDb2VmZmljaWVudCA8PSAwKSB7XG4gICAgdGhyb3cgbmV3IFZhbHVlRXJyb3IoJ1JldHJ5UG9saWN5LmJhY2tvZmZDb2VmZmljaWVudCBtdXN0IGJlIGdyZWF0ZXIgdGhhbiAwJyk7XG4gIH1cbiAgaWYgKHJldHJ5UG9saWN5Lm1heGltdW1BdHRlbXB0cyAhPSBudWxsKSB7XG4gICAgaWYgKHJldHJ5UG9saWN5Lm1heGltdW1BdHRlbXB0cyA9PT0gTnVtYmVyLlBPU0lUSVZFX0lORklOSVRZKSB7XG4gICAgICAvLyBkcm9wIGZpZWxkIChJbmZpbml0eSBpcyB0aGUgZGVmYXVsdClcbiAgICAgIGNvbnN0IHsgbWF4aW11bUF0dGVtcHRzOiBfLCAuLi53aXRob3V0IH0gPSByZXRyeVBvbGljeTtcbiAgICAgIHJldHJ5UG9saWN5ID0gd2l0aG91dDtcbiAgICB9IGVsc2UgaWYgKHJldHJ5UG9saWN5Lm1heGltdW1BdHRlbXB0cyA8PSAwKSB7XG4gICAgICB0aHJvdyBuZXcgVmFsdWVFcnJvcignUmV0cnlQb2xpY3kubWF4aW11bUF0dGVtcHRzIG11c3QgYmUgYSBwb3NpdGl2ZSBpbnRlZ2VyJyk7XG4gICAgfSBlbHNlIGlmICghTnVtYmVyLmlzSW50ZWdlcihyZXRyeVBvbGljeS5tYXhpbXVtQXR0ZW1wdHMpKSB7XG4gICAgICB0aHJvdyBuZXcgVmFsdWVFcnJvcignUmV0cnlQb2xpY3kubWF4aW11bUF0dGVtcHRzIG11c3QgYmUgYW4gaW50ZWdlcicpO1xuICAgIH1cbiAgfVxuICBjb25zdCBtYXhpbXVtSW50ZXJ2YWwgPSBtc09wdGlvbmFsVG9OdW1iZXIocmV0cnlQb2xpY3kubWF4aW11bUludGVydmFsKTtcbiAgY29uc3QgaW5pdGlhbEludGVydmFsID0gbXNUb051bWJlcihyZXRyeVBvbGljeS5pbml0aWFsSW50ZXJ2YWwgPz8gMTAwMCk7XG4gIGlmIChtYXhpbXVtSW50ZXJ2YWwgPT09IDApIHtcbiAgICB0aHJvdyBuZXcgVmFsdWVFcnJvcignUmV0cnlQb2xpY3kubWF4aW11bUludGVydmFsIGNhbm5vdCBiZSAwJyk7XG4gIH1cbiAgaWYgKGluaXRpYWxJbnRlcnZhbCA9PT0gMCkge1xuICAgIHRocm93IG5ldyBWYWx1ZUVycm9yKCdSZXRyeVBvbGljeS5pbml0aWFsSW50ZXJ2YWwgY2Fubm90IGJlIDAnKTtcbiAgfVxuICBpZiAobWF4aW11bUludGVydmFsICE9IG51bGwgJiYgbWF4aW11bUludGVydmFsIDwgaW5pdGlhbEludGVydmFsKSB7XG4gICAgdGhyb3cgbmV3IFZhbHVlRXJyb3IoJ1JldHJ5UG9saWN5Lm1heGltdW1JbnRlcnZhbCBjYW5ub3QgYmUgbGVzcyB0aGFuIGl0cyBpbml0aWFsSW50ZXJ2YWwnKTtcbiAgfVxuICByZXR1cm4ge1xuICAgIG1heGltdW1BdHRlbXB0czogcmV0cnlQb2xpY3kubWF4aW11bUF0dGVtcHRzLFxuICAgIGluaXRpYWxJbnRlcnZhbDogbXNUb1RzKGluaXRpYWxJbnRlcnZhbCksXG4gICAgbWF4aW11bUludGVydmFsOiBtc09wdGlvbmFsVG9UcyhtYXhpbXVtSW50ZXJ2YWwpLFxuICAgIGJhY2tvZmZDb2VmZmljaWVudDogcmV0cnlQb2xpY3kuYmFja29mZkNvZWZmaWNpZW50LFxuICAgIG5vblJldHJ5YWJsZUVycm9yVHlwZXM6IHJldHJ5UG9saWN5Lm5vblJldHJ5YWJsZUVycm9yVHlwZXMsXG4gIH07XG59XG5cbi8qKlxuICogVHVybiBhIHByb3RvIGNvbXBhdGlibGUgUmV0cnlQb2xpY3kgaW50byBhIFRTIFJldHJ5UG9saWN5XG4gKi9cbmV4cG9ydCBmdW5jdGlvbiBkZWNvbXBpbGVSZXRyeVBvbGljeShcbiAgcmV0cnlQb2xpY3k/OiB0ZW1wb3JhbC5hcGkuY29tbW9uLnYxLklSZXRyeVBvbGljeSB8IG51bGxcbik6IFJldHJ5UG9saWN5IHwgdW5kZWZpbmVkIHtcbiAgaWYgKCFyZXRyeVBvbGljeSkge1xuICAgIHJldHVybiB1bmRlZmluZWQ7XG4gIH1cblxuICByZXR1cm4ge1xuICAgIGJhY2tvZmZDb2VmZmljaWVudDogcmV0cnlQb2xpY3kuYmFja29mZkNvZWZmaWNpZW50ID8/IHVuZGVmaW5lZCxcbiAgICBtYXhpbXVtQXR0ZW1wdHM6IHJldHJ5UG9saWN5Lm1heGltdW1BdHRlbXB0cyA/PyB1bmRlZmluZWQsXG4gICAgbWF4aW11bUludGVydmFsOiBvcHRpb25hbFRzVG9NcyhyZXRyeVBvbGljeS5tYXhpbXVtSW50ZXJ2YWwpLFxuICAgIGluaXRpYWxJbnRlcnZhbDogb3B0aW9uYWxUc1RvTXMocmV0cnlQb2xpY3kuaW5pdGlhbEludGVydmFsKSxcbiAgICBub25SZXRyeWFibGVFcnJvclR5cGVzOiByZXRyeVBvbGljeS5ub25SZXRyeWFibGVFcnJvclR5cGVzID8/IHVuZGVmaW5lZCxcbiAgfTtcbn1cbiIsImltcG9ydCBMb25nIGZyb20gJ2xvbmcnOyAvLyBlc2xpbnQtZGlzYWJsZS1saW5lIGltcG9ydC9uby1uYW1lZC1hcy1kZWZhdWx0XG5pbXBvcnQgbXMsIHsgU3RyaW5nVmFsdWUgfSBmcm9tICdtcyc7XG5pbXBvcnQgdHlwZSB7IGdvb2dsZSB9IGZyb20gJ0B0ZW1wb3JhbGlvL3Byb3RvJztcbmltcG9ydCB7IFZhbHVlRXJyb3IgfSBmcm9tICcuL2Vycm9ycyc7XG5cbi8vIE5PVEU6IHRoZXNlIGFyZSB0aGUgc2FtZSBpbnRlcmZhY2UgaW4gSlNcbi8vIGdvb2dsZS5wcm90b2J1Zi5JRHVyYXRpb247XG4vLyBnb29nbGUucHJvdG9idWYuSVRpbWVzdGFtcDtcbi8vIFRoZSBjb252ZXJzaW9uIGZ1bmN0aW9ucyBiZWxvdyBzaG91bGQgd29yayBmb3IgYm90aFxuXG5leHBvcnQgdHlwZSBUaW1lc3RhbXAgPSBnb29nbGUucHJvdG9idWYuSVRpbWVzdGFtcDtcblxuLyoqXG4gKiBBIGR1cmF0aW9uLCBleHByZXNzZWQgZWl0aGVyIGFzIGEgbnVtYmVyIG9mIG1pbGxpc2Vjb25kcywgb3IgYXMgYSB7QGxpbmsgaHR0cHM6Ly93d3cubnBtanMuY29tL3BhY2thZ2UvbXMgfCBtcy1mb3JtYXR0ZWQgc3RyaW5nfS5cbiAqL1xuZXhwb3J0IHR5cGUgRHVyYXRpb24gPSBTdHJpbmdWYWx1ZSB8IG51bWJlcjtcblxuZXhwb3J0IHR5cGUgeyBTdHJpbmdWYWx1ZSB9IGZyb20gJ21zJztcblxuLyoqXG4gKiBMb3NzeSBjb252ZXJzaW9uIGZ1bmN0aW9uIGZyb20gVGltZXN0YW1wIHRvIG51bWJlciBkdWUgdG8gcG9zc2libGUgb3ZlcmZsb3cuXG4gKiBJZiB0cyBpcyBudWxsIG9yIHVuZGVmaW5lZCByZXR1cm5zIHVuZGVmaW5lZC5cbiAqL1xuZXhwb3J0IGZ1bmN0aW9uIG9wdGlvbmFsVHNUb01zKHRzOiBUaW1lc3RhbXAgfCBudWxsIHwgdW5kZWZpbmVkKTogbnVtYmVyIHwgdW5kZWZpbmVkIHtcbiAgaWYgKHRzID09PSB1bmRlZmluZWQgfHwgdHMgPT09IG51bGwpIHtcbiAgICByZXR1cm4gdW5kZWZpbmVkO1xuICB9XG4gIHJldHVybiB0c1RvTXModHMpO1xufVxuXG4vKipcbiAqIExvc3N5IGNvbnZlcnNpb24gZnVuY3Rpb24gZnJvbSBUaW1lc3RhbXAgdG8gbnVtYmVyIGR1ZSB0byBwb3NzaWJsZSBvdmVyZmxvd1xuICovXG5leHBvcnQgZnVuY3Rpb24gdHNUb01zKHRzOiBUaW1lc3RhbXAgfCBudWxsIHwgdW5kZWZpbmVkKTogbnVtYmVyIHtcbiAgaWYgKHRzID09PSB1bmRlZmluZWQgfHwgdHMgPT09IG51bGwpIHtcbiAgICB0aHJvdyBuZXcgRXJyb3IoYEV4cGVjdGVkIHRpbWVzdGFtcCwgZ290ICR7dHN9YCk7XG4gIH1cbiAgY29uc3QgeyBzZWNvbmRzLCBuYW5vcyB9ID0gdHM7XG4gIHJldHVybiAoc2Vjb25kcyB8fCBMb25nLlVaRVJPKVxuICAgIC5tdWwoMTAwMClcbiAgICAuYWRkKE1hdGguZmxvb3IoKG5hbm9zIHx8IDApIC8gMTAwMDAwMCkpXG4gICAgLnRvTnVtYmVyKCk7XG59XG5cbmV4cG9ydCBmdW5jdGlvbiBtc051bWJlclRvVHMobWlsbGlzOiBudW1iZXIpOiBUaW1lc3RhbXAge1xuICBjb25zdCBzZWNvbmRzID0gTWF0aC5mbG9vcihtaWxsaXMgLyAxMDAwKTtcbiAgY29uc3QgbmFub3MgPSAobWlsbGlzICUgMTAwMCkgKiAxMDAwMDAwO1xuICBpZiAoTnVtYmVyLmlzTmFOKHNlY29uZHMpIHx8IE51bWJlci5pc05hTihuYW5vcykpIHtcbiAgICB0aHJvdyBuZXcgVmFsdWVFcnJvcihgSW52YWxpZCBtaWxsaXMgJHttaWxsaXN9YCk7XG4gIH1cbiAgcmV0dXJuIHsgc2Vjb25kczogTG9uZy5mcm9tTnVtYmVyKHNlY29uZHMpLCBuYW5vcyB9O1xufVxuXG5leHBvcnQgZnVuY3Rpb24gbXNUb1RzKHN0cjogRHVyYXRpb24pOiBUaW1lc3RhbXAge1xuICByZXR1cm4gbXNOdW1iZXJUb1RzKG1zVG9OdW1iZXIoc3RyKSk7XG59XG5cbmV4cG9ydCBmdW5jdGlvbiBtc09wdGlvbmFsVG9UcyhzdHI6IER1cmF0aW9uIHwgdW5kZWZpbmVkKTogVGltZXN0YW1wIHwgdW5kZWZpbmVkIHtcbiAgcmV0dXJuIHN0ciA/IG1zVG9UcyhzdHIpIDogdW5kZWZpbmVkO1xufVxuXG5leHBvcnQgZnVuY3Rpb24gbXNPcHRpb25hbFRvTnVtYmVyKHZhbDogRHVyYXRpb24gfCB1bmRlZmluZWQpOiBudW1iZXIgfCB1bmRlZmluZWQge1xuICBpZiAodmFsID09PSB1bmRlZmluZWQpIHJldHVybiB1bmRlZmluZWQ7XG4gIHJldHVybiBtc1RvTnVtYmVyKHZhbCk7XG59XG5cbmV4cG9ydCBmdW5jdGlvbiBtc1RvTnVtYmVyKHZhbDogRHVyYXRpb24pOiBudW1iZXIge1xuICBpZiAodHlwZW9mIHZhbCA9PT0gJ251bWJlcicpIHtcbiAgICByZXR1cm4gdmFsO1xuICB9XG4gIHJldHVybiBtc1dpdGhWYWxpZGF0aW9uKHZhbCk7XG59XG5cbmZ1bmN0aW9uIG1zV2l0aFZhbGlkYXRpb24oc3RyOiBTdHJpbmdWYWx1ZSk6IG51bWJlciB7XG4gIGNvbnN0IG1pbGxpcyA9IG1zKHN0cik7XG4gIGlmIChtaWxsaXMgPT0gbnVsbCB8fCBpc05hTihtaWxsaXMpKSB7XG4gICAgdGhyb3cgbmV3IFR5cGVFcnJvcihgSW52YWxpZCBkdXJhdGlvbiBzdHJpbmc6ICcke3N0cn0nYCk7XG4gIH1cbiAgcmV0dXJuIG1pbGxpcztcbn1cblxuZXhwb3J0IGZ1bmN0aW9uIHRzVG9EYXRlKHRzOiBUaW1lc3RhbXApOiBEYXRlIHtcbiAgcmV0dXJuIG5ldyBEYXRlKHRzVG9Ncyh0cykpO1xufVxuXG5leHBvcnQgZnVuY3Rpb24gb3B0aW9uYWxUc1RvRGF0ZSh0czogVGltZXN0YW1wIHwgbnVsbCB8IHVuZGVmaW5lZCk6IERhdGUgfCB1bmRlZmluZWQge1xuICBpZiAodHMgPT09IHVuZGVmaW5lZCB8fCB0cyA9PT0gbnVsbCkge1xuICAgIHJldHVybiB1bmRlZmluZWQ7XG4gIH1cbiAgcmV0dXJuIG5ldyBEYXRlKHRzVG9Ncyh0cykpO1xufVxuXG4vLyB0cy1wcnVuZS1pZ25vcmUtbmV4dCAoaW1wb3J0ZWQgdmlhIHNjaGVkdWxlLWhlbHBlcnMudHMpXG5leHBvcnQgZnVuY3Rpb24gb3B0aW9uYWxEYXRlVG9UcyhkYXRlOiBEYXRlIHwgbnVsbCB8IHVuZGVmaW5lZCk6IFRpbWVzdGFtcCB8IHVuZGVmaW5lZCB7XG4gIGlmIChkYXRlID09PSB1bmRlZmluZWQgfHwgZGF0ZSA9PT0gbnVsbCkge1xuICAgIHJldHVybiB1bmRlZmluZWQ7XG4gIH1cbiAgcmV0dXJuIG1zVG9UcyhkYXRlLmdldFRpbWUoKSk7XG59XG4iLCIvKiogU2hvcnRoYW5kIGFsaWFzICovXG5leHBvcnQgdHlwZSBBbnlGdW5jID0gKC4uLmFyZ3M6IGFueVtdKSA9PiBhbnk7XG4vKiogQSB0dXBsZSB3aXRob3V0IGl0cyBsYXN0IGVsZW1lbnQgKi9cbmV4cG9ydCB0eXBlIE9taXRMYXN0PFQ+ID0gVCBleHRlbmRzIFsuLi5pbmZlciBSRVNULCBhbnldID8gUkVTVCA6IG5ldmVyO1xuLyoqIEYgd2l0aCBhbGwgYXJndW1lbnRzIGJ1dCB0aGUgbGFzdCAqL1xuZXhwb3J0IHR5cGUgT21pdExhc3RQYXJhbTxGIGV4dGVuZHMgQW55RnVuYz4gPSAoLi4uYXJnczogT21pdExhc3Q8UGFyYW1ldGVyczxGPj4pID0+IFJldHVyblR5cGU8Rj47XG4vKiogUmVxdWlyZSB0aGF0IFQgaGFzIGF0IGxlYXN0IG9uZSBvZiB0aGUgcHJvdmlkZWQgcHJvcGVydGllcyBkZWZpbmVkICovXG5leHBvcnQgdHlwZSBSZXF1aXJlQXRMZWFzdE9uZTxULCBLZXlzIGV4dGVuZHMga2V5b2YgVCA9IGtleW9mIFQ+ID0gUGljazxULCBFeGNsdWRlPGtleW9mIFQsIEtleXM+PiAmXG4gIHtcbiAgICBbSyBpbiBLZXlzXS0/OiBSZXF1aXJlZDxQaWNrPFQsIEs+PiAmIFBhcnRpYWw8UGljazxULCBFeGNsdWRlPEtleXMsIEs+Pj47XG4gIH1bS2V5c107XG5cbi8qKiBWZXJpZnkgdGhhdCBhbiB0eXBlIF9Db3B5IGV4dGVuZHMgX09yaWcgKi9cbmV4cG9ydCBmdW5jdGlvbiBjaGVja0V4dGVuZHM8X09yaWcsIF9Db3B5IGV4dGVuZHMgX09yaWc+KCk6IHZvaWQge1xuICAvLyBub29wLCBqdXN0IHR5cGUgY2hlY2tcbn1cblxuZXhwb3J0IHR5cGUgUmVwbGFjZTxCYXNlLCBOZXc+ID0gT21pdDxCYXNlLCBrZXlvZiBOZXc+ICYgTmV3O1xuXG5leHBvcnQgZnVuY3Rpb24gaXNSZWNvcmQodmFsdWU6IHVua25vd24pOiB2YWx1ZSBpcyBSZWNvcmQ8c3RyaW5nLCB1bmtub3duPiB7XG4gIHJldHVybiB0eXBlb2YgdmFsdWUgPT09ICdvYmplY3QnICYmIHZhbHVlICE9PSBudWxsO1xufVxuXG5leHBvcnQgZnVuY3Rpb24gaGFzT3duUHJvcGVydHk8WCBleHRlbmRzIFJlY29yZDxzdHJpbmcsIHVua25vd24+LCBZIGV4dGVuZHMgUHJvcGVydHlLZXk+KFxuICByZWNvcmQ6IFgsXG4gIHByb3A6IFlcbik6IHJlY29yZCBpcyBYICYgUmVjb3JkPFksIHVua25vd24+IHtcbiAgcmV0dXJuIHByb3AgaW4gcmVjb3JkO1xufVxuXG5leHBvcnQgZnVuY3Rpb24gaGFzT3duUHJvcGVydGllczxYIGV4dGVuZHMgUmVjb3JkPHN0cmluZywgdW5rbm93bj4sIFkgZXh0ZW5kcyBQcm9wZXJ0eUtleT4oXG4gIHJlY29yZDogWCxcbiAgcHJvcHM6IFlbXVxuKTogcmVjb3JkIGlzIFggJiBSZWNvcmQ8WSwgdW5rbm93bj4ge1xuICByZXR1cm4gcHJvcHMuZXZlcnkoKHByb3ApID0+IHByb3AgaW4gcmVjb3JkKTtcbn1cblxuZXhwb3J0IGZ1bmN0aW9uIGlzRXJyb3IoZXJyb3I6IHVua25vd24pOiBlcnJvciBpcyBFcnJvciB7XG4gIHJldHVybiAoXG4gICAgaXNSZWNvcmQoZXJyb3IpICYmXG4gICAgdHlwZW9mIGVycm9yLm5hbWUgPT09ICdzdHJpbmcnICYmXG4gICAgdHlwZW9mIGVycm9yLm1lc3NhZ2UgPT09ICdzdHJpbmcnICYmXG4gICAgKGVycm9yLnN0YWNrID09IG51bGwgfHwgdHlwZW9mIGVycm9yLnN0YWNrID09PSAnc3RyaW5nJylcbiAgKTtcbn1cblxuZXhwb3J0IGZ1bmN0aW9uIGlzQWJvcnRFcnJvcihlcnJvcjogdW5rbm93bik6IGVycm9yIGlzIEVycm9yICYgeyBuYW1lOiAnQWJvcnRFcnJvcicgfSB7XG4gIHJldHVybiBpc0Vycm9yKGVycm9yKSAmJiBlcnJvci5uYW1lID09PSAnQWJvcnRFcnJvcic7XG59XG5cbi8qKlxuICogR2V0IGBlcnJvci5tZXNzYWdlYCAob3IgYHVuZGVmaW5lZGAgaWYgbm90IHByZXNlbnQpXG4gKi9cbmV4cG9ydCBmdW5jdGlvbiBlcnJvck1lc3NhZ2UoZXJyb3I6IHVua25vd24pOiBzdHJpbmcgfCB1bmRlZmluZWQge1xuICBpZiAoaXNFcnJvcihlcnJvcikpIHtcbiAgICByZXR1cm4gZXJyb3IubWVzc2FnZTtcbiAgfSBlbHNlIGlmICh0eXBlb2YgZXJyb3IgPT09ICdzdHJpbmcnKSB7XG4gICAgcmV0dXJuIGVycm9yO1xuICB9XG4gIHJldHVybiB1bmRlZmluZWQ7XG59XG5cbmludGVyZmFjZSBFcnJvcldpdGhDb2RlIHtcbiAgY29kZTogc3RyaW5nO1xufVxuXG5mdW5jdGlvbiBpc0Vycm9yV2l0aENvZGUoZXJyb3I6IHVua25vd24pOiBlcnJvciBpcyBFcnJvcldpdGhDb2RlIHtcbiAgcmV0dXJuIGlzUmVjb3JkKGVycm9yKSAmJiB0eXBlb2YgZXJyb3IuY29kZSA9PT0gJ3N0cmluZyc7XG59XG5cbi8qKlxuICogR2V0IGBlcnJvci5jb2RlYCAob3IgYHVuZGVmaW5lZGAgaWYgbm90IHByZXNlbnQpXG4gKi9cbmV4cG9ydCBmdW5jdGlvbiBlcnJvckNvZGUoZXJyb3I6IHVua25vd24pOiBzdHJpbmcgfCB1bmRlZmluZWQge1xuICBpZiAoaXNFcnJvcldpdGhDb2RlKGVycm9yKSkge1xuICAgIHJldHVybiBlcnJvci5jb2RlO1xuICB9XG5cbiAgcmV0dXJuIHVuZGVmaW5lZDtcbn1cblxuLyoqXG4gKiBBc3NlcnRzIHRoYXQgc29tZSB0eXBlIGlzIHRoZSBuZXZlciB0eXBlXG4gKi9cbmV4cG9ydCBmdW5jdGlvbiBhc3NlcnROZXZlcihtc2c6IHN0cmluZywgeDogbmV2ZXIpOiBuZXZlciB7XG4gIHRocm93IG5ldyBUeXBlRXJyb3IobXNnICsgJzogJyArIHgpO1xufVxuXG5leHBvcnQgdHlwZSBDbGFzczxFIGV4dGVuZHMgRXJyb3I+ID0ge1xuICBuZXcgKC4uLmFyZ3M6IGFueVtdKTogRTtcbiAgcHJvdG90eXBlOiBFO1xufTtcblxuLyoqXG4gKiBBIGRlY29yYXRvciB0byBiZSB1c2VkIG9uIGVycm9yIGNsYXNzZXMuIEl0IGFkZHMgdGhlICduYW1lJyBwcm9wZXJ0eSBBTkQgcHJvdmlkZXMgYSBjdXN0b21cbiAqICdpbnN0YW5jZW9mJyBoYW5kbGVyIHRoYXQgd29ya3MgY29ycmVjdGx5IGFjcm9zcyBleGVjdXRpb24gY29udGV4dHMuXG4gKlxuICogIyMjIERldGFpbHMgIyMjXG4gKlxuICogQWNjb3JkaW5nIHRvIHRoZSBFY21hU2NyaXB0J3Mgc3BlYywgdGhlIGRlZmF1bHQgYmVoYXZpb3Igb2YgSmF2YVNjcmlwdCdzIGB4IGluc3RhbmNlb2YgWWAgb3BlcmF0b3IgaXMgdG8gd2FsayB1cCB0aGVcbiAqIHByb3RvdHlwZSBjaGFpbiBvZiBvYmplY3QgJ3gnLCBjaGVja2luZyBpZiBhbnkgY29uc3RydWN0b3IgaW4gdGhhdCBoaWVyYXJjaHkgaXMgX2V4YWN0bHkgdGhlIHNhbWUgb2JqZWN0XyBhcyB0aGVcbiAqIGNvbnN0cnVjdG9yIGZ1bmN0aW9uICdZJy5cbiAqXG4gKiBVbmZvcnR1bmF0ZWx5LCBpdCBoYXBwZW5zIGluIHZhcmlvdXMgc2l0dWF0aW9ucyB0aGF0IGRpZmZlcmVudCBjb25zdHJ1Y3RvciBmdW5jdGlvbiBvYmplY3RzIGdldCBjcmVhdGVkIGZvciB3aGF0XG4gKiBhcHBlYXJzIHRvIGJlIHRoZSB2ZXJ5IHNhbWUgY2xhc3MuIFRoaXMgbGVhZHMgdG8gc3VycHJpc2luZyBiZWhhdmlvciB3aGVyZSBgaW5zdGFuY2VvZmAgcmV0dXJucyBmYWxzZSB0aG91Z2ggaXQgaXNcbiAqIGtub3duIHRoYXQgdGhlIG9iamVjdCBpcyBpbmRlZWQgYW4gaW5zdGFuY2Ugb2YgdGhhdCBjbGFzcy4gT25lIHBhcnRpY3VsYXIgY2FzZSB3aGVyZSB0aGlzIGhhcHBlbnMgaXMgd2hlbiBjb25zdHJ1Y3RvclxuICogJ1knIGJlbG9uZ3MgdG8gYSBkaWZmZXJlbnQgcmVhbG0gdGhhbiB0aGUgY29uc3R1Y3RvciB3aXRoIHdoaWNoICd4JyB3YXMgaW5zdGFudGlhdGVkLiBBbm90aGVyIGNhc2UgaXMgd2hlbiB0d28gY29waWVzXG4gKiBvZiB0aGUgc2FtZSBsaWJyYXJ5IGdldHMgbG9hZGVkIGluIHRoZSBzYW1lIHJlYWxtLlxuICpcbiAqIEluIHByYWN0aWNlLCB0aGlzIHRlbmRzIHRvIGNhdXNlIGlzc3VlcyB3aGVuIGNyb3NzaW5nIHRoZSB3b3JrZmxvdy1zYW5kYm94aW5nIGJvdW5kYXJ5IChzaW5jZSBOb2RlJ3Mgdm0gbW9kdWxlXG4gKiByZWFsbHkgY3JlYXRlcyBuZXcgZXhlY3V0aW9uIHJlYWxtcyksIGFzIHdlbGwgYXMgd2hlbiBydW5uaW5nIHRlc3RzIHVzaW5nIEplc3QgKHNlZSBodHRwczovL2dpdGh1Yi5jb20vamVzdGpzL2plc3QvaXNzdWVzLzI1NDlcbiAqIGZvciBzb21lIGRldGFpbHMgb24gdGhhdCBvbmUpLlxuICpcbiAqIFRoaXMgZnVuY3Rpb24gaW5qZWN0cyBhIGN1c3RvbSAnaW5zdGFuY2VvZicgaGFuZGxlciBpbnRvIHRoZSBwcm90b3R5cGUgb2YgJ2NsYXp6Jywgd2hpY2ggaXMgYm90aCBjcm9zcy1yZWFsbSBzYWZlIGFuZFxuICogY3Jvc3MtY29waWVzLW9mLXRoZS1zYW1lLWxpYiBzYWZlLiBJdCB3b3JrcyBieSBhZGRpbmcgYSBzcGVjaWFsIHN5bWJvbCBwcm9wZXJ0eSB0byB0aGUgcHJvdG90eXBlIG9mICdjbGF6eicsIGFuZCB0aGVuXG4gKiBjaGVja2luZyBmb3IgdGhlIHByZXNlbmNlIG9mIHRoYXQgc3ltYm9sLlxuICovXG5leHBvcnQgZnVuY3Rpb24gU3ltYm9sQmFzZWRJbnN0YW5jZU9mRXJyb3I8RSBleHRlbmRzIEVycm9yPihtYXJrZXJOYW1lOiBzdHJpbmcpOiAoY2xheno6IENsYXNzPEU+KSA9PiB2b2lkIHtcbiAgcmV0dXJuIChjbGF6ejogQ2xhc3M8RT4pOiB2b2lkID0+IHtcbiAgICBjb25zdCBtYXJrZXIgPSBTeW1ib2wuZm9yKGBfX3RlbXBvcmFsX2lzJHttYXJrZXJOYW1lfWApO1xuXG4gICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KGNsYXp6LnByb3RvdHlwZSwgJ25hbWUnLCB7IHZhbHVlOiBtYXJrZXJOYW1lLCBlbnVtZXJhYmxlOiB0cnVlIH0pO1xuICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eShjbGF6ei5wcm90b3R5cGUsIG1hcmtlciwgeyB2YWx1ZTogdHJ1ZSwgZW51bWVyYWJsZTogZmFsc2UgfSk7XG4gICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KGNsYXp6LCBTeW1ib2wuaGFzSW5zdGFuY2UsIHtcbiAgICAgIC8vIGVzbGludC1kaXNhYmxlLW5leHQtbGluZSBvYmplY3Qtc2hvcnRoYW5kXG4gICAgICB2YWx1ZTogZnVuY3Rpb24gKHRoaXM6IGFueSwgZXJyb3I6IG9iamVjdCk6IGJvb2xlYW4ge1xuICAgICAgICBpZiAodGhpcyA9PT0gY2xhenopIHtcbiAgICAgICAgICByZXR1cm4gaXNSZWNvcmQoZXJyb3IpICYmIChlcnJvciBhcyBhbnkpW21hcmtlcl0gPT09IHRydWU7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgLy8gJ3RoaXMnIG11c3QgYmUgYSBfc3ViY2xhc3NfIG9mIGNsYXp6IHRoYXQgZG9lc24ndCByZWRlZmluZWQgW1N5bWJvbC5oYXNJbnN0YW5jZV0sIHNvIHRoYXQgaXQgaW5oZXJpdGVkXG4gICAgICAgICAgLy8gZnJvbSBjbGF6eidzIFtTeW1ib2wuaGFzSW5zdGFuY2VdLiBJZiB3ZSBkb24ndCBoYW5kbGUgdGhpcyBwYXJ0aWN1bGFyIHNpdHVhdGlvbiwgdGhlblxuICAgICAgICAgIC8vIGB4IGluc3RhbmNlb2YgU3ViY2xhc3NPZlBhcmVudGAgd291bGQgcmV0dXJuIHRydWUgZm9yIGFueSBpbnN0YW5jZSBvZiAnUGFyZW50Jywgd2hpY2ggaXMgY2xlYXJseSB3cm9uZy5cbiAgICAgICAgICAvL1xuICAgICAgICAgIC8vIElkZWFsbHksIGl0J2QgYmUgcHJlZmVyYWJsZSB0byBhdm9pZCB0aGlzIGNhc2UgZW50aXJlbHksIGJ5IG1ha2luZyBzdXJlIHRoYXQgYWxsIHN1YmNsYXNzZXMgb2YgJ2NsYXp6J1xuICAgICAgICAgIC8vIHJlZGVmaW5lIFtTeW1ib2wuaGFzSW5zdGFuY2VdLCBidXQgd2UgY2FuJ3QgZW5mb3JjZSB0aGF0LiBXZSB0aGVyZWZvcmUgZmFsbGJhY2sgdG8gdGhlIGRlZmF1bHQgaW5zdGFuY2VvZlxuICAgICAgICAgIC8vIGJlaGF2aW9yICh3aGljaCBpcyBOT1QgY3Jvc3MtcmVhbG0gc2FmZSkuXG4gICAgICAgICAgcmV0dXJuIHRoaXMucHJvdG90eXBlLmlzUHJvdG90eXBlT2YoZXJyb3IpOyAvLyBlc2xpbnQtZGlzYWJsZS1saW5lIG5vLXByb3RvdHlwZS1idWlsdGluc1xuICAgICAgICB9XG4gICAgICB9LFxuICAgIH0pO1xuICB9O1xufVxuXG4vLyBUaGFua3MgTUROOiBodHRwczovL2RldmVsb3Blci5tb3ppbGxhLm9yZy9lbi1VUy9kb2NzL1dlYi9KYXZhU2NyaXB0L1JlZmVyZW5jZS9HbG9iYWxfT2JqZWN0cy9PYmplY3QvZnJlZXplXG5leHBvcnQgZnVuY3Rpb24gZGVlcEZyZWV6ZTxUPihvYmplY3Q6IFQpOiBUIHtcbiAgLy8gUmV0cmlldmUgdGhlIHByb3BlcnR5IG5hbWVzIGRlZmluZWQgb24gb2JqZWN0XG4gIGNvbnN0IHByb3BOYW1lcyA9IE9iamVjdC5nZXRPd25Qcm9wZXJ0eU5hbWVzKG9iamVjdCk7XG5cbiAgLy8gRnJlZXplIHByb3BlcnRpZXMgYmVmb3JlIGZyZWV6aW5nIHNlbGZcbiAgZm9yIChjb25zdCBuYW1lIG9mIHByb3BOYW1lcykge1xuICAgIGNvbnN0IHZhbHVlID0gKG9iamVjdCBhcyBhbnkpW25hbWVdO1xuXG4gICAgaWYgKHZhbHVlICYmIHR5cGVvZiB2YWx1ZSA9PT0gJ29iamVjdCcpIHtcbiAgICAgIHRyeSB7XG4gICAgICAgIGRlZXBGcmVlemUodmFsdWUpO1xuICAgICAgfSBjYXRjaCAoZXJyKSB7XG4gICAgICAgIC8vIFRoaXMgaXMgb2theSwgdGhlcmUgYXJlIHNvbWUgdHlwZWQgYXJyYXlzIHRoYXQgY2Fubm90IGJlIGZyb3plbiAoZW5jb2RpbmdLZXlzKVxuICAgICAgfVxuICAgIH0gZWxzZSBpZiAodHlwZW9mIHZhbHVlID09PSAnZnVuY3Rpb24nKSB7XG4gICAgICBPYmplY3QuZnJlZXplKHZhbHVlKTtcbiAgICB9XG4gIH1cblxuICByZXR1cm4gT2JqZWN0LmZyZWV6ZShvYmplY3QpO1xufVxuIiwiaW1wb3J0IHR5cGUgeyBjb3Jlc2RrIH0gZnJvbSAnQHRlbXBvcmFsaW8vcHJvdG8nO1xuaW1wb3J0IHR5cGUgeyBWZXJzaW9uaW5nSW50ZW50IGFzIFZlcnNpb25pbmdJbnRlbnRTdHJpbmcgfSBmcm9tICcuL3ZlcnNpb25pbmctaW50ZW50JztcbmltcG9ydCB7IGFzc2VydE5ldmVyLCBjaGVja0V4dGVuZHMgfSBmcm9tICcuL3R5cGUtaGVscGVycyc7XG5cbi8vIEF2b2lkIGltcG9ydGluZyB0aGUgcHJvdG8gaW1wbGVtZW50YXRpb24gdG8gcmVkdWNlIHdvcmtmbG93IGJ1bmRsZSBzaXplXG4vLyBDb3BpZWQgZnJvbSBjb3Jlc2RrLmNvbW1vbi5WZXJzaW9uaW5nSW50ZW50XG4vKipcbiAqIFByb3RvYnVmIGVudW0gcmVwcmVzZW50YXRpb24gb2Yge0BsaW5rIFZlcnNpb25pbmdJbnRlbnRTdHJpbmd9LlxuICpcbiAqIEBleHBlcmltZW50YWxcbiAqL1xuZXhwb3J0IGVudW0gVmVyc2lvbmluZ0ludGVudCB7XG4gIFVOU1BFQ0lGSUVEID0gMCxcbiAgQ09NUEFUSUJMRSA9IDEsXG4gIERFRkFVTFQgPSAyLFxufVxuXG5jaGVja0V4dGVuZHM8Y29yZXNkay5jb21tb24uVmVyc2lvbmluZ0ludGVudCwgVmVyc2lvbmluZ0ludGVudD4oKTtcbmNoZWNrRXh0ZW5kczxWZXJzaW9uaW5nSW50ZW50LCBjb3Jlc2RrLmNvbW1vbi5WZXJzaW9uaW5nSW50ZW50PigpO1xuXG5leHBvcnQgZnVuY3Rpb24gdmVyc2lvbmluZ0ludGVudFRvUHJvdG8oaW50ZW50OiBWZXJzaW9uaW5nSW50ZW50U3RyaW5nIHwgdW5kZWZpbmVkKTogVmVyc2lvbmluZ0ludGVudCB7XG4gIHN3aXRjaCAoaW50ZW50KSB7XG4gICAgY2FzZSAnREVGQVVMVCc6XG4gICAgICByZXR1cm4gVmVyc2lvbmluZ0ludGVudC5ERUZBVUxUO1xuICAgIGNhc2UgJ0NPTVBBVElCTEUnOlxuICAgICAgcmV0dXJuIFZlcnNpb25pbmdJbnRlbnQuQ09NUEFUSUJMRTtcbiAgICBjYXNlIHVuZGVmaW5lZDpcbiAgICAgIHJldHVybiBWZXJzaW9uaW5nSW50ZW50LlVOU1BFQ0lGSUVEO1xuICAgIGRlZmF1bHQ6XG4gICAgICBhc3NlcnROZXZlcignVW5leHBlY3RlZCBWZXJzaW9uaW5nSW50ZW50JywgaW50ZW50KTtcbiAgfVxufVxuIiwiLyoqXG4gKiBJbmRpY2F0ZXMgd2hldGhlciB0aGUgdXNlciBpbnRlbmRzIGNlcnRhaW4gY29tbWFuZHMgdG8gYmUgcnVuIG9uIGEgY29tcGF0aWJsZSB3b3JrZXIgQnVpbGQgSWQgdmVyc2lvbiBvciBub3QuXG4gKlxuICogYENPTVBBVElCTEVgIGluZGljYXRlcyB0aGF0IHRoZSBjb21tYW5kIHNob3VsZCBydW4gb24gYSB3b3JrZXIgd2l0aCBjb21wYXRpYmxlIHZlcnNpb24gaWYgcG9zc2libGUuIEl0IG1heSBub3QgYmVcbiAqIHBvc3NpYmxlIGlmIHRoZSB0YXJnZXQgdGFzayBxdWV1ZSBkb2VzIG5vdCBhbHNvIGhhdmUga25vd2xlZGdlIG9mIHRoZSBjdXJyZW50IHdvcmtlcidzIEJ1aWxkIElkLlxuICpcbiAqIGBERUZBVUxUYCBpbmRpY2F0ZXMgdGhhdCB0aGUgY29tbWFuZCBzaG91bGQgcnVuIG9uIHRoZSB0YXJnZXQgdGFzayBxdWV1ZSdzIGN1cnJlbnQgb3ZlcmFsbC1kZWZhdWx0IEJ1aWxkIElkLlxuICpcbiAqIFdoZXJlIHRoaXMgdHlwZSBpcyBhY2NlcHRlZCBvcHRpb25hbGx5LCBhbiB1bnNldCB2YWx1ZSBpbmRpY2F0ZXMgdGhhdCB0aGUgU0RLIHNob3VsZCBjaG9vc2UgdGhlIG1vc3Qgc2Vuc2libGUgZGVmYXVsdFxuICogYmVoYXZpb3IgZm9yIHRoZSB0eXBlIG9mIGNvbW1hbmQsIGFjY291bnRpbmcgZm9yIHdoZXRoZXIgdGhlIGNvbW1hbmQgd2lsbCBiZSBydW4gb24gdGhlIHNhbWUgdGFzayBxdWV1ZSBhcyB0aGVcbiAqIGN1cnJlbnQgd29ya2VyLiBUaGUgZGVmYXVsdCBiZWhhdmlvciBmb3Igc3RhcnRpbmcgV29ya2Zsb3dzIGlzIGBERUZBVUxUYC4gVGhlIGRlZmF1bHQgYmVoYXZpb3IgZm9yIFdvcmtmbG93cyBzdGFydGluZ1xuICogQWN0aXZpdGllcywgc3RhcnRpbmcgQ2hpbGQgV29ya2Zsb3dzLCBvciBDb250aW51aW5nIEFzIE5ldyBpcyBgQ09NUEFUSUJMRWAuXG4gKlxuICogQGV4cGVyaW1lbnRhbFxuICovXG5leHBvcnQgdHlwZSBWZXJzaW9uaW5nSW50ZW50ID0gJ0NPTVBBVElCTEUnIHwgJ0RFRkFVTFQnO1xuIiwiaW1wb3J0IHsgV29ya2Zsb3csIFdvcmtmbG93UmVzdWx0VHlwZSwgU2lnbmFsRGVmaW5pdGlvbiB9IGZyb20gJy4vaW50ZXJmYWNlcyc7XG5cbi8qKlxuICogQmFzZSBXb3JrZmxvd0hhbmRsZSBpbnRlcmZhY2UsIGV4dGVuZGVkIGluIHdvcmtmbG93IGFuZCBjbGllbnQgbGlicy5cbiAqXG4gKiBUcmFuc2Zvcm1zIGEgd29ya2Zsb3cgaW50ZXJmYWNlIGBUYCBpbnRvIGEgY2xpZW50IGludGVyZmFjZS5cbiAqL1xuZXhwb3J0IGludGVyZmFjZSBCYXNlV29ya2Zsb3dIYW5kbGU8VCBleHRlbmRzIFdvcmtmbG93PiB7XG4gIC8qKlxuICAgKiBQcm9taXNlIHRoYXQgcmVzb2x2ZXMgd2hlbiBXb3JrZmxvdyBleGVjdXRpb24gY29tcGxldGVzXG4gICAqL1xuICByZXN1bHQoKTogUHJvbWlzZTxXb3JrZmxvd1Jlc3VsdFR5cGU8VD4+O1xuXG4gIC8qKlxuICAgKiBTaWduYWwgYSBydW5uaW5nIFdvcmtmbG93LlxuICAgKlxuICAgKiBAcGFyYW0gZGVmIGEgc2lnbmFsIGRlZmluaXRpb24gYXMgcmV0dXJuZWQgZnJvbSB7QGxpbmsgZGVmaW5lU2lnbmFsfVxuICAgKlxuICAgKiBAZXhhbXBsZVxuICAgKiBgYGB0c1xuICAgKiBhd2FpdCBoYW5kbGUuc2lnbmFsKGluY3JlbWVudFNpZ25hbCwgMyk7XG4gICAqIGBgYFxuICAgKi9cbiAgc2lnbmFsPEFyZ3MgZXh0ZW5kcyBhbnlbXSA9IFtdLCBOYW1lIGV4dGVuZHMgc3RyaW5nID0gc3RyaW5nPihcbiAgICBkZWY6IFNpZ25hbERlZmluaXRpb248QXJncywgTmFtZT4gfCBzdHJpbmcsXG4gICAgLi4uYXJnczogQXJnc1xuICApOiBQcm9taXNlPHZvaWQ+O1xuXG4gIC8qKlxuICAgKiBUaGUgd29ya2Zsb3dJZCBvZiB0aGUgY3VycmVudCBXb3JrZmxvd1xuICAgKi9cbiAgcmVhZG9ubHkgd29ya2Zsb3dJZDogc3RyaW5nO1xufVxuIiwiaW1wb3J0IHR5cGUgeyB0ZW1wb3JhbCB9IGZyb20gJ0B0ZW1wb3JhbGlvL3Byb3RvJztcbmltcG9ydCB7IFNlYXJjaEF0dHJpYnV0ZXMsIFdvcmtmbG93IH0gZnJvbSAnLi9pbnRlcmZhY2VzJztcbmltcG9ydCB7IFJldHJ5UG9saWN5IH0gZnJvbSAnLi9yZXRyeS1wb2xpY3knO1xuaW1wb3J0IHsgRHVyYXRpb24gfSBmcm9tICcuL3RpbWUnO1xuaW1wb3J0IHsgY2hlY2tFeHRlbmRzIH0gZnJvbSAnLi90eXBlLWhlbHBlcnMnO1xuXG4vLyBBdm9pZCBpbXBvcnRpbmcgdGhlIHByb3RvIGltcGxlbWVudGF0aW9uIHRvIHJlZHVjZSB3b3JrZmxvdyBidW5kbGUgc2l6ZVxuLy8gQ29waWVkIGZyb20gdGVtcG9yYWwuYXBpLmVudW1zLnYxLldvcmtmbG93SWRSZXVzZVBvbGljeVxuLyoqXG4gKiBDb25jZXB0OiB7QGxpbmsgaHR0cHM6Ly9kb2NzLnRlbXBvcmFsLmlvL2NvbmNlcHRzL3doYXQtaXMtYS13b3JrZmxvdy1pZC1yZXVzZS1wb2xpY3kvIHwgV29ya2Zsb3cgSWQgUmV1c2UgUG9saWN5fVxuICpcbiAqIFdoZXRoZXIgYSBXb3JrZmxvdyBjYW4gYmUgc3RhcnRlZCB3aXRoIGEgV29ya2Zsb3cgSWQgb2YgYSBDbG9zZWQgV29ya2Zsb3cuXG4gKlxuICogKk5vdGU6IEEgV29ya2Zsb3cgY2FuIG5ldmVyIGJlIHN0YXJ0ZWQgd2l0aCBhIFdvcmtmbG93IElkIG9mIGEgUnVubmluZyBXb3JrZmxvdy4qXG4gKi9cbmV4cG9ydCBlbnVtIFdvcmtmbG93SWRSZXVzZVBvbGljeSB7XG4gIC8qKlxuICAgKiBObyBuZWVkIHRvIHVzZSB0aGlzLlxuICAgKlxuICAgKiAoSWYgYSBgV29ya2Zsb3dJZFJldXNlUG9saWN5YCBpcyBzZXQgdG8gdGhpcywgb3IgaXMgbm90IHNldCBhdCBhbGwsIHRoZSBkZWZhdWx0IHZhbHVlIHdpbGwgYmUgdXNlZC4pXG4gICAqL1xuICBXT1JLRkxPV19JRF9SRVVTRV9QT0xJQ1lfVU5TUEVDSUZJRUQgPSAwLFxuXG4gIC8qKlxuICAgKiBUaGUgV29ya2Zsb3cgY2FuIGJlIHN0YXJ0ZWQgaWYgdGhlIHByZXZpb3VzIFdvcmtmbG93IGlzIGluIGEgQ2xvc2VkIHN0YXRlLlxuICAgKiBAZGVmYXVsdFxuICAgKi9cbiAgV09SS0ZMT1dfSURfUkVVU0VfUE9MSUNZX0FMTE9XX0RVUExJQ0FURSA9IDEsXG5cbiAgLyoqXG4gICAqIFRoZSBXb3JrZmxvdyBjYW4gYmUgc3RhcnRlZCBpZiB0aGUgcHJldmlvdXMgV29ya2Zsb3cgaXMgaW4gYSBDbG9zZWQgc3RhdGUgdGhhdCBpcyBub3QgQ29tcGxldGVkLlxuICAgKi9cbiAgV09SS0ZMT1dfSURfUkVVU0VfUE9MSUNZX0FMTE9XX0RVUExJQ0FURV9GQUlMRURfT05MWSA9IDIsXG5cbiAgLyoqXG4gICAqIFRoZSBXb3JrZmxvdyBjYW5ub3QgYmUgc3RhcnRlZC5cbiAgICovXG4gIFdPUktGTE9XX0lEX1JFVVNFX1BPTElDWV9SRUpFQ1RfRFVQTElDQVRFID0gMyxcblxuICAvKipcbiAgICogVGVybWluYXRlIHRoZSBjdXJyZW50IHdvcmtmbG93IGlmIG9uZSBpcyBhbHJlYWR5IHJ1bm5pbmcuXG4gICAqL1xuICBXT1JLRkxPV19JRF9SRVVTRV9QT0xJQ1lfVEVSTUlOQVRFX0lGX1JVTk5JTkcgPSA0LFxufVxuXG5jaGVja0V4dGVuZHM8dGVtcG9yYWwuYXBpLmVudW1zLnYxLldvcmtmbG93SWRSZXVzZVBvbGljeSwgV29ya2Zsb3dJZFJldXNlUG9saWN5PigpO1xuY2hlY2tFeHRlbmRzPFdvcmtmbG93SWRSZXVzZVBvbGljeSwgdGVtcG9yYWwuYXBpLmVudW1zLnYxLldvcmtmbG93SWRSZXVzZVBvbGljeT4oKTtcblxuZXhwb3J0IGludGVyZmFjZSBCYXNlV29ya2Zsb3dPcHRpb25zIHtcbiAgLyoqXG4gICAqIFdoZXRoZXIgYSBXb3JrZmxvdyBjYW4gYmUgc3RhcnRlZCB3aXRoIGEgV29ya2Zsb3cgSWQgb2YgYSBDbG9zZWQgV29ya2Zsb3cuXG4gICAqXG4gICAqICpOb3RlOiBBIFdvcmtmbG93IGNhbiBuZXZlciBiZSBzdGFydGVkIHdpdGggYSBXb3JrZmxvdyBJZCBvZiBhIFJ1bm5pbmcgV29ya2Zsb3cuKlxuICAgKlxuICAgKiBAZGVmYXVsdCB7QGxpbmsgV29ya2Zsb3dJZFJldXNlUG9saWN5LldPUktGTE9XX0lEX1JFVVNFX1BPTElDWV9BTExPV19EVVBMSUNBVEV9XG4gICAqL1xuICB3b3JrZmxvd0lkUmV1c2VQb2xpY3k/OiBXb3JrZmxvd0lkUmV1c2VQb2xpY3k7XG5cbiAgLyoqXG4gICAqIENvbnRyb2xzIGhvdyBhIFdvcmtmbG93IEV4ZWN1dGlvbiBpcyByZXRyaWVkLlxuICAgKlxuICAgKiBCeSBkZWZhdWx0LCBXb3JrZmxvdyBFeGVjdXRpb25zIGFyZSBub3QgcmV0cmllZC4gRG8gbm90IG92ZXJyaWRlIHRoaXMgYmVoYXZpb3IgdW5sZXNzIHlvdSBrbm93IHdoYXQgeW91J3JlIGRvaW5nLlxuICAgKiB7QGxpbmsgaHR0cHM6Ly9kb2NzLnRlbXBvcmFsLmlvL2NvbmNlcHRzL3doYXQtaXMtYS1yZXRyeS1wb2xpY3kvIHwgTW9yZSBpbmZvcm1hdGlvbn0uXG4gICAqL1xuICByZXRyeT86IFJldHJ5UG9saWN5O1xuXG4gIC8qKlxuICAgKiBPcHRpb25hbCBjcm9uIHNjaGVkdWxlIGZvciBXb3JrZmxvdy4gSWYgYSBjcm9uIHNjaGVkdWxlIGlzIHNwZWNpZmllZCwgdGhlIFdvcmtmbG93IHdpbGwgcnVuIGFzIGEgY3JvbiBiYXNlZCBvbiB0aGVcbiAgICogc2NoZWR1bGUuIFRoZSBzY2hlZHVsaW5nIHdpbGwgYmUgYmFzZWQgb24gVVRDIHRpbWUuIFRoZSBzY2hlZHVsZSBmb3IgdGhlIG5leHQgcnVuIG9ubHkgaGFwcGVucyBhZnRlciB0aGUgY3VycmVudFxuICAgKiBydW4gaXMgY29tcGxldGVkL2ZhaWxlZC90aW1lb3V0LiBJZiBhIFJldHJ5UG9saWN5IGlzIGFsc28gc3VwcGxpZWQsIGFuZCB0aGUgV29ya2Zsb3cgZmFpbGVkIG9yIHRpbWVkIG91dCwgdGhlXG4gICAqIFdvcmtmbG93IHdpbGwgYmUgcmV0cmllZCBiYXNlZCBvbiB0aGUgcmV0cnkgcG9saWN5LiBXaGlsZSB0aGUgV29ya2Zsb3cgaXMgcmV0cnlpbmcsIGl0IHdvbid0IHNjaGVkdWxlIGl0cyBuZXh0IHJ1bi5cbiAgICogSWYgdGhlIG5leHQgc2NoZWR1bGUgaXMgZHVlIHdoaWxlIHRoZSBXb3JrZmxvdyBpcyBydW5uaW5nIChvciByZXRyeWluZyksIHRoZW4gaXQgd2lsbCBza2lwIHRoYXQgc2NoZWR1bGUuIENyb25cbiAgICogV29ya2Zsb3cgd2lsbCBub3Qgc3RvcCB1bnRpbCBpdCBpcyB0ZXJtaW5hdGVkIG9yIGNhbmNlbGxlZCAoYnkgcmV0dXJuaW5nIHRlbXBvcmFsLkNhbmNlbGVkRXJyb3IpLlxuICAgKiBodHRwczovL2Nyb250YWIuZ3VydS8gaXMgdXNlZnVsIGZvciB0ZXN0aW5nIHlvdXIgY3JvbiBleHByZXNzaW9ucy5cbiAgICovXG4gIGNyb25TY2hlZHVsZT86IHN0cmluZztcblxuICAvKipcbiAgICogU3BlY2lmaWVzIGFkZGl0aW9uYWwgbm9uLWluZGV4ZWQgaW5mb3JtYXRpb24gdG8gYXR0YWNoIHRvIHRoZSBXb3JrZmxvdyBFeGVjdXRpb24uIFRoZSB2YWx1ZXMgY2FuIGJlIGFueXRoaW5nIHRoYXRcbiAgICogaXMgc2VyaWFsaXphYmxlIGJ5IHtAbGluayBEYXRhQ29udmVydGVyfS5cbiAgICovXG4gIG1lbW8/OiBSZWNvcmQ8c3RyaW5nLCB1bmtub3duPjtcblxuICAvKipcbiAgICogU3BlY2lmaWVzIGFkZGl0aW9uYWwgaW5kZXhlZCBpbmZvcm1hdGlvbiB0byBhdHRhY2ggdG8gdGhlIFdvcmtmbG93IEV4ZWN1dGlvbi4gTW9yZSBpbmZvOlxuICAgKiBodHRwczovL2RvY3MudGVtcG9yYWwuaW8vZG9jcy90eXBlc2NyaXB0L3NlYXJjaC1hdHRyaWJ1dGVzXG4gICAqXG4gICAqIFZhbHVlcyBhcmUgYWx3YXlzIGNvbnZlcnRlZCB1c2luZyB7QGxpbmsgSnNvblBheWxvYWRDb252ZXJ0ZXJ9LCBldmVuIHdoZW4gYSBjdXN0b20gZGF0YSBjb252ZXJ0ZXIgaXMgcHJvdmlkZWQuXG4gICAqL1xuICBzZWFyY2hBdHRyaWJ1dGVzPzogU2VhcmNoQXR0cmlidXRlcztcbn1cblxuZXhwb3J0IHR5cGUgV2l0aFdvcmtmbG93QXJnczxXIGV4dGVuZHMgV29ya2Zsb3csIFQ+ID0gVCAmXG4gIChQYXJhbWV0ZXJzPFc+IGV4dGVuZHMgW2FueSwgLi4uYW55W11dXG4gICAgPyB7XG4gICAgICAgIC8qKlxuICAgICAgICAgKiBBcmd1bWVudHMgdG8gcGFzcyB0byB0aGUgV29ya2Zsb3dcbiAgICAgICAgICovXG4gICAgICAgIGFyZ3M6IFBhcmFtZXRlcnM8Vz4gfCBSZWFkb25seTxQYXJhbWV0ZXJzPFc+PjtcbiAgICAgIH1cbiAgICA6IHtcbiAgICAgICAgLyoqXG4gICAgICAgICAqIEFyZ3VtZW50cyB0byBwYXNzIHRvIHRoZSBXb3JrZmxvd1xuICAgICAgICAgKi9cbiAgICAgICAgYXJncz86IFBhcmFtZXRlcnM8Vz4gfCBSZWFkb25seTxQYXJhbWV0ZXJzPFc+PjtcbiAgICAgIH0pO1xuXG5leHBvcnQgaW50ZXJmYWNlIFdvcmtmbG93RHVyYXRpb25PcHRpb25zIHtcbiAgLyoqXG4gICAqIFRoZSB0aW1lIGFmdGVyIHdoaWNoIHdvcmtmbG93IHJ1biBpcyBhdXRvbWF0aWNhbGx5IHRlcm1pbmF0ZWQgYnkgVGVtcG9yYWwgc2VydmljZS4gRG8gbm90XG4gICAqIHJlbHkgb24gcnVuIHRpbWVvdXQgZm9yIGJ1c2luZXNzIGxldmVsIHRpbWVvdXRzLiBJdCBpcyBwcmVmZXJyZWQgdG8gdXNlIGluIHdvcmtmbG93IHRpbWVyc1xuICAgKiBmb3IgdGhpcyBwdXJwb3NlLlxuICAgKlxuICAgKiBAZm9ybWF0IG51bWJlciBvZiBtaWxsaXNlY29uZHMgb3Ige0BsaW5rIGh0dHBzOi8vd3d3Lm5wbWpzLmNvbS9wYWNrYWdlL21zIHwgbXMtZm9ybWF0dGVkIHN0cmluZ31cbiAgICovXG4gIHdvcmtmbG93UnVuVGltZW91dD86IER1cmF0aW9uO1xuXG4gIC8qKlxuICAgKlxuICAgKiBUaGUgdGltZSBhZnRlciB3aGljaCB3b3JrZmxvdyBleGVjdXRpb24gKHdoaWNoIGluY2x1ZGVzIHJ1biByZXRyaWVzIGFuZCBjb250aW51ZSBhcyBuZXcpIGlzXG4gICAqIGF1dG9tYXRpY2FsbHkgdGVybWluYXRlZCBieSBUZW1wb3JhbCBzZXJ2aWNlLiBEbyBub3QgcmVseSBvbiBleGVjdXRpb24gdGltZW91dCBmb3IgYnVzaW5lc3NcbiAgICogbGV2ZWwgdGltZW91dHMuIEl0IGlzIHByZWZlcnJlZCB0byB1c2UgaW4gd29ya2Zsb3cgdGltZXJzIGZvciB0aGlzIHB1cnBvc2UuXG4gICAqXG4gICAqIEBmb3JtYXQgbnVtYmVyIG9mIG1pbGxpc2Vjb25kcyBvciB7QGxpbmsgaHR0cHM6Ly93d3cubnBtanMuY29tL3BhY2thZ2UvbXMgfCBtcy1mb3JtYXR0ZWQgc3RyaW5nfVxuICAgKi9cbiAgd29ya2Zsb3dFeGVjdXRpb25UaW1lb3V0PzogRHVyYXRpb247XG5cbiAgLyoqXG4gICAqIE1heGltdW0gZXhlY3V0aW9uIHRpbWUgb2YgYSBzaW5nbGUgd29ya2Zsb3cgdGFzay4gRGVmYXVsdCBpcyAxMCBzZWNvbmRzLlxuICAgKlxuICAgKiBAZm9ybWF0IG51bWJlciBvZiBtaWxsaXNlY29uZHMgb3Ige0BsaW5rIGh0dHBzOi8vd3d3Lm5wbWpzLmNvbS9wYWNrYWdlL21zIHwgbXMtZm9ybWF0dGVkIHN0cmluZ31cbiAgICovXG4gIHdvcmtmbG93VGFza1RpbWVvdXQ/OiBEdXJhdGlvbjtcbn1cblxuZXhwb3J0IHR5cGUgQ29tbW9uV29ya2Zsb3dPcHRpb25zID0gQmFzZVdvcmtmbG93T3B0aW9ucyAmIFdvcmtmbG93RHVyYXRpb25PcHRpb25zO1xuXG5leHBvcnQgZnVuY3Rpb24gZXh0cmFjdFdvcmtmbG93VHlwZTxUIGV4dGVuZHMgV29ya2Zsb3c+KHdvcmtmbG93VHlwZU9yRnVuYzogc3RyaW5nIHwgVCk6IHN0cmluZyB7XG4gIGlmICh0eXBlb2Ygd29ya2Zsb3dUeXBlT3JGdW5jID09PSAnc3RyaW5nJykgcmV0dXJuIHdvcmtmbG93VHlwZU9yRnVuYyBhcyBzdHJpbmc7XG4gIGlmICh0eXBlb2Ygd29ya2Zsb3dUeXBlT3JGdW5jID09PSAnZnVuY3Rpb24nKSB7XG4gICAgaWYgKHdvcmtmbG93VHlwZU9yRnVuYz8ubmFtZSkgcmV0dXJuIHdvcmtmbG93VHlwZU9yRnVuYy5uYW1lO1xuICAgIHRocm93IG5ldyBUeXBlRXJyb3IoJ0ludmFsaWQgd29ya2Zsb3cgdHlwZTogdGhlIHdvcmtmbG93IGZ1bmN0aW9uIGlzIGFub255bW91cycpO1xuICB9XG4gIHRocm93IG5ldyBUeXBlRXJyb3IoXG4gICAgYEludmFsaWQgd29ya2Zsb3cgdHlwZTogZXhwZWN0ZWQgZWl0aGVyIGEgc3RyaW5nIG9yIGEgZnVuY3Rpb24sIGdvdCAnJHt0eXBlb2Ygd29ya2Zsb3dUeXBlT3JGdW5jfSdgXG4gICk7XG59XG4iLCIvKipcbiAqIEhlbHBlcnMuXG4gKi9cblxudmFyIHMgPSAxMDAwO1xudmFyIG0gPSBzICogNjA7XG52YXIgaCA9IG0gKiA2MDtcbnZhciBkID0gaCAqIDI0O1xudmFyIHcgPSBkICogNztcbnZhciB5ID0gZCAqIDM2NS4yNTtcblxuLyoqXG4gKiBQYXJzZSBvciBmb3JtYXQgdGhlIGdpdmVuIGB2YWxgLlxuICpcbiAqIE9wdGlvbnM6XG4gKlxuICogIC0gYGxvbmdgIHZlcmJvc2UgZm9ybWF0dGluZyBbZmFsc2VdXG4gKlxuICogQHBhcmFtIHtTdHJpbmd8TnVtYmVyfSB2YWxcbiAqIEBwYXJhbSB7T2JqZWN0fSBbb3B0aW9uc11cbiAqIEB0aHJvd3Mge0Vycm9yfSB0aHJvdyBhbiBlcnJvciBpZiB2YWwgaXMgbm90IGEgbm9uLWVtcHR5IHN0cmluZyBvciBhIG51bWJlclxuICogQHJldHVybiB7U3RyaW5nfE51bWJlcn1cbiAqIEBhcGkgcHVibGljXG4gKi9cblxubW9kdWxlLmV4cG9ydHMgPSBmdW5jdGlvbih2YWwsIG9wdGlvbnMpIHtcbiAgb3B0aW9ucyA9IG9wdGlvbnMgfHwge307XG4gIHZhciB0eXBlID0gdHlwZW9mIHZhbDtcbiAgaWYgKHR5cGUgPT09ICdzdHJpbmcnICYmIHZhbC5sZW5ndGggPiAwKSB7XG4gICAgcmV0dXJuIHBhcnNlKHZhbCk7XG4gIH0gZWxzZSBpZiAodHlwZSA9PT0gJ251bWJlcicgJiYgaXNGaW5pdGUodmFsKSkge1xuICAgIHJldHVybiBvcHRpb25zLmxvbmcgPyBmbXRMb25nKHZhbCkgOiBmbXRTaG9ydCh2YWwpO1xuICB9XG4gIHRocm93IG5ldyBFcnJvcihcbiAgICAndmFsIGlzIG5vdCBhIG5vbi1lbXB0eSBzdHJpbmcgb3IgYSB2YWxpZCBudW1iZXIuIHZhbD0nICtcbiAgICAgIEpTT04uc3RyaW5naWZ5KHZhbClcbiAgKTtcbn07XG5cbi8qKlxuICogUGFyc2UgdGhlIGdpdmVuIGBzdHJgIGFuZCByZXR1cm4gbWlsbGlzZWNvbmRzLlxuICpcbiAqIEBwYXJhbSB7U3RyaW5nfSBzdHJcbiAqIEByZXR1cm4ge051bWJlcn1cbiAqIEBhcGkgcHJpdmF0ZVxuICovXG5cbmZ1bmN0aW9uIHBhcnNlKHN0cikge1xuICBzdHIgPSBTdHJpbmcoc3RyKTtcbiAgaWYgKHN0ci5sZW5ndGggPiAxMDApIHtcbiAgICByZXR1cm47XG4gIH1cbiAgdmFyIG1hdGNoID0gL14oLT8oPzpcXGQrKT9cXC4/XFxkKykgKihtaWxsaXNlY29uZHM/fG1zZWNzP3xtc3xzZWNvbmRzP3xzZWNzP3xzfG1pbnV0ZXM/fG1pbnM/fG18aG91cnM/fGhycz98aHxkYXlzP3xkfHdlZWtzP3x3fHllYXJzP3x5cnM/fHkpPyQvaS5leGVjKFxuICAgIHN0clxuICApO1xuICBpZiAoIW1hdGNoKSB7XG4gICAgcmV0dXJuO1xuICB9XG4gIHZhciBuID0gcGFyc2VGbG9hdChtYXRjaFsxXSk7XG4gIHZhciB0eXBlID0gKG1hdGNoWzJdIHx8ICdtcycpLnRvTG93ZXJDYXNlKCk7XG4gIHN3aXRjaCAodHlwZSkge1xuICAgIGNhc2UgJ3llYXJzJzpcbiAgICBjYXNlICd5ZWFyJzpcbiAgICBjYXNlICd5cnMnOlxuICAgIGNhc2UgJ3lyJzpcbiAgICBjYXNlICd5JzpcbiAgICAgIHJldHVybiBuICogeTtcbiAgICBjYXNlICd3ZWVrcyc6XG4gICAgY2FzZSAnd2Vlayc6XG4gICAgY2FzZSAndyc6XG4gICAgICByZXR1cm4gbiAqIHc7XG4gICAgY2FzZSAnZGF5cyc6XG4gICAgY2FzZSAnZGF5JzpcbiAgICBjYXNlICdkJzpcbiAgICAgIHJldHVybiBuICogZDtcbiAgICBjYXNlICdob3Vycyc6XG4gICAgY2FzZSAnaG91cic6XG4gICAgY2FzZSAnaHJzJzpcbiAgICBjYXNlICdocic6XG4gICAgY2FzZSAnaCc6XG4gICAgICByZXR1cm4gbiAqIGg7XG4gICAgY2FzZSAnbWludXRlcyc6XG4gICAgY2FzZSAnbWludXRlJzpcbiAgICBjYXNlICdtaW5zJzpcbiAgICBjYXNlICdtaW4nOlxuICAgIGNhc2UgJ20nOlxuICAgICAgcmV0dXJuIG4gKiBtO1xuICAgIGNhc2UgJ3NlY29uZHMnOlxuICAgIGNhc2UgJ3NlY29uZCc6XG4gICAgY2FzZSAnc2Vjcyc6XG4gICAgY2FzZSAnc2VjJzpcbiAgICBjYXNlICdzJzpcbiAgICAgIHJldHVybiBuICogcztcbiAgICBjYXNlICdtaWxsaXNlY29uZHMnOlxuICAgIGNhc2UgJ21pbGxpc2Vjb25kJzpcbiAgICBjYXNlICdtc2Vjcyc6XG4gICAgY2FzZSAnbXNlYyc6XG4gICAgY2FzZSAnbXMnOlxuICAgICAgcmV0dXJuIG47XG4gICAgZGVmYXVsdDpcbiAgICAgIHJldHVybiB1bmRlZmluZWQ7XG4gIH1cbn1cblxuLyoqXG4gKiBTaG9ydCBmb3JtYXQgZm9yIGBtc2AuXG4gKlxuICogQHBhcmFtIHtOdW1iZXJ9IG1zXG4gKiBAcmV0dXJuIHtTdHJpbmd9XG4gKiBAYXBpIHByaXZhdGVcbiAqL1xuXG5mdW5jdGlvbiBmbXRTaG9ydChtcykge1xuICB2YXIgbXNBYnMgPSBNYXRoLmFicyhtcyk7XG4gIGlmIChtc0FicyA+PSBkKSB7XG4gICAgcmV0dXJuIE1hdGgucm91bmQobXMgLyBkKSArICdkJztcbiAgfVxuICBpZiAobXNBYnMgPj0gaCkge1xuICAgIHJldHVybiBNYXRoLnJvdW5kKG1zIC8gaCkgKyAnaCc7XG4gIH1cbiAgaWYgKG1zQWJzID49IG0pIHtcbiAgICByZXR1cm4gTWF0aC5yb3VuZChtcyAvIG0pICsgJ20nO1xuICB9XG4gIGlmIChtc0FicyA+PSBzKSB7XG4gICAgcmV0dXJuIE1hdGgucm91bmQobXMgLyBzKSArICdzJztcbiAgfVxuICByZXR1cm4gbXMgKyAnbXMnO1xufVxuXG4vKipcbiAqIExvbmcgZm9ybWF0IGZvciBgbXNgLlxuICpcbiAqIEBwYXJhbSB7TnVtYmVyfSBtc1xuICogQHJldHVybiB7U3RyaW5nfVxuICogQGFwaSBwcml2YXRlXG4gKi9cblxuZnVuY3Rpb24gZm10TG9uZyhtcykge1xuICB2YXIgbXNBYnMgPSBNYXRoLmFicyhtcyk7XG4gIGlmIChtc0FicyA+PSBkKSB7XG4gICAgcmV0dXJuIHBsdXJhbChtcywgbXNBYnMsIGQsICdkYXknKTtcbiAgfVxuICBpZiAobXNBYnMgPj0gaCkge1xuICAgIHJldHVybiBwbHVyYWwobXMsIG1zQWJzLCBoLCAnaG91cicpO1xuICB9XG4gIGlmIChtc0FicyA+PSBtKSB7XG4gICAgcmV0dXJuIHBsdXJhbChtcywgbXNBYnMsIG0sICdtaW51dGUnKTtcbiAgfVxuICBpZiAobXNBYnMgPj0gcykge1xuICAgIHJldHVybiBwbHVyYWwobXMsIG1zQWJzLCBzLCAnc2Vjb25kJyk7XG4gIH1cbiAgcmV0dXJuIG1zICsgJyBtcyc7XG59XG5cbi8qKlxuICogUGx1cmFsaXphdGlvbiBoZWxwZXIuXG4gKi9cblxuZnVuY3Rpb24gcGx1cmFsKG1zLCBtc0FicywgbiwgbmFtZSkge1xuICB2YXIgaXNQbHVyYWwgPSBtc0FicyA+PSBuICogMS41O1xuICByZXR1cm4gTWF0aC5yb3VuZChtcyAvIG4pICsgJyAnICsgbmFtZSArIChpc1BsdXJhbCA/ICdzJyA6ICcnKTtcbn1cbiIsIi8qIGVzbGludC1lbnYgYnJvd3NlciAqL1xuXG4vKipcbiAqIFRoaXMgaXMgdGhlIHdlYiBicm93c2VyIGltcGxlbWVudGF0aW9uIG9mIGBkZWJ1ZygpYC5cbiAqL1xuXG5leHBvcnRzLmZvcm1hdEFyZ3MgPSBmb3JtYXRBcmdzO1xuZXhwb3J0cy5zYXZlID0gc2F2ZTtcbmV4cG9ydHMubG9hZCA9IGxvYWQ7XG5leHBvcnRzLnVzZUNvbG9ycyA9IHVzZUNvbG9ycztcbmV4cG9ydHMuc3RvcmFnZSA9IGxvY2Fsc3RvcmFnZSgpO1xuZXhwb3J0cy5kZXN0cm95ID0gKCgpID0+IHtcblx0bGV0IHdhcm5lZCA9IGZhbHNlO1xuXG5cdHJldHVybiAoKSA9PiB7XG5cdFx0aWYgKCF3YXJuZWQpIHtcblx0XHRcdHdhcm5lZCA9IHRydWU7XG5cdFx0XHRjb25zb2xlLndhcm4oJ0luc3RhbmNlIG1ldGhvZCBgZGVidWcuZGVzdHJveSgpYCBpcyBkZXByZWNhdGVkIGFuZCBubyBsb25nZXIgZG9lcyBhbnl0aGluZy4gSXQgd2lsbCBiZSByZW1vdmVkIGluIHRoZSBuZXh0IG1ham9yIHZlcnNpb24gb2YgYGRlYnVnYC4nKTtcblx0XHR9XG5cdH07XG59KSgpO1xuXG4vKipcbiAqIENvbG9ycy5cbiAqL1xuXG5leHBvcnRzLmNvbG9ycyA9IFtcblx0JyMwMDAwQ0MnLFxuXHQnIzAwMDBGRicsXG5cdCcjMDAzM0NDJyxcblx0JyMwMDMzRkYnLFxuXHQnIzAwNjZDQycsXG5cdCcjMDA2NkZGJyxcblx0JyMwMDk5Q0MnLFxuXHQnIzAwOTlGRicsXG5cdCcjMDBDQzAwJyxcblx0JyMwMENDMzMnLFxuXHQnIzAwQ0M2NicsXG5cdCcjMDBDQzk5Jyxcblx0JyMwMENDQ0MnLFxuXHQnIzAwQ0NGRicsXG5cdCcjMzMwMENDJyxcblx0JyMzMzAwRkYnLFxuXHQnIzMzMzNDQycsXG5cdCcjMzMzM0ZGJyxcblx0JyMzMzY2Q0MnLFxuXHQnIzMzNjZGRicsXG5cdCcjMzM5OUNDJyxcblx0JyMzMzk5RkYnLFxuXHQnIzMzQ0MwMCcsXG5cdCcjMzNDQzMzJyxcblx0JyMzM0NDNjYnLFxuXHQnIzMzQ0M5OScsXG5cdCcjMzNDQ0NDJyxcblx0JyMzM0NDRkYnLFxuXHQnIzY2MDBDQycsXG5cdCcjNjYwMEZGJyxcblx0JyM2NjMzQ0MnLFxuXHQnIzY2MzNGRicsXG5cdCcjNjZDQzAwJyxcblx0JyM2NkNDMzMnLFxuXHQnIzk5MDBDQycsXG5cdCcjOTkwMEZGJyxcblx0JyM5OTMzQ0MnLFxuXHQnIzk5MzNGRicsXG5cdCcjOTlDQzAwJyxcblx0JyM5OUNDMzMnLFxuXHQnI0NDMDAwMCcsXG5cdCcjQ0MwMDMzJyxcblx0JyNDQzAwNjYnLFxuXHQnI0NDMDA5OScsXG5cdCcjQ0MwMENDJyxcblx0JyNDQzAwRkYnLFxuXHQnI0NDMzMwMCcsXG5cdCcjQ0MzMzMzJyxcblx0JyNDQzMzNjYnLFxuXHQnI0NDMzM5OScsXG5cdCcjQ0MzM0NDJyxcblx0JyNDQzMzRkYnLFxuXHQnI0NDNjYwMCcsXG5cdCcjQ0M2NjMzJyxcblx0JyNDQzk5MDAnLFxuXHQnI0NDOTkzMycsXG5cdCcjQ0NDQzAwJyxcblx0JyNDQ0NDMzMnLFxuXHQnI0ZGMDAwMCcsXG5cdCcjRkYwMDMzJyxcblx0JyNGRjAwNjYnLFxuXHQnI0ZGMDA5OScsXG5cdCcjRkYwMENDJyxcblx0JyNGRjAwRkYnLFxuXHQnI0ZGMzMwMCcsXG5cdCcjRkYzMzMzJyxcblx0JyNGRjMzNjYnLFxuXHQnI0ZGMzM5OScsXG5cdCcjRkYzM0NDJyxcblx0JyNGRjMzRkYnLFxuXHQnI0ZGNjYwMCcsXG5cdCcjRkY2NjMzJyxcblx0JyNGRjk5MDAnLFxuXHQnI0ZGOTkzMycsXG5cdCcjRkZDQzAwJyxcblx0JyNGRkNDMzMnXG5dO1xuXG4vKipcbiAqIEN1cnJlbnRseSBvbmx5IFdlYktpdC1iYXNlZCBXZWIgSW5zcGVjdG9ycywgRmlyZWZveCA+PSB2MzEsXG4gKiBhbmQgdGhlIEZpcmVidWcgZXh0ZW5zaW9uIChhbnkgRmlyZWZveCB2ZXJzaW9uKSBhcmUga25vd25cbiAqIHRvIHN1cHBvcnQgXCIlY1wiIENTUyBjdXN0b21pemF0aW9ucy5cbiAqXG4gKiBUT0RPOiBhZGQgYSBgbG9jYWxTdG9yYWdlYCB2YXJpYWJsZSB0byBleHBsaWNpdGx5IGVuYWJsZS9kaXNhYmxlIGNvbG9yc1xuICovXG5cbi8vIGVzbGludC1kaXNhYmxlLW5leHQtbGluZSBjb21wbGV4aXR5XG5mdW5jdGlvbiB1c2VDb2xvcnMoKSB7XG5cdC8vIE5COiBJbiBhbiBFbGVjdHJvbiBwcmVsb2FkIHNjcmlwdCwgZG9jdW1lbnQgd2lsbCBiZSBkZWZpbmVkIGJ1dCBub3QgZnVsbHlcblx0Ly8gaW5pdGlhbGl6ZWQuIFNpbmNlIHdlIGtub3cgd2UncmUgaW4gQ2hyb21lLCB3ZSdsbCBqdXN0IGRldGVjdCB0aGlzIGNhc2Vcblx0Ly8gZXhwbGljaXRseVxuXHRpZiAodHlwZW9mIHdpbmRvdyAhPT0gJ3VuZGVmaW5lZCcgJiYgd2luZG93LnByb2Nlc3MgJiYgKHdpbmRvdy5wcm9jZXNzLnR5cGUgPT09ICdyZW5kZXJlcicgfHwgd2luZG93LnByb2Nlc3MuX19ud2pzKSkge1xuXHRcdHJldHVybiB0cnVlO1xuXHR9XG5cblx0Ly8gSW50ZXJuZXQgRXhwbG9yZXIgYW5kIEVkZ2UgZG8gbm90IHN1cHBvcnQgY29sb3JzLlxuXHRpZiAodHlwZW9mIG5hdmlnYXRvciAhPT0gJ3VuZGVmaW5lZCcgJiYgbmF2aWdhdG9yLnVzZXJBZ2VudCAmJiBuYXZpZ2F0b3IudXNlckFnZW50LnRvTG93ZXJDYXNlKCkubWF0Y2goLyhlZGdlfHRyaWRlbnQpXFwvKFxcZCspLykpIHtcblx0XHRyZXR1cm4gZmFsc2U7XG5cdH1cblxuXHRsZXQgbTtcblxuXHQvLyBJcyB3ZWJraXQ/IGh0dHA6Ly9zdGFja292ZXJmbG93LmNvbS9hLzE2NDU5NjA2LzM3Njc3M1xuXHQvLyBkb2N1bWVudCBpcyB1bmRlZmluZWQgaW4gcmVhY3QtbmF0aXZlOiBodHRwczovL2dpdGh1Yi5jb20vZmFjZWJvb2svcmVhY3QtbmF0aXZlL3B1bGwvMTYzMlxuXHRyZXR1cm4gKHR5cGVvZiBkb2N1bWVudCAhPT0gJ3VuZGVmaW5lZCcgJiYgZG9jdW1lbnQuZG9jdW1lbnRFbGVtZW50ICYmIGRvY3VtZW50LmRvY3VtZW50RWxlbWVudC5zdHlsZSAmJiBkb2N1bWVudC5kb2N1bWVudEVsZW1lbnQuc3R5bGUuV2Via2l0QXBwZWFyYW5jZSkgfHxcblx0XHQvLyBJcyBmaXJlYnVnPyBodHRwOi8vc3RhY2tvdmVyZmxvdy5jb20vYS8zOTgxMjAvMzc2NzczXG5cdFx0KHR5cGVvZiB3aW5kb3cgIT09ICd1bmRlZmluZWQnICYmIHdpbmRvdy5jb25zb2xlICYmICh3aW5kb3cuY29uc29sZS5maXJlYnVnIHx8ICh3aW5kb3cuY29uc29sZS5leGNlcHRpb24gJiYgd2luZG93LmNvbnNvbGUudGFibGUpKSkgfHxcblx0XHQvLyBJcyBmaXJlZm94ID49IHYzMT9cblx0XHQvLyBodHRwczovL2RldmVsb3Blci5tb3ppbGxhLm9yZy9lbi1VUy9kb2NzL1Rvb2xzL1dlYl9Db25zb2xlI1N0eWxpbmdfbWVzc2FnZXNcblx0XHQodHlwZW9mIG5hdmlnYXRvciAhPT0gJ3VuZGVmaW5lZCcgJiYgbmF2aWdhdG9yLnVzZXJBZ2VudCAmJiAobSA9IG5hdmlnYXRvci51c2VyQWdlbnQudG9Mb3dlckNhc2UoKS5tYXRjaCgvZmlyZWZveFxcLyhcXGQrKS8pKSAmJiBwYXJzZUludChtWzFdLCAxMCkgPj0gMzEpIHx8XG5cdFx0Ly8gRG91YmxlIGNoZWNrIHdlYmtpdCBpbiB1c2VyQWdlbnQganVzdCBpbiBjYXNlIHdlIGFyZSBpbiBhIHdvcmtlclxuXHRcdCh0eXBlb2YgbmF2aWdhdG9yICE9PSAndW5kZWZpbmVkJyAmJiBuYXZpZ2F0b3IudXNlckFnZW50ICYmIG5hdmlnYXRvci51c2VyQWdlbnQudG9Mb3dlckNhc2UoKS5tYXRjaCgvYXBwbGV3ZWJraXRcXC8oXFxkKykvKSk7XG59XG5cbi8qKlxuICogQ29sb3JpemUgbG9nIGFyZ3VtZW50cyBpZiBlbmFibGVkLlxuICpcbiAqIEBhcGkgcHVibGljXG4gKi9cblxuZnVuY3Rpb24gZm9ybWF0QXJncyhhcmdzKSB7XG5cdGFyZ3NbMF0gPSAodGhpcy51c2VDb2xvcnMgPyAnJWMnIDogJycpICtcblx0XHR0aGlzLm5hbWVzcGFjZSArXG5cdFx0KHRoaXMudXNlQ29sb3JzID8gJyAlYycgOiAnICcpICtcblx0XHRhcmdzWzBdICtcblx0XHQodGhpcy51c2VDb2xvcnMgPyAnJWMgJyA6ICcgJykgK1xuXHRcdCcrJyArIG1vZHVsZS5leHBvcnRzLmh1bWFuaXplKHRoaXMuZGlmZik7XG5cblx0aWYgKCF0aGlzLnVzZUNvbG9ycykge1xuXHRcdHJldHVybjtcblx0fVxuXG5cdGNvbnN0IGMgPSAnY29sb3I6ICcgKyB0aGlzLmNvbG9yO1xuXHRhcmdzLnNwbGljZSgxLCAwLCBjLCAnY29sb3I6IGluaGVyaXQnKTtcblxuXHQvLyBUaGUgZmluYWwgXCIlY1wiIGlzIHNvbWV3aGF0IHRyaWNreSwgYmVjYXVzZSB0aGVyZSBjb3VsZCBiZSBvdGhlclxuXHQvLyBhcmd1bWVudHMgcGFzc2VkIGVpdGhlciBiZWZvcmUgb3IgYWZ0ZXIgdGhlICVjLCBzbyB3ZSBuZWVkIHRvXG5cdC8vIGZpZ3VyZSBvdXQgdGhlIGNvcnJlY3QgaW5kZXggdG8gaW5zZXJ0IHRoZSBDU1MgaW50b1xuXHRsZXQgaW5kZXggPSAwO1xuXHRsZXQgbGFzdEMgPSAwO1xuXHRhcmdzWzBdLnJlcGxhY2UoLyVbYS16QS1aJV0vZywgbWF0Y2ggPT4ge1xuXHRcdGlmIChtYXRjaCA9PT0gJyUlJykge1xuXHRcdFx0cmV0dXJuO1xuXHRcdH1cblx0XHRpbmRleCsrO1xuXHRcdGlmIChtYXRjaCA9PT0gJyVjJykge1xuXHRcdFx0Ly8gV2Ugb25seSBhcmUgaW50ZXJlc3RlZCBpbiB0aGUgKmxhc3QqICVjXG5cdFx0XHQvLyAodGhlIHVzZXIgbWF5IGhhdmUgcHJvdmlkZWQgdGhlaXIgb3duKVxuXHRcdFx0bGFzdEMgPSBpbmRleDtcblx0XHR9XG5cdH0pO1xuXG5cdGFyZ3Muc3BsaWNlKGxhc3RDLCAwLCBjKTtcbn1cblxuLyoqXG4gKiBJbnZva2VzIGBjb25zb2xlLmRlYnVnKClgIHdoZW4gYXZhaWxhYmxlLlxuICogTm8tb3Agd2hlbiBgY29uc29sZS5kZWJ1Z2AgaXMgbm90IGEgXCJmdW5jdGlvblwiLlxuICogSWYgYGNvbnNvbGUuZGVidWdgIGlzIG5vdCBhdmFpbGFibGUsIGZhbGxzIGJhY2tcbiAqIHRvIGBjb25zb2xlLmxvZ2AuXG4gKlxuICogQGFwaSBwdWJsaWNcbiAqL1xuZXhwb3J0cy5sb2cgPSBjb25zb2xlLmRlYnVnIHx8IGNvbnNvbGUubG9nIHx8ICgoKSA9PiB7fSk7XG5cbi8qKlxuICogU2F2ZSBgbmFtZXNwYWNlc2AuXG4gKlxuICogQHBhcmFtIHtTdHJpbmd9IG5hbWVzcGFjZXNcbiAqIEBhcGkgcHJpdmF0ZVxuICovXG5mdW5jdGlvbiBzYXZlKG5hbWVzcGFjZXMpIHtcblx0dHJ5IHtcblx0XHRpZiAobmFtZXNwYWNlcykge1xuXHRcdFx0ZXhwb3J0cy5zdG9yYWdlLnNldEl0ZW0oJ2RlYnVnJywgbmFtZXNwYWNlcyk7XG5cdFx0fSBlbHNlIHtcblx0XHRcdGV4cG9ydHMuc3RvcmFnZS5yZW1vdmVJdGVtKCdkZWJ1ZycpO1xuXHRcdH1cblx0fSBjYXRjaCAoZXJyb3IpIHtcblx0XHQvLyBTd2FsbG93XG5cdFx0Ly8gWFhYIChAUWl4LSkgc2hvdWxkIHdlIGJlIGxvZ2dpbmcgdGhlc2U/XG5cdH1cbn1cblxuLyoqXG4gKiBMb2FkIGBuYW1lc3BhY2VzYC5cbiAqXG4gKiBAcmV0dXJuIHtTdHJpbmd9IHJldHVybnMgdGhlIHByZXZpb3VzbHkgcGVyc2lzdGVkIGRlYnVnIG1vZGVzXG4gKiBAYXBpIHByaXZhdGVcbiAqL1xuZnVuY3Rpb24gbG9hZCgpIHtcblx0bGV0IHI7XG5cdHRyeSB7XG5cdFx0ciA9IGV4cG9ydHMuc3RvcmFnZS5nZXRJdGVtKCdkZWJ1ZycpO1xuXHR9IGNhdGNoIChlcnJvcikge1xuXHRcdC8vIFN3YWxsb3dcblx0XHQvLyBYWFggKEBRaXgtKSBzaG91bGQgd2UgYmUgbG9nZ2luZyB0aGVzZT9cblx0fVxuXG5cdC8vIElmIGRlYnVnIGlzbid0IHNldCBpbiBMUywgYW5kIHdlJ3JlIGluIEVsZWN0cm9uLCB0cnkgdG8gbG9hZCAkREVCVUdcblx0aWYgKCFyICYmIHR5cGVvZiBwcm9jZXNzICE9PSAndW5kZWZpbmVkJyAmJiAnZW52JyBpbiBwcm9jZXNzKSB7XG5cdFx0ciA9IHByb2Nlc3MuZW52LkRFQlVHO1xuXHR9XG5cblx0cmV0dXJuIHI7XG59XG5cbi8qKlxuICogTG9jYWxzdG9yYWdlIGF0dGVtcHRzIHRvIHJldHVybiB0aGUgbG9jYWxzdG9yYWdlLlxuICpcbiAqIFRoaXMgaXMgbmVjZXNzYXJ5IGJlY2F1c2Ugc2FmYXJpIHRocm93c1xuICogd2hlbiBhIHVzZXIgZGlzYWJsZXMgY29va2llcy9sb2NhbHN0b3JhZ2VcbiAqIGFuZCB5b3UgYXR0ZW1wdCB0byBhY2Nlc3MgaXQuXG4gKlxuICogQHJldHVybiB7TG9jYWxTdG9yYWdlfVxuICogQGFwaSBwcml2YXRlXG4gKi9cblxuZnVuY3Rpb24gbG9jYWxzdG9yYWdlKCkge1xuXHR0cnkge1xuXHRcdC8vIFRWTUxLaXQgKEFwcGxlIFRWIEpTIFJ1bnRpbWUpIGRvZXMgbm90IGhhdmUgYSB3aW5kb3cgb2JqZWN0LCBqdXN0IGxvY2FsU3RvcmFnZSBpbiB0aGUgZ2xvYmFsIGNvbnRleHRcblx0XHQvLyBUaGUgQnJvd3NlciBhbHNvIGhhcyBsb2NhbFN0b3JhZ2UgaW4gdGhlIGdsb2JhbCBjb250ZXh0LlxuXHRcdHJldHVybiBsb2NhbFN0b3JhZ2U7XG5cdH0gY2F0Y2ggKGVycm9yKSB7XG5cdFx0Ly8gU3dhbGxvd1xuXHRcdC8vIFhYWCAoQFFpeC0pIHNob3VsZCB3ZSBiZSBsb2dnaW5nIHRoZXNlP1xuXHR9XG59XG5cbm1vZHVsZS5leHBvcnRzID0gcmVxdWlyZSgnLi9jb21tb24nKShleHBvcnRzKTtcblxuY29uc3Qge2Zvcm1hdHRlcnN9ID0gbW9kdWxlLmV4cG9ydHM7XG5cbi8qKlxuICogTWFwICVqIHRvIGBKU09OLnN0cmluZ2lmeSgpYCwgc2luY2Ugbm8gV2ViIEluc3BlY3RvcnMgZG8gdGhhdCBieSBkZWZhdWx0LlxuICovXG5cbmZvcm1hdHRlcnMuaiA9IGZ1bmN0aW9uICh2KSB7XG5cdHRyeSB7XG5cdFx0cmV0dXJuIEpTT04uc3RyaW5naWZ5KHYpO1xuXHR9IGNhdGNoIChlcnJvcikge1xuXHRcdHJldHVybiAnW1VuZXhwZWN0ZWRKU09OUGFyc2VFcnJvcl06ICcgKyBlcnJvci5tZXNzYWdlO1xuXHR9XG59O1xuIiwiXG4vKipcbiAqIFRoaXMgaXMgdGhlIGNvbW1vbiBsb2dpYyBmb3IgYm90aCB0aGUgTm9kZS5qcyBhbmQgd2ViIGJyb3dzZXJcbiAqIGltcGxlbWVudGF0aW9ucyBvZiBgZGVidWcoKWAuXG4gKi9cblxuZnVuY3Rpb24gc2V0dXAoZW52KSB7XG5cdGNyZWF0ZURlYnVnLmRlYnVnID0gY3JlYXRlRGVidWc7XG5cdGNyZWF0ZURlYnVnLmRlZmF1bHQgPSBjcmVhdGVEZWJ1Zztcblx0Y3JlYXRlRGVidWcuY29lcmNlID0gY29lcmNlO1xuXHRjcmVhdGVEZWJ1Zy5kaXNhYmxlID0gZGlzYWJsZTtcblx0Y3JlYXRlRGVidWcuZW5hYmxlID0gZW5hYmxlO1xuXHRjcmVhdGVEZWJ1Zy5lbmFibGVkID0gZW5hYmxlZDtcblx0Y3JlYXRlRGVidWcuaHVtYW5pemUgPSByZXF1aXJlKCdtcycpO1xuXHRjcmVhdGVEZWJ1Zy5kZXN0cm95ID0gZGVzdHJveTtcblxuXHRPYmplY3Qua2V5cyhlbnYpLmZvckVhY2goa2V5ID0+IHtcblx0XHRjcmVhdGVEZWJ1Z1trZXldID0gZW52W2tleV07XG5cdH0pO1xuXG5cdC8qKlxuXHQqIFRoZSBjdXJyZW50bHkgYWN0aXZlIGRlYnVnIG1vZGUgbmFtZXMsIGFuZCBuYW1lcyB0byBza2lwLlxuXHQqL1xuXG5cdGNyZWF0ZURlYnVnLm5hbWVzID0gW107XG5cdGNyZWF0ZURlYnVnLnNraXBzID0gW107XG5cblx0LyoqXG5cdCogTWFwIG9mIHNwZWNpYWwgXCIlblwiIGhhbmRsaW5nIGZ1bmN0aW9ucywgZm9yIHRoZSBkZWJ1ZyBcImZvcm1hdFwiIGFyZ3VtZW50LlxuXHQqXG5cdCogVmFsaWQga2V5IG5hbWVzIGFyZSBhIHNpbmdsZSwgbG93ZXIgb3IgdXBwZXItY2FzZSBsZXR0ZXIsIGkuZS4gXCJuXCIgYW5kIFwiTlwiLlxuXHQqL1xuXHRjcmVhdGVEZWJ1Zy5mb3JtYXR0ZXJzID0ge307XG5cblx0LyoqXG5cdCogU2VsZWN0cyBhIGNvbG9yIGZvciBhIGRlYnVnIG5hbWVzcGFjZVxuXHQqIEBwYXJhbSB7U3RyaW5nfSBuYW1lc3BhY2UgVGhlIG5hbWVzcGFjZSBzdHJpbmcgZm9yIHRoZSBkZWJ1ZyBpbnN0YW5jZSB0byBiZSBjb2xvcmVkXG5cdCogQHJldHVybiB7TnVtYmVyfFN0cmluZ30gQW4gQU5TSSBjb2xvciBjb2RlIGZvciB0aGUgZ2l2ZW4gbmFtZXNwYWNlXG5cdCogQGFwaSBwcml2YXRlXG5cdCovXG5cdGZ1bmN0aW9uIHNlbGVjdENvbG9yKG5hbWVzcGFjZSkge1xuXHRcdGxldCBoYXNoID0gMDtcblxuXHRcdGZvciAobGV0IGkgPSAwOyBpIDwgbmFtZXNwYWNlLmxlbmd0aDsgaSsrKSB7XG5cdFx0XHRoYXNoID0gKChoYXNoIDw8IDUpIC0gaGFzaCkgKyBuYW1lc3BhY2UuY2hhckNvZGVBdChpKTtcblx0XHRcdGhhc2ggfD0gMDsgLy8gQ29udmVydCB0byAzMmJpdCBpbnRlZ2VyXG5cdFx0fVxuXG5cdFx0cmV0dXJuIGNyZWF0ZURlYnVnLmNvbG9yc1tNYXRoLmFicyhoYXNoKSAlIGNyZWF0ZURlYnVnLmNvbG9ycy5sZW5ndGhdO1xuXHR9XG5cdGNyZWF0ZURlYnVnLnNlbGVjdENvbG9yID0gc2VsZWN0Q29sb3I7XG5cblx0LyoqXG5cdCogQ3JlYXRlIGEgZGVidWdnZXIgd2l0aCB0aGUgZ2l2ZW4gYG5hbWVzcGFjZWAuXG5cdCpcblx0KiBAcGFyYW0ge1N0cmluZ30gbmFtZXNwYWNlXG5cdCogQHJldHVybiB7RnVuY3Rpb259XG5cdCogQGFwaSBwdWJsaWNcblx0Ki9cblx0ZnVuY3Rpb24gY3JlYXRlRGVidWcobmFtZXNwYWNlKSB7XG5cdFx0bGV0IHByZXZUaW1lO1xuXHRcdGxldCBlbmFibGVPdmVycmlkZSA9IG51bGw7XG5cdFx0bGV0IG5hbWVzcGFjZXNDYWNoZTtcblx0XHRsZXQgZW5hYmxlZENhY2hlO1xuXG5cdFx0ZnVuY3Rpb24gZGVidWcoLi4uYXJncykge1xuXHRcdFx0Ly8gRGlzYWJsZWQ/XG5cdFx0XHRpZiAoIWRlYnVnLmVuYWJsZWQpIHtcblx0XHRcdFx0cmV0dXJuO1xuXHRcdFx0fVxuXG5cdFx0XHRjb25zdCBzZWxmID0gZGVidWc7XG5cblx0XHRcdC8vIFNldCBgZGlmZmAgdGltZXN0YW1wXG5cdFx0XHRjb25zdCBjdXJyID0gTnVtYmVyKG5ldyBEYXRlKCkpO1xuXHRcdFx0Y29uc3QgbXMgPSBjdXJyIC0gKHByZXZUaW1lIHx8IGN1cnIpO1xuXHRcdFx0c2VsZi5kaWZmID0gbXM7XG5cdFx0XHRzZWxmLnByZXYgPSBwcmV2VGltZTtcblx0XHRcdHNlbGYuY3VyciA9IGN1cnI7XG5cdFx0XHRwcmV2VGltZSA9IGN1cnI7XG5cblx0XHRcdGFyZ3NbMF0gPSBjcmVhdGVEZWJ1Zy5jb2VyY2UoYXJnc1swXSk7XG5cblx0XHRcdGlmICh0eXBlb2YgYXJnc1swXSAhPT0gJ3N0cmluZycpIHtcblx0XHRcdFx0Ly8gQW55dGhpbmcgZWxzZSBsZXQncyBpbnNwZWN0IHdpdGggJU9cblx0XHRcdFx0YXJncy51bnNoaWZ0KCclTycpO1xuXHRcdFx0fVxuXG5cdFx0XHQvLyBBcHBseSBhbnkgYGZvcm1hdHRlcnNgIHRyYW5zZm9ybWF0aW9uc1xuXHRcdFx0bGV0IGluZGV4ID0gMDtcblx0XHRcdGFyZ3NbMF0gPSBhcmdzWzBdLnJlcGxhY2UoLyUoW2EtekEtWiVdKS9nLCAobWF0Y2gsIGZvcm1hdCkgPT4ge1xuXHRcdFx0XHQvLyBJZiB3ZSBlbmNvdW50ZXIgYW4gZXNjYXBlZCAlIHRoZW4gZG9uJ3QgaW5jcmVhc2UgdGhlIGFycmF5IGluZGV4XG5cdFx0XHRcdGlmIChtYXRjaCA9PT0gJyUlJykge1xuXHRcdFx0XHRcdHJldHVybiAnJSc7XG5cdFx0XHRcdH1cblx0XHRcdFx0aW5kZXgrKztcblx0XHRcdFx0Y29uc3QgZm9ybWF0dGVyID0gY3JlYXRlRGVidWcuZm9ybWF0dGVyc1tmb3JtYXRdO1xuXHRcdFx0XHRpZiAodHlwZW9mIGZvcm1hdHRlciA9PT0gJ2Z1bmN0aW9uJykge1xuXHRcdFx0XHRcdGNvbnN0IHZhbCA9IGFyZ3NbaW5kZXhdO1xuXHRcdFx0XHRcdG1hdGNoID0gZm9ybWF0dGVyLmNhbGwoc2VsZiwgdmFsKTtcblxuXHRcdFx0XHRcdC8vIE5vdyB3ZSBuZWVkIHRvIHJlbW92ZSBgYXJnc1tpbmRleF1gIHNpbmNlIGl0J3MgaW5saW5lZCBpbiB0aGUgYGZvcm1hdGBcblx0XHRcdFx0XHRhcmdzLnNwbGljZShpbmRleCwgMSk7XG5cdFx0XHRcdFx0aW5kZXgtLTtcblx0XHRcdFx0fVxuXHRcdFx0XHRyZXR1cm4gbWF0Y2g7XG5cdFx0XHR9KTtcblxuXHRcdFx0Ly8gQXBwbHkgZW52LXNwZWNpZmljIGZvcm1hdHRpbmcgKGNvbG9ycywgZXRjLilcblx0XHRcdGNyZWF0ZURlYnVnLmZvcm1hdEFyZ3MuY2FsbChzZWxmLCBhcmdzKTtcblxuXHRcdFx0Y29uc3QgbG9nRm4gPSBzZWxmLmxvZyB8fCBjcmVhdGVEZWJ1Zy5sb2c7XG5cdFx0XHRsb2dGbi5hcHBseShzZWxmLCBhcmdzKTtcblx0XHR9XG5cblx0XHRkZWJ1Zy5uYW1lc3BhY2UgPSBuYW1lc3BhY2U7XG5cdFx0ZGVidWcudXNlQ29sb3JzID0gY3JlYXRlRGVidWcudXNlQ29sb3JzKCk7XG5cdFx0ZGVidWcuY29sb3IgPSBjcmVhdGVEZWJ1Zy5zZWxlY3RDb2xvcihuYW1lc3BhY2UpO1xuXHRcdGRlYnVnLmV4dGVuZCA9IGV4dGVuZDtcblx0XHRkZWJ1Zy5kZXN0cm95ID0gY3JlYXRlRGVidWcuZGVzdHJveTsgLy8gWFhYIFRlbXBvcmFyeS4gV2lsbCBiZSByZW1vdmVkIGluIHRoZSBuZXh0IG1ham9yIHJlbGVhc2UuXG5cblx0XHRPYmplY3QuZGVmaW5lUHJvcGVydHkoZGVidWcsICdlbmFibGVkJywge1xuXHRcdFx0ZW51bWVyYWJsZTogdHJ1ZSxcblx0XHRcdGNvbmZpZ3VyYWJsZTogZmFsc2UsXG5cdFx0XHRnZXQ6ICgpID0+IHtcblx0XHRcdFx0aWYgKGVuYWJsZU92ZXJyaWRlICE9PSBudWxsKSB7XG5cdFx0XHRcdFx0cmV0dXJuIGVuYWJsZU92ZXJyaWRlO1xuXHRcdFx0XHR9XG5cdFx0XHRcdGlmIChuYW1lc3BhY2VzQ2FjaGUgIT09IGNyZWF0ZURlYnVnLm5hbWVzcGFjZXMpIHtcblx0XHRcdFx0XHRuYW1lc3BhY2VzQ2FjaGUgPSBjcmVhdGVEZWJ1Zy5uYW1lc3BhY2VzO1xuXHRcdFx0XHRcdGVuYWJsZWRDYWNoZSA9IGNyZWF0ZURlYnVnLmVuYWJsZWQobmFtZXNwYWNlKTtcblx0XHRcdFx0fVxuXG5cdFx0XHRcdHJldHVybiBlbmFibGVkQ2FjaGU7XG5cdFx0XHR9LFxuXHRcdFx0c2V0OiB2ID0+IHtcblx0XHRcdFx0ZW5hYmxlT3ZlcnJpZGUgPSB2O1xuXHRcdFx0fVxuXHRcdH0pO1xuXG5cdFx0Ly8gRW52LXNwZWNpZmljIGluaXRpYWxpemF0aW9uIGxvZ2ljIGZvciBkZWJ1ZyBpbnN0YW5jZXNcblx0XHRpZiAodHlwZW9mIGNyZWF0ZURlYnVnLmluaXQgPT09ICdmdW5jdGlvbicpIHtcblx0XHRcdGNyZWF0ZURlYnVnLmluaXQoZGVidWcpO1xuXHRcdH1cblxuXHRcdHJldHVybiBkZWJ1Zztcblx0fVxuXG5cdGZ1bmN0aW9uIGV4dGVuZChuYW1lc3BhY2UsIGRlbGltaXRlcikge1xuXHRcdGNvbnN0IG5ld0RlYnVnID0gY3JlYXRlRGVidWcodGhpcy5uYW1lc3BhY2UgKyAodHlwZW9mIGRlbGltaXRlciA9PT0gJ3VuZGVmaW5lZCcgPyAnOicgOiBkZWxpbWl0ZXIpICsgbmFtZXNwYWNlKTtcblx0XHRuZXdEZWJ1Zy5sb2cgPSB0aGlzLmxvZztcblx0XHRyZXR1cm4gbmV3RGVidWc7XG5cdH1cblxuXHQvKipcblx0KiBFbmFibGVzIGEgZGVidWcgbW9kZSBieSBuYW1lc3BhY2VzLiBUaGlzIGNhbiBpbmNsdWRlIG1vZGVzXG5cdCogc2VwYXJhdGVkIGJ5IGEgY29sb24gYW5kIHdpbGRjYXJkcy5cblx0KlxuXHQqIEBwYXJhbSB7U3RyaW5nfSBuYW1lc3BhY2VzXG5cdCogQGFwaSBwdWJsaWNcblx0Ki9cblx0ZnVuY3Rpb24gZW5hYmxlKG5hbWVzcGFjZXMpIHtcblx0XHRjcmVhdGVEZWJ1Zy5zYXZlKG5hbWVzcGFjZXMpO1xuXHRcdGNyZWF0ZURlYnVnLm5hbWVzcGFjZXMgPSBuYW1lc3BhY2VzO1xuXG5cdFx0Y3JlYXRlRGVidWcubmFtZXMgPSBbXTtcblx0XHRjcmVhdGVEZWJ1Zy5za2lwcyA9IFtdO1xuXG5cdFx0bGV0IGk7XG5cdFx0Y29uc3Qgc3BsaXQgPSAodHlwZW9mIG5hbWVzcGFjZXMgPT09ICdzdHJpbmcnID8gbmFtZXNwYWNlcyA6ICcnKS5zcGxpdCgvW1xccyxdKy8pO1xuXHRcdGNvbnN0IGxlbiA9IHNwbGl0Lmxlbmd0aDtcblxuXHRcdGZvciAoaSA9IDA7IGkgPCBsZW47IGkrKykge1xuXHRcdFx0aWYgKCFzcGxpdFtpXSkge1xuXHRcdFx0XHQvLyBpZ25vcmUgZW1wdHkgc3RyaW5nc1xuXHRcdFx0XHRjb250aW51ZTtcblx0XHRcdH1cblxuXHRcdFx0bmFtZXNwYWNlcyA9IHNwbGl0W2ldLnJlcGxhY2UoL1xcKi9nLCAnLio/Jyk7XG5cblx0XHRcdGlmIChuYW1lc3BhY2VzWzBdID09PSAnLScpIHtcblx0XHRcdFx0Y3JlYXRlRGVidWcuc2tpcHMucHVzaChuZXcgUmVnRXhwKCdeJyArIG5hbWVzcGFjZXMuc2xpY2UoMSkgKyAnJCcpKTtcblx0XHRcdH0gZWxzZSB7XG5cdFx0XHRcdGNyZWF0ZURlYnVnLm5hbWVzLnB1c2gobmV3IFJlZ0V4cCgnXicgKyBuYW1lc3BhY2VzICsgJyQnKSk7XG5cdFx0XHR9XG5cdFx0fVxuXHR9XG5cblx0LyoqXG5cdCogRGlzYWJsZSBkZWJ1ZyBvdXRwdXQuXG5cdCpcblx0KiBAcmV0dXJuIHtTdHJpbmd9IG5hbWVzcGFjZXNcblx0KiBAYXBpIHB1YmxpY1xuXHQqL1xuXHRmdW5jdGlvbiBkaXNhYmxlKCkge1xuXHRcdGNvbnN0IG5hbWVzcGFjZXMgPSBbXG5cdFx0XHQuLi5jcmVhdGVEZWJ1Zy5uYW1lcy5tYXAodG9OYW1lc3BhY2UpLFxuXHRcdFx0Li4uY3JlYXRlRGVidWcuc2tpcHMubWFwKHRvTmFtZXNwYWNlKS5tYXAobmFtZXNwYWNlID0+ICctJyArIG5hbWVzcGFjZSlcblx0XHRdLmpvaW4oJywnKTtcblx0XHRjcmVhdGVEZWJ1Zy5lbmFibGUoJycpO1xuXHRcdHJldHVybiBuYW1lc3BhY2VzO1xuXHR9XG5cblx0LyoqXG5cdCogUmV0dXJucyB0cnVlIGlmIHRoZSBnaXZlbiBtb2RlIG5hbWUgaXMgZW5hYmxlZCwgZmFsc2Ugb3RoZXJ3aXNlLlxuXHQqXG5cdCogQHBhcmFtIHtTdHJpbmd9IG5hbWVcblx0KiBAcmV0dXJuIHtCb29sZWFufVxuXHQqIEBhcGkgcHVibGljXG5cdCovXG5cdGZ1bmN0aW9uIGVuYWJsZWQobmFtZSkge1xuXHRcdGlmIChuYW1lW25hbWUubGVuZ3RoIC0gMV0gPT09ICcqJykge1xuXHRcdFx0cmV0dXJuIHRydWU7XG5cdFx0fVxuXG5cdFx0bGV0IGk7XG5cdFx0bGV0IGxlbjtcblxuXHRcdGZvciAoaSA9IDAsIGxlbiA9IGNyZWF0ZURlYnVnLnNraXBzLmxlbmd0aDsgaSA8IGxlbjsgaSsrKSB7XG5cdFx0XHRpZiAoY3JlYXRlRGVidWcuc2tpcHNbaV0udGVzdChuYW1lKSkge1xuXHRcdFx0XHRyZXR1cm4gZmFsc2U7XG5cdFx0XHR9XG5cdFx0fVxuXG5cdFx0Zm9yIChpID0gMCwgbGVuID0gY3JlYXRlRGVidWcubmFtZXMubGVuZ3RoOyBpIDwgbGVuOyBpKyspIHtcblx0XHRcdGlmIChjcmVhdGVEZWJ1Zy5uYW1lc1tpXS50ZXN0KG5hbWUpKSB7XG5cdFx0XHRcdHJldHVybiB0cnVlO1xuXHRcdFx0fVxuXHRcdH1cblxuXHRcdHJldHVybiBmYWxzZTtcblx0fVxuXG5cdC8qKlxuXHQqIENvbnZlcnQgcmVnZXhwIHRvIG5hbWVzcGFjZVxuXHQqXG5cdCogQHBhcmFtIHtSZWdFeHB9IHJlZ3hlcFxuXHQqIEByZXR1cm4ge1N0cmluZ30gbmFtZXNwYWNlXG5cdCogQGFwaSBwcml2YXRlXG5cdCovXG5cdGZ1bmN0aW9uIHRvTmFtZXNwYWNlKHJlZ2V4cCkge1xuXHRcdHJldHVybiByZWdleHAudG9TdHJpbmcoKVxuXHRcdFx0LnN1YnN0cmluZygyLCByZWdleHAudG9TdHJpbmcoKS5sZW5ndGggLSAyKVxuXHRcdFx0LnJlcGxhY2UoL1xcLlxcKlxcPyQvLCAnKicpO1xuXHR9XG5cblx0LyoqXG5cdCogQ29lcmNlIGB2YWxgLlxuXHQqXG5cdCogQHBhcmFtIHtNaXhlZH0gdmFsXG5cdCogQHJldHVybiB7TWl4ZWR9XG5cdCogQGFwaSBwcml2YXRlXG5cdCovXG5cdGZ1bmN0aW9uIGNvZXJjZSh2YWwpIHtcblx0XHRpZiAodmFsIGluc3RhbmNlb2YgRXJyb3IpIHtcblx0XHRcdHJldHVybiB2YWwuc3RhY2sgfHwgdmFsLm1lc3NhZ2U7XG5cdFx0fVxuXHRcdHJldHVybiB2YWw7XG5cdH1cblxuXHQvKipcblx0KiBYWFggRE8gTk9UIFVTRS4gVGhpcyBpcyBhIHRlbXBvcmFyeSBzdHViIGZ1bmN0aW9uLlxuXHQqIFhYWCBJdCBXSUxMIGJlIHJlbW92ZWQgaW4gdGhlIG5leHQgbWFqb3IgcmVsZWFzZS5cblx0Ki9cblx0ZnVuY3Rpb24gZGVzdHJveSgpIHtcblx0XHRjb25zb2xlLndhcm4oJ0luc3RhbmNlIG1ldGhvZCBgZGVidWcuZGVzdHJveSgpYCBpcyBkZXByZWNhdGVkIGFuZCBubyBsb25nZXIgZG9lcyBhbnl0aGluZy4gSXQgd2lsbCBiZSByZW1vdmVkIGluIHRoZSBuZXh0IG1ham9yIHZlcnNpb24gb2YgYGRlYnVnYC4nKTtcblx0fVxuXG5cdGNyZWF0ZURlYnVnLmVuYWJsZShjcmVhdGVEZWJ1Zy5sb2FkKCkpO1xuXG5cdHJldHVybiBjcmVhdGVEZWJ1Zztcbn1cblxubW9kdWxlLmV4cG9ydHMgPSBzZXR1cDtcbiIsImV4cG9ydCBmdW5jdGlvbiBhc3NlcnQoY29uZGl0aW9uOiBib29sZWFuLCBtc2c/OiBzdHJpbmcpOiBhc3NlcnRzIGNvbmRpdGlvbiB7XG4gIGlmICghY29uZGl0aW9uKSB0aHJvdyBuZXcgRXJyb3IobXNnIHx8ICdBc3NlcnRpb24gZmFpbGVkJylcbn1cbiIsImltcG9ydCB7IGlzSGV4IH0gZnJvbSAndmllbSdcbmltcG9ydCB7IGFzc2VydCB9IGZyb20gJy4vYXNzZXJ0J1xuXG4vKipcbiAqIENvbnZlcnRzIGEgaGV4IHN0cmluZyB0byBhIFBvc3RncmVzIGJ5dGVhIHN0cmluZy5cbiAqIEBzZWUgaHR0cHM6Ly93d3cucG9zdGdyZXNxbC5vcmcvZG9jcy8xNi9mdW5jdGlvbnMtYmluYXJ5c3RyaW5nLmh0bWwjRU5DT0RFLUZPUk1BVC1IRVhcbiAqIEBwYXJhbSBzdHJcbiAqIEByZXR1cm5zIGBcXFxceCR7c3RyaW5nfWBcbiAqL1xuZXhwb3J0IGZ1bmN0aW9uIGhleFRvQnl0ZWEoc3RyOiBgMHgke3N0cmluZ31gKTogYFxcXFx4JHtzdHJpbmd9YCB7XG4gIGFzc2VydChpc0hleChzdHIpLCAnSGV4IHN0cmluZyBtdXN0IHN0YXJ0IHdpdGggMHgnKVxuICByZXR1cm4gYFxcXFx4JHtzdHIuc2xpY2UoMikudG9Mb3dlckNhc2UoKX1gXG59XG4iLCJleHBvcnQgKiBmcm9tICcuL3RyYW5zZmVyLXdvcmtmbG93L3dvcmtmbG93J1xuZXhwb3J0ICogZnJvbSAnLi9kaXN0cmlidXRpb24td29ya2Zsb3cvd29ya2Zsb3cnXG4iLCIvLyB3b3JrZmxvd3MudHNcbmltcG9ydCB7IHByb3h5QWN0aXZpdGllcywgbG9nLCBBcHBsaWNhdGlvbkZhaWx1cmUgfSBmcm9tICdAdGVtcG9yYWxpby93b3JrZmxvdydcbmltcG9ydCB0eXBlIHsgY3JlYXRlRGlzdHJpYnV0aW9uQWN0aXZpdGllcyB9IGZyb20gJy4vYWN0aXZpdGllcydcblxuY29uc3Qge1xuICBjYWxjdWxhdGVEaXN0cmlidXRpb25TaGFyZXNBY3Rpdml0eSxcbiAgZmV0Y2hEaXN0cmlidXRpb25BY3Rpdml0eSxcbiAgZmV0Y2hBbGxPcGVuRGlzdHJpYnV0aW9uc0FjdGl2aXR5LFxufSA9IHByb3h5QWN0aXZpdGllczxSZXR1cm5UeXBlPHR5cGVvZiBjcmVhdGVEaXN0cmlidXRpb25BY3Rpdml0aWVzPj4oe1xuICBzdGFydFRvQ2xvc2VUaW1lb3V0OiAnMzAgc2Vjb25kcycsXG59KVxuXG5leHBvcnQgYXN5bmMgZnVuY3Rpb24gRGlzdHJpYnV0aW9uV29ya2Zsb3coZGlzdHJpYnV0aW9uSWQ6IG51bWJlcik6IFByb21pc2U8dm9pZD4ge1xuICBjb25zdCBkaXN0cmlidXRpb24gPSBhd2FpdCBmZXRjaERpc3RyaWJ1dGlvbkFjdGl2aXR5KGRpc3RyaWJ1dGlvbklkLnRvU3RyaW5nKCkpXG4gIGlmICghZGlzdHJpYnV0aW9uKSB0aHJvdyBuZXcgQXBwbGljYXRpb25GYWlsdXJlKCdEaXN0cmlidXRpb24gbm90IGZvdW5kJylcbiAgYXdhaXQgY2FsY3VsYXRlRGlzdHJpYnV0aW9uU2hhcmVzQWN0aXZpdHkoZGlzdHJpYnV0aW9uKVxufVxuXG5leHBvcnQgYXN5bmMgZnVuY3Rpb24gRGlzdHJpYnV0aW9uc1dvcmtmbG93KCk6IFByb21pc2U8dm9pZD4ge1xuICAvLyBmZXRjaCBhbGwgZGlzdHJpYnV0aW9ucyBpbiBxdWFsaWZpY2F0aW9uIHBlcmlvZFxuICBjb25zdCBkaXN0cmlidXRpb25zID0gYXdhaXQgZmV0Y2hBbGxPcGVuRGlzdHJpYnV0aW9uc0FjdGl2aXR5KClcbiAgaWYgKCFkaXN0cmlidXRpb25zKSB0aHJvdyBuZXcgQXBwbGljYXRpb25GYWlsdXJlKCdObyBkaXN0cmlidXRpb25zIGZvdW5kJylcblxuICBmb3IgKGNvbnN0IGRpc3RyaWJ1dGlvbiBvZiBkaXN0cmlidXRpb25zKSB7XG4gICAgYXdhaXQgRGlzdHJpYnV0aW9uV29ya2Zsb3coZGlzdHJpYnV0aW9uLmlkKSAvLyBjYWxjdWxhdGUgb25lIGRpc3RyaWJ1dGlvbiBhdCBhIHRpbWUgZm9yIG5vd1xuICB9XG59XG4iLCJpbXBvcnQgeyBwcm94eUFjdGl2aXRpZXMsIHdvcmtmbG93SW5mbyB9IGZyb20gJ0B0ZW1wb3JhbGlvL3dvcmtmbG93J1xuaW1wb3J0IHR5cGUgeyBjcmVhdGVUcmFuc2ZlckFjdGl2aXRpZXMgfSBmcm9tICcuL2FjdGl2aXRpZXMnXG5pbXBvcnQgdHlwZSB7IFVzZXJPcGVyYXRpb24gfSBmcm9tICdwZXJtaXNzaW9ubGVzcydcbmltcG9ydCBzdXBlcmpzb24gZnJvbSAnc3VwZXJqc29uJ1xuaW1wb3J0IGRlYnVnIGZyb20gJ2RlYnVnJ1xuaW1wb3J0IHsgaGV4VG9CeXRlYSB9IGZyb20gJ2FwcC91dGlscy9oZXhUb0J5dGVhJ1xuXG5jb25zdCBsb2cgPSBkZWJ1Zygnd29ya2Zsb3dzOnRyYW5zZmVyJylcblxuY29uc3Qge1xuICB1cHNlcnRUZW1wb3JhbFNlbmRBY2NvdW50VHJhbnNmZXJBY3Rpdml0eSxcbiAgc2ltdWxhdGVUcmFuc2ZlckFjdGl2aXR5LFxuICBnZXRCYXNlQmxvY2tOdW1iZXJBY3Rpdml0eSxcbiAgZGVjb2RlVHJhbnNmZXJVc2VyT3BBY3Rpdml0eSxcbiAgdXBkYXRlVGVtcG9yYWxTZW5kQWNjb3VudFRyYW5zZmVyQWN0aXZpdHksXG4gIHNlbmRVc2VyT3BBY3Rpdml0eSxcbiAgd2FpdEZvclRyYW5zYWN0aW9uUmVjZWlwdEFjdGl2aXR5LFxufSA9IHByb3h5QWN0aXZpdGllczxSZXR1cm5UeXBlPHR5cGVvZiBjcmVhdGVUcmFuc2ZlckFjdGl2aXRpZXM+Pih7XG4gIC8vIFRPRE86IG1ha2UgdGhpcyBjb25maWd1cmFibGVhXG4gIHN0YXJ0VG9DbG9zZVRpbWVvdXQ6ICcxMCBtaW51dGVzJyxcbn0pXG5cbmV4cG9ydCBhc3luYyBmdW5jdGlvbiBUcmFuc2ZlcldvcmtmbG93KHVzZXJPcDogVXNlck9wZXJhdGlvbjwndjAuNyc+KSB7XG4gIGNvbnN0IHdvcmtmbG93SWQgPSB3b3JrZmxvd0luZm8oKS53b3JrZmxvd0lkXG4gIGxvZygnU3RhcnRpbmcgU2VuZFRyYW5zZmVyIFdvcmtmbG93IHdpdGggdXNlck9wOicsIHdvcmtmbG93SWQpXG4gIGF3YWl0IHVwc2VydFRlbXBvcmFsU2VuZEFjY291bnRUcmFuc2ZlckFjdGl2aXR5KHtcbiAgICB3b3JrZmxvd0lkLFxuICAgIGRhdGE6IHtcbiAgICAgIHNlbmRlcjogaGV4VG9CeXRlYSh1c2VyT3Auc2VuZGVyKSxcbiAgICB9LFxuICB9KVxuXG4gIGxvZygnU2ltdWxhdGluZyB0cmFuc2ZlcicsIHdvcmtmbG93SWQpXG4gIGNvbnN0IF8gPSBhd2FpdCBzaW11bGF0ZVRyYW5zZmVyQWN0aXZpdHkod29ya2Zsb3dJZCwgdXNlck9wKVxuICBsb2coJ1N1Y2Nlc3NmdWxseSBzaW11bGF0ZWQgdHJhbnNmZXInLCB3b3JrZmxvd0lkKVxuXG4gIGxvZygnR2V0dGluZyBsYXRlc3QgYmFzZSBibG9jaycsIHdvcmtmbG93SWQpXG4gIGNvbnN0IGNyZWF0ZWRBdEJsb2NrTnVtID0gYXdhaXQgZ2V0QmFzZUJsb2NrTnVtYmVyQWN0aXZpdHkoKVxuICBsb2coJ0Jhc2UgYmxvY2s6JywgeyB3b3JrZmxvd0lkLCBjcmVhdGVkQXRCbG9ja051bTogY3JlYXRlZEF0QmxvY2tOdW0udG9TdHJpbmcoKSB9KVxuXG4gIGxvZygnRGVjb2RpbmcgdHJhbnNmZXIgdXNlck9wJywgd29ya2Zsb3dJZClcbiAgY29uc3QgeyB0b2tlbiwgZnJvbSwgdG8sIGFtb3VudCB9ID0gYXdhaXQgZGVjb2RlVHJhbnNmZXJVc2VyT3BBY3Rpdml0eSh3b3JrZmxvd0lkLCB1c2VyT3ApXG4gIGxvZygnRGVjb2RlZCB0cmFuc2ZlciB1c2VyT3AnLCB7IHdvcmtmbG93SWQsIHRva2VuLCBmcm9tLCB0bywgYW1vdW50OiBhbW91bnQudG9TdHJpbmcoKSB9KVxuXG4gIGxvZygnSW5zZXJ0aW5nIHRlbXBvcmFsIHRyYW5zZmVyIGludG8gdGVtcG9yYWwuc2VuZF9hY2NvdW50X3RyYW5zZmVycycsIHdvcmtmbG93SWQpXG4gIGNvbnN0IHN1Ym1pdHRlZFRyYW5zZmVyID0gdG9rZW5cbiAgICA/IGF3YWl0IHVwZGF0ZVRlbXBvcmFsU2VuZEFjY291bnRUcmFuc2ZlckFjdGl2aXR5KHtcbiAgICAgICAgd29ya2Zsb3dJZCxcbiAgICAgICAgc3RhdHVzOiAnc3VibWl0dGVkJyxcbiAgICAgICAgY3JlYXRlZEF0QmxvY2tOdW0sXG4gICAgICAgIGRhdGE6IHtcbiAgICAgICAgICBmOiBmcm9tLFxuICAgICAgICAgIHQ6IHRvLFxuICAgICAgICAgIHY6IGFtb3VudC50b1N0cmluZygpLFxuICAgICAgICAgIGxvZ19hZGRyOiB0b2tlbixcbiAgICAgICAgfSxcbiAgICAgIH0pXG4gICAgOiBhd2FpdCB1cGRhdGVUZW1wb3JhbFNlbmRBY2NvdW50VHJhbnNmZXJBY3Rpdml0eSh7XG4gICAgICAgIHdvcmtmbG93SWQsXG4gICAgICAgIHN0YXR1czogJ3N1Ym1pdHRlZCcsXG4gICAgICAgIGNyZWF0ZWRBdEJsb2NrTnVtLFxuICAgICAgICBkYXRhOiB7XG4gICAgICAgICAgc2VuZGVyOiBmcm9tLFxuICAgICAgICAgIHZhbHVlOiBhbW91bnQudG9TdHJpbmcoKSxcbiAgICAgICAgICBsb2dfYWRkcjogdG8sXG4gICAgICAgIH0sXG4gICAgICB9KVxuICBsb2coJ0luc2VydGVkIHRlbXBvcmFsIHRyYW5zZmVyIGludG8gdGVtcG9yYWwuc2VuZF9hY2NvdW50X3RyYW5zZmVycycsIHdvcmtmbG93SWQpXG5cbiAgbG9nKCdTZW5kaW5nIFVzZXJPcGVyYXRpb24nLCBzdXBlcmpzb24uc3RyaW5naWZ5KHVzZXJPcCkpXG4gIGNvbnN0IGhhc2ggPSBhd2FpdCBzZW5kVXNlck9wQWN0aXZpdHkod29ya2Zsb3dJZCwgdXNlck9wKVxuICBsb2coJ1VzZXJPcGVyYXRpb24gc2VudCwgaGFzaDonLCBoYXNoKVxuICBjb25zdCBzZW50VHJhbnNmZXIgPSBhd2FpdCB1cGRhdGVUZW1wb3JhbFNlbmRBY2NvdW50VHJhbnNmZXJBY3Rpdml0eSh7XG4gICAgd29ya2Zsb3dJZCxcbiAgICBzdGF0dXM6ICdzZW50JyxcbiAgICBkYXRhOiB7XG4gICAgICAuLi4oc3VibWl0dGVkVHJhbnNmZXIuZGF0YSBhcyBSZWNvcmQ8c3RyaW5nLCB1bmtub3duPiksXG4gICAgICB1c2VyX29wX2hhc2g6IGhhc2gsXG4gICAgfSxcbiAgfSlcblxuICBjb25zdCByZWNlaXB0ID0gYXdhaXQgd2FpdEZvclRyYW5zYWN0aW9uUmVjZWlwdEFjdGl2aXR5KHdvcmtmbG93SWQsIGhhc2gpXG4gIGxvZygnUmVjZWlwdCByZWNlaXZlZDonLCB7IHR4X2hhc2g6IHJlY2VpcHQudHJhbnNhY3Rpb25IYXNoIH0pXG5cbiAgYXdhaXQgdXBkYXRlVGVtcG9yYWxTZW5kQWNjb3VudFRyYW5zZmVyQWN0aXZpdHkoe1xuICAgIHdvcmtmbG93SWQsXG4gICAgc3RhdHVzOiAnY29uZmlybWVkJyxcbiAgICBkYXRhOiB7XG4gICAgICAuLi4oc2VudFRyYW5zZmVyLmRhdGEgYXMgUmVjb3JkPHN0cmluZywgdW5rbm93bj4pLFxuICAgICAgdHhfaGFzaDogaGV4VG9CeXRlYShyZWNlaXB0LnRyYW5zYWN0aW9uSGFzaCksXG4gICAgICBibG9ja19udW06IHJlY2VpcHQuYmxvY2tOdW1iZXIudG9TdHJpbmcoKSxcbiAgICB9LFxuICB9KVxuICByZXR1cm4gaGFzaFxufVxuIiwiLyogKGlnbm9yZWQpICovIiwiXCJ1c2Ugc3RyaWN0XCI7XG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJfX2VzTW9kdWxlXCIsIHsgdmFsdWU6IHRydWUgfSk7XG4vLyBIZWxwZXJzLlxuY29uc3QgcyA9IDEwMDA7XG5jb25zdCBtID0gcyAqIDYwO1xuY29uc3QgaCA9IG0gKiA2MDtcbmNvbnN0IGQgPSBoICogMjQ7XG5jb25zdCB3ID0gZCAqIDc7XG5jb25zdCB5ID0gZCAqIDM2NS4yNTtcbmZ1bmN0aW9uIG1zKHZhbHVlLCBvcHRpb25zKSB7XG4gICAgdHJ5IHtcbiAgICAgICAgaWYgKHR5cGVvZiB2YWx1ZSA9PT0gJ3N0cmluZycgJiYgdmFsdWUubGVuZ3RoID4gMCkge1xuICAgICAgICAgICAgcmV0dXJuIHBhcnNlKHZhbHVlKTtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIGlmICh0eXBlb2YgdmFsdWUgPT09ICdudW1iZXInICYmIGlzRmluaXRlKHZhbHVlKSkge1xuICAgICAgICAgICAgcmV0dXJuIG9wdGlvbnM/LmxvbmcgPyBmbXRMb25nKHZhbHVlKSA6IGZtdFNob3J0KHZhbHVlKTtcbiAgICAgICAgfVxuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ1ZhbHVlIGlzIG5vdCBhIHN0cmluZyBvciBudW1iZXIuJyk7XG4gICAgfVxuICAgIGNhdGNoIChlcnJvcikge1xuICAgICAgICBjb25zdCBtZXNzYWdlID0gaXNFcnJvcihlcnJvcilcbiAgICAgICAgICAgID8gYCR7ZXJyb3IubWVzc2FnZX0uIHZhbHVlPSR7SlNPTi5zdHJpbmdpZnkodmFsdWUpfWBcbiAgICAgICAgICAgIDogJ0FuIHVua25vd24gZXJyb3IgaGFzIG9jY3VyZWQuJztcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKG1lc3NhZ2UpO1xuICAgIH1cbn1cbi8qKlxuICogUGFyc2UgdGhlIGdpdmVuIGBzdHJgIGFuZCByZXR1cm4gbWlsbGlzZWNvbmRzLlxuICovXG5mdW5jdGlvbiBwYXJzZShzdHIpIHtcbiAgICBzdHIgPSBTdHJpbmcoc3RyKTtcbiAgICBpZiAoc3RyLmxlbmd0aCA+IDEwMCkge1xuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ1ZhbHVlIGV4Y2VlZHMgdGhlIG1heGltdW0gbGVuZ3RoIG9mIDEwMCBjaGFyYWN0ZXJzLicpO1xuICAgIH1cbiAgICBjb25zdCBtYXRjaCA9IC9eKC0/KD86XFxkKyk/XFwuP1xcZCspICoobWlsbGlzZWNvbmRzP3xtc2Vjcz98bXN8c2Vjb25kcz98c2Vjcz98c3xtaW51dGVzP3xtaW5zP3xtfGhvdXJzP3xocnM/fGh8ZGF5cz98ZHx3ZWVrcz98d3x5ZWFycz98eXJzP3x5KT8kL2kuZXhlYyhzdHIpO1xuICAgIGlmICghbWF0Y2gpIHtcbiAgICAgICAgcmV0dXJuIE5hTjtcbiAgICB9XG4gICAgY29uc3QgbiA9IHBhcnNlRmxvYXQobWF0Y2hbMV0pO1xuICAgIGNvbnN0IHR5cGUgPSAobWF0Y2hbMl0gfHwgJ21zJykudG9Mb3dlckNhc2UoKTtcbiAgICBzd2l0Y2ggKHR5cGUpIHtcbiAgICAgICAgY2FzZSAneWVhcnMnOlxuICAgICAgICBjYXNlICd5ZWFyJzpcbiAgICAgICAgY2FzZSAneXJzJzpcbiAgICAgICAgY2FzZSAneXInOlxuICAgICAgICBjYXNlICd5JzpcbiAgICAgICAgICAgIHJldHVybiBuICogeTtcbiAgICAgICAgY2FzZSAnd2Vla3MnOlxuICAgICAgICBjYXNlICd3ZWVrJzpcbiAgICAgICAgY2FzZSAndyc6XG4gICAgICAgICAgICByZXR1cm4gbiAqIHc7XG4gICAgICAgIGNhc2UgJ2RheXMnOlxuICAgICAgICBjYXNlICdkYXknOlxuICAgICAgICBjYXNlICdkJzpcbiAgICAgICAgICAgIHJldHVybiBuICogZDtcbiAgICAgICAgY2FzZSAnaG91cnMnOlxuICAgICAgICBjYXNlICdob3VyJzpcbiAgICAgICAgY2FzZSAnaHJzJzpcbiAgICAgICAgY2FzZSAnaHInOlxuICAgICAgICBjYXNlICdoJzpcbiAgICAgICAgICAgIHJldHVybiBuICogaDtcbiAgICAgICAgY2FzZSAnbWludXRlcyc6XG4gICAgICAgIGNhc2UgJ21pbnV0ZSc6XG4gICAgICAgIGNhc2UgJ21pbnMnOlxuICAgICAgICBjYXNlICdtaW4nOlxuICAgICAgICBjYXNlICdtJzpcbiAgICAgICAgICAgIHJldHVybiBuICogbTtcbiAgICAgICAgY2FzZSAnc2Vjb25kcyc6XG4gICAgICAgIGNhc2UgJ3NlY29uZCc6XG4gICAgICAgIGNhc2UgJ3NlY3MnOlxuICAgICAgICBjYXNlICdzZWMnOlxuICAgICAgICBjYXNlICdzJzpcbiAgICAgICAgICAgIHJldHVybiBuICogcztcbiAgICAgICAgY2FzZSAnbWlsbGlzZWNvbmRzJzpcbiAgICAgICAgY2FzZSAnbWlsbGlzZWNvbmQnOlxuICAgICAgICBjYXNlICdtc2Vjcyc6XG4gICAgICAgIGNhc2UgJ21zZWMnOlxuICAgICAgICBjYXNlICdtcyc6XG4gICAgICAgICAgICByZXR1cm4gbjtcbiAgICAgICAgZGVmYXVsdDpcbiAgICAgICAgICAgIC8vIFRoaXMgc2hvdWxkIG5ldmVyIG9jY3VyLlxuICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKGBUaGUgdW5pdCAke3R5cGV9IHdhcyBtYXRjaGVkLCBidXQgbm8gbWF0Y2hpbmcgY2FzZSBleGlzdHMuYCk7XG4gICAgfVxufVxuZXhwb3J0cy5kZWZhdWx0ID0gbXM7XG4vKipcbiAqIFNob3J0IGZvcm1hdCBmb3IgYG1zYC5cbiAqL1xuZnVuY3Rpb24gZm10U2hvcnQobXMpIHtcbiAgICBjb25zdCBtc0FicyA9IE1hdGguYWJzKG1zKTtcbiAgICBpZiAobXNBYnMgPj0gZCkge1xuICAgICAgICByZXR1cm4gYCR7TWF0aC5yb3VuZChtcyAvIGQpfWRgO1xuICAgIH1cbiAgICBpZiAobXNBYnMgPj0gaCkge1xuICAgICAgICByZXR1cm4gYCR7TWF0aC5yb3VuZChtcyAvIGgpfWhgO1xuICAgIH1cbiAgICBpZiAobXNBYnMgPj0gbSkge1xuICAgICAgICByZXR1cm4gYCR7TWF0aC5yb3VuZChtcyAvIG0pfW1gO1xuICAgIH1cbiAgICBpZiAobXNBYnMgPj0gcykge1xuICAgICAgICByZXR1cm4gYCR7TWF0aC5yb3VuZChtcyAvIHMpfXNgO1xuICAgIH1cbiAgICByZXR1cm4gYCR7bXN9bXNgO1xufVxuLyoqXG4gKiBMb25nIGZvcm1hdCBmb3IgYG1zYC5cbiAqL1xuZnVuY3Rpb24gZm10TG9uZyhtcykge1xuICAgIGNvbnN0IG1zQWJzID0gTWF0aC5hYnMobXMpO1xuICAgIGlmIChtc0FicyA+PSBkKSB7XG4gICAgICAgIHJldHVybiBwbHVyYWwobXMsIG1zQWJzLCBkLCAnZGF5Jyk7XG4gICAgfVxuICAgIGlmIChtc0FicyA+PSBoKSB7XG4gICAgICAgIHJldHVybiBwbHVyYWwobXMsIG1zQWJzLCBoLCAnaG91cicpO1xuICAgIH1cbiAgICBpZiAobXNBYnMgPj0gbSkge1xuICAgICAgICByZXR1cm4gcGx1cmFsKG1zLCBtc0FicywgbSwgJ21pbnV0ZScpO1xuICAgIH1cbiAgICBpZiAobXNBYnMgPj0gcykge1xuICAgICAgICByZXR1cm4gcGx1cmFsKG1zLCBtc0FicywgcywgJ3NlY29uZCcpO1xuICAgIH1cbiAgICByZXR1cm4gYCR7bXN9IG1zYDtcbn1cbi8qKlxuICogUGx1cmFsaXphdGlvbiBoZWxwZXIuXG4gKi9cbmZ1bmN0aW9uIHBsdXJhbChtcywgbXNBYnMsIG4sIG5hbWUpIHtcbiAgICBjb25zdCBpc1BsdXJhbCA9IG1zQWJzID49IG4gKiAxLjU7XG4gICAgcmV0dXJuIGAke01hdGgucm91bmQobXMgLyBuKX0gJHtuYW1lfSR7aXNQbHVyYWwgPyAncycgOiAnJ31gO1xufVxuLyoqXG4gKiBBIHR5cGUgZ3VhcmQgZm9yIGVycm9ycy5cbiAqL1xuZnVuY3Rpb24gaXNFcnJvcihlcnJvcikge1xuICAgIHJldHVybiB0eXBlb2YgZXJyb3IgPT09ICdvYmplY3QnICYmIGVycm9yICE9PSBudWxsICYmICdtZXNzYWdlJyBpbiBlcnJvcjtcbn1cbm1vZHVsZS5leHBvcnRzID0gZXhwb3J0cy5kZWZhdWx0O1xubW9kdWxlLmV4cG9ydHMuZGVmYXVsdCA9IGV4cG9ydHMuZGVmYXVsdDtcbiIsIlwidXNlIHN0cmljdFwiO1xuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiX19lc01vZHVsZVwiLCB7IHZhbHVlOiB0cnVlIH0pO1xuLy8gSGVscGVycy5cbmNvbnN0IHMgPSAxMDAwO1xuY29uc3QgbSA9IHMgKiA2MDtcbmNvbnN0IGggPSBtICogNjA7XG5jb25zdCBkID0gaCAqIDI0O1xuY29uc3QgdyA9IGQgKiA3O1xuY29uc3QgeSA9IGQgKiAzNjUuMjU7XG5mdW5jdGlvbiBtcyh2YWx1ZSwgb3B0aW9ucykge1xuICAgIHRyeSB7XG4gICAgICAgIGlmICh0eXBlb2YgdmFsdWUgPT09ICdzdHJpbmcnICYmIHZhbHVlLmxlbmd0aCA+IDApIHtcbiAgICAgICAgICAgIHJldHVybiBwYXJzZSh2YWx1ZSk7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSBpZiAodHlwZW9mIHZhbHVlID09PSAnbnVtYmVyJyAmJiBpc0Zpbml0ZSh2YWx1ZSkpIHtcbiAgICAgICAgICAgIHJldHVybiBvcHRpb25zPy5sb25nID8gZm10TG9uZyh2YWx1ZSkgOiBmbXRTaG9ydCh2YWx1ZSk7XG4gICAgICAgIH1cbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdWYWx1ZSBpcyBub3QgYSBzdHJpbmcgb3IgbnVtYmVyLicpO1xuICAgIH1cbiAgICBjYXRjaCAoZXJyb3IpIHtcbiAgICAgICAgY29uc3QgbWVzc2FnZSA9IGlzRXJyb3IoZXJyb3IpXG4gICAgICAgICAgICA/IGAke2Vycm9yLm1lc3NhZ2V9LiB2YWx1ZT0ke0pTT04uc3RyaW5naWZ5KHZhbHVlKX1gXG4gICAgICAgICAgICA6ICdBbiB1bmtub3duIGVycm9yIGhhcyBvY2N1cmVkLic7XG4gICAgICAgIHRocm93IG5ldyBFcnJvcihtZXNzYWdlKTtcbiAgICB9XG59XG4vKipcbiAqIFBhcnNlIHRoZSBnaXZlbiBgc3RyYCBhbmQgcmV0dXJuIG1pbGxpc2Vjb25kcy5cbiAqL1xuZnVuY3Rpb24gcGFyc2Uoc3RyKSB7XG4gICAgc3RyID0gU3RyaW5nKHN0cik7XG4gICAgaWYgKHN0ci5sZW5ndGggPiAxMDApIHtcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdWYWx1ZSBleGNlZWRzIHRoZSBtYXhpbXVtIGxlbmd0aCBvZiAxMDAgY2hhcmFjdGVycy4nKTtcbiAgICB9XG4gICAgY29uc3QgbWF0Y2ggPSAvXigtPyg/OlxcZCspP1xcLj9cXGQrKSAqKG1pbGxpc2Vjb25kcz98bXNlY3M/fG1zfHNlY29uZHM/fHNlY3M/fHN8bWludXRlcz98bWlucz98bXxob3Vycz98aHJzP3xofGRheXM/fGR8d2Vla3M/fHd8eWVhcnM/fHlycz98eSk/JC9pLmV4ZWMoc3RyKTtcbiAgICBpZiAoIW1hdGNoKSB7XG4gICAgICAgIHJldHVybiBOYU47XG4gICAgfVxuICAgIGNvbnN0IG4gPSBwYXJzZUZsb2F0KG1hdGNoWzFdKTtcbiAgICBjb25zdCB0eXBlID0gKG1hdGNoWzJdIHx8ICdtcycpLnRvTG93ZXJDYXNlKCk7XG4gICAgc3dpdGNoICh0eXBlKSB7XG4gICAgICAgIGNhc2UgJ3llYXJzJzpcbiAgICAgICAgY2FzZSAneWVhcic6XG4gICAgICAgIGNhc2UgJ3lycyc6XG4gICAgICAgIGNhc2UgJ3lyJzpcbiAgICAgICAgY2FzZSAneSc6XG4gICAgICAgICAgICByZXR1cm4gbiAqIHk7XG4gICAgICAgIGNhc2UgJ3dlZWtzJzpcbiAgICAgICAgY2FzZSAnd2Vlayc6XG4gICAgICAgIGNhc2UgJ3cnOlxuICAgICAgICAgICAgcmV0dXJuIG4gKiB3O1xuICAgICAgICBjYXNlICdkYXlzJzpcbiAgICAgICAgY2FzZSAnZGF5JzpcbiAgICAgICAgY2FzZSAnZCc6XG4gICAgICAgICAgICByZXR1cm4gbiAqIGQ7XG4gICAgICAgIGNhc2UgJ2hvdXJzJzpcbiAgICAgICAgY2FzZSAnaG91cic6XG4gICAgICAgIGNhc2UgJ2hycyc6XG4gICAgICAgIGNhc2UgJ2hyJzpcbiAgICAgICAgY2FzZSAnaCc6XG4gICAgICAgICAgICByZXR1cm4gbiAqIGg7XG4gICAgICAgIGNhc2UgJ21pbnV0ZXMnOlxuICAgICAgICBjYXNlICdtaW51dGUnOlxuICAgICAgICBjYXNlICdtaW5zJzpcbiAgICAgICAgY2FzZSAnbWluJzpcbiAgICAgICAgY2FzZSAnbSc6XG4gICAgICAgICAgICByZXR1cm4gbiAqIG07XG4gICAgICAgIGNhc2UgJ3NlY29uZHMnOlxuICAgICAgICBjYXNlICdzZWNvbmQnOlxuICAgICAgICBjYXNlICdzZWNzJzpcbiAgICAgICAgY2FzZSAnc2VjJzpcbiAgICAgICAgY2FzZSAncyc6XG4gICAgICAgICAgICByZXR1cm4gbiAqIHM7XG4gICAgICAgIGNhc2UgJ21pbGxpc2Vjb25kcyc6XG4gICAgICAgIGNhc2UgJ21pbGxpc2Vjb25kJzpcbiAgICAgICAgY2FzZSAnbXNlY3MnOlxuICAgICAgICBjYXNlICdtc2VjJzpcbiAgICAgICAgY2FzZSAnbXMnOlxuICAgICAgICAgICAgcmV0dXJuIG47XG4gICAgICAgIGRlZmF1bHQ6XG4gICAgICAgICAgICAvLyBUaGlzIHNob3VsZCBuZXZlciBvY2N1ci5cbiAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcihgVGhlIHVuaXQgJHt0eXBlfSB3YXMgbWF0Y2hlZCwgYnV0IG5vIG1hdGNoaW5nIGNhc2UgZXhpc3RzLmApO1xuICAgIH1cbn1cbmV4cG9ydHMuZGVmYXVsdCA9IG1zO1xuLyoqXG4gKiBTaG9ydCBmb3JtYXQgZm9yIGBtc2AuXG4gKi9cbmZ1bmN0aW9uIGZtdFNob3J0KG1zKSB7XG4gICAgY29uc3QgbXNBYnMgPSBNYXRoLmFicyhtcyk7XG4gICAgaWYgKG1zQWJzID49IGQpIHtcbiAgICAgICAgcmV0dXJuIGAke01hdGgucm91bmQobXMgLyBkKX1kYDtcbiAgICB9XG4gICAgaWYgKG1zQWJzID49IGgpIHtcbiAgICAgICAgcmV0dXJuIGAke01hdGgucm91bmQobXMgLyBoKX1oYDtcbiAgICB9XG4gICAgaWYgKG1zQWJzID49IG0pIHtcbiAgICAgICAgcmV0dXJuIGAke01hdGgucm91bmQobXMgLyBtKX1tYDtcbiAgICB9XG4gICAgaWYgKG1zQWJzID49IHMpIHtcbiAgICAgICAgcmV0dXJuIGAke01hdGgucm91bmQobXMgLyBzKX1zYDtcbiAgICB9XG4gICAgcmV0dXJuIGAke21zfW1zYDtcbn1cbi8qKlxuICogTG9uZyBmb3JtYXQgZm9yIGBtc2AuXG4gKi9cbmZ1bmN0aW9uIGZtdExvbmcobXMpIHtcbiAgICBjb25zdCBtc0FicyA9IE1hdGguYWJzKG1zKTtcbiAgICBpZiAobXNBYnMgPj0gZCkge1xuICAgICAgICByZXR1cm4gcGx1cmFsKG1zLCBtc0FicywgZCwgJ2RheScpO1xuICAgIH1cbiAgICBpZiAobXNBYnMgPj0gaCkge1xuICAgICAgICByZXR1cm4gcGx1cmFsKG1zLCBtc0FicywgaCwgJ2hvdXInKTtcbiAgICB9XG4gICAgaWYgKG1zQWJzID49IG0pIHtcbiAgICAgICAgcmV0dXJuIHBsdXJhbChtcywgbXNBYnMsIG0sICdtaW51dGUnKTtcbiAgICB9XG4gICAgaWYgKG1zQWJzID49IHMpIHtcbiAgICAgICAgcmV0dXJuIHBsdXJhbChtcywgbXNBYnMsIHMsICdzZWNvbmQnKTtcbiAgICB9XG4gICAgcmV0dXJuIGAke21zfSBtc2A7XG59XG4vKipcbiAqIFBsdXJhbGl6YXRpb24gaGVscGVyLlxuICovXG5mdW5jdGlvbiBwbHVyYWwobXMsIG1zQWJzLCBuLCBuYW1lKSB7XG4gICAgY29uc3QgaXNQbHVyYWwgPSBtc0FicyA+PSBuICogMS41O1xuICAgIHJldHVybiBgJHtNYXRoLnJvdW5kKG1zIC8gbil9ICR7bmFtZX0ke2lzUGx1cmFsID8gJ3MnIDogJyd9YDtcbn1cbi8qKlxuICogQSB0eXBlIGd1YXJkIGZvciBlcnJvcnMuXG4gKi9cbmZ1bmN0aW9uIGlzRXJyb3IoZXJyb3IpIHtcbiAgICByZXR1cm4gdHlwZW9mIGVycm9yID09PSAnb2JqZWN0JyAmJiBlcnJvciAhPT0gbnVsbCAmJiAnbWVzc2FnZScgaW4gZXJyb3I7XG59XG5tb2R1bGUuZXhwb3J0cyA9IGV4cG9ydHMuZGVmYXVsdDtcbm1vZHVsZS5leHBvcnRzLmRlZmF1bHQgPSBleHBvcnRzLmRlZmF1bHQ7XG4iLCIvLyBHRU5FUkFURUQgRklMRS4gRE8gTk9UIEVESVQuXG52YXIgTG9uZyA9IChmdW5jdGlvbihleHBvcnRzKSB7XG4gIFwidXNlIHN0cmljdFwiO1xuICBcbiAgT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiX19lc01vZHVsZVwiLCB7XG4gICAgdmFsdWU6IHRydWVcbiAgfSk7XG4gIGV4cG9ydHMuZGVmYXVsdCA9IHZvaWQgMDtcbiAgXG4gIC8qKlxuICAgKiBAbGljZW5zZVxuICAgKiBDb3B5cmlnaHQgMjAwOSBUaGUgQ2xvc3VyZSBMaWJyYXJ5IEF1dGhvcnNcbiAgICogQ29weXJpZ2h0IDIwMjAgRGFuaWVsIFdpcnR6IC8gVGhlIGxvbmcuanMgQXV0aG9ycy5cbiAgICpcbiAgICogTGljZW5zZWQgdW5kZXIgdGhlIEFwYWNoZSBMaWNlbnNlLCBWZXJzaW9uIDIuMCAodGhlIFwiTGljZW5zZVwiKTtcbiAgICogeW91IG1heSBub3QgdXNlIHRoaXMgZmlsZSBleGNlcHQgaW4gY29tcGxpYW5jZSB3aXRoIHRoZSBMaWNlbnNlLlxuICAgKiBZb3UgbWF5IG9idGFpbiBhIGNvcHkgb2YgdGhlIExpY2Vuc2UgYXRcbiAgICpcbiAgICogICAgIGh0dHA6Ly93d3cuYXBhY2hlLm9yZy9saWNlbnNlcy9MSUNFTlNFLTIuMFxuICAgKlxuICAgKiBVbmxlc3MgcmVxdWlyZWQgYnkgYXBwbGljYWJsZSBsYXcgb3IgYWdyZWVkIHRvIGluIHdyaXRpbmcsIHNvZnR3YXJlXG4gICAqIGRpc3RyaWJ1dGVkIHVuZGVyIHRoZSBMaWNlbnNlIGlzIGRpc3RyaWJ1dGVkIG9uIGFuIFwiQVMgSVNcIiBCQVNJUyxcbiAgICogV0lUSE9VVCBXQVJSQU5USUVTIE9SIENPTkRJVElPTlMgT0YgQU5ZIEtJTkQsIGVpdGhlciBleHByZXNzIG9yIGltcGxpZWQuXG4gICAqIFNlZSB0aGUgTGljZW5zZSBmb3IgdGhlIHNwZWNpZmljIGxhbmd1YWdlIGdvdmVybmluZyBwZXJtaXNzaW9ucyBhbmRcbiAgICogbGltaXRhdGlvbnMgdW5kZXIgdGhlIExpY2Vuc2UuXG4gICAqXG4gICAqIFNQRFgtTGljZW5zZS1JZGVudGlmaWVyOiBBcGFjaGUtMi4wXG4gICAqL1xuICAvLyBXZWJBc3NlbWJseSBvcHRpbWl6YXRpb25zIHRvIGRvIG5hdGl2ZSBpNjQgbXVsdGlwbGljYXRpb24gYW5kIGRpdmlkZVxuICB2YXIgd2FzbSA9IG51bGw7XG4gIFxuICB0cnkge1xuICAgIHdhc20gPSBuZXcgV2ViQXNzZW1ibHkuSW5zdGFuY2UobmV3IFdlYkFzc2VtYmx5Lk1vZHVsZShuZXcgVWludDhBcnJheShbMCwgOTcsIDExNSwgMTA5LCAxLCAwLCAwLCAwLCAxLCAxMywgMiwgOTYsIDAsIDEsIDEyNywgOTYsIDQsIDEyNywgMTI3LCAxMjcsIDEyNywgMSwgMTI3LCAzLCA3LCA2LCAwLCAxLCAxLCAxLCAxLCAxLCA2LCA2LCAxLCAxMjcsIDEsIDY1LCAwLCAxMSwgNywgNTAsIDYsIDMsIDEwOSwgMTE3LCAxMDgsIDAsIDEsIDUsIDEwMCwgMTA1LCAxMTgsIDk1LCAxMTUsIDAsIDIsIDUsIDEwMCwgMTA1LCAxMTgsIDk1LCAxMTcsIDAsIDMsIDUsIDExNCwgMTAxLCAxMDksIDk1LCAxMTUsIDAsIDQsIDUsIDExNCwgMTAxLCAxMDksIDk1LCAxMTcsIDAsIDUsIDgsIDEwMywgMTAxLCAxMTYsIDk1LCAxMDQsIDEwNSwgMTAzLCAxMDQsIDAsIDAsIDEwLCAxOTEsIDEsIDYsIDQsIDAsIDM1LCAwLCAxMSwgMzYsIDEsIDEsIDEyNiwgMzIsIDAsIDE3MywgMzIsIDEsIDE3MywgNjYsIDMyLCAxMzQsIDEzMiwgMzIsIDIsIDE3MywgMzIsIDMsIDE3MywgNjYsIDMyLCAxMzQsIDEzMiwgMTI2LCAzNCwgNCwgNjYsIDMyLCAxMzUsIDE2NywgMzYsIDAsIDMyLCA0LCAxNjcsIDExLCAzNiwgMSwgMSwgMTI2LCAzMiwgMCwgMTczLCAzMiwgMSwgMTczLCA2NiwgMzIsIDEzNCwgMTMyLCAzMiwgMiwgMTczLCAzMiwgMywgMTczLCA2NiwgMzIsIDEzNCwgMTMyLCAxMjcsIDM0LCA0LCA2NiwgMzIsIDEzNSwgMTY3LCAzNiwgMCwgMzIsIDQsIDE2NywgMTEsIDM2LCAxLCAxLCAxMjYsIDMyLCAwLCAxNzMsIDMyLCAxLCAxNzMsIDY2LCAzMiwgMTM0LCAxMzIsIDMyLCAyLCAxNzMsIDMyLCAzLCAxNzMsIDY2LCAzMiwgMTM0LCAxMzIsIDEyOCwgMzQsIDQsIDY2LCAzMiwgMTM1LCAxNjcsIDM2LCAwLCAzMiwgNCwgMTY3LCAxMSwgMzYsIDEsIDEsIDEyNiwgMzIsIDAsIDE3MywgMzIsIDEsIDE3MywgNjYsIDMyLCAxMzQsIDEzMiwgMzIsIDIsIDE3MywgMzIsIDMsIDE3MywgNjYsIDMyLCAxMzQsIDEzMiwgMTI5LCAzNCwgNCwgNjYsIDMyLCAxMzUsIDE2NywgMzYsIDAsIDMyLCA0LCAxNjcsIDExLCAzNiwgMSwgMSwgMTI2LCAzMiwgMCwgMTczLCAzMiwgMSwgMTczLCA2NiwgMzIsIDEzNCwgMTMyLCAzMiwgMiwgMTczLCAzMiwgMywgMTczLCA2NiwgMzIsIDEzNCwgMTMyLCAxMzAsIDM0LCA0LCA2NiwgMzIsIDEzNSwgMTY3LCAzNiwgMCwgMzIsIDQsIDE2NywgMTFdKSksIHt9KS5leHBvcnRzO1xuICB9IGNhdGNoIChlKSB7Ly8gbm8gd2FzbSBzdXBwb3J0IDooXG4gIH1cbiAgLyoqXG4gICAqIENvbnN0cnVjdHMgYSA2NCBiaXQgdHdvJ3MtY29tcGxlbWVudCBpbnRlZ2VyLCBnaXZlbiBpdHMgbG93IGFuZCBoaWdoIDMyIGJpdCB2YWx1ZXMgYXMgKnNpZ25lZCogaW50ZWdlcnMuXG4gICAqICBTZWUgdGhlIGZyb20qIGZ1bmN0aW9ucyBiZWxvdyBmb3IgbW9yZSBjb252ZW5pZW50IHdheXMgb2YgY29uc3RydWN0aW5nIExvbmdzLlxuICAgKiBAZXhwb3J0cyBMb25nXG4gICAqIEBjbGFzcyBBIExvbmcgY2xhc3MgZm9yIHJlcHJlc2VudGluZyBhIDY0IGJpdCB0d28ncy1jb21wbGVtZW50IGludGVnZXIgdmFsdWUuXG4gICAqIEBwYXJhbSB7bnVtYmVyfSBsb3cgVGhlIGxvdyAoc2lnbmVkKSAzMiBiaXRzIG9mIHRoZSBsb25nXG4gICAqIEBwYXJhbSB7bnVtYmVyfSBoaWdoIFRoZSBoaWdoIChzaWduZWQpIDMyIGJpdHMgb2YgdGhlIGxvbmdcbiAgICogQHBhcmFtIHtib29sZWFuPX0gdW5zaWduZWQgV2hldGhlciB1bnNpZ25lZCBvciBub3QsIGRlZmF1bHRzIHRvIHNpZ25lZFxuICAgKiBAY29uc3RydWN0b3JcbiAgICovXG4gIFxuICBcbiAgZnVuY3Rpb24gTG9uZyhsb3csIGhpZ2gsIHVuc2lnbmVkKSB7XG4gICAgLyoqXG4gICAgICogVGhlIGxvdyAzMiBiaXRzIGFzIGEgc2lnbmVkIHZhbHVlLlxuICAgICAqIEB0eXBlIHtudW1iZXJ9XG4gICAgICovXG4gICAgdGhpcy5sb3cgPSBsb3cgfCAwO1xuICAgIC8qKlxuICAgICAqIFRoZSBoaWdoIDMyIGJpdHMgYXMgYSBzaWduZWQgdmFsdWUuXG4gICAgICogQHR5cGUge251bWJlcn1cbiAgICAgKi9cbiAgXG4gICAgdGhpcy5oaWdoID0gaGlnaCB8IDA7XG4gICAgLyoqXG4gICAgICogV2hldGhlciB1bnNpZ25lZCBvciBub3QuXG4gICAgICogQHR5cGUge2Jvb2xlYW59XG4gICAgICovXG4gIFxuICAgIHRoaXMudW5zaWduZWQgPSAhIXVuc2lnbmVkO1xuICB9IC8vIFRoZSBpbnRlcm5hbCByZXByZXNlbnRhdGlvbiBvZiBhIGxvbmcgaXMgdGhlIHR3byBnaXZlbiBzaWduZWQsIDMyLWJpdCB2YWx1ZXMuXG4gIC8vIFdlIHVzZSAzMi1iaXQgcGllY2VzIGJlY2F1c2UgdGhlc2UgYXJlIHRoZSBzaXplIG9mIGludGVnZXJzIG9uIHdoaWNoXG4gIC8vIEphdmFzY3JpcHQgcGVyZm9ybXMgYml0LW9wZXJhdGlvbnMuICBGb3Igb3BlcmF0aW9ucyBsaWtlIGFkZGl0aW9uIGFuZFxuICAvLyBtdWx0aXBsaWNhdGlvbiwgd2Ugc3BsaXQgZWFjaCBudW1iZXIgaW50byAxNiBiaXQgcGllY2VzLCB3aGljaCBjYW4gZWFzaWx5IGJlXG4gIC8vIG11bHRpcGxpZWQgd2l0aGluIEphdmFzY3JpcHQncyBmbG9hdGluZy1wb2ludCByZXByZXNlbnRhdGlvbiB3aXRob3V0IG92ZXJmbG93XG4gIC8vIG9yIGNoYW5nZSBpbiBzaWduLlxuICAvL1xuICAvLyBJbiB0aGUgYWxnb3JpdGhtcyBiZWxvdywgd2UgZnJlcXVlbnRseSByZWR1Y2UgdGhlIG5lZ2F0aXZlIGNhc2UgdG8gdGhlXG4gIC8vIHBvc2l0aXZlIGNhc2UgYnkgbmVnYXRpbmcgdGhlIGlucHV0KHMpIGFuZCB0aGVuIHBvc3QtcHJvY2Vzc2luZyB0aGUgcmVzdWx0LlxuICAvLyBOb3RlIHRoYXQgd2UgbXVzdCBBTFdBWVMgY2hlY2sgc3BlY2lhbGx5IHdoZXRoZXIgdGhvc2UgdmFsdWVzIGFyZSBNSU5fVkFMVUVcbiAgLy8gKC0yXjYzKSBiZWNhdXNlIC1NSU5fVkFMVUUgPT0gTUlOX1ZBTFVFIChzaW5jZSAyXjYzIGNhbm5vdCBiZSByZXByZXNlbnRlZCBhc1xuICAvLyBhIHBvc2l0aXZlIG51bWJlciwgaXQgb3ZlcmZsb3dzIGJhY2sgaW50byBhIG5lZ2F0aXZlKS4gIE5vdCBoYW5kbGluZyB0aGlzXG4gIC8vIGNhc2Ugd291bGQgb2Z0ZW4gcmVzdWx0IGluIGluZmluaXRlIHJlY3Vyc2lvbi5cbiAgLy9cbiAgLy8gQ29tbW9uIGNvbnN0YW50IHZhbHVlcyBaRVJPLCBPTkUsIE5FR19PTkUsIGV0Yy4gYXJlIGRlZmluZWQgYmVsb3cgdGhlIGZyb20qXG4gIC8vIG1ldGhvZHMgb24gd2hpY2ggdGhleSBkZXBlbmQuXG4gIFxuICAvKipcbiAgICogQW4gaW5kaWNhdG9yIHVzZWQgdG8gcmVsaWFibHkgZGV0ZXJtaW5lIGlmIGFuIG9iamVjdCBpcyBhIExvbmcgb3Igbm90LlxuICAgKiBAdHlwZSB7Ym9vbGVhbn1cbiAgICogQGNvbnN0XG4gICAqIEBwcml2YXRlXG4gICAqL1xuICBcbiAgXG4gIExvbmcucHJvdG90eXBlLl9faXNMb25nX187XG4gIE9iamVjdC5kZWZpbmVQcm9wZXJ0eShMb25nLnByb3RvdHlwZSwgXCJfX2lzTG9uZ19fXCIsIHtcbiAgICB2YWx1ZTogdHJ1ZVxuICB9KTtcbiAgLyoqXG4gICAqIEBmdW5jdGlvblxuICAgKiBAcGFyYW0geyp9IG9iaiBPYmplY3RcbiAgICogQHJldHVybnMge2Jvb2xlYW59XG4gICAqIEBpbm5lclxuICAgKi9cbiAgXG4gIGZ1bmN0aW9uIGlzTG9uZyhvYmopIHtcbiAgICByZXR1cm4gKG9iaiAmJiBvYmpbXCJfX2lzTG9uZ19fXCJdKSA9PT0gdHJ1ZTtcbiAgfVxuICAvKipcbiAgICogQGZ1bmN0aW9uXG4gICAqIEBwYXJhbSB7Kn0gdmFsdWUgbnVtYmVyXG4gICAqIEByZXR1cm5zIHtudW1iZXJ9XG4gICAqIEBpbm5lclxuICAgKi9cbiAgXG4gIFxuICBmdW5jdGlvbiBjdHozMih2YWx1ZSkge1xuICAgIHZhciBjID0gTWF0aC5jbHozMih2YWx1ZSAmIC12YWx1ZSk7XG4gICAgcmV0dXJuIHZhbHVlID8gMzEgLSBjIDogYztcbiAgfVxuICAvKipcbiAgICogVGVzdHMgaWYgdGhlIHNwZWNpZmllZCBvYmplY3QgaXMgYSBMb25nLlxuICAgKiBAZnVuY3Rpb25cbiAgICogQHBhcmFtIHsqfSBvYmogT2JqZWN0XG4gICAqIEByZXR1cm5zIHtib29sZWFufVxuICAgKi9cbiAgXG4gIFxuICBMb25nLmlzTG9uZyA9IGlzTG9uZztcbiAgLyoqXG4gICAqIEEgY2FjaGUgb2YgdGhlIExvbmcgcmVwcmVzZW50YXRpb25zIG9mIHNtYWxsIGludGVnZXIgdmFsdWVzLlxuICAgKiBAdHlwZSB7IU9iamVjdH1cbiAgICogQGlubmVyXG4gICAqL1xuICBcbiAgdmFyIElOVF9DQUNIRSA9IHt9O1xuICAvKipcbiAgICogQSBjYWNoZSBvZiB0aGUgTG9uZyByZXByZXNlbnRhdGlvbnMgb2Ygc21hbGwgdW5zaWduZWQgaW50ZWdlciB2YWx1ZXMuXG4gICAqIEB0eXBlIHshT2JqZWN0fVxuICAgKiBAaW5uZXJcbiAgICovXG4gIFxuICB2YXIgVUlOVF9DQUNIRSA9IHt9O1xuICAvKipcbiAgICogQHBhcmFtIHtudW1iZXJ9IHZhbHVlXG4gICAqIEBwYXJhbSB7Ym9vbGVhbj19IHVuc2lnbmVkXG4gICAqIEByZXR1cm5zIHshTG9uZ31cbiAgICogQGlubmVyXG4gICAqL1xuICBcbiAgZnVuY3Rpb24gZnJvbUludCh2YWx1ZSwgdW5zaWduZWQpIHtcbiAgICB2YXIgb2JqLCBjYWNoZWRPYmosIGNhY2hlO1xuICBcbiAgICBpZiAodW5zaWduZWQpIHtcbiAgICAgIHZhbHVlID4+Pj0gMDtcbiAgXG4gICAgICBpZiAoY2FjaGUgPSAwIDw9IHZhbHVlICYmIHZhbHVlIDwgMjU2KSB7XG4gICAgICAgIGNhY2hlZE9iaiA9IFVJTlRfQ0FDSEVbdmFsdWVdO1xuICAgICAgICBpZiAoY2FjaGVkT2JqKSByZXR1cm4gY2FjaGVkT2JqO1xuICAgICAgfVxuICBcbiAgICAgIG9iaiA9IGZyb21CaXRzKHZhbHVlLCAwLCB0cnVlKTtcbiAgICAgIGlmIChjYWNoZSkgVUlOVF9DQUNIRVt2YWx1ZV0gPSBvYmo7XG4gICAgICByZXR1cm4gb2JqO1xuICAgIH0gZWxzZSB7XG4gICAgICB2YWx1ZSB8PSAwO1xuICBcbiAgICAgIGlmIChjYWNoZSA9IC0xMjggPD0gdmFsdWUgJiYgdmFsdWUgPCAxMjgpIHtcbiAgICAgICAgY2FjaGVkT2JqID0gSU5UX0NBQ0hFW3ZhbHVlXTtcbiAgICAgICAgaWYgKGNhY2hlZE9iaikgcmV0dXJuIGNhY2hlZE9iajtcbiAgICAgIH1cbiAgXG4gICAgICBvYmogPSBmcm9tQml0cyh2YWx1ZSwgdmFsdWUgPCAwID8gLTEgOiAwLCBmYWxzZSk7XG4gICAgICBpZiAoY2FjaGUpIElOVF9DQUNIRVt2YWx1ZV0gPSBvYmo7XG4gICAgICByZXR1cm4gb2JqO1xuICAgIH1cbiAgfVxuICAvKipcbiAgICogUmV0dXJucyBhIExvbmcgcmVwcmVzZW50aW5nIHRoZSBnaXZlbiAzMiBiaXQgaW50ZWdlciB2YWx1ZS5cbiAgICogQGZ1bmN0aW9uXG4gICAqIEBwYXJhbSB7bnVtYmVyfSB2YWx1ZSBUaGUgMzIgYml0IGludGVnZXIgaW4gcXVlc3Rpb25cbiAgICogQHBhcmFtIHtib29sZWFuPX0gdW5zaWduZWQgV2hldGhlciB1bnNpZ25lZCBvciBub3QsIGRlZmF1bHRzIHRvIHNpZ25lZFxuICAgKiBAcmV0dXJucyB7IUxvbmd9IFRoZSBjb3JyZXNwb25kaW5nIExvbmcgdmFsdWVcbiAgICovXG4gIFxuICBcbiAgTG9uZy5mcm9tSW50ID0gZnJvbUludDtcbiAgLyoqXG4gICAqIEBwYXJhbSB7bnVtYmVyfSB2YWx1ZVxuICAgKiBAcGFyYW0ge2Jvb2xlYW49fSB1bnNpZ25lZFxuICAgKiBAcmV0dXJucyB7IUxvbmd9XG4gICAqIEBpbm5lclxuICAgKi9cbiAgXG4gIGZ1bmN0aW9uIGZyb21OdW1iZXIodmFsdWUsIHVuc2lnbmVkKSB7XG4gICAgaWYgKGlzTmFOKHZhbHVlKSkgcmV0dXJuIHVuc2lnbmVkID8gVVpFUk8gOiBaRVJPO1xuICBcbiAgICBpZiAodW5zaWduZWQpIHtcbiAgICAgIGlmICh2YWx1ZSA8IDApIHJldHVybiBVWkVSTztcbiAgICAgIGlmICh2YWx1ZSA+PSBUV09fUFdSXzY0X0RCTCkgcmV0dXJuIE1BWF9VTlNJR05FRF9WQUxVRTtcbiAgICB9IGVsc2Uge1xuICAgICAgaWYgKHZhbHVlIDw9IC1UV09fUFdSXzYzX0RCTCkgcmV0dXJuIE1JTl9WQUxVRTtcbiAgICAgIGlmICh2YWx1ZSArIDEgPj0gVFdPX1BXUl82M19EQkwpIHJldHVybiBNQVhfVkFMVUU7XG4gICAgfVxuICBcbiAgICBpZiAodmFsdWUgPCAwKSByZXR1cm4gZnJvbU51bWJlcigtdmFsdWUsIHVuc2lnbmVkKS5uZWcoKTtcbiAgICByZXR1cm4gZnJvbUJpdHModmFsdWUgJSBUV09fUFdSXzMyX0RCTCB8IDAsIHZhbHVlIC8gVFdPX1BXUl8zMl9EQkwgfCAwLCB1bnNpZ25lZCk7XG4gIH1cbiAgLyoqXG4gICAqIFJldHVybnMgYSBMb25nIHJlcHJlc2VudGluZyB0aGUgZ2l2ZW4gdmFsdWUsIHByb3ZpZGVkIHRoYXQgaXQgaXMgYSBmaW5pdGUgbnVtYmVyLiBPdGhlcndpc2UsIHplcm8gaXMgcmV0dXJuZWQuXG4gICAqIEBmdW5jdGlvblxuICAgKiBAcGFyYW0ge251bWJlcn0gdmFsdWUgVGhlIG51bWJlciBpbiBxdWVzdGlvblxuICAgKiBAcGFyYW0ge2Jvb2xlYW49fSB1bnNpZ25lZCBXaGV0aGVyIHVuc2lnbmVkIG9yIG5vdCwgZGVmYXVsdHMgdG8gc2lnbmVkXG4gICAqIEByZXR1cm5zIHshTG9uZ30gVGhlIGNvcnJlc3BvbmRpbmcgTG9uZyB2YWx1ZVxuICAgKi9cbiAgXG4gIFxuICBMb25nLmZyb21OdW1iZXIgPSBmcm9tTnVtYmVyO1xuICAvKipcbiAgICogQHBhcmFtIHtudW1iZXJ9IGxvd0JpdHNcbiAgICogQHBhcmFtIHtudW1iZXJ9IGhpZ2hCaXRzXG4gICAqIEBwYXJhbSB7Ym9vbGVhbj19IHVuc2lnbmVkXG4gICAqIEByZXR1cm5zIHshTG9uZ31cbiAgICogQGlubmVyXG4gICAqL1xuICBcbiAgZnVuY3Rpb24gZnJvbUJpdHMobG93Qml0cywgaGlnaEJpdHMsIHVuc2lnbmVkKSB7XG4gICAgcmV0dXJuIG5ldyBMb25nKGxvd0JpdHMsIGhpZ2hCaXRzLCB1bnNpZ25lZCk7XG4gIH1cbiAgLyoqXG4gICAqIFJldHVybnMgYSBMb25nIHJlcHJlc2VudGluZyB0aGUgNjQgYml0IGludGVnZXIgdGhhdCBjb21lcyBieSBjb25jYXRlbmF0aW5nIHRoZSBnaXZlbiBsb3cgYW5kIGhpZ2ggYml0cy4gRWFjaCBpc1xuICAgKiAgYXNzdW1lZCB0byB1c2UgMzIgYml0cy5cbiAgICogQGZ1bmN0aW9uXG4gICAqIEBwYXJhbSB7bnVtYmVyfSBsb3dCaXRzIFRoZSBsb3cgMzIgYml0c1xuICAgKiBAcGFyYW0ge251bWJlcn0gaGlnaEJpdHMgVGhlIGhpZ2ggMzIgYml0c1xuICAgKiBAcGFyYW0ge2Jvb2xlYW49fSB1bnNpZ25lZCBXaGV0aGVyIHVuc2lnbmVkIG9yIG5vdCwgZGVmYXVsdHMgdG8gc2lnbmVkXG4gICAqIEByZXR1cm5zIHshTG9uZ30gVGhlIGNvcnJlc3BvbmRpbmcgTG9uZyB2YWx1ZVxuICAgKi9cbiAgXG4gIFxuICBMb25nLmZyb21CaXRzID0gZnJvbUJpdHM7XG4gIC8qKlxuICAgKiBAZnVuY3Rpb25cbiAgICogQHBhcmFtIHtudW1iZXJ9IGJhc2VcbiAgICogQHBhcmFtIHtudW1iZXJ9IGV4cG9uZW50XG4gICAqIEByZXR1cm5zIHtudW1iZXJ9XG4gICAqIEBpbm5lclxuICAgKi9cbiAgXG4gIHZhciBwb3dfZGJsID0gTWF0aC5wb3c7IC8vIFVzZWQgNCB0aW1lcyAoNCo4IHRvIDE1KzQpXG4gIFxuICAvKipcbiAgICogQHBhcmFtIHtzdHJpbmd9IHN0clxuICAgKiBAcGFyYW0geyhib29sZWFufG51bWJlcik9fSB1bnNpZ25lZFxuICAgKiBAcGFyYW0ge251bWJlcj19IHJhZGl4XG4gICAqIEByZXR1cm5zIHshTG9uZ31cbiAgICogQGlubmVyXG4gICAqL1xuICBcbiAgZnVuY3Rpb24gZnJvbVN0cmluZyhzdHIsIHVuc2lnbmVkLCByYWRpeCkge1xuICAgIGlmIChzdHIubGVuZ3RoID09PSAwKSB0aHJvdyBFcnJvcignZW1wdHkgc3RyaW5nJyk7XG4gIFxuICAgIGlmICh0eXBlb2YgdW5zaWduZWQgPT09ICdudW1iZXInKSB7XG4gICAgICAvLyBGb3IgZ29vZy5tYXRoLmxvbmcgY29tcGF0aWJpbGl0eVxuICAgICAgcmFkaXggPSB1bnNpZ25lZDtcbiAgICAgIHVuc2lnbmVkID0gZmFsc2U7XG4gICAgfSBlbHNlIHtcbiAgICAgIHVuc2lnbmVkID0gISF1bnNpZ25lZDtcbiAgICB9XG4gIFxuICAgIGlmIChzdHIgPT09IFwiTmFOXCIgfHwgc3RyID09PSBcIkluZmluaXR5XCIgfHwgc3RyID09PSBcIitJbmZpbml0eVwiIHx8IHN0ciA9PT0gXCItSW5maW5pdHlcIikgcmV0dXJuIHVuc2lnbmVkID8gVVpFUk8gOiBaRVJPO1xuICAgIHJhZGl4ID0gcmFkaXggfHwgMTA7XG4gICAgaWYgKHJhZGl4IDwgMiB8fCAzNiA8IHJhZGl4KSB0aHJvdyBSYW5nZUVycm9yKCdyYWRpeCcpO1xuICAgIHZhciBwO1xuICAgIGlmICgocCA9IHN0ci5pbmRleE9mKCctJykpID4gMCkgdGhyb3cgRXJyb3IoJ2ludGVyaW9yIGh5cGhlbicpO2Vsc2UgaWYgKHAgPT09IDApIHtcbiAgICAgIHJldHVybiBmcm9tU3RyaW5nKHN0ci5zdWJzdHJpbmcoMSksIHVuc2lnbmVkLCByYWRpeCkubmVnKCk7XG4gICAgfSAvLyBEbyBzZXZlcmFsICg4KSBkaWdpdHMgZWFjaCB0aW1lIHRocm91Z2ggdGhlIGxvb3AsIHNvIGFzIHRvXG4gICAgLy8gbWluaW1pemUgdGhlIGNhbGxzIHRvIHRoZSB2ZXJ5IGV4cGVuc2l2ZSBlbXVsYXRlZCBkaXYuXG4gIFxuICAgIHZhciByYWRpeFRvUG93ZXIgPSBmcm9tTnVtYmVyKHBvd19kYmwocmFkaXgsIDgpKTtcbiAgICB2YXIgcmVzdWx0ID0gWkVSTztcbiAgXG4gICAgZm9yICh2YXIgaSA9IDA7IGkgPCBzdHIubGVuZ3RoOyBpICs9IDgpIHtcbiAgICAgIHZhciBzaXplID0gTWF0aC5taW4oOCwgc3RyLmxlbmd0aCAtIGkpLFxuICAgICAgICAgIHZhbHVlID0gcGFyc2VJbnQoc3RyLnN1YnN0cmluZyhpLCBpICsgc2l6ZSksIHJhZGl4KTtcbiAgXG4gICAgICBpZiAoc2l6ZSA8IDgpIHtcbiAgICAgICAgdmFyIHBvd2VyID0gZnJvbU51bWJlcihwb3dfZGJsKHJhZGl4LCBzaXplKSk7XG4gICAgICAgIHJlc3VsdCA9IHJlc3VsdC5tdWwocG93ZXIpLmFkZChmcm9tTnVtYmVyKHZhbHVlKSk7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICByZXN1bHQgPSByZXN1bHQubXVsKHJhZGl4VG9Qb3dlcik7XG4gICAgICAgIHJlc3VsdCA9IHJlc3VsdC5hZGQoZnJvbU51bWJlcih2YWx1ZSkpO1xuICAgICAgfVxuICAgIH1cbiAgXG4gICAgcmVzdWx0LnVuc2lnbmVkID0gdW5zaWduZWQ7XG4gICAgcmV0dXJuIHJlc3VsdDtcbiAgfVxuICAvKipcbiAgICogUmV0dXJucyBhIExvbmcgcmVwcmVzZW50YXRpb24gb2YgdGhlIGdpdmVuIHN0cmluZywgd3JpdHRlbiB1c2luZyB0aGUgc3BlY2lmaWVkIHJhZGl4LlxuICAgKiBAZnVuY3Rpb25cbiAgICogQHBhcmFtIHtzdHJpbmd9IHN0ciBUaGUgdGV4dHVhbCByZXByZXNlbnRhdGlvbiBvZiB0aGUgTG9uZ1xuICAgKiBAcGFyYW0geyhib29sZWFufG51bWJlcik9fSB1bnNpZ25lZCBXaGV0aGVyIHVuc2lnbmVkIG9yIG5vdCwgZGVmYXVsdHMgdG8gc2lnbmVkXG4gICAqIEBwYXJhbSB7bnVtYmVyPX0gcmFkaXggVGhlIHJhZGl4IGluIHdoaWNoIHRoZSB0ZXh0IGlzIHdyaXR0ZW4gKDItMzYpLCBkZWZhdWx0cyB0byAxMFxuICAgKiBAcmV0dXJucyB7IUxvbmd9IFRoZSBjb3JyZXNwb25kaW5nIExvbmcgdmFsdWVcbiAgICovXG4gIFxuICBcbiAgTG9uZy5mcm9tU3RyaW5nID0gZnJvbVN0cmluZztcbiAgLyoqXG4gICAqIEBmdW5jdGlvblxuICAgKiBAcGFyYW0geyFMb25nfG51bWJlcnxzdHJpbmd8IXtsb3c6IG51bWJlciwgaGlnaDogbnVtYmVyLCB1bnNpZ25lZDogYm9vbGVhbn19IHZhbFxuICAgKiBAcGFyYW0ge2Jvb2xlYW49fSB1bnNpZ25lZFxuICAgKiBAcmV0dXJucyB7IUxvbmd9XG4gICAqIEBpbm5lclxuICAgKi9cbiAgXG4gIGZ1bmN0aW9uIGZyb21WYWx1ZSh2YWwsIHVuc2lnbmVkKSB7XG4gICAgaWYgKHR5cGVvZiB2YWwgPT09ICdudW1iZXInKSByZXR1cm4gZnJvbU51bWJlcih2YWwsIHVuc2lnbmVkKTtcbiAgICBpZiAodHlwZW9mIHZhbCA9PT0gJ3N0cmluZycpIHJldHVybiBmcm9tU3RyaW5nKHZhbCwgdW5zaWduZWQpOyAvLyBUaHJvd3MgZm9yIG5vbi1vYmplY3RzLCBjb252ZXJ0cyBub24taW5zdGFuY2VvZiBMb25nOlxuICBcbiAgICByZXR1cm4gZnJvbUJpdHModmFsLmxvdywgdmFsLmhpZ2gsIHR5cGVvZiB1bnNpZ25lZCA9PT0gJ2Jvb2xlYW4nID8gdW5zaWduZWQgOiB2YWwudW5zaWduZWQpO1xuICB9XG4gIC8qKlxuICAgKiBDb252ZXJ0cyB0aGUgc3BlY2lmaWVkIHZhbHVlIHRvIGEgTG9uZyB1c2luZyB0aGUgYXBwcm9wcmlhdGUgZnJvbSogZnVuY3Rpb24gZm9yIGl0cyB0eXBlLlxuICAgKiBAZnVuY3Rpb25cbiAgICogQHBhcmFtIHshTG9uZ3xudW1iZXJ8c3RyaW5nfCF7bG93OiBudW1iZXIsIGhpZ2g6IG51bWJlciwgdW5zaWduZWQ6IGJvb2xlYW59fSB2YWwgVmFsdWVcbiAgICogQHBhcmFtIHtib29sZWFuPX0gdW5zaWduZWQgV2hldGhlciB1bnNpZ25lZCBvciBub3QsIGRlZmF1bHRzIHRvIHNpZ25lZFxuICAgKiBAcmV0dXJucyB7IUxvbmd9XG4gICAqL1xuICBcbiAgXG4gIExvbmcuZnJvbVZhbHVlID0gZnJvbVZhbHVlOyAvLyBOT1RFOiB0aGUgY29tcGlsZXIgc2hvdWxkIGlubGluZSB0aGVzZSBjb25zdGFudCB2YWx1ZXMgYmVsb3cgYW5kIHRoZW4gcmVtb3ZlIHRoZXNlIHZhcmlhYmxlcywgc28gdGhlcmUgc2hvdWxkIGJlXG4gIC8vIG5vIHJ1bnRpbWUgcGVuYWx0eSBmb3IgdGhlc2UuXG4gIFxuICAvKipcbiAgICogQHR5cGUge251bWJlcn1cbiAgICogQGNvbnN0XG4gICAqIEBpbm5lclxuICAgKi9cbiAgXG4gIHZhciBUV09fUFdSXzE2X0RCTCA9IDEgPDwgMTY7XG4gIC8qKlxuICAgKiBAdHlwZSB7bnVtYmVyfVxuICAgKiBAY29uc3RcbiAgICogQGlubmVyXG4gICAqL1xuICBcbiAgdmFyIFRXT19QV1JfMjRfREJMID0gMSA8PCAyNDtcbiAgLyoqXG4gICAqIEB0eXBlIHtudW1iZXJ9XG4gICAqIEBjb25zdFxuICAgKiBAaW5uZXJcbiAgICovXG4gIFxuICB2YXIgVFdPX1BXUl8zMl9EQkwgPSBUV09fUFdSXzE2X0RCTCAqIFRXT19QV1JfMTZfREJMO1xuICAvKipcbiAgICogQHR5cGUge251bWJlcn1cbiAgICogQGNvbnN0XG4gICAqIEBpbm5lclxuICAgKi9cbiAgXG4gIHZhciBUV09fUFdSXzY0X0RCTCA9IFRXT19QV1JfMzJfREJMICogVFdPX1BXUl8zMl9EQkw7XG4gIC8qKlxuICAgKiBAdHlwZSB7bnVtYmVyfVxuICAgKiBAY29uc3RcbiAgICogQGlubmVyXG4gICAqL1xuICBcbiAgdmFyIFRXT19QV1JfNjNfREJMID0gVFdPX1BXUl82NF9EQkwgLyAyO1xuICAvKipcbiAgICogQHR5cGUgeyFMb25nfVxuICAgKiBAY29uc3RcbiAgICogQGlubmVyXG4gICAqL1xuICBcbiAgdmFyIFRXT19QV1JfMjQgPSBmcm9tSW50KFRXT19QV1JfMjRfREJMKTtcbiAgLyoqXG4gICAqIEB0eXBlIHshTG9uZ31cbiAgICogQGlubmVyXG4gICAqL1xuICBcbiAgdmFyIFpFUk8gPSBmcm9tSW50KDApO1xuICAvKipcbiAgICogU2lnbmVkIHplcm8uXG4gICAqIEB0eXBlIHshTG9uZ31cbiAgICovXG4gIFxuICBMb25nLlpFUk8gPSBaRVJPO1xuICAvKipcbiAgICogQHR5cGUgeyFMb25nfVxuICAgKiBAaW5uZXJcbiAgICovXG4gIFxuICB2YXIgVVpFUk8gPSBmcm9tSW50KDAsIHRydWUpO1xuICAvKipcbiAgICogVW5zaWduZWQgemVyby5cbiAgICogQHR5cGUgeyFMb25nfVxuICAgKi9cbiAgXG4gIExvbmcuVVpFUk8gPSBVWkVSTztcbiAgLyoqXG4gICAqIEB0eXBlIHshTG9uZ31cbiAgICogQGlubmVyXG4gICAqL1xuICBcbiAgdmFyIE9ORSA9IGZyb21JbnQoMSk7XG4gIC8qKlxuICAgKiBTaWduZWQgb25lLlxuICAgKiBAdHlwZSB7IUxvbmd9XG4gICAqL1xuICBcbiAgTG9uZy5PTkUgPSBPTkU7XG4gIC8qKlxuICAgKiBAdHlwZSB7IUxvbmd9XG4gICAqIEBpbm5lclxuICAgKi9cbiAgXG4gIHZhciBVT05FID0gZnJvbUludCgxLCB0cnVlKTtcbiAgLyoqXG4gICAqIFVuc2lnbmVkIG9uZS5cbiAgICogQHR5cGUgeyFMb25nfVxuICAgKi9cbiAgXG4gIExvbmcuVU9ORSA9IFVPTkU7XG4gIC8qKlxuICAgKiBAdHlwZSB7IUxvbmd9XG4gICAqIEBpbm5lclxuICAgKi9cbiAgXG4gIHZhciBORUdfT05FID0gZnJvbUludCgtMSk7XG4gIC8qKlxuICAgKiBTaWduZWQgbmVnYXRpdmUgb25lLlxuICAgKiBAdHlwZSB7IUxvbmd9XG4gICAqL1xuICBcbiAgTG9uZy5ORUdfT05FID0gTkVHX09ORTtcbiAgLyoqXG4gICAqIEB0eXBlIHshTG9uZ31cbiAgICogQGlubmVyXG4gICAqL1xuICBcbiAgdmFyIE1BWF9WQUxVRSA9IGZyb21CaXRzKDB4RkZGRkZGRkYgfCAwLCAweDdGRkZGRkZGIHwgMCwgZmFsc2UpO1xuICAvKipcbiAgICogTWF4aW11bSBzaWduZWQgdmFsdWUuXG4gICAqIEB0eXBlIHshTG9uZ31cbiAgICovXG4gIFxuICBMb25nLk1BWF9WQUxVRSA9IE1BWF9WQUxVRTtcbiAgLyoqXG4gICAqIEB0eXBlIHshTG9uZ31cbiAgICogQGlubmVyXG4gICAqL1xuICBcbiAgdmFyIE1BWF9VTlNJR05FRF9WQUxVRSA9IGZyb21CaXRzKDB4RkZGRkZGRkYgfCAwLCAweEZGRkZGRkZGIHwgMCwgdHJ1ZSk7XG4gIC8qKlxuICAgKiBNYXhpbXVtIHVuc2lnbmVkIHZhbHVlLlxuICAgKiBAdHlwZSB7IUxvbmd9XG4gICAqL1xuICBcbiAgTG9uZy5NQVhfVU5TSUdORURfVkFMVUUgPSBNQVhfVU5TSUdORURfVkFMVUU7XG4gIC8qKlxuICAgKiBAdHlwZSB7IUxvbmd9XG4gICAqIEBpbm5lclxuICAgKi9cbiAgXG4gIHZhciBNSU5fVkFMVUUgPSBmcm9tQml0cygwLCAweDgwMDAwMDAwIHwgMCwgZmFsc2UpO1xuICAvKipcbiAgICogTWluaW11bSBzaWduZWQgdmFsdWUuXG4gICAqIEB0eXBlIHshTG9uZ31cbiAgICovXG4gIFxuICBMb25nLk1JTl9WQUxVRSA9IE1JTl9WQUxVRTtcbiAgLyoqXG4gICAqIEBhbGlhcyBMb25nLnByb3RvdHlwZVxuICAgKiBAaW5uZXJcbiAgICovXG4gIFxuICB2YXIgTG9uZ1Byb3RvdHlwZSA9IExvbmcucHJvdG90eXBlO1xuICAvKipcbiAgICogQ29udmVydHMgdGhlIExvbmcgdG8gYSAzMiBiaXQgaW50ZWdlciwgYXNzdW1pbmcgaXQgaXMgYSAzMiBiaXQgaW50ZWdlci5cbiAgICogQHRoaXMgeyFMb25nfVxuICAgKiBAcmV0dXJucyB7bnVtYmVyfVxuICAgKi9cbiAgXG4gIExvbmdQcm90b3R5cGUudG9JbnQgPSBmdW5jdGlvbiB0b0ludCgpIHtcbiAgICByZXR1cm4gdGhpcy51bnNpZ25lZCA/IHRoaXMubG93ID4+PiAwIDogdGhpcy5sb3c7XG4gIH07XG4gIC8qKlxuICAgKiBDb252ZXJ0cyB0aGUgTG9uZyB0byBhIHRoZSBuZWFyZXN0IGZsb2F0aW5nLXBvaW50IHJlcHJlc2VudGF0aW9uIG9mIHRoaXMgdmFsdWUgKGRvdWJsZSwgNTMgYml0IG1hbnRpc3NhKS5cbiAgICogQHRoaXMgeyFMb25nfVxuICAgKiBAcmV0dXJucyB7bnVtYmVyfVxuICAgKi9cbiAgXG4gIFxuICBMb25nUHJvdG90eXBlLnRvTnVtYmVyID0gZnVuY3Rpb24gdG9OdW1iZXIoKSB7XG4gICAgaWYgKHRoaXMudW5zaWduZWQpIHJldHVybiAodGhpcy5oaWdoID4+PiAwKSAqIFRXT19QV1JfMzJfREJMICsgKHRoaXMubG93ID4+PiAwKTtcbiAgICByZXR1cm4gdGhpcy5oaWdoICogVFdPX1BXUl8zMl9EQkwgKyAodGhpcy5sb3cgPj4+IDApO1xuICB9O1xuICAvKipcbiAgICogQ29udmVydHMgdGhlIExvbmcgdG8gYSBzdHJpbmcgd3JpdHRlbiBpbiB0aGUgc3BlY2lmaWVkIHJhZGl4LlxuICAgKiBAdGhpcyB7IUxvbmd9XG4gICAqIEBwYXJhbSB7bnVtYmVyPX0gcmFkaXggUmFkaXggKDItMzYpLCBkZWZhdWx0cyB0byAxMFxuICAgKiBAcmV0dXJucyB7c3RyaW5nfVxuICAgKiBAb3ZlcnJpZGVcbiAgICogQHRocm93cyB7UmFuZ2VFcnJvcn0gSWYgYHJhZGl4YCBpcyBvdXQgb2YgcmFuZ2VcbiAgICovXG4gIFxuICBcbiAgTG9uZ1Byb3RvdHlwZS50b1N0cmluZyA9IGZ1bmN0aW9uIHRvU3RyaW5nKHJhZGl4KSB7XG4gICAgcmFkaXggPSByYWRpeCB8fCAxMDtcbiAgICBpZiAocmFkaXggPCAyIHx8IDM2IDwgcmFkaXgpIHRocm93IFJhbmdlRXJyb3IoJ3JhZGl4Jyk7XG4gICAgaWYgKHRoaXMuaXNaZXJvKCkpIHJldHVybiAnMCc7XG4gIFxuICAgIGlmICh0aGlzLmlzTmVnYXRpdmUoKSkge1xuICAgICAgLy8gVW5zaWduZWQgTG9uZ3MgYXJlIG5ldmVyIG5lZ2F0aXZlXG4gICAgICBpZiAodGhpcy5lcShNSU5fVkFMVUUpKSB7XG4gICAgICAgIC8vIFdlIG5lZWQgdG8gY2hhbmdlIHRoZSBMb25nIHZhbHVlIGJlZm9yZSBpdCBjYW4gYmUgbmVnYXRlZCwgc28gd2UgcmVtb3ZlXG4gICAgICAgIC8vIHRoZSBib3R0b20tbW9zdCBkaWdpdCBpbiB0aGlzIGJhc2UgYW5kIHRoZW4gcmVjdXJzZSB0byBkbyB0aGUgcmVzdC5cbiAgICAgICAgdmFyIHJhZGl4TG9uZyA9IGZyb21OdW1iZXIocmFkaXgpLFxuICAgICAgICAgICAgZGl2ID0gdGhpcy5kaXYocmFkaXhMb25nKSxcbiAgICAgICAgICAgIHJlbTEgPSBkaXYubXVsKHJhZGl4TG9uZykuc3ViKHRoaXMpO1xuICAgICAgICByZXR1cm4gZGl2LnRvU3RyaW5nKHJhZGl4KSArIHJlbTEudG9JbnQoKS50b1N0cmluZyhyYWRpeCk7XG4gICAgICB9IGVsc2UgcmV0dXJuICctJyArIHRoaXMubmVnKCkudG9TdHJpbmcocmFkaXgpO1xuICAgIH0gLy8gRG8gc2V2ZXJhbCAoNikgZGlnaXRzIGVhY2ggdGltZSB0aHJvdWdoIHRoZSBsb29wLCBzbyBhcyB0b1xuICAgIC8vIG1pbmltaXplIHRoZSBjYWxscyB0byB0aGUgdmVyeSBleHBlbnNpdmUgZW11bGF0ZWQgZGl2LlxuICBcbiAgXG4gICAgdmFyIHJhZGl4VG9Qb3dlciA9IGZyb21OdW1iZXIocG93X2RibChyYWRpeCwgNiksIHRoaXMudW5zaWduZWQpLFxuICAgICAgICByZW0gPSB0aGlzO1xuICAgIHZhciByZXN1bHQgPSAnJztcbiAgXG4gICAgd2hpbGUgKHRydWUpIHtcbiAgICAgIHZhciByZW1EaXYgPSByZW0uZGl2KHJhZGl4VG9Qb3dlciksXG4gICAgICAgICAgaW50dmFsID0gcmVtLnN1YihyZW1EaXYubXVsKHJhZGl4VG9Qb3dlcikpLnRvSW50KCkgPj4+IDAsXG4gICAgICAgICAgZGlnaXRzID0gaW50dmFsLnRvU3RyaW5nKHJhZGl4KTtcbiAgICAgIHJlbSA9IHJlbURpdjtcbiAgICAgIGlmIChyZW0uaXNaZXJvKCkpIHJldHVybiBkaWdpdHMgKyByZXN1bHQ7ZWxzZSB7XG4gICAgICAgIHdoaWxlIChkaWdpdHMubGVuZ3RoIDwgNikgZGlnaXRzID0gJzAnICsgZGlnaXRzO1xuICBcbiAgICAgICAgcmVzdWx0ID0gJycgKyBkaWdpdHMgKyByZXN1bHQ7XG4gICAgICB9XG4gICAgfVxuICB9O1xuICAvKipcbiAgICogR2V0cyB0aGUgaGlnaCAzMiBiaXRzIGFzIGEgc2lnbmVkIGludGVnZXIuXG4gICAqIEB0aGlzIHshTG9uZ31cbiAgICogQHJldHVybnMge251bWJlcn0gU2lnbmVkIGhpZ2ggYml0c1xuICAgKi9cbiAgXG4gIFxuICBMb25nUHJvdG90eXBlLmdldEhpZ2hCaXRzID0gZnVuY3Rpb24gZ2V0SGlnaEJpdHMoKSB7XG4gICAgcmV0dXJuIHRoaXMuaGlnaDtcbiAgfTtcbiAgLyoqXG4gICAqIEdldHMgdGhlIGhpZ2ggMzIgYml0cyBhcyBhbiB1bnNpZ25lZCBpbnRlZ2VyLlxuICAgKiBAdGhpcyB7IUxvbmd9XG4gICAqIEByZXR1cm5zIHtudW1iZXJ9IFVuc2lnbmVkIGhpZ2ggYml0c1xuICAgKi9cbiAgXG4gIFxuICBMb25nUHJvdG90eXBlLmdldEhpZ2hCaXRzVW5zaWduZWQgPSBmdW5jdGlvbiBnZXRIaWdoQml0c1Vuc2lnbmVkKCkge1xuICAgIHJldHVybiB0aGlzLmhpZ2ggPj4+IDA7XG4gIH07XG4gIC8qKlxuICAgKiBHZXRzIHRoZSBsb3cgMzIgYml0cyBhcyBhIHNpZ25lZCBpbnRlZ2VyLlxuICAgKiBAdGhpcyB7IUxvbmd9XG4gICAqIEByZXR1cm5zIHtudW1iZXJ9IFNpZ25lZCBsb3cgYml0c1xuICAgKi9cbiAgXG4gIFxuICBMb25nUHJvdG90eXBlLmdldExvd0JpdHMgPSBmdW5jdGlvbiBnZXRMb3dCaXRzKCkge1xuICAgIHJldHVybiB0aGlzLmxvdztcbiAgfTtcbiAgLyoqXG4gICAqIEdldHMgdGhlIGxvdyAzMiBiaXRzIGFzIGFuIHVuc2lnbmVkIGludGVnZXIuXG4gICAqIEB0aGlzIHshTG9uZ31cbiAgICogQHJldHVybnMge251bWJlcn0gVW5zaWduZWQgbG93IGJpdHNcbiAgICovXG4gIFxuICBcbiAgTG9uZ1Byb3RvdHlwZS5nZXRMb3dCaXRzVW5zaWduZWQgPSBmdW5jdGlvbiBnZXRMb3dCaXRzVW5zaWduZWQoKSB7XG4gICAgcmV0dXJuIHRoaXMubG93ID4+PiAwO1xuICB9O1xuICAvKipcbiAgICogR2V0cyB0aGUgbnVtYmVyIG9mIGJpdHMgbmVlZGVkIHRvIHJlcHJlc2VudCB0aGUgYWJzb2x1dGUgdmFsdWUgb2YgdGhpcyBMb25nLlxuICAgKiBAdGhpcyB7IUxvbmd9XG4gICAqIEByZXR1cm5zIHtudW1iZXJ9XG4gICAqL1xuICBcbiAgXG4gIExvbmdQcm90b3R5cGUuZ2V0TnVtQml0c0FicyA9IGZ1bmN0aW9uIGdldE51bUJpdHNBYnMoKSB7XG4gICAgaWYgKHRoaXMuaXNOZWdhdGl2ZSgpKSAvLyBVbnNpZ25lZCBMb25ncyBhcmUgbmV2ZXIgbmVnYXRpdmVcbiAgICAgIHJldHVybiB0aGlzLmVxKE1JTl9WQUxVRSkgPyA2NCA6IHRoaXMubmVnKCkuZ2V0TnVtQml0c0FicygpO1xuICAgIHZhciB2YWwgPSB0aGlzLmhpZ2ggIT0gMCA/IHRoaXMuaGlnaCA6IHRoaXMubG93O1xuICBcbiAgICBmb3IgKHZhciBiaXQgPSAzMTsgYml0ID4gMDsgYml0LS0pIGlmICgodmFsICYgMSA8PCBiaXQpICE9IDApIGJyZWFrO1xuICBcbiAgICByZXR1cm4gdGhpcy5oaWdoICE9IDAgPyBiaXQgKyAzMyA6IGJpdCArIDE7XG4gIH07XG4gIC8qKlxuICAgKiBUZXN0cyBpZiB0aGlzIExvbmcncyB2YWx1ZSBlcXVhbHMgemVyby5cbiAgICogQHRoaXMgeyFMb25nfVxuICAgKiBAcmV0dXJucyB7Ym9vbGVhbn1cbiAgICovXG4gIFxuICBcbiAgTG9uZ1Byb3RvdHlwZS5pc1plcm8gPSBmdW5jdGlvbiBpc1plcm8oKSB7XG4gICAgcmV0dXJuIHRoaXMuaGlnaCA9PT0gMCAmJiB0aGlzLmxvdyA9PT0gMDtcbiAgfTtcbiAgLyoqXG4gICAqIFRlc3RzIGlmIHRoaXMgTG9uZydzIHZhbHVlIGVxdWFscyB6ZXJvLiBUaGlzIGlzIGFuIGFsaWFzIG9mIHtAbGluayBMb25nI2lzWmVyb30uXG4gICAqIEByZXR1cm5zIHtib29sZWFufVxuICAgKi9cbiAgXG4gIFxuICBMb25nUHJvdG90eXBlLmVxeiA9IExvbmdQcm90b3R5cGUuaXNaZXJvO1xuICAvKipcbiAgICogVGVzdHMgaWYgdGhpcyBMb25nJ3MgdmFsdWUgaXMgbmVnYXRpdmUuXG4gICAqIEB0aGlzIHshTG9uZ31cbiAgICogQHJldHVybnMge2Jvb2xlYW59XG4gICAqL1xuICBcbiAgTG9uZ1Byb3RvdHlwZS5pc05lZ2F0aXZlID0gZnVuY3Rpb24gaXNOZWdhdGl2ZSgpIHtcbiAgICByZXR1cm4gIXRoaXMudW5zaWduZWQgJiYgdGhpcy5oaWdoIDwgMDtcbiAgfTtcbiAgLyoqXG4gICAqIFRlc3RzIGlmIHRoaXMgTG9uZydzIHZhbHVlIGlzIHBvc2l0aXZlIG9yIHplcm8uXG4gICAqIEB0aGlzIHshTG9uZ31cbiAgICogQHJldHVybnMge2Jvb2xlYW59XG4gICAqL1xuICBcbiAgXG4gIExvbmdQcm90b3R5cGUuaXNQb3NpdGl2ZSA9IGZ1bmN0aW9uIGlzUG9zaXRpdmUoKSB7XG4gICAgcmV0dXJuIHRoaXMudW5zaWduZWQgfHwgdGhpcy5oaWdoID49IDA7XG4gIH07XG4gIC8qKlxuICAgKiBUZXN0cyBpZiB0aGlzIExvbmcncyB2YWx1ZSBpcyBvZGQuXG4gICAqIEB0aGlzIHshTG9uZ31cbiAgICogQHJldHVybnMge2Jvb2xlYW59XG4gICAqL1xuICBcbiAgXG4gIExvbmdQcm90b3R5cGUuaXNPZGQgPSBmdW5jdGlvbiBpc09kZCgpIHtcbiAgICByZXR1cm4gKHRoaXMubG93ICYgMSkgPT09IDE7XG4gIH07XG4gIC8qKlxuICAgKiBUZXN0cyBpZiB0aGlzIExvbmcncyB2YWx1ZSBpcyBldmVuLlxuICAgKiBAdGhpcyB7IUxvbmd9XG4gICAqIEByZXR1cm5zIHtib29sZWFufVxuICAgKi9cbiAgXG4gIFxuICBMb25nUHJvdG90eXBlLmlzRXZlbiA9IGZ1bmN0aW9uIGlzRXZlbigpIHtcbiAgICByZXR1cm4gKHRoaXMubG93ICYgMSkgPT09IDA7XG4gIH07XG4gIC8qKlxuICAgKiBUZXN0cyBpZiB0aGlzIExvbmcncyB2YWx1ZSBlcXVhbHMgdGhlIHNwZWNpZmllZCdzLlxuICAgKiBAdGhpcyB7IUxvbmd9XG4gICAqIEBwYXJhbSB7IUxvbmd8bnVtYmVyfHN0cmluZ30gb3RoZXIgT3RoZXIgdmFsdWVcbiAgICogQHJldHVybnMge2Jvb2xlYW59XG4gICAqL1xuICBcbiAgXG4gIExvbmdQcm90b3R5cGUuZXF1YWxzID0gZnVuY3Rpb24gZXF1YWxzKG90aGVyKSB7XG4gICAgaWYgKCFpc0xvbmcob3RoZXIpKSBvdGhlciA9IGZyb21WYWx1ZShvdGhlcik7XG4gICAgaWYgKHRoaXMudW5zaWduZWQgIT09IG90aGVyLnVuc2lnbmVkICYmIHRoaXMuaGlnaCA+Pj4gMzEgPT09IDEgJiYgb3RoZXIuaGlnaCA+Pj4gMzEgPT09IDEpIHJldHVybiBmYWxzZTtcbiAgICByZXR1cm4gdGhpcy5oaWdoID09PSBvdGhlci5oaWdoICYmIHRoaXMubG93ID09PSBvdGhlci5sb3c7XG4gIH07XG4gIC8qKlxuICAgKiBUZXN0cyBpZiB0aGlzIExvbmcncyB2YWx1ZSBlcXVhbHMgdGhlIHNwZWNpZmllZCdzLiBUaGlzIGlzIGFuIGFsaWFzIG9mIHtAbGluayBMb25nI2VxdWFsc30uXG4gICAqIEBmdW5jdGlvblxuICAgKiBAcGFyYW0geyFMb25nfG51bWJlcnxzdHJpbmd9IG90aGVyIE90aGVyIHZhbHVlXG4gICAqIEByZXR1cm5zIHtib29sZWFufVxuICAgKi9cbiAgXG4gIFxuICBMb25nUHJvdG90eXBlLmVxID0gTG9uZ1Byb3RvdHlwZS5lcXVhbHM7XG4gIC8qKlxuICAgKiBUZXN0cyBpZiB0aGlzIExvbmcncyB2YWx1ZSBkaWZmZXJzIGZyb20gdGhlIHNwZWNpZmllZCdzLlxuICAgKiBAdGhpcyB7IUxvbmd9XG4gICAqIEBwYXJhbSB7IUxvbmd8bnVtYmVyfHN0cmluZ30gb3RoZXIgT3RoZXIgdmFsdWVcbiAgICogQHJldHVybnMge2Jvb2xlYW59XG4gICAqL1xuICBcbiAgTG9uZ1Byb3RvdHlwZS5ub3RFcXVhbHMgPSBmdW5jdGlvbiBub3RFcXVhbHMob3RoZXIpIHtcbiAgICByZXR1cm4gIXRoaXMuZXEoXG4gICAgLyogdmFsaWRhdGVzICovXG4gICAgb3RoZXIpO1xuICB9O1xuICAvKipcbiAgICogVGVzdHMgaWYgdGhpcyBMb25nJ3MgdmFsdWUgZGlmZmVycyBmcm9tIHRoZSBzcGVjaWZpZWQncy4gVGhpcyBpcyBhbiBhbGlhcyBvZiB7QGxpbmsgTG9uZyNub3RFcXVhbHN9LlxuICAgKiBAZnVuY3Rpb25cbiAgICogQHBhcmFtIHshTG9uZ3xudW1iZXJ8c3RyaW5nfSBvdGhlciBPdGhlciB2YWx1ZVxuICAgKiBAcmV0dXJucyB7Ym9vbGVhbn1cbiAgICovXG4gIFxuICBcbiAgTG9uZ1Byb3RvdHlwZS5uZXEgPSBMb25nUHJvdG90eXBlLm5vdEVxdWFscztcbiAgLyoqXG4gICAqIFRlc3RzIGlmIHRoaXMgTG9uZydzIHZhbHVlIGRpZmZlcnMgZnJvbSB0aGUgc3BlY2lmaWVkJ3MuIFRoaXMgaXMgYW4gYWxpYXMgb2Yge0BsaW5rIExvbmcjbm90RXF1YWxzfS5cbiAgICogQGZ1bmN0aW9uXG4gICAqIEBwYXJhbSB7IUxvbmd8bnVtYmVyfHN0cmluZ30gb3RoZXIgT3RoZXIgdmFsdWVcbiAgICogQHJldHVybnMge2Jvb2xlYW59XG4gICAqL1xuICBcbiAgTG9uZ1Byb3RvdHlwZS5uZSA9IExvbmdQcm90b3R5cGUubm90RXF1YWxzO1xuICAvKipcbiAgICogVGVzdHMgaWYgdGhpcyBMb25nJ3MgdmFsdWUgaXMgbGVzcyB0aGFuIHRoZSBzcGVjaWZpZWQncy5cbiAgICogQHRoaXMgeyFMb25nfVxuICAgKiBAcGFyYW0geyFMb25nfG51bWJlcnxzdHJpbmd9IG90aGVyIE90aGVyIHZhbHVlXG4gICAqIEByZXR1cm5zIHtib29sZWFufVxuICAgKi9cbiAgXG4gIExvbmdQcm90b3R5cGUubGVzc1RoYW4gPSBmdW5jdGlvbiBsZXNzVGhhbihvdGhlcikge1xuICAgIHJldHVybiB0aGlzLmNvbXAoXG4gICAgLyogdmFsaWRhdGVzICovXG4gICAgb3RoZXIpIDwgMDtcbiAgfTtcbiAgLyoqXG4gICAqIFRlc3RzIGlmIHRoaXMgTG9uZydzIHZhbHVlIGlzIGxlc3MgdGhhbiB0aGUgc3BlY2lmaWVkJ3MuIFRoaXMgaXMgYW4gYWxpYXMgb2Yge0BsaW5rIExvbmcjbGVzc1RoYW59LlxuICAgKiBAZnVuY3Rpb25cbiAgICogQHBhcmFtIHshTG9uZ3xudW1iZXJ8c3RyaW5nfSBvdGhlciBPdGhlciB2YWx1ZVxuICAgKiBAcmV0dXJucyB7Ym9vbGVhbn1cbiAgICovXG4gIFxuICBcbiAgTG9uZ1Byb3RvdHlwZS5sdCA9IExvbmdQcm90b3R5cGUubGVzc1RoYW47XG4gIC8qKlxuICAgKiBUZXN0cyBpZiB0aGlzIExvbmcncyB2YWx1ZSBpcyBsZXNzIHRoYW4gb3IgZXF1YWwgdGhlIHNwZWNpZmllZCdzLlxuICAgKiBAdGhpcyB7IUxvbmd9XG4gICAqIEBwYXJhbSB7IUxvbmd8bnVtYmVyfHN0cmluZ30gb3RoZXIgT3RoZXIgdmFsdWVcbiAgICogQHJldHVybnMge2Jvb2xlYW59XG4gICAqL1xuICBcbiAgTG9uZ1Byb3RvdHlwZS5sZXNzVGhhbk9yRXF1YWwgPSBmdW5jdGlvbiBsZXNzVGhhbk9yRXF1YWwob3RoZXIpIHtcbiAgICByZXR1cm4gdGhpcy5jb21wKFxuICAgIC8qIHZhbGlkYXRlcyAqL1xuICAgIG90aGVyKSA8PSAwO1xuICB9O1xuICAvKipcbiAgICogVGVzdHMgaWYgdGhpcyBMb25nJ3MgdmFsdWUgaXMgbGVzcyB0aGFuIG9yIGVxdWFsIHRoZSBzcGVjaWZpZWQncy4gVGhpcyBpcyBhbiBhbGlhcyBvZiB7QGxpbmsgTG9uZyNsZXNzVGhhbk9yRXF1YWx9LlxuICAgKiBAZnVuY3Rpb25cbiAgICogQHBhcmFtIHshTG9uZ3xudW1iZXJ8c3RyaW5nfSBvdGhlciBPdGhlciB2YWx1ZVxuICAgKiBAcmV0dXJucyB7Ym9vbGVhbn1cbiAgICovXG4gIFxuICBcbiAgTG9uZ1Byb3RvdHlwZS5sdGUgPSBMb25nUHJvdG90eXBlLmxlc3NUaGFuT3JFcXVhbDtcbiAgLyoqXG4gICAqIFRlc3RzIGlmIHRoaXMgTG9uZydzIHZhbHVlIGlzIGxlc3MgdGhhbiBvciBlcXVhbCB0aGUgc3BlY2lmaWVkJ3MuIFRoaXMgaXMgYW4gYWxpYXMgb2Yge0BsaW5rIExvbmcjbGVzc1RoYW5PckVxdWFsfS5cbiAgICogQGZ1bmN0aW9uXG4gICAqIEBwYXJhbSB7IUxvbmd8bnVtYmVyfHN0cmluZ30gb3RoZXIgT3RoZXIgdmFsdWVcbiAgICogQHJldHVybnMge2Jvb2xlYW59XG4gICAqL1xuICBcbiAgTG9uZ1Byb3RvdHlwZS5sZSA9IExvbmdQcm90b3R5cGUubGVzc1RoYW5PckVxdWFsO1xuICAvKipcbiAgICogVGVzdHMgaWYgdGhpcyBMb25nJ3MgdmFsdWUgaXMgZ3JlYXRlciB0aGFuIHRoZSBzcGVjaWZpZWQncy5cbiAgICogQHRoaXMgeyFMb25nfVxuICAgKiBAcGFyYW0geyFMb25nfG51bWJlcnxzdHJpbmd9IG90aGVyIE90aGVyIHZhbHVlXG4gICAqIEByZXR1cm5zIHtib29sZWFufVxuICAgKi9cbiAgXG4gIExvbmdQcm90b3R5cGUuZ3JlYXRlclRoYW4gPSBmdW5jdGlvbiBncmVhdGVyVGhhbihvdGhlcikge1xuICAgIHJldHVybiB0aGlzLmNvbXAoXG4gICAgLyogdmFsaWRhdGVzICovXG4gICAgb3RoZXIpID4gMDtcbiAgfTtcbiAgLyoqXG4gICAqIFRlc3RzIGlmIHRoaXMgTG9uZydzIHZhbHVlIGlzIGdyZWF0ZXIgdGhhbiB0aGUgc3BlY2lmaWVkJ3MuIFRoaXMgaXMgYW4gYWxpYXMgb2Yge0BsaW5rIExvbmcjZ3JlYXRlclRoYW59LlxuICAgKiBAZnVuY3Rpb25cbiAgICogQHBhcmFtIHshTG9uZ3xudW1iZXJ8c3RyaW5nfSBvdGhlciBPdGhlciB2YWx1ZVxuICAgKiBAcmV0dXJucyB7Ym9vbGVhbn1cbiAgICovXG4gIFxuICBcbiAgTG9uZ1Byb3RvdHlwZS5ndCA9IExvbmdQcm90b3R5cGUuZ3JlYXRlclRoYW47XG4gIC8qKlxuICAgKiBUZXN0cyBpZiB0aGlzIExvbmcncyB2YWx1ZSBpcyBncmVhdGVyIHRoYW4gb3IgZXF1YWwgdGhlIHNwZWNpZmllZCdzLlxuICAgKiBAdGhpcyB7IUxvbmd9XG4gICAqIEBwYXJhbSB7IUxvbmd8bnVtYmVyfHN0cmluZ30gb3RoZXIgT3RoZXIgdmFsdWVcbiAgICogQHJldHVybnMge2Jvb2xlYW59XG4gICAqL1xuICBcbiAgTG9uZ1Byb3RvdHlwZS5ncmVhdGVyVGhhbk9yRXF1YWwgPSBmdW5jdGlvbiBncmVhdGVyVGhhbk9yRXF1YWwob3RoZXIpIHtcbiAgICByZXR1cm4gdGhpcy5jb21wKFxuICAgIC8qIHZhbGlkYXRlcyAqL1xuICAgIG90aGVyKSA+PSAwO1xuICB9O1xuICAvKipcbiAgICogVGVzdHMgaWYgdGhpcyBMb25nJ3MgdmFsdWUgaXMgZ3JlYXRlciB0aGFuIG9yIGVxdWFsIHRoZSBzcGVjaWZpZWQncy4gVGhpcyBpcyBhbiBhbGlhcyBvZiB7QGxpbmsgTG9uZyNncmVhdGVyVGhhbk9yRXF1YWx9LlxuICAgKiBAZnVuY3Rpb25cbiAgICogQHBhcmFtIHshTG9uZ3xudW1iZXJ8c3RyaW5nfSBvdGhlciBPdGhlciB2YWx1ZVxuICAgKiBAcmV0dXJucyB7Ym9vbGVhbn1cbiAgICovXG4gIFxuICBcbiAgTG9uZ1Byb3RvdHlwZS5ndGUgPSBMb25nUHJvdG90eXBlLmdyZWF0ZXJUaGFuT3JFcXVhbDtcbiAgLyoqXG4gICAqIFRlc3RzIGlmIHRoaXMgTG9uZydzIHZhbHVlIGlzIGdyZWF0ZXIgdGhhbiBvciBlcXVhbCB0aGUgc3BlY2lmaWVkJ3MuIFRoaXMgaXMgYW4gYWxpYXMgb2Yge0BsaW5rIExvbmcjZ3JlYXRlclRoYW5PckVxdWFsfS5cbiAgICogQGZ1bmN0aW9uXG4gICAqIEBwYXJhbSB7IUxvbmd8bnVtYmVyfHN0cmluZ30gb3RoZXIgT3RoZXIgdmFsdWVcbiAgICogQHJldHVybnMge2Jvb2xlYW59XG4gICAqL1xuICBcbiAgTG9uZ1Byb3RvdHlwZS5nZSA9IExvbmdQcm90b3R5cGUuZ3JlYXRlclRoYW5PckVxdWFsO1xuICAvKipcbiAgICogQ29tcGFyZXMgdGhpcyBMb25nJ3MgdmFsdWUgd2l0aCB0aGUgc3BlY2lmaWVkJ3MuXG4gICAqIEB0aGlzIHshTG9uZ31cbiAgICogQHBhcmFtIHshTG9uZ3xudW1iZXJ8c3RyaW5nfSBvdGhlciBPdGhlciB2YWx1ZVxuICAgKiBAcmV0dXJucyB7bnVtYmVyfSAwIGlmIHRoZXkgYXJlIHRoZSBzYW1lLCAxIGlmIHRoZSB0aGlzIGlzIGdyZWF0ZXIgYW5kIC0xXG4gICAqICBpZiB0aGUgZ2l2ZW4gb25lIGlzIGdyZWF0ZXJcbiAgICovXG4gIFxuICBMb25nUHJvdG90eXBlLmNvbXBhcmUgPSBmdW5jdGlvbiBjb21wYXJlKG90aGVyKSB7XG4gICAgaWYgKCFpc0xvbmcob3RoZXIpKSBvdGhlciA9IGZyb21WYWx1ZShvdGhlcik7XG4gICAgaWYgKHRoaXMuZXEob3RoZXIpKSByZXR1cm4gMDtcbiAgICB2YXIgdGhpc05lZyA9IHRoaXMuaXNOZWdhdGl2ZSgpLFxuICAgICAgICBvdGhlck5lZyA9IG90aGVyLmlzTmVnYXRpdmUoKTtcbiAgICBpZiAodGhpc05lZyAmJiAhb3RoZXJOZWcpIHJldHVybiAtMTtcbiAgICBpZiAoIXRoaXNOZWcgJiYgb3RoZXJOZWcpIHJldHVybiAxOyAvLyBBdCB0aGlzIHBvaW50IHRoZSBzaWduIGJpdHMgYXJlIHRoZSBzYW1lXG4gIFxuICAgIGlmICghdGhpcy51bnNpZ25lZCkgcmV0dXJuIHRoaXMuc3ViKG90aGVyKS5pc05lZ2F0aXZlKCkgPyAtMSA6IDE7IC8vIEJvdGggYXJlIHBvc2l0aXZlIGlmIGF0IGxlYXN0IG9uZSBpcyB1bnNpZ25lZFxuICBcbiAgICByZXR1cm4gb3RoZXIuaGlnaCA+Pj4gMCA+IHRoaXMuaGlnaCA+Pj4gMCB8fCBvdGhlci5oaWdoID09PSB0aGlzLmhpZ2ggJiYgb3RoZXIubG93ID4+PiAwID4gdGhpcy5sb3cgPj4+IDAgPyAtMSA6IDE7XG4gIH07XG4gIC8qKlxuICAgKiBDb21wYXJlcyB0aGlzIExvbmcncyB2YWx1ZSB3aXRoIHRoZSBzcGVjaWZpZWQncy4gVGhpcyBpcyBhbiBhbGlhcyBvZiB7QGxpbmsgTG9uZyNjb21wYXJlfS5cbiAgICogQGZ1bmN0aW9uXG4gICAqIEBwYXJhbSB7IUxvbmd8bnVtYmVyfHN0cmluZ30gb3RoZXIgT3RoZXIgdmFsdWVcbiAgICogQHJldHVybnMge251bWJlcn0gMCBpZiB0aGV5IGFyZSB0aGUgc2FtZSwgMSBpZiB0aGUgdGhpcyBpcyBncmVhdGVyIGFuZCAtMVxuICAgKiAgaWYgdGhlIGdpdmVuIG9uZSBpcyBncmVhdGVyXG4gICAqL1xuICBcbiAgXG4gIExvbmdQcm90b3R5cGUuY29tcCA9IExvbmdQcm90b3R5cGUuY29tcGFyZTtcbiAgLyoqXG4gICAqIE5lZ2F0ZXMgdGhpcyBMb25nJ3MgdmFsdWUuXG4gICAqIEB0aGlzIHshTG9uZ31cbiAgICogQHJldHVybnMgeyFMb25nfSBOZWdhdGVkIExvbmdcbiAgICovXG4gIFxuICBMb25nUHJvdG90eXBlLm5lZ2F0ZSA9IGZ1bmN0aW9uIG5lZ2F0ZSgpIHtcbiAgICBpZiAoIXRoaXMudW5zaWduZWQgJiYgdGhpcy5lcShNSU5fVkFMVUUpKSByZXR1cm4gTUlOX1ZBTFVFO1xuICAgIHJldHVybiB0aGlzLm5vdCgpLmFkZChPTkUpO1xuICB9O1xuICAvKipcbiAgICogTmVnYXRlcyB0aGlzIExvbmcncyB2YWx1ZS4gVGhpcyBpcyBhbiBhbGlhcyBvZiB7QGxpbmsgTG9uZyNuZWdhdGV9LlxuICAgKiBAZnVuY3Rpb25cbiAgICogQHJldHVybnMgeyFMb25nfSBOZWdhdGVkIExvbmdcbiAgICovXG4gIFxuICBcbiAgTG9uZ1Byb3RvdHlwZS5uZWcgPSBMb25nUHJvdG90eXBlLm5lZ2F0ZTtcbiAgLyoqXG4gICAqIFJldHVybnMgdGhlIHN1bSBvZiB0aGlzIGFuZCB0aGUgc3BlY2lmaWVkIExvbmcuXG4gICAqIEB0aGlzIHshTG9uZ31cbiAgICogQHBhcmFtIHshTG9uZ3xudW1iZXJ8c3RyaW5nfSBhZGRlbmQgQWRkZW5kXG4gICAqIEByZXR1cm5zIHshTG9uZ30gU3VtXG4gICAqL1xuICBcbiAgTG9uZ1Byb3RvdHlwZS5hZGQgPSBmdW5jdGlvbiBhZGQoYWRkZW5kKSB7XG4gICAgaWYgKCFpc0xvbmcoYWRkZW5kKSkgYWRkZW5kID0gZnJvbVZhbHVlKGFkZGVuZCk7IC8vIERpdmlkZSBlYWNoIG51bWJlciBpbnRvIDQgY2h1bmtzIG9mIDE2IGJpdHMsIGFuZCB0aGVuIHN1bSB0aGUgY2h1bmtzLlxuICBcbiAgICB2YXIgYTQ4ID0gdGhpcy5oaWdoID4+PiAxNjtcbiAgICB2YXIgYTMyID0gdGhpcy5oaWdoICYgMHhGRkZGO1xuICAgIHZhciBhMTYgPSB0aGlzLmxvdyA+Pj4gMTY7XG4gICAgdmFyIGEwMCA9IHRoaXMubG93ICYgMHhGRkZGO1xuICAgIHZhciBiNDggPSBhZGRlbmQuaGlnaCA+Pj4gMTY7XG4gICAgdmFyIGIzMiA9IGFkZGVuZC5oaWdoICYgMHhGRkZGO1xuICAgIHZhciBiMTYgPSBhZGRlbmQubG93ID4+PiAxNjtcbiAgICB2YXIgYjAwID0gYWRkZW5kLmxvdyAmIDB4RkZGRjtcbiAgICB2YXIgYzQ4ID0gMCxcbiAgICAgICAgYzMyID0gMCxcbiAgICAgICAgYzE2ID0gMCxcbiAgICAgICAgYzAwID0gMDtcbiAgICBjMDAgKz0gYTAwICsgYjAwO1xuICAgIGMxNiArPSBjMDAgPj4+IDE2O1xuICAgIGMwMCAmPSAweEZGRkY7XG4gICAgYzE2ICs9IGExNiArIGIxNjtcbiAgICBjMzIgKz0gYzE2ID4+PiAxNjtcbiAgICBjMTYgJj0gMHhGRkZGO1xuICAgIGMzMiArPSBhMzIgKyBiMzI7XG4gICAgYzQ4ICs9IGMzMiA+Pj4gMTY7XG4gICAgYzMyICY9IDB4RkZGRjtcbiAgICBjNDggKz0gYTQ4ICsgYjQ4O1xuICAgIGM0OCAmPSAweEZGRkY7XG4gICAgcmV0dXJuIGZyb21CaXRzKGMxNiA8PCAxNiB8IGMwMCwgYzQ4IDw8IDE2IHwgYzMyLCB0aGlzLnVuc2lnbmVkKTtcbiAgfTtcbiAgLyoqXG4gICAqIFJldHVybnMgdGhlIGRpZmZlcmVuY2Ugb2YgdGhpcyBhbmQgdGhlIHNwZWNpZmllZCBMb25nLlxuICAgKiBAdGhpcyB7IUxvbmd9XG4gICAqIEBwYXJhbSB7IUxvbmd8bnVtYmVyfHN0cmluZ30gc3VidHJhaGVuZCBTdWJ0cmFoZW5kXG4gICAqIEByZXR1cm5zIHshTG9uZ30gRGlmZmVyZW5jZVxuICAgKi9cbiAgXG4gIFxuICBMb25nUHJvdG90eXBlLnN1YnRyYWN0ID0gZnVuY3Rpb24gc3VidHJhY3Qoc3VidHJhaGVuZCkge1xuICAgIGlmICghaXNMb25nKHN1YnRyYWhlbmQpKSBzdWJ0cmFoZW5kID0gZnJvbVZhbHVlKHN1YnRyYWhlbmQpO1xuICAgIHJldHVybiB0aGlzLmFkZChzdWJ0cmFoZW5kLm5lZygpKTtcbiAgfTtcbiAgLyoqXG4gICAqIFJldHVybnMgdGhlIGRpZmZlcmVuY2Ugb2YgdGhpcyBhbmQgdGhlIHNwZWNpZmllZCBMb25nLiBUaGlzIGlzIGFuIGFsaWFzIG9mIHtAbGluayBMb25nI3N1YnRyYWN0fS5cbiAgICogQGZ1bmN0aW9uXG4gICAqIEBwYXJhbSB7IUxvbmd8bnVtYmVyfHN0cmluZ30gc3VidHJhaGVuZCBTdWJ0cmFoZW5kXG4gICAqIEByZXR1cm5zIHshTG9uZ30gRGlmZmVyZW5jZVxuICAgKi9cbiAgXG4gIFxuICBMb25nUHJvdG90eXBlLnN1YiA9IExvbmdQcm90b3R5cGUuc3VidHJhY3Q7XG4gIC8qKlxuICAgKiBSZXR1cm5zIHRoZSBwcm9kdWN0IG9mIHRoaXMgYW5kIHRoZSBzcGVjaWZpZWQgTG9uZy5cbiAgICogQHRoaXMgeyFMb25nfVxuICAgKiBAcGFyYW0geyFMb25nfG51bWJlcnxzdHJpbmd9IG11bHRpcGxpZXIgTXVsdGlwbGllclxuICAgKiBAcmV0dXJucyB7IUxvbmd9IFByb2R1Y3RcbiAgICovXG4gIFxuICBMb25nUHJvdG90eXBlLm11bHRpcGx5ID0gZnVuY3Rpb24gbXVsdGlwbHkobXVsdGlwbGllcikge1xuICAgIGlmICh0aGlzLmlzWmVybygpKSByZXR1cm4gdGhpcztcbiAgICBpZiAoIWlzTG9uZyhtdWx0aXBsaWVyKSkgbXVsdGlwbGllciA9IGZyb21WYWx1ZShtdWx0aXBsaWVyKTsgLy8gdXNlIHdhc20gc3VwcG9ydCBpZiBwcmVzZW50XG4gIFxuICAgIGlmICh3YXNtKSB7XG4gICAgICB2YXIgbG93ID0gd2FzbVtcIm11bFwiXSh0aGlzLmxvdywgdGhpcy5oaWdoLCBtdWx0aXBsaWVyLmxvdywgbXVsdGlwbGllci5oaWdoKTtcbiAgICAgIHJldHVybiBmcm9tQml0cyhsb3csIHdhc21bXCJnZXRfaGlnaFwiXSgpLCB0aGlzLnVuc2lnbmVkKTtcbiAgICB9XG4gIFxuICAgIGlmIChtdWx0aXBsaWVyLmlzWmVybygpKSByZXR1cm4gdGhpcy51bnNpZ25lZCA/IFVaRVJPIDogWkVSTztcbiAgICBpZiAodGhpcy5lcShNSU5fVkFMVUUpKSByZXR1cm4gbXVsdGlwbGllci5pc09kZCgpID8gTUlOX1ZBTFVFIDogWkVSTztcbiAgICBpZiAobXVsdGlwbGllci5lcShNSU5fVkFMVUUpKSByZXR1cm4gdGhpcy5pc09kZCgpID8gTUlOX1ZBTFVFIDogWkVSTztcbiAgXG4gICAgaWYgKHRoaXMuaXNOZWdhdGl2ZSgpKSB7XG4gICAgICBpZiAobXVsdGlwbGllci5pc05lZ2F0aXZlKCkpIHJldHVybiB0aGlzLm5lZygpLm11bChtdWx0aXBsaWVyLm5lZygpKTtlbHNlIHJldHVybiB0aGlzLm5lZygpLm11bChtdWx0aXBsaWVyKS5uZWcoKTtcbiAgICB9IGVsc2UgaWYgKG11bHRpcGxpZXIuaXNOZWdhdGl2ZSgpKSByZXR1cm4gdGhpcy5tdWwobXVsdGlwbGllci5uZWcoKSkubmVnKCk7IC8vIElmIGJvdGggbG9uZ3MgYXJlIHNtYWxsLCB1c2UgZmxvYXQgbXVsdGlwbGljYXRpb25cbiAgXG4gIFxuICAgIGlmICh0aGlzLmx0KFRXT19QV1JfMjQpICYmIG11bHRpcGxpZXIubHQoVFdPX1BXUl8yNCkpIHJldHVybiBmcm9tTnVtYmVyKHRoaXMudG9OdW1iZXIoKSAqIG11bHRpcGxpZXIudG9OdW1iZXIoKSwgdGhpcy51bnNpZ25lZCk7IC8vIERpdmlkZSBlYWNoIGxvbmcgaW50byA0IGNodW5rcyBvZiAxNiBiaXRzLCBhbmQgdGhlbiBhZGQgdXAgNHg0IHByb2R1Y3RzLlxuICAgIC8vIFdlIGNhbiBza2lwIHByb2R1Y3RzIHRoYXQgd291bGQgb3ZlcmZsb3cuXG4gIFxuICAgIHZhciBhNDggPSB0aGlzLmhpZ2ggPj4+IDE2O1xuICAgIHZhciBhMzIgPSB0aGlzLmhpZ2ggJiAweEZGRkY7XG4gICAgdmFyIGExNiA9IHRoaXMubG93ID4+PiAxNjtcbiAgICB2YXIgYTAwID0gdGhpcy5sb3cgJiAweEZGRkY7XG4gICAgdmFyIGI0OCA9IG11bHRpcGxpZXIuaGlnaCA+Pj4gMTY7XG4gICAgdmFyIGIzMiA9IG11bHRpcGxpZXIuaGlnaCAmIDB4RkZGRjtcbiAgICB2YXIgYjE2ID0gbXVsdGlwbGllci5sb3cgPj4+IDE2O1xuICAgIHZhciBiMDAgPSBtdWx0aXBsaWVyLmxvdyAmIDB4RkZGRjtcbiAgICB2YXIgYzQ4ID0gMCxcbiAgICAgICAgYzMyID0gMCxcbiAgICAgICAgYzE2ID0gMCxcbiAgICAgICAgYzAwID0gMDtcbiAgICBjMDAgKz0gYTAwICogYjAwO1xuICAgIGMxNiArPSBjMDAgPj4+IDE2O1xuICAgIGMwMCAmPSAweEZGRkY7XG4gICAgYzE2ICs9IGExNiAqIGIwMDtcbiAgICBjMzIgKz0gYzE2ID4+PiAxNjtcbiAgICBjMTYgJj0gMHhGRkZGO1xuICAgIGMxNiArPSBhMDAgKiBiMTY7XG4gICAgYzMyICs9IGMxNiA+Pj4gMTY7XG4gICAgYzE2ICY9IDB4RkZGRjtcbiAgICBjMzIgKz0gYTMyICogYjAwO1xuICAgIGM0OCArPSBjMzIgPj4+IDE2O1xuICAgIGMzMiAmPSAweEZGRkY7XG4gICAgYzMyICs9IGExNiAqIGIxNjtcbiAgICBjNDggKz0gYzMyID4+PiAxNjtcbiAgICBjMzIgJj0gMHhGRkZGO1xuICAgIGMzMiArPSBhMDAgKiBiMzI7XG4gICAgYzQ4ICs9IGMzMiA+Pj4gMTY7XG4gICAgYzMyICY9IDB4RkZGRjtcbiAgICBjNDggKz0gYTQ4ICogYjAwICsgYTMyICogYjE2ICsgYTE2ICogYjMyICsgYTAwICogYjQ4O1xuICAgIGM0OCAmPSAweEZGRkY7XG4gICAgcmV0dXJuIGZyb21CaXRzKGMxNiA8PCAxNiB8IGMwMCwgYzQ4IDw8IDE2IHwgYzMyLCB0aGlzLnVuc2lnbmVkKTtcbiAgfTtcbiAgLyoqXG4gICAqIFJldHVybnMgdGhlIHByb2R1Y3Qgb2YgdGhpcyBhbmQgdGhlIHNwZWNpZmllZCBMb25nLiBUaGlzIGlzIGFuIGFsaWFzIG9mIHtAbGluayBMb25nI211bHRpcGx5fS5cbiAgICogQGZ1bmN0aW9uXG4gICAqIEBwYXJhbSB7IUxvbmd8bnVtYmVyfHN0cmluZ30gbXVsdGlwbGllciBNdWx0aXBsaWVyXG4gICAqIEByZXR1cm5zIHshTG9uZ30gUHJvZHVjdFxuICAgKi9cbiAgXG4gIFxuICBMb25nUHJvdG90eXBlLm11bCA9IExvbmdQcm90b3R5cGUubXVsdGlwbHk7XG4gIC8qKlxuICAgKiBSZXR1cm5zIHRoaXMgTG9uZyBkaXZpZGVkIGJ5IHRoZSBzcGVjaWZpZWQuIFRoZSByZXN1bHQgaXMgc2lnbmVkIGlmIHRoaXMgTG9uZyBpcyBzaWduZWQgb3JcbiAgICogIHVuc2lnbmVkIGlmIHRoaXMgTG9uZyBpcyB1bnNpZ25lZC5cbiAgICogQHRoaXMgeyFMb25nfVxuICAgKiBAcGFyYW0geyFMb25nfG51bWJlcnxzdHJpbmd9IGRpdmlzb3IgRGl2aXNvclxuICAgKiBAcmV0dXJucyB7IUxvbmd9IFF1b3RpZW50XG4gICAqL1xuICBcbiAgTG9uZ1Byb3RvdHlwZS5kaXZpZGUgPSBmdW5jdGlvbiBkaXZpZGUoZGl2aXNvcikge1xuICAgIGlmICghaXNMb25nKGRpdmlzb3IpKSBkaXZpc29yID0gZnJvbVZhbHVlKGRpdmlzb3IpO1xuICAgIGlmIChkaXZpc29yLmlzWmVybygpKSB0aHJvdyBFcnJvcignZGl2aXNpb24gYnkgemVybycpOyAvLyB1c2Ugd2FzbSBzdXBwb3J0IGlmIHByZXNlbnRcbiAgXG4gICAgaWYgKHdhc20pIHtcbiAgICAgIC8vIGd1YXJkIGFnYWluc3Qgc2lnbmVkIGRpdmlzaW9uIG92ZXJmbG93OiB0aGUgbGFyZ2VzdFxuICAgICAgLy8gbmVnYXRpdmUgbnVtYmVyIC8gLTEgd291bGQgYmUgMSBsYXJnZXIgdGhhbiB0aGUgbGFyZ2VzdFxuICAgICAgLy8gcG9zaXRpdmUgbnVtYmVyLCBkdWUgdG8gdHdvJ3MgY29tcGxlbWVudC5cbiAgICAgIGlmICghdGhpcy51bnNpZ25lZCAmJiB0aGlzLmhpZ2ggPT09IC0weDgwMDAwMDAwICYmIGRpdmlzb3IubG93ID09PSAtMSAmJiBkaXZpc29yLmhpZ2ggPT09IC0xKSB7XG4gICAgICAgIC8vIGJlIGNvbnNpc3RlbnQgd2l0aCBub24td2FzbSBjb2RlIHBhdGhcbiAgICAgICAgcmV0dXJuIHRoaXM7XG4gICAgICB9XG4gIFxuICAgICAgdmFyIGxvdyA9ICh0aGlzLnVuc2lnbmVkID8gd2FzbVtcImRpdl91XCJdIDogd2FzbVtcImRpdl9zXCJdKSh0aGlzLmxvdywgdGhpcy5oaWdoLCBkaXZpc29yLmxvdywgZGl2aXNvci5oaWdoKTtcbiAgICAgIHJldHVybiBmcm9tQml0cyhsb3csIHdhc21bXCJnZXRfaGlnaFwiXSgpLCB0aGlzLnVuc2lnbmVkKTtcbiAgICB9XG4gIFxuICAgIGlmICh0aGlzLmlzWmVybygpKSByZXR1cm4gdGhpcy51bnNpZ25lZCA/IFVaRVJPIDogWkVSTztcbiAgICB2YXIgYXBwcm94LCByZW0sIHJlcztcbiAgXG4gICAgaWYgKCF0aGlzLnVuc2lnbmVkKSB7XG4gICAgICAvLyBUaGlzIHNlY3Rpb24gaXMgb25seSByZWxldmFudCBmb3Igc2lnbmVkIGxvbmdzIGFuZCBpcyBkZXJpdmVkIGZyb20gdGhlXG4gICAgICAvLyBjbG9zdXJlIGxpYnJhcnkgYXMgYSB3aG9sZS5cbiAgICAgIGlmICh0aGlzLmVxKE1JTl9WQUxVRSkpIHtcbiAgICAgICAgaWYgKGRpdmlzb3IuZXEoT05FKSB8fCBkaXZpc29yLmVxKE5FR19PTkUpKSByZXR1cm4gTUlOX1ZBTFVFOyAvLyByZWNhbGwgdGhhdCAtTUlOX1ZBTFVFID09IE1JTl9WQUxVRVxuICAgICAgICBlbHNlIGlmIChkaXZpc29yLmVxKE1JTl9WQUxVRSkpIHJldHVybiBPTkU7ZWxzZSB7XG4gICAgICAgICAgLy8gQXQgdGhpcyBwb2ludCwgd2UgaGF2ZSB8b3RoZXJ8ID49IDIsIHNvIHx0aGlzL290aGVyfCA8IHxNSU5fVkFMVUV8LlxuICAgICAgICAgIHZhciBoYWxmVGhpcyA9IHRoaXMuc2hyKDEpO1xuICAgICAgICAgIGFwcHJveCA9IGhhbGZUaGlzLmRpdihkaXZpc29yKS5zaGwoMSk7XG4gIFxuICAgICAgICAgIGlmIChhcHByb3guZXEoWkVSTykpIHtcbiAgICAgICAgICAgIHJldHVybiBkaXZpc29yLmlzTmVnYXRpdmUoKSA/IE9ORSA6IE5FR19PTkU7XG4gICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIHJlbSA9IHRoaXMuc3ViKGRpdmlzb3IubXVsKGFwcHJveCkpO1xuICAgICAgICAgICAgcmVzID0gYXBwcm94LmFkZChyZW0uZGl2KGRpdmlzb3IpKTtcbiAgICAgICAgICAgIHJldHVybiByZXM7XG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICB9IGVsc2UgaWYgKGRpdmlzb3IuZXEoTUlOX1ZBTFVFKSkgcmV0dXJuIHRoaXMudW5zaWduZWQgPyBVWkVSTyA6IFpFUk87XG4gIFxuICAgICAgaWYgKHRoaXMuaXNOZWdhdGl2ZSgpKSB7XG4gICAgICAgIGlmIChkaXZpc29yLmlzTmVnYXRpdmUoKSkgcmV0dXJuIHRoaXMubmVnKCkuZGl2KGRpdmlzb3IubmVnKCkpO1xuICAgICAgICByZXR1cm4gdGhpcy5uZWcoKS5kaXYoZGl2aXNvcikubmVnKCk7XG4gICAgICB9IGVsc2UgaWYgKGRpdmlzb3IuaXNOZWdhdGl2ZSgpKSByZXR1cm4gdGhpcy5kaXYoZGl2aXNvci5uZWcoKSkubmVnKCk7XG4gIFxuICAgICAgcmVzID0gWkVSTztcbiAgICB9IGVsc2Uge1xuICAgICAgLy8gVGhlIGFsZ29yaXRobSBiZWxvdyBoYXMgbm90IGJlZW4gbWFkZSBmb3IgdW5zaWduZWQgbG9uZ3MuIEl0J3MgdGhlcmVmb3JlXG4gICAgICAvLyByZXF1aXJlZCB0byB0YWtlIHNwZWNpYWwgY2FyZSBvZiB0aGUgTVNCIHByaW9yIHRvIHJ1bm5pbmcgaXQuXG4gICAgICBpZiAoIWRpdmlzb3IudW5zaWduZWQpIGRpdmlzb3IgPSBkaXZpc29yLnRvVW5zaWduZWQoKTtcbiAgICAgIGlmIChkaXZpc29yLmd0KHRoaXMpKSByZXR1cm4gVVpFUk87XG4gICAgICBpZiAoZGl2aXNvci5ndCh0aGlzLnNocnUoMSkpKSAvLyAxNSA+Pj4gMSA9IDcgOyB3aXRoIGRpdmlzb3IgPSA4IDsgdHJ1ZVxuICAgICAgICByZXR1cm4gVU9ORTtcbiAgICAgIHJlcyA9IFVaRVJPO1xuICAgIH0gLy8gUmVwZWF0IHRoZSBmb2xsb3dpbmcgdW50aWwgdGhlIHJlbWFpbmRlciBpcyBsZXNzIHRoYW4gb3RoZXI6ICBmaW5kIGFcbiAgICAvLyBmbG9hdGluZy1wb2ludCB0aGF0IGFwcHJveGltYXRlcyByZW1haW5kZXIgLyBvdGhlciAqZnJvbSBiZWxvdyosIGFkZCB0aGlzXG4gICAgLy8gaW50byB0aGUgcmVzdWx0LCBhbmQgc3VidHJhY3QgaXQgZnJvbSB0aGUgcmVtYWluZGVyLiAgSXQgaXMgY3JpdGljYWwgdGhhdFxuICAgIC8vIHRoZSBhcHByb3hpbWF0ZSB2YWx1ZSBpcyBsZXNzIHRoYW4gb3IgZXF1YWwgdG8gdGhlIHJlYWwgdmFsdWUgc28gdGhhdCB0aGVcbiAgICAvLyByZW1haW5kZXIgbmV2ZXIgYmVjb21lcyBuZWdhdGl2ZS5cbiAgXG4gIFxuICAgIHJlbSA9IHRoaXM7XG4gIFxuICAgIHdoaWxlIChyZW0uZ3RlKGRpdmlzb3IpKSB7XG4gICAgICAvLyBBcHByb3hpbWF0ZSB0aGUgcmVzdWx0IG9mIGRpdmlzaW9uLiBUaGlzIG1heSBiZSBhIGxpdHRsZSBncmVhdGVyIG9yXG4gICAgICAvLyBzbWFsbGVyIHRoYW4gdGhlIGFjdHVhbCB2YWx1ZS5cbiAgICAgIGFwcHJveCA9IE1hdGgubWF4KDEsIE1hdGguZmxvb3IocmVtLnRvTnVtYmVyKCkgLyBkaXZpc29yLnRvTnVtYmVyKCkpKTsgLy8gV2Ugd2lsbCB0d2VhayB0aGUgYXBwcm94aW1hdGUgcmVzdWx0IGJ5IGNoYW5naW5nIGl0IGluIHRoZSA0OC10aCBkaWdpdCBvclxuICAgICAgLy8gdGhlIHNtYWxsZXN0IG5vbi1mcmFjdGlvbmFsIGRpZ2l0LCB3aGljaGV2ZXIgaXMgbGFyZ2VyLlxuICBcbiAgICAgIHZhciBsb2cyID0gTWF0aC5jZWlsKE1hdGgubG9nKGFwcHJveCkgLyBNYXRoLkxOMiksXG4gICAgICAgICAgZGVsdGEgPSBsb2cyIDw9IDQ4ID8gMSA6IHBvd19kYmwoMiwgbG9nMiAtIDQ4KSxcbiAgICAgICAgICAvLyBEZWNyZWFzZSB0aGUgYXBwcm94aW1hdGlvbiB1bnRpbCBpdCBpcyBzbWFsbGVyIHRoYW4gdGhlIHJlbWFpbmRlci4gIE5vdGVcbiAgICAgIC8vIHRoYXQgaWYgaXQgaXMgdG9vIGxhcmdlLCB0aGUgcHJvZHVjdCBvdmVyZmxvd3MgYW5kIGlzIG5lZ2F0aXZlLlxuICAgICAgYXBwcm94UmVzID0gZnJvbU51bWJlcihhcHByb3gpLFxuICAgICAgICAgIGFwcHJveFJlbSA9IGFwcHJveFJlcy5tdWwoZGl2aXNvcik7XG4gIFxuICAgICAgd2hpbGUgKGFwcHJveFJlbS5pc05lZ2F0aXZlKCkgfHwgYXBwcm94UmVtLmd0KHJlbSkpIHtcbiAgICAgICAgYXBwcm94IC09IGRlbHRhO1xuICAgICAgICBhcHByb3hSZXMgPSBmcm9tTnVtYmVyKGFwcHJveCwgdGhpcy51bnNpZ25lZCk7XG4gICAgICAgIGFwcHJveFJlbSA9IGFwcHJveFJlcy5tdWwoZGl2aXNvcik7XG4gICAgICB9IC8vIFdlIGtub3cgdGhlIGFuc3dlciBjYW4ndCBiZSB6ZXJvLi4uIGFuZCBhY3R1YWxseSwgemVybyB3b3VsZCBjYXVzZVxuICAgICAgLy8gaW5maW5pdGUgcmVjdXJzaW9uIHNpbmNlIHdlIHdvdWxkIG1ha2Ugbm8gcHJvZ3Jlc3MuXG4gIFxuICBcbiAgICAgIGlmIChhcHByb3hSZXMuaXNaZXJvKCkpIGFwcHJveFJlcyA9IE9ORTtcbiAgICAgIHJlcyA9IHJlcy5hZGQoYXBwcm94UmVzKTtcbiAgICAgIHJlbSA9IHJlbS5zdWIoYXBwcm94UmVtKTtcbiAgICB9XG4gIFxuICAgIHJldHVybiByZXM7XG4gIH07XG4gIC8qKlxuICAgKiBSZXR1cm5zIHRoaXMgTG9uZyBkaXZpZGVkIGJ5IHRoZSBzcGVjaWZpZWQuIFRoaXMgaXMgYW4gYWxpYXMgb2Yge0BsaW5rIExvbmcjZGl2aWRlfS5cbiAgICogQGZ1bmN0aW9uXG4gICAqIEBwYXJhbSB7IUxvbmd8bnVtYmVyfHN0cmluZ30gZGl2aXNvciBEaXZpc29yXG4gICAqIEByZXR1cm5zIHshTG9uZ30gUXVvdGllbnRcbiAgICovXG4gIFxuICBcbiAgTG9uZ1Byb3RvdHlwZS5kaXYgPSBMb25nUHJvdG90eXBlLmRpdmlkZTtcbiAgLyoqXG4gICAqIFJldHVybnMgdGhpcyBMb25nIG1vZHVsbyB0aGUgc3BlY2lmaWVkLlxuICAgKiBAdGhpcyB7IUxvbmd9XG4gICAqIEBwYXJhbSB7IUxvbmd8bnVtYmVyfHN0cmluZ30gZGl2aXNvciBEaXZpc29yXG4gICAqIEByZXR1cm5zIHshTG9uZ30gUmVtYWluZGVyXG4gICAqL1xuICBcbiAgTG9uZ1Byb3RvdHlwZS5tb2R1bG8gPSBmdW5jdGlvbiBtb2R1bG8oZGl2aXNvcikge1xuICAgIGlmICghaXNMb25nKGRpdmlzb3IpKSBkaXZpc29yID0gZnJvbVZhbHVlKGRpdmlzb3IpOyAvLyB1c2Ugd2FzbSBzdXBwb3J0IGlmIHByZXNlbnRcbiAgXG4gICAgaWYgKHdhc20pIHtcbiAgICAgIHZhciBsb3cgPSAodGhpcy51bnNpZ25lZCA/IHdhc21bXCJyZW1fdVwiXSA6IHdhc21bXCJyZW1fc1wiXSkodGhpcy5sb3csIHRoaXMuaGlnaCwgZGl2aXNvci5sb3csIGRpdmlzb3IuaGlnaCk7XG4gICAgICByZXR1cm4gZnJvbUJpdHMobG93LCB3YXNtW1wiZ2V0X2hpZ2hcIl0oKSwgdGhpcy51bnNpZ25lZCk7XG4gICAgfVxuICBcbiAgICByZXR1cm4gdGhpcy5zdWIodGhpcy5kaXYoZGl2aXNvcikubXVsKGRpdmlzb3IpKTtcbiAgfTtcbiAgLyoqXG4gICAqIFJldHVybnMgdGhpcyBMb25nIG1vZHVsbyB0aGUgc3BlY2lmaWVkLiBUaGlzIGlzIGFuIGFsaWFzIG9mIHtAbGluayBMb25nI21vZHVsb30uXG4gICAqIEBmdW5jdGlvblxuICAgKiBAcGFyYW0geyFMb25nfG51bWJlcnxzdHJpbmd9IGRpdmlzb3IgRGl2aXNvclxuICAgKiBAcmV0dXJucyB7IUxvbmd9IFJlbWFpbmRlclxuICAgKi9cbiAgXG4gIFxuICBMb25nUHJvdG90eXBlLm1vZCA9IExvbmdQcm90b3R5cGUubW9kdWxvO1xuICAvKipcbiAgICogUmV0dXJucyB0aGlzIExvbmcgbW9kdWxvIHRoZSBzcGVjaWZpZWQuIFRoaXMgaXMgYW4gYWxpYXMgb2Yge0BsaW5rIExvbmcjbW9kdWxvfS5cbiAgICogQGZ1bmN0aW9uXG4gICAqIEBwYXJhbSB7IUxvbmd8bnVtYmVyfHN0cmluZ30gZGl2aXNvciBEaXZpc29yXG4gICAqIEByZXR1cm5zIHshTG9uZ30gUmVtYWluZGVyXG4gICAqL1xuICBcbiAgTG9uZ1Byb3RvdHlwZS5yZW0gPSBMb25nUHJvdG90eXBlLm1vZHVsbztcbiAgLyoqXG4gICAqIFJldHVybnMgdGhlIGJpdHdpc2UgTk9UIG9mIHRoaXMgTG9uZy5cbiAgICogQHRoaXMgeyFMb25nfVxuICAgKiBAcmV0dXJucyB7IUxvbmd9XG4gICAqL1xuICBcbiAgTG9uZ1Byb3RvdHlwZS5ub3QgPSBmdW5jdGlvbiBub3QoKSB7XG4gICAgcmV0dXJuIGZyb21CaXRzKH50aGlzLmxvdywgfnRoaXMuaGlnaCwgdGhpcy51bnNpZ25lZCk7XG4gIH07XG4gIC8qKlxuICAgKiBSZXR1cm5zIGNvdW50IGxlYWRpbmcgemVyb3Mgb2YgdGhpcyBMb25nLlxuICAgKiBAdGhpcyB7IUxvbmd9XG4gICAqIEByZXR1cm5zIHshbnVtYmVyfVxuICAgKi9cbiAgXG4gIFxuICBMb25nUHJvdG90eXBlLmNvdW50TGVhZGluZ1plcm9zID0gZnVuY3Rpb24gY291bnRMZWFkaW5nWmVyb3MoKSB7XG4gICAgcmV0dXJuIHRoaXMuaGlnaCA/IE1hdGguY2x6MzIodGhpcy5oaWdoKSA6IE1hdGguY2x6MzIodGhpcy5sb3cpICsgMzI7XG4gIH07XG4gIC8qKlxuICAgKiBSZXR1cm5zIGNvdW50IGxlYWRpbmcgemVyb3MuIFRoaXMgaXMgYW4gYWxpYXMgb2Yge0BsaW5rIExvbmcjY291bnRMZWFkaW5nWmVyb3N9LlxuICAgKiBAZnVuY3Rpb25cbiAgICogQHBhcmFtIHshTG9uZ31cbiAgICogQHJldHVybnMgeyFudW1iZXJ9XG4gICAqL1xuICBcbiAgXG4gIExvbmdQcm90b3R5cGUuY2x6ID0gTG9uZ1Byb3RvdHlwZS5jb3VudExlYWRpbmdaZXJvcztcbiAgLyoqXG4gICAqIFJldHVybnMgY291bnQgdHJhaWxpbmcgemVyb3Mgb2YgdGhpcyBMb25nLlxuICAgKiBAdGhpcyB7IUxvbmd9XG4gICAqIEByZXR1cm5zIHshbnVtYmVyfVxuICAgKi9cbiAgXG4gIExvbmdQcm90b3R5cGUuY291bnRUcmFpbGluZ1plcm9zID0gZnVuY3Rpb24gY291bnRUcmFpbGluZ1plcm9zKCkge1xuICAgIHJldHVybiB0aGlzLmxvdyA/IGN0ejMyKHRoaXMubG93KSA6IGN0ejMyKHRoaXMuaGlnaCkgKyAzMjtcbiAgfTtcbiAgLyoqXG4gICAqIFJldHVybnMgY291bnQgdHJhaWxpbmcgemVyb3MuIFRoaXMgaXMgYW4gYWxpYXMgb2Yge0BsaW5rIExvbmcjY291bnRUcmFpbGluZ1plcm9zfS5cbiAgICogQGZ1bmN0aW9uXG4gICAqIEBwYXJhbSB7IUxvbmd9XG4gICAqIEByZXR1cm5zIHshbnVtYmVyfVxuICAgKi9cbiAgXG4gIFxuICBMb25nUHJvdG90eXBlLmN0eiA9IExvbmdQcm90b3R5cGUuY291bnRUcmFpbGluZ1plcm9zO1xuICAvKipcbiAgICogUmV0dXJucyB0aGUgYml0d2lzZSBBTkQgb2YgdGhpcyBMb25nIGFuZCB0aGUgc3BlY2lmaWVkLlxuICAgKiBAdGhpcyB7IUxvbmd9XG4gICAqIEBwYXJhbSB7IUxvbmd8bnVtYmVyfHN0cmluZ30gb3RoZXIgT3RoZXIgTG9uZ1xuICAgKiBAcmV0dXJucyB7IUxvbmd9XG4gICAqL1xuICBcbiAgTG9uZ1Byb3RvdHlwZS5hbmQgPSBmdW5jdGlvbiBhbmQob3RoZXIpIHtcbiAgICBpZiAoIWlzTG9uZyhvdGhlcikpIG90aGVyID0gZnJvbVZhbHVlKG90aGVyKTtcbiAgICByZXR1cm4gZnJvbUJpdHModGhpcy5sb3cgJiBvdGhlci5sb3csIHRoaXMuaGlnaCAmIG90aGVyLmhpZ2gsIHRoaXMudW5zaWduZWQpO1xuICB9O1xuICAvKipcbiAgICogUmV0dXJucyB0aGUgYml0d2lzZSBPUiBvZiB0aGlzIExvbmcgYW5kIHRoZSBzcGVjaWZpZWQuXG4gICAqIEB0aGlzIHshTG9uZ31cbiAgICogQHBhcmFtIHshTG9uZ3xudW1iZXJ8c3RyaW5nfSBvdGhlciBPdGhlciBMb25nXG4gICAqIEByZXR1cm5zIHshTG9uZ31cbiAgICovXG4gIFxuICBcbiAgTG9uZ1Byb3RvdHlwZS5vciA9IGZ1bmN0aW9uIG9yKG90aGVyKSB7XG4gICAgaWYgKCFpc0xvbmcob3RoZXIpKSBvdGhlciA9IGZyb21WYWx1ZShvdGhlcik7XG4gICAgcmV0dXJuIGZyb21CaXRzKHRoaXMubG93IHwgb3RoZXIubG93LCB0aGlzLmhpZ2ggfCBvdGhlci5oaWdoLCB0aGlzLnVuc2lnbmVkKTtcbiAgfTtcbiAgLyoqXG4gICAqIFJldHVybnMgdGhlIGJpdHdpc2UgWE9SIG9mIHRoaXMgTG9uZyBhbmQgdGhlIGdpdmVuIG9uZS5cbiAgICogQHRoaXMgeyFMb25nfVxuICAgKiBAcGFyYW0geyFMb25nfG51bWJlcnxzdHJpbmd9IG90aGVyIE90aGVyIExvbmdcbiAgICogQHJldHVybnMgeyFMb25nfVxuICAgKi9cbiAgXG4gIFxuICBMb25nUHJvdG90eXBlLnhvciA9IGZ1bmN0aW9uIHhvcihvdGhlcikge1xuICAgIGlmICghaXNMb25nKG90aGVyKSkgb3RoZXIgPSBmcm9tVmFsdWUob3RoZXIpO1xuICAgIHJldHVybiBmcm9tQml0cyh0aGlzLmxvdyBeIG90aGVyLmxvdywgdGhpcy5oaWdoIF4gb3RoZXIuaGlnaCwgdGhpcy51bnNpZ25lZCk7XG4gIH07XG4gIC8qKlxuICAgKiBSZXR1cm5zIHRoaXMgTG9uZyB3aXRoIGJpdHMgc2hpZnRlZCB0byB0aGUgbGVmdCBieSB0aGUgZ2l2ZW4gYW1vdW50LlxuICAgKiBAdGhpcyB7IUxvbmd9XG4gICAqIEBwYXJhbSB7bnVtYmVyfCFMb25nfSBudW1CaXRzIE51bWJlciBvZiBiaXRzXG4gICAqIEByZXR1cm5zIHshTG9uZ30gU2hpZnRlZCBMb25nXG4gICAqL1xuICBcbiAgXG4gIExvbmdQcm90b3R5cGUuc2hpZnRMZWZ0ID0gZnVuY3Rpb24gc2hpZnRMZWZ0KG51bUJpdHMpIHtcbiAgICBpZiAoaXNMb25nKG51bUJpdHMpKSBudW1CaXRzID0gbnVtQml0cy50b0ludCgpO1xuICAgIGlmICgobnVtQml0cyAmPSA2MykgPT09IDApIHJldHVybiB0aGlzO2Vsc2UgaWYgKG51bUJpdHMgPCAzMikgcmV0dXJuIGZyb21CaXRzKHRoaXMubG93IDw8IG51bUJpdHMsIHRoaXMuaGlnaCA8PCBudW1CaXRzIHwgdGhpcy5sb3cgPj4+IDMyIC0gbnVtQml0cywgdGhpcy51bnNpZ25lZCk7ZWxzZSByZXR1cm4gZnJvbUJpdHMoMCwgdGhpcy5sb3cgPDwgbnVtQml0cyAtIDMyLCB0aGlzLnVuc2lnbmVkKTtcbiAgfTtcbiAgLyoqXG4gICAqIFJldHVybnMgdGhpcyBMb25nIHdpdGggYml0cyBzaGlmdGVkIHRvIHRoZSBsZWZ0IGJ5IHRoZSBnaXZlbiBhbW91bnQuIFRoaXMgaXMgYW4gYWxpYXMgb2Yge0BsaW5rIExvbmcjc2hpZnRMZWZ0fS5cbiAgICogQGZ1bmN0aW9uXG4gICAqIEBwYXJhbSB7bnVtYmVyfCFMb25nfSBudW1CaXRzIE51bWJlciBvZiBiaXRzXG4gICAqIEByZXR1cm5zIHshTG9uZ30gU2hpZnRlZCBMb25nXG4gICAqL1xuICBcbiAgXG4gIExvbmdQcm90b3R5cGUuc2hsID0gTG9uZ1Byb3RvdHlwZS5zaGlmdExlZnQ7XG4gIC8qKlxuICAgKiBSZXR1cm5zIHRoaXMgTG9uZyB3aXRoIGJpdHMgYXJpdGhtZXRpY2FsbHkgc2hpZnRlZCB0byB0aGUgcmlnaHQgYnkgdGhlIGdpdmVuIGFtb3VudC5cbiAgICogQHRoaXMgeyFMb25nfVxuICAgKiBAcGFyYW0ge251bWJlcnwhTG9uZ30gbnVtQml0cyBOdW1iZXIgb2YgYml0c1xuICAgKiBAcmV0dXJucyB7IUxvbmd9IFNoaWZ0ZWQgTG9uZ1xuICAgKi9cbiAgXG4gIExvbmdQcm90b3R5cGUuc2hpZnRSaWdodCA9IGZ1bmN0aW9uIHNoaWZ0UmlnaHQobnVtQml0cykge1xuICAgIGlmIChpc0xvbmcobnVtQml0cykpIG51bUJpdHMgPSBudW1CaXRzLnRvSW50KCk7XG4gICAgaWYgKChudW1CaXRzICY9IDYzKSA9PT0gMCkgcmV0dXJuIHRoaXM7ZWxzZSBpZiAobnVtQml0cyA8IDMyKSByZXR1cm4gZnJvbUJpdHModGhpcy5sb3cgPj4+IG51bUJpdHMgfCB0aGlzLmhpZ2ggPDwgMzIgLSBudW1CaXRzLCB0aGlzLmhpZ2ggPj4gbnVtQml0cywgdGhpcy51bnNpZ25lZCk7ZWxzZSByZXR1cm4gZnJvbUJpdHModGhpcy5oaWdoID4+IG51bUJpdHMgLSAzMiwgdGhpcy5oaWdoID49IDAgPyAwIDogLTEsIHRoaXMudW5zaWduZWQpO1xuICB9O1xuICAvKipcbiAgICogUmV0dXJucyB0aGlzIExvbmcgd2l0aCBiaXRzIGFyaXRobWV0aWNhbGx5IHNoaWZ0ZWQgdG8gdGhlIHJpZ2h0IGJ5IHRoZSBnaXZlbiBhbW91bnQuIFRoaXMgaXMgYW4gYWxpYXMgb2Yge0BsaW5rIExvbmcjc2hpZnRSaWdodH0uXG4gICAqIEBmdW5jdGlvblxuICAgKiBAcGFyYW0ge251bWJlcnwhTG9uZ30gbnVtQml0cyBOdW1iZXIgb2YgYml0c1xuICAgKiBAcmV0dXJucyB7IUxvbmd9IFNoaWZ0ZWQgTG9uZ1xuICAgKi9cbiAgXG4gIFxuICBMb25nUHJvdG90eXBlLnNociA9IExvbmdQcm90b3R5cGUuc2hpZnRSaWdodDtcbiAgLyoqXG4gICAqIFJldHVybnMgdGhpcyBMb25nIHdpdGggYml0cyBsb2dpY2FsbHkgc2hpZnRlZCB0byB0aGUgcmlnaHQgYnkgdGhlIGdpdmVuIGFtb3VudC5cbiAgICogQHRoaXMgeyFMb25nfVxuICAgKiBAcGFyYW0ge251bWJlcnwhTG9uZ30gbnVtQml0cyBOdW1iZXIgb2YgYml0c1xuICAgKiBAcmV0dXJucyB7IUxvbmd9IFNoaWZ0ZWQgTG9uZ1xuICAgKi9cbiAgXG4gIExvbmdQcm90b3R5cGUuc2hpZnRSaWdodFVuc2lnbmVkID0gZnVuY3Rpb24gc2hpZnRSaWdodFVuc2lnbmVkKG51bUJpdHMpIHtcbiAgICBpZiAoaXNMb25nKG51bUJpdHMpKSBudW1CaXRzID0gbnVtQml0cy50b0ludCgpO1xuICAgIGlmICgobnVtQml0cyAmPSA2MykgPT09IDApIHJldHVybiB0aGlzO1xuICAgIGlmIChudW1CaXRzIDwgMzIpIHJldHVybiBmcm9tQml0cyh0aGlzLmxvdyA+Pj4gbnVtQml0cyB8IHRoaXMuaGlnaCA8PCAzMiAtIG51bUJpdHMsIHRoaXMuaGlnaCA+Pj4gbnVtQml0cywgdGhpcy51bnNpZ25lZCk7XG4gICAgaWYgKG51bUJpdHMgPT09IDMyKSByZXR1cm4gZnJvbUJpdHModGhpcy5oaWdoLCAwLCB0aGlzLnVuc2lnbmVkKTtcbiAgICByZXR1cm4gZnJvbUJpdHModGhpcy5oaWdoID4+PiBudW1CaXRzIC0gMzIsIDAsIHRoaXMudW5zaWduZWQpO1xuICB9O1xuICAvKipcbiAgICogUmV0dXJucyB0aGlzIExvbmcgd2l0aCBiaXRzIGxvZ2ljYWxseSBzaGlmdGVkIHRvIHRoZSByaWdodCBieSB0aGUgZ2l2ZW4gYW1vdW50LiBUaGlzIGlzIGFuIGFsaWFzIG9mIHtAbGluayBMb25nI3NoaWZ0UmlnaHRVbnNpZ25lZH0uXG4gICAqIEBmdW5jdGlvblxuICAgKiBAcGFyYW0ge251bWJlcnwhTG9uZ30gbnVtQml0cyBOdW1iZXIgb2YgYml0c1xuICAgKiBAcmV0dXJucyB7IUxvbmd9IFNoaWZ0ZWQgTG9uZ1xuICAgKi9cbiAgXG4gIFxuICBMb25nUHJvdG90eXBlLnNocnUgPSBMb25nUHJvdG90eXBlLnNoaWZ0UmlnaHRVbnNpZ25lZDtcbiAgLyoqXG4gICAqIFJldHVybnMgdGhpcyBMb25nIHdpdGggYml0cyBsb2dpY2FsbHkgc2hpZnRlZCB0byB0aGUgcmlnaHQgYnkgdGhlIGdpdmVuIGFtb3VudC4gVGhpcyBpcyBhbiBhbGlhcyBvZiB7QGxpbmsgTG9uZyNzaGlmdFJpZ2h0VW5zaWduZWR9LlxuICAgKiBAZnVuY3Rpb25cbiAgICogQHBhcmFtIHtudW1iZXJ8IUxvbmd9IG51bUJpdHMgTnVtYmVyIG9mIGJpdHNcbiAgICogQHJldHVybnMgeyFMb25nfSBTaGlmdGVkIExvbmdcbiAgICovXG4gIFxuICBMb25nUHJvdG90eXBlLnNocl91ID0gTG9uZ1Byb3RvdHlwZS5zaGlmdFJpZ2h0VW5zaWduZWQ7XG4gIC8qKlxuICAgKiBSZXR1cm5zIHRoaXMgTG9uZyB3aXRoIGJpdHMgcm90YXRlZCB0byB0aGUgbGVmdCBieSB0aGUgZ2l2ZW4gYW1vdW50LlxuICAgKiBAdGhpcyB7IUxvbmd9XG4gICAqIEBwYXJhbSB7bnVtYmVyfCFMb25nfSBudW1CaXRzIE51bWJlciBvZiBiaXRzXG4gICAqIEByZXR1cm5zIHshTG9uZ30gUm90YXRlZCBMb25nXG4gICAqL1xuICBcbiAgTG9uZ1Byb3RvdHlwZS5yb3RhdGVMZWZ0ID0gZnVuY3Rpb24gcm90YXRlTGVmdChudW1CaXRzKSB7XG4gICAgdmFyIGI7XG4gICAgaWYgKGlzTG9uZyhudW1CaXRzKSkgbnVtQml0cyA9IG51bUJpdHMudG9JbnQoKTtcbiAgICBpZiAoKG51bUJpdHMgJj0gNjMpID09PSAwKSByZXR1cm4gdGhpcztcbiAgICBpZiAobnVtQml0cyA9PT0gMzIpIHJldHVybiBmcm9tQml0cyh0aGlzLmhpZ2gsIHRoaXMubG93LCB0aGlzLnVuc2lnbmVkKTtcbiAgXG4gICAgaWYgKG51bUJpdHMgPCAzMikge1xuICAgICAgYiA9IDMyIC0gbnVtQml0cztcbiAgICAgIHJldHVybiBmcm9tQml0cyh0aGlzLmxvdyA8PCBudW1CaXRzIHwgdGhpcy5oaWdoID4+PiBiLCB0aGlzLmhpZ2ggPDwgbnVtQml0cyB8IHRoaXMubG93ID4+PiBiLCB0aGlzLnVuc2lnbmVkKTtcbiAgICB9XG4gIFxuICAgIG51bUJpdHMgLT0gMzI7XG4gICAgYiA9IDMyIC0gbnVtQml0cztcbiAgICByZXR1cm4gZnJvbUJpdHModGhpcy5oaWdoIDw8IG51bUJpdHMgfCB0aGlzLmxvdyA+Pj4gYiwgdGhpcy5sb3cgPDwgbnVtQml0cyB8IHRoaXMuaGlnaCA+Pj4gYiwgdGhpcy51bnNpZ25lZCk7XG4gIH07XG4gIC8qKlxuICAgKiBSZXR1cm5zIHRoaXMgTG9uZyB3aXRoIGJpdHMgcm90YXRlZCB0byB0aGUgbGVmdCBieSB0aGUgZ2l2ZW4gYW1vdW50LiBUaGlzIGlzIGFuIGFsaWFzIG9mIHtAbGluayBMb25nI3JvdGF0ZUxlZnR9LlxuICAgKiBAZnVuY3Rpb25cbiAgICogQHBhcmFtIHtudW1iZXJ8IUxvbmd9IG51bUJpdHMgTnVtYmVyIG9mIGJpdHNcbiAgICogQHJldHVybnMgeyFMb25nfSBSb3RhdGVkIExvbmdcbiAgICovXG4gIFxuICBcbiAgTG9uZ1Byb3RvdHlwZS5yb3RsID0gTG9uZ1Byb3RvdHlwZS5yb3RhdGVMZWZ0O1xuICAvKipcbiAgICogUmV0dXJucyB0aGlzIExvbmcgd2l0aCBiaXRzIHJvdGF0ZWQgdG8gdGhlIHJpZ2h0IGJ5IHRoZSBnaXZlbiBhbW91bnQuXG4gICAqIEB0aGlzIHshTG9uZ31cbiAgICogQHBhcmFtIHtudW1iZXJ8IUxvbmd9IG51bUJpdHMgTnVtYmVyIG9mIGJpdHNcbiAgICogQHJldHVybnMgeyFMb25nfSBSb3RhdGVkIExvbmdcbiAgICovXG4gIFxuICBMb25nUHJvdG90eXBlLnJvdGF0ZVJpZ2h0ID0gZnVuY3Rpb24gcm90YXRlUmlnaHQobnVtQml0cykge1xuICAgIHZhciBiO1xuICAgIGlmIChpc0xvbmcobnVtQml0cykpIG51bUJpdHMgPSBudW1CaXRzLnRvSW50KCk7XG4gICAgaWYgKChudW1CaXRzICY9IDYzKSA9PT0gMCkgcmV0dXJuIHRoaXM7XG4gICAgaWYgKG51bUJpdHMgPT09IDMyKSByZXR1cm4gZnJvbUJpdHModGhpcy5oaWdoLCB0aGlzLmxvdywgdGhpcy51bnNpZ25lZCk7XG4gIFxuICAgIGlmIChudW1CaXRzIDwgMzIpIHtcbiAgICAgIGIgPSAzMiAtIG51bUJpdHM7XG4gICAgICByZXR1cm4gZnJvbUJpdHModGhpcy5oaWdoIDw8IGIgfCB0aGlzLmxvdyA+Pj4gbnVtQml0cywgdGhpcy5sb3cgPDwgYiB8IHRoaXMuaGlnaCA+Pj4gbnVtQml0cywgdGhpcy51bnNpZ25lZCk7XG4gICAgfVxuICBcbiAgICBudW1CaXRzIC09IDMyO1xuICAgIGIgPSAzMiAtIG51bUJpdHM7XG4gICAgcmV0dXJuIGZyb21CaXRzKHRoaXMubG93IDw8IGIgfCB0aGlzLmhpZ2ggPj4+IG51bUJpdHMsIHRoaXMuaGlnaCA8PCBiIHwgdGhpcy5sb3cgPj4+IG51bUJpdHMsIHRoaXMudW5zaWduZWQpO1xuICB9O1xuICAvKipcbiAgICogUmV0dXJucyB0aGlzIExvbmcgd2l0aCBiaXRzIHJvdGF0ZWQgdG8gdGhlIHJpZ2h0IGJ5IHRoZSBnaXZlbiBhbW91bnQuIFRoaXMgaXMgYW4gYWxpYXMgb2Yge0BsaW5rIExvbmcjcm90YXRlUmlnaHR9LlxuICAgKiBAZnVuY3Rpb25cbiAgICogQHBhcmFtIHtudW1iZXJ8IUxvbmd9IG51bUJpdHMgTnVtYmVyIG9mIGJpdHNcbiAgICogQHJldHVybnMgeyFMb25nfSBSb3RhdGVkIExvbmdcbiAgICovXG4gIFxuICBcbiAgTG9uZ1Byb3RvdHlwZS5yb3RyID0gTG9uZ1Byb3RvdHlwZS5yb3RhdGVSaWdodDtcbiAgLyoqXG4gICAqIENvbnZlcnRzIHRoaXMgTG9uZyB0byBzaWduZWQuXG4gICAqIEB0aGlzIHshTG9uZ31cbiAgICogQHJldHVybnMgeyFMb25nfSBTaWduZWQgbG9uZ1xuICAgKi9cbiAgXG4gIExvbmdQcm90b3R5cGUudG9TaWduZWQgPSBmdW5jdGlvbiB0b1NpZ25lZCgpIHtcbiAgICBpZiAoIXRoaXMudW5zaWduZWQpIHJldHVybiB0aGlzO1xuICAgIHJldHVybiBmcm9tQml0cyh0aGlzLmxvdywgdGhpcy5oaWdoLCBmYWxzZSk7XG4gIH07XG4gIC8qKlxuICAgKiBDb252ZXJ0cyB0aGlzIExvbmcgdG8gdW5zaWduZWQuXG4gICAqIEB0aGlzIHshTG9uZ31cbiAgICogQHJldHVybnMgeyFMb25nfSBVbnNpZ25lZCBsb25nXG4gICAqL1xuICBcbiAgXG4gIExvbmdQcm90b3R5cGUudG9VbnNpZ25lZCA9IGZ1bmN0aW9uIHRvVW5zaWduZWQoKSB7XG4gICAgaWYgKHRoaXMudW5zaWduZWQpIHJldHVybiB0aGlzO1xuICAgIHJldHVybiBmcm9tQml0cyh0aGlzLmxvdywgdGhpcy5oaWdoLCB0cnVlKTtcbiAgfTtcbiAgLyoqXG4gICAqIENvbnZlcnRzIHRoaXMgTG9uZyB0byBpdHMgYnl0ZSByZXByZXNlbnRhdGlvbi5cbiAgICogQHBhcmFtIHtib29sZWFuPX0gbGUgV2hldGhlciBsaXR0bGUgb3IgYmlnIGVuZGlhbiwgZGVmYXVsdHMgdG8gYmlnIGVuZGlhblxuICAgKiBAdGhpcyB7IUxvbmd9XG4gICAqIEByZXR1cm5zIHshQXJyYXkuPG51bWJlcj59IEJ5dGUgcmVwcmVzZW50YXRpb25cbiAgICovXG4gIFxuICBcbiAgTG9uZ1Byb3RvdHlwZS50b0J5dGVzID0gZnVuY3Rpb24gdG9CeXRlcyhsZSkge1xuICAgIHJldHVybiBsZSA/IHRoaXMudG9CeXRlc0xFKCkgOiB0aGlzLnRvQnl0ZXNCRSgpO1xuICB9O1xuICAvKipcbiAgICogQ29udmVydHMgdGhpcyBMb25nIHRvIGl0cyBsaXR0bGUgZW5kaWFuIGJ5dGUgcmVwcmVzZW50YXRpb24uXG4gICAqIEB0aGlzIHshTG9uZ31cbiAgICogQHJldHVybnMgeyFBcnJheS48bnVtYmVyPn0gTGl0dGxlIGVuZGlhbiBieXRlIHJlcHJlc2VudGF0aW9uXG4gICAqL1xuICBcbiAgXG4gIExvbmdQcm90b3R5cGUudG9CeXRlc0xFID0gZnVuY3Rpb24gdG9CeXRlc0xFKCkge1xuICAgIHZhciBoaSA9IHRoaXMuaGlnaCxcbiAgICAgICAgbG8gPSB0aGlzLmxvdztcbiAgICByZXR1cm4gW2xvICYgMHhmZiwgbG8gPj4+IDggJiAweGZmLCBsbyA+Pj4gMTYgJiAweGZmLCBsbyA+Pj4gMjQsIGhpICYgMHhmZiwgaGkgPj4+IDggJiAweGZmLCBoaSA+Pj4gMTYgJiAweGZmLCBoaSA+Pj4gMjRdO1xuICB9O1xuICAvKipcbiAgICogQ29udmVydHMgdGhpcyBMb25nIHRvIGl0cyBiaWcgZW5kaWFuIGJ5dGUgcmVwcmVzZW50YXRpb24uXG4gICAqIEB0aGlzIHshTG9uZ31cbiAgICogQHJldHVybnMgeyFBcnJheS48bnVtYmVyPn0gQmlnIGVuZGlhbiBieXRlIHJlcHJlc2VudGF0aW9uXG4gICAqL1xuICBcbiAgXG4gIExvbmdQcm90b3R5cGUudG9CeXRlc0JFID0gZnVuY3Rpb24gdG9CeXRlc0JFKCkge1xuICAgIHZhciBoaSA9IHRoaXMuaGlnaCxcbiAgICAgICAgbG8gPSB0aGlzLmxvdztcbiAgICByZXR1cm4gW2hpID4+PiAyNCwgaGkgPj4+IDE2ICYgMHhmZiwgaGkgPj4+IDggJiAweGZmLCBoaSAmIDB4ZmYsIGxvID4+PiAyNCwgbG8gPj4+IDE2ICYgMHhmZiwgbG8gPj4+IDggJiAweGZmLCBsbyAmIDB4ZmZdO1xuICB9O1xuICAvKipcbiAgICogQ3JlYXRlcyBhIExvbmcgZnJvbSBpdHMgYnl0ZSByZXByZXNlbnRhdGlvbi5cbiAgICogQHBhcmFtIHshQXJyYXkuPG51bWJlcj59IGJ5dGVzIEJ5dGUgcmVwcmVzZW50YXRpb25cbiAgICogQHBhcmFtIHtib29sZWFuPX0gdW5zaWduZWQgV2hldGhlciB1bnNpZ25lZCBvciBub3QsIGRlZmF1bHRzIHRvIHNpZ25lZFxuICAgKiBAcGFyYW0ge2Jvb2xlYW49fSBsZSBXaGV0aGVyIGxpdHRsZSBvciBiaWcgZW5kaWFuLCBkZWZhdWx0cyB0byBiaWcgZW5kaWFuXG4gICAqIEByZXR1cm5zIHtMb25nfSBUaGUgY29ycmVzcG9uZGluZyBMb25nIHZhbHVlXG4gICAqL1xuICBcbiAgXG4gIExvbmcuZnJvbUJ5dGVzID0gZnVuY3Rpb24gZnJvbUJ5dGVzKGJ5dGVzLCB1bnNpZ25lZCwgbGUpIHtcbiAgICByZXR1cm4gbGUgPyBMb25nLmZyb21CeXRlc0xFKGJ5dGVzLCB1bnNpZ25lZCkgOiBMb25nLmZyb21CeXRlc0JFKGJ5dGVzLCB1bnNpZ25lZCk7XG4gIH07XG4gIC8qKlxuICAgKiBDcmVhdGVzIGEgTG9uZyBmcm9tIGl0cyBsaXR0bGUgZW5kaWFuIGJ5dGUgcmVwcmVzZW50YXRpb24uXG4gICAqIEBwYXJhbSB7IUFycmF5LjxudW1iZXI+fSBieXRlcyBMaXR0bGUgZW5kaWFuIGJ5dGUgcmVwcmVzZW50YXRpb25cbiAgICogQHBhcmFtIHtib29sZWFuPX0gdW5zaWduZWQgV2hldGhlciB1bnNpZ25lZCBvciBub3QsIGRlZmF1bHRzIHRvIHNpZ25lZFxuICAgKiBAcmV0dXJucyB7TG9uZ30gVGhlIGNvcnJlc3BvbmRpbmcgTG9uZyB2YWx1ZVxuICAgKi9cbiAgXG4gIFxuICBMb25nLmZyb21CeXRlc0xFID0gZnVuY3Rpb24gZnJvbUJ5dGVzTEUoYnl0ZXMsIHVuc2lnbmVkKSB7XG4gICAgcmV0dXJuIG5ldyBMb25nKGJ5dGVzWzBdIHwgYnl0ZXNbMV0gPDwgOCB8IGJ5dGVzWzJdIDw8IDE2IHwgYnl0ZXNbM10gPDwgMjQsIGJ5dGVzWzRdIHwgYnl0ZXNbNV0gPDwgOCB8IGJ5dGVzWzZdIDw8IDE2IHwgYnl0ZXNbN10gPDwgMjQsIHVuc2lnbmVkKTtcbiAgfTtcbiAgLyoqXG4gICAqIENyZWF0ZXMgYSBMb25nIGZyb20gaXRzIGJpZyBlbmRpYW4gYnl0ZSByZXByZXNlbnRhdGlvbi5cbiAgICogQHBhcmFtIHshQXJyYXkuPG51bWJlcj59IGJ5dGVzIEJpZyBlbmRpYW4gYnl0ZSByZXByZXNlbnRhdGlvblxuICAgKiBAcGFyYW0ge2Jvb2xlYW49fSB1bnNpZ25lZCBXaGV0aGVyIHVuc2lnbmVkIG9yIG5vdCwgZGVmYXVsdHMgdG8gc2lnbmVkXG4gICAqIEByZXR1cm5zIHtMb25nfSBUaGUgY29ycmVzcG9uZGluZyBMb25nIHZhbHVlXG4gICAqL1xuICBcbiAgXG4gIExvbmcuZnJvbUJ5dGVzQkUgPSBmdW5jdGlvbiBmcm9tQnl0ZXNCRShieXRlcywgdW5zaWduZWQpIHtcbiAgICByZXR1cm4gbmV3IExvbmcoYnl0ZXNbNF0gPDwgMjQgfCBieXRlc1s1XSA8PCAxNiB8IGJ5dGVzWzZdIDw8IDggfCBieXRlc1s3XSwgYnl0ZXNbMF0gPDwgMjQgfCBieXRlc1sxXSA8PCAxNiB8IGJ5dGVzWzJdIDw8IDggfCBieXRlc1szXSwgdW5zaWduZWQpO1xuICB9O1xuICBcbiAgdmFyIF9kZWZhdWx0ID0gTG9uZztcbiAgZXhwb3J0cy5kZWZhdWx0ID0gX2RlZmF1bHQ7XG4gIHJldHVybiBcImRlZmF1bHRcIiBpbiBleHBvcnRzID8gZXhwb3J0cy5kZWZhdWx0IDogZXhwb3J0cztcbn0pKHt9KTtcbmlmICh0eXBlb2YgZGVmaW5lID09PSAnZnVuY3Rpb24nICYmIGRlZmluZS5hbWQpIGRlZmluZShbXSwgZnVuY3Rpb24oKSB7IHJldHVybiBMb25nOyB9KTtcbmVsc2UgaWYgKHR5cGVvZiBtb2R1bGUgPT09ICdvYmplY3QnICYmIHR5cGVvZiBleHBvcnRzID09PSAnb2JqZWN0JykgbW9kdWxlLmV4cG9ydHMgPSBMb25nO1xuIiwiXCJ1c2Ugc3RyaWN0XCI7dmFyIF89T2JqZWN0LmRlZmluZVByb3BlcnR5O3ZhciBQZT1PYmplY3QuZ2V0T3duUHJvcGVydHlEZXNjcmlwdG9yO3ZhciBSZT1PYmplY3QuZ2V0T3duUHJvcGVydHlOYW1lczt2YXIgU2U9T2JqZWN0LnByb3RvdHlwZS5oYXNPd25Qcm9wZXJ0eTt2YXIgQWU9KGUsdCk9Pntmb3IodmFyIHIgaW4gdClfKGUscix7Z2V0OnRbcl0sZW51bWVyYWJsZTohMH0pfSxOZT0oZSx0LHIsbik9PntpZih0JiZ0eXBlb2YgdD09XCJvYmplY3RcInx8dHlwZW9mIHQ9PVwiZnVuY3Rpb25cIilmb3IobGV0IHMgb2YgUmUodCkpIVNlLmNhbGwoZSxzKSYmcyE9PXImJl8oZSxzLHtnZXQ6KCk9PnRbc10sZW51bWVyYWJsZTohKG49UGUodCxzKSl8fG4uZW51bWVyYWJsZX0pO3JldHVybiBlfTt2YXIga2U9ZT0+TmUoXyh7fSxcIl9fZXNNb2R1bGVcIix7dmFsdWU6ITB9KSxlKTt2YXIgJGU9e307QWUoJGUse3BheWxvYWRDb252ZXJ0ZXI6KCk9PkZlfSk7bW9kdWxlLmV4cG9ydHM9a2UoJGUpO3ZhciBqPXJlcXVpcmUoXCJAdGVtcG9yYWxpby9jb21tb25cIik7dmFyIE09cmVxdWlyZShcIkB0ZW1wb3JhbGlvL2NvbW1vblwiKTt2YXIgaz1jbGFzc3tjb25zdHJ1Y3Rvcigpe3RoaXMua2V5VG9WYWx1ZT1uZXcgTWFwLHRoaXMudmFsdWVUb0tleT1uZXcgTWFwfXNldCh0LHIpe3RoaXMua2V5VG9WYWx1ZS5zZXQodCxyKSx0aGlzLnZhbHVlVG9LZXkuc2V0KHIsdCl9Z2V0QnlLZXkodCl7cmV0dXJuIHRoaXMua2V5VG9WYWx1ZS5nZXQodCl9Z2V0QnlWYWx1ZSh0KXtyZXR1cm4gdGhpcy52YWx1ZVRvS2V5LmdldCh0KX1jbGVhcigpe3RoaXMua2V5VG9WYWx1ZS5jbGVhcigpLHRoaXMudmFsdWVUb0tleS5jbGVhcigpfX07dmFyIGI9Y2xhc3N7Y29uc3RydWN0b3IodCl7dGhpcy5nZW5lcmF0ZUlkZW50aWZpZXI9dCx0aGlzLmt2PW5ldyBrfXJlZ2lzdGVyKHQscil7dGhpcy5rdi5nZXRCeVZhbHVlKHQpfHwocnx8KHI9dGhpcy5nZW5lcmF0ZUlkZW50aWZpZXIodCkpLHRoaXMua3Yuc2V0KHIsdCkpfWNsZWFyKCl7dGhpcy5rdi5jbGVhcigpfWdldElkZW50aWZpZXIodCl7cmV0dXJuIHRoaXMua3YuZ2V0QnlWYWx1ZSh0KX1nZXRWYWx1ZSh0KXtyZXR1cm4gdGhpcy5rdi5nZXRCeUtleSh0KX19O3ZhciBJPWNsYXNzIGV4dGVuZHMgYntjb25zdHJ1Y3Rvcigpe3N1cGVyKHQ9PnQubmFtZSksdGhpcy5jbGFzc1RvQWxsb3dlZFByb3BzPW5ldyBNYXB9cmVnaXN0ZXIodCxyKXt0eXBlb2Ygcj09XCJvYmplY3RcIj8oci5hbGxvd1Byb3BzJiZ0aGlzLmNsYXNzVG9BbGxvd2VkUHJvcHMuc2V0KHQsci5hbGxvd1Byb3BzKSxzdXBlci5yZWdpc3Rlcih0LHIuaWRlbnRpZmllcikpOnN1cGVyLnJlZ2lzdGVyKHQscil9Z2V0QWxsb3dlZFByb3BzKHQpe3JldHVybiB0aGlzLmNsYXNzVG9BbGxvd2VkUHJvcHMuZ2V0KHQpfX07ZnVuY3Rpb24gSWUoZSl7aWYoXCJ2YWx1ZXNcImluIE9iamVjdClyZXR1cm4gT2JqZWN0LnZhbHVlcyhlKTtsZXQgdD1bXTtmb3IobGV0IHIgaW4gZSllLmhhc093blByb3BlcnR5KHIpJiZ0LnB1c2goZVtyXSk7cmV0dXJuIHR9ZnVuY3Rpb24gWihlLHQpe2xldCByPUllKGUpO2lmKFwiZmluZFwiaW4gcilyZXR1cm4gci5maW5kKHQpO2xldCBuPXI7Zm9yKGxldCBzPTA7czxuLmxlbmd0aDtzKyspe2xldCBvPW5bc107aWYodChvKSlyZXR1cm4gb319ZnVuY3Rpb24gZyhlLHQpe09iamVjdC5lbnRyaWVzKGUpLmZvckVhY2goKFtyLG5dKT0+dChuLHIpKX1mdW5jdGlvbiBFKGUsdCl7cmV0dXJuIGUuaW5kZXhPZih0KSE9PS0xfWZ1bmN0aW9uIHEoZSx0KXtmb3IobGV0IHI9MDtyPGUubGVuZ3RoO3IrKyl7bGV0IG49ZVtyXTtpZih0KG4pKXJldHVybiBufX12YXIgVD1jbGFzc3tjb25zdHJ1Y3Rvcigpe3RoaXMudHJhbnNmb21lcnM9e319cmVnaXN0ZXIodCl7dGhpcy50cmFuc2ZvbWVyc1t0Lm5hbWVdPXR9ZmluZEFwcGxpY2FibGUodCl7cmV0dXJuIFoodGhpcy50cmFuc2ZvbWVycyxyPT5yLmlzQXBwbGljYWJsZSh0KSl9ZmluZEJ5TmFtZSh0KXtyZXR1cm4gdGhpcy50cmFuc2ZvbWVyc1t0XX19O3ZhciBUZT1lPT5PYmplY3QucHJvdG90eXBlLnRvU3RyaW5nLmNhbGwoZSkuc2xpY2UoOCwtMSksSz1lPT50eXBlb2YgZT5cInVcIix2ZT1lPT5lPT09bnVsbCxoPWU9PnR5cGVvZiBlIT1cIm9iamVjdFwifHxlPT09bnVsbHx8ZT09PU9iamVjdC5wcm90b3R5cGU/ITE6T2JqZWN0LmdldFByb3RvdHlwZU9mKGUpPT09bnVsbD8hMDpPYmplY3QuZ2V0UHJvdG90eXBlT2YoZSk9PT1PYmplY3QucHJvdG90eXBlLHY9ZT0+aChlKSYmT2JqZWN0LmtleXMoZSkubGVuZ3RoPT09MCxsPWU9PkFycmF5LmlzQXJyYXkoZSksVmU9ZT0+dHlwZW9mIGU9PVwic3RyaW5nXCIsVWU9ZT0+dHlwZW9mIGU9PVwibnVtYmVyXCImJiFpc05hTihlKSxDZT1lPT50eXBlb2YgZT09XCJib29sZWFuXCIsSj1lPT5lIGluc3RhbmNlb2YgUmVnRXhwLHk9ZT0+ZSBpbnN0YW5jZW9mIE1hcCxkPWU9PmUgaW5zdGFuY2VvZiBTZXQsRj1lPT5UZShlKT09PVwiU3ltYm9sXCIsZWU9ZT0+ZSBpbnN0YW5jZW9mIERhdGUmJiFpc05hTihlLnZhbHVlT2YoKSksdGU9ZT0+ZSBpbnN0YW5jZW9mIEVycm9yLCQ9ZT0+dHlwZW9mIGU9PVwibnVtYmVyXCImJmlzTmFOKGUpLHJlPWU9PkNlKGUpfHx2ZShlKXx8SyhlKXx8VWUoZSl8fFZlKGUpfHxGKGUpLG5lPWU9PnR5cGVvZiBlPT1cImJpZ2ludFwiLHNlPWU9PmU9PT0xLzB8fGU9PT0tMS8wLG9lPWU9PkFycmF5QnVmZmVyLmlzVmlldyhlKSYmIShlIGluc3RhbmNlb2YgRGF0YVZpZXcpLGllPWU9PmUgaW5zdGFuY2VvZiBVUkw7dmFyIEw9ZT0+ZS5yZXBsYWNlKC9cXC4vZyxcIlxcXFwuXCIpLFY9ZT0+ZS5tYXAoU3RyaW5nKS5tYXAoTCkuam9pbihcIi5cIiksTz1lPT57bGV0IHQ9W10scj1cIlwiO2ZvcihsZXQgcz0wO3M8ZS5sZW5ndGg7cysrKXtsZXQgbz1lLmNoYXJBdChzKTtpZihvPT09XCJcXFxcXCImJmUuY2hhckF0KHMrMSk9PT1cIi5cIil7cis9XCIuXCIscysrO2NvbnRpbnVlfWlmKG89PT1cIi5cIil7dC5wdXNoKHIpLHI9XCJcIjtjb250aW51ZX1yKz1vfWxldCBuPXI7cmV0dXJuIHQucHVzaChuKSx0fTtmdW5jdGlvbiBwKGUsdCxyLG4pe3JldHVybntpc0FwcGxpY2FibGU6ZSxhbm5vdGF0aW9uOnQsdHJhbnNmb3JtOnIsdW50cmFuc2Zvcm06bn19dmFyIGFlPVtwKEssXCJ1bmRlZmluZWRcIiwoKT0+bnVsbCwoKT0+e30pLHAobmUsXCJiaWdpbnRcIixlPT5lLnRvU3RyaW5nKCksZT0+dHlwZW9mIEJpZ0ludDxcInVcIj9CaWdJbnQoZSk6KGNvbnNvbGUuZXJyb3IoXCJQbGVhc2UgYWRkIGEgQmlnSW50IHBvbHlmaWxsLlwiKSxlKSkscChlZSxcIkRhdGVcIixlPT5lLnRvSVNPU3RyaW5nKCksZT0+bmV3IERhdGUoZSkpLHAodGUsXCJFcnJvclwiLChlLHQpPT57bGV0IHI9e25hbWU6ZS5uYW1lLG1lc3NhZ2U6ZS5tZXNzYWdlfTtyZXR1cm4gdC5hbGxvd2VkRXJyb3JQcm9wcy5mb3JFYWNoKG49PntyW25dPWVbbl19KSxyfSwoZSx0KT0+e2xldCByPW5ldyBFcnJvcihlLm1lc3NhZ2UpO3JldHVybiByLm5hbWU9ZS5uYW1lLHIuc3RhY2s9ZS5zdGFjayx0LmFsbG93ZWRFcnJvclByb3BzLmZvckVhY2gobj0+e3Jbbl09ZVtuXX0pLHJ9KSxwKEosXCJyZWdleHBcIixlPT5cIlwiK2UsZT0+e2xldCB0PWUuc2xpY2UoMSxlLmxhc3RJbmRleE9mKFwiL1wiKSkscj1lLnNsaWNlKGUubGFzdEluZGV4T2YoXCIvXCIpKzEpO3JldHVybiBuZXcgUmVnRXhwKHQscil9KSxwKGQsXCJzZXRcIixlPT5bLi4uZS52YWx1ZXMoKV0sZT0+bmV3IFNldChlKSkscCh5LFwibWFwXCIsZT0+Wy4uLmUuZW50cmllcygpXSxlPT5uZXcgTWFwKGUpKSxwKGU9PiQoZSl8fHNlKGUpLFwibnVtYmVyXCIsZT0+JChlKT9cIk5hTlwiOmU+MD9cIkluZmluaXR5XCI6XCItSW5maW5pdHlcIixOdW1iZXIpLHAoZT0+ZT09PTAmJjEvZT09PS0xLzAsXCJudW1iZXJcIiwoKT0+XCItMFwiLE51bWJlcikscChpZSxcIlVSTFwiLGU9PmUudG9TdHJpbmcoKSxlPT5uZXcgVVJMKGUpKV07ZnVuY3Rpb24gVShlLHQscixuKXtyZXR1cm57aXNBcHBsaWNhYmxlOmUsYW5ub3RhdGlvbjp0LHRyYW5zZm9ybTpyLHVudHJhbnNmb3JtOm59fXZhciB1ZT1VKChlLHQpPT5GKGUpPyEhdC5zeW1ib2xSZWdpc3RyeS5nZXRJZGVudGlmaWVyKGUpOiExLChlLHQpPT5bXCJzeW1ib2xcIix0LnN5bWJvbFJlZ2lzdHJ5LmdldElkZW50aWZpZXIoZSldLGU9PmUuZGVzY3JpcHRpb24sKGUsdCxyKT0+e2xldCBuPXIuc3ltYm9sUmVnaXN0cnkuZ2V0VmFsdWUodFsxXSk7aWYoIW4pdGhyb3cgbmV3IEVycm9yKFwiVHJ5aW5nIHRvIGRlc2VyaWFsaXplIHVua25vd24gc3ltYm9sXCIpO3JldHVybiBufSksemU9W0ludDhBcnJheSxVaW50OEFycmF5LEludDE2QXJyYXksVWludDE2QXJyYXksSW50MzJBcnJheSxVaW50MzJBcnJheSxGbG9hdDMyQXJyYXksRmxvYXQ2NEFycmF5LFVpbnQ4Q2xhbXBlZEFycmF5XS5yZWR1Y2UoKGUsdCk9PihlW3QubmFtZV09dCxlKSx7fSksY2U9VShvZSxlPT5bXCJ0eXBlZC1hcnJheVwiLGUuY29uc3RydWN0b3IubmFtZV0sZT0+Wy4uLmVdLChlLHQpPT57bGV0IHI9emVbdFsxXV07aWYoIXIpdGhyb3cgbmV3IEVycm9yKFwiVHJ5aW5nIHRvIGRlc2VyaWFsaXplIHVua25vd24gdHlwZWQgYXJyYXlcIik7cmV0dXJuIG5ldyByKGUpfSk7ZnVuY3Rpb24gVyhlLHQpe3JldHVybiBlPy5jb25zdHJ1Y3Rvcj8hIXQuY2xhc3NSZWdpc3RyeS5nZXRJZGVudGlmaWVyKGUuY29uc3RydWN0b3IpOiExfXZhciBmZT1VKFcsKGUsdCk9PltcImNsYXNzXCIsdC5jbGFzc1JlZ2lzdHJ5LmdldElkZW50aWZpZXIoZS5jb25zdHJ1Y3RvcildLChlLHQpPT57bGV0IHI9dC5jbGFzc1JlZ2lzdHJ5LmdldEFsbG93ZWRQcm9wcyhlLmNvbnN0cnVjdG9yKTtpZighcilyZXR1cm57Li4uZX07bGV0IG49e307cmV0dXJuIHIuZm9yRWFjaChzPT57bltzXT1lW3NdfSksbn0sKGUsdCxyKT0+e2xldCBuPXIuY2xhc3NSZWdpc3RyeS5nZXRWYWx1ZSh0WzFdKTtpZighbil0aHJvdyBuZXcgRXJyb3IoYFRyeWluZyB0byBkZXNlcmlhbGl6ZSB1bmtub3duIGNsYXNzICcke3RbMV19JyAtIGNoZWNrIGh0dHBzOi8vZ2l0aHViLmNvbS9ibGl0ei1qcy9zdXBlcmpzb24vaXNzdWVzLzExNiNpc3N1ZWNvbW1lbnQtNzczOTk2NTY0YCk7cmV0dXJuIE9iamVjdC5hc3NpZ24oT2JqZWN0LmNyZWF0ZShuLnByb3RvdHlwZSksZSl9KSxsZT1VKChlLHQpPT4hIXQuY3VzdG9tVHJhbnNmb3JtZXJSZWdpc3RyeS5maW5kQXBwbGljYWJsZShlKSwoZSx0KT0+W1wiY3VzdG9tXCIsdC5jdXN0b21UcmFuc2Zvcm1lclJlZ2lzdHJ5LmZpbmRBcHBsaWNhYmxlKGUpLm5hbWVdLChlLHQpPT50LmN1c3RvbVRyYW5zZm9ybWVyUmVnaXN0cnkuZmluZEFwcGxpY2FibGUoZSkuc2VyaWFsaXplKGUpLChlLHQscik9PntsZXQgbj1yLmN1c3RvbVRyYW5zZm9ybWVyUmVnaXN0cnkuZmluZEJ5TmFtZSh0WzFdKTtpZighbil0aHJvdyBuZXcgRXJyb3IoXCJUcnlpbmcgdG8gZGVzZXJpYWxpemUgdW5rbm93biBjdXN0b20gdmFsdWVcIik7cmV0dXJuIG4uZGVzZXJpYWxpemUoZSl9KSxCZT1bZmUsdWUsbGUsY2VdLEc9KGUsdCk9PntsZXQgcj1xKEJlLHM9PnMuaXNBcHBsaWNhYmxlKGUsdCkpO2lmKHIpcmV0dXJue3ZhbHVlOnIudHJhbnNmb3JtKGUsdCksdHlwZTpyLmFubm90YXRpb24oZSx0KX07bGV0IG49cShhZSxzPT5zLmlzQXBwbGljYWJsZShlLHQpKTtpZihuKXJldHVybnt2YWx1ZTpuLnRyYW5zZm9ybShlLHQpLHR5cGU6bi5hbm5vdGF0aW9ufX0scGU9e307YWUuZm9yRWFjaChlPT57cGVbZS5hbm5vdGF0aW9uXT1lfSk7dmFyIG1lPShlLHQscik9PntpZihsKHQpKXN3aXRjaCh0WzBdKXtjYXNlXCJzeW1ib2xcIjpyZXR1cm4gdWUudW50cmFuc2Zvcm0oZSx0LHIpO2Nhc2VcImNsYXNzXCI6cmV0dXJuIGZlLnVudHJhbnNmb3JtKGUsdCxyKTtjYXNlXCJjdXN0b21cIjpyZXR1cm4gbGUudW50cmFuc2Zvcm0oZSx0LHIpO2Nhc2VcInR5cGVkLWFycmF5XCI6cmV0dXJuIGNlLnVudHJhbnNmb3JtKGUsdCxyKTtkZWZhdWx0OnRocm93IG5ldyBFcnJvcihcIlVua25vd24gdHJhbnNmb3JtYXRpb246IFwiK3QpfWVsc2V7bGV0IG49cGVbdF07aWYoIW4pdGhyb3cgbmV3IEVycm9yKFwiVW5rbm93biB0cmFuc2Zvcm1hdGlvbjogXCIrdCk7cmV0dXJuIG4udW50cmFuc2Zvcm0oZSxyKX19O3ZhciB4PShlLHQpPT57aWYodD5lLnNpemUpdGhyb3cgbmV3IEVycm9yKFwiaW5kZXggb3V0IG9mIGJvdW5kc1wiKTtsZXQgcj1lLmtleXMoKTtmb3IoO3Q+MDspci5uZXh0KCksdC0tO3JldHVybiByLm5leHQoKS52YWx1ZX07ZnVuY3Rpb24geWUoZSl7aWYoRShlLFwiX19wcm90b19fXCIpKXRocm93IG5ldyBFcnJvcihcIl9fcHJvdG9fXyBpcyBub3QgYWxsb3dlZCBhcyBhIHByb3BlcnR5XCIpO2lmKEUoZSxcInByb3RvdHlwZVwiKSl0aHJvdyBuZXcgRXJyb3IoXCJwcm90b3R5cGUgaXMgbm90IGFsbG93ZWQgYXMgYSBwcm9wZXJ0eVwiKTtpZihFKGUsXCJjb25zdHJ1Y3RvclwiKSl0aHJvdyBuZXcgRXJyb3IoXCJjb25zdHJ1Y3RvciBpcyBub3QgYWxsb3dlZCBhcyBhIHByb3BlcnR5XCIpfXZhciBkZT0oZSx0KT0+e3llKHQpO2ZvcihsZXQgcj0wO3I8dC5sZW5ndGg7cisrKXtsZXQgbj10W3JdO2lmKGQoZSkpZT14KGUsK24pO2Vsc2UgaWYoeShlKSl7bGV0IHM9K24sbz0rdFsrK3JdPT0wP1wia2V5XCI6XCJ2YWx1ZVwiLGE9eChlLHMpO3N3aXRjaChvKXtjYXNlXCJrZXlcIjplPWE7YnJlYWs7Y2FzZVwidmFsdWVcIjplPWUuZ2V0KGEpO2JyZWFrfX1lbHNlIGU9ZVtuXX1yZXR1cm4gZX0sQz0oZSx0LHIpPT57aWYoeWUodCksdC5sZW5ndGg9PT0wKXJldHVybiByKGUpO2xldCBuPWU7Zm9yKGxldCBvPTA7bzx0Lmxlbmd0aC0xO28rKyl7bGV0IGE9dFtvXTtpZihsKG4pKXtsZXQgdT0rYTtuPW5bdV19ZWxzZSBpZihoKG4pKW49blthXTtlbHNlIGlmKGQobikpe2xldCB1PSthO249eChuLHUpfWVsc2UgaWYoeShuKSl7aWYobz09PXQubGVuZ3RoLTIpYnJlYWs7bGV0IGM9K2EsTj0rdFsrK29dPT0wP1wia2V5XCI6XCJ2YWx1ZVwiLHc9eChuLGMpO3N3aXRjaChOKXtjYXNlXCJrZXlcIjpuPXc7YnJlYWs7Y2FzZVwidmFsdWVcIjpuPW4uZ2V0KHcpO2JyZWFrfX19bGV0IHM9dFt0Lmxlbmd0aC0xXTtpZihsKG4pP25bK3NdPXIoblsrc10pOmgobikmJihuW3NdPXIobltzXSkpLGQobikpe2xldCBvPXgobiwrcyksYT1yKG8pO28hPT1hJiYobi5kZWxldGUobyksbi5hZGQoYSkpfWlmKHkobikpe2xldCBvPSt0W3QubGVuZ3RoLTJdLGE9eChuLG8pO3N3aXRjaCgrcz09MD9cImtleVwiOlwidmFsdWVcIil7Y2FzZVwia2V5XCI6e2xldCBjPXIoYSk7bi5zZXQoYyxuLmdldChhKSksYyE9PWEmJm4uZGVsZXRlKGEpO2JyZWFrfWNhc2VcInZhbHVlXCI6e24uc2V0KGEscihuLmdldChhKSkpO2JyZWFrfX19cmV0dXJuIGV9O2Z1bmN0aW9uIFkoZSx0LHI9W10pe2lmKCFlKXJldHVybjtpZighbChlKSl7ZyhlLChvLGEpPT5ZKG8sdCxbLi4uciwuLi5PKGEpXSkpO3JldHVybn1sZXRbbixzXT1lO3MmJmcocywobyxhKT0+e1kobyx0LFsuLi5yLC4uLk8oYSldKX0pLHQobixyKX1mdW5jdGlvbiBnZShlLHQscil7cmV0dXJuIFkodCwobixzKT0+e2U9QyhlLHMsbz0+bWUobyxuLHIpKX0pLGV9ZnVuY3Rpb24gaGUoZSx0KXtmdW5jdGlvbiByKG4scyl7bGV0IG89ZGUoZSxPKHMpKTtuLm1hcChPKS5mb3JFYWNoKGE9PntlPUMoZSxhLCgpPT5vKX0pfWlmKGwodCkpe2xldFtuLHNdPXQ7bi5mb3JFYWNoKG89PntlPUMoZSxPKG8pLCgpPT5lKX0pLHMmJmcocyxyKX1lbHNlIGcodCxyKTtyZXR1cm4gZX12YXIgRGU9KGUsdCk9PmgoZSl8fGwoZSl8fHkoZSl8fGQoZSl8fFcoZSx0KTtmdW5jdGlvbiBNZShlLHQscil7bGV0IG49ci5nZXQoZSk7bj9uLnB1c2godCk6ci5zZXQoZSxbdF0pfWZ1bmN0aW9uIHdlKGUsdCl7bGV0IHI9e30sbjtyZXR1cm4gZS5mb3JFYWNoKHM9PntpZihzLmxlbmd0aDw9MSlyZXR1cm47dHx8KHM9cy5tYXAodT0+dS5tYXAoU3RyaW5nKSkuc29ydCgodSxjKT0+dS5sZW5ndGgtYy5sZW5ndGgpKTtsZXRbbywuLi5hXT1zO28ubGVuZ3RoPT09MD9uPWEubWFwKFYpOnJbVihvKV09YS5tYXAoVil9KSxuP3Yocik/W25dOltuLHJdOnYocik/dm9pZCAwOnJ9dmFyIEg9KGUsdCxyLG4scz1bXSxvPVtdLGE9bmV3IE1hcCk9PntsZXQgdT1yZShlKTtpZighdSl7TWUoZSxzLHQpO2xldCBtPWEuZ2V0KGUpO2lmKG0pcmV0dXJuIG4/e3RyYW5zZm9ybWVkVmFsdWU6bnVsbH06bX1pZighRGUoZSxyKSl7bGV0IG09RyhlLHIpLGY9bT97dHJhbnNmb3JtZWRWYWx1ZTptLnZhbHVlLGFubm90YXRpb25zOlttLnR5cGVdfTp7dHJhbnNmb3JtZWRWYWx1ZTplfTtyZXR1cm4gdXx8YS5zZXQoZSxmKSxmfWlmKEUobyxlKSlyZXR1cm57dHJhbnNmb3JtZWRWYWx1ZTpudWxsfTtsZXQgYz1HKGUsciksTj1jPy52YWx1ZT8/ZSx3PWwoTik/W106e30sUj17fTtnKE4sKG0sZik9PntpZihmPT09XCJfX3Byb3RvX19cInx8Zj09PVwiY29uc3RydWN0b3JcInx8Zj09PVwicHJvdG90eXBlXCIpdGhyb3cgbmV3IEVycm9yKGBEZXRlY3RlZCBwcm9wZXJ0eSAke2Z9LiBUaGlzIGlzIGEgcHJvdG90eXBlIHBvbGx1dGlvbiByaXNrLCBwbGVhc2UgcmVtb3ZlIGl0IGZyb20geW91ciBvYmplY3QuYCk7bGV0IFM9SChtLHQscixuLFsuLi5zLGZdLFsuLi5vLGVdLGEpO3dbZl09Uy50cmFuc2Zvcm1lZFZhbHVlLGwoUy5hbm5vdGF0aW9ucyk/UltmXT1TLmFubm90YXRpb25zOmgoUy5hbm5vdGF0aW9ucykmJmcoUy5hbm5vdGF0aW9ucywoT2UseGUpPT57UltMKGYpK1wiLlwiK3hlXT1PZX0pfSk7bGV0IFg9dihSKT97dHJhbnNmb3JtZWRWYWx1ZTp3LGFubm90YXRpb25zOmM/W2MudHlwZV06dm9pZCAwfTp7dHJhbnNmb3JtZWRWYWx1ZTp3LGFubm90YXRpb25zOmM/W2MudHlwZSxSXTpSfTtyZXR1cm4gdXx8YS5zZXQoZSxYKSxYfTtmdW5jdGlvbiB6KGUpe3JldHVybiBPYmplY3QucHJvdG90eXBlLnRvU3RyaW5nLmNhbGwoZSkuc2xpY2UoOCwtMSl9ZnVuY3Rpb24gUShlKXtyZXR1cm4geihlKT09PVwiQXJyYXlcIn1mdW5jdGlvbiBiZShlKXtpZih6KGUpIT09XCJPYmplY3RcIilyZXR1cm4hMTtsZXQgdD1PYmplY3QuZ2V0UHJvdG90eXBlT2YoZSk7cmV0dXJuISF0JiZ0LmNvbnN0cnVjdG9yPT09T2JqZWN0JiZ0PT09T2JqZWN0LnByb3RvdHlwZX1mdW5jdGlvbiBqZShlKXtyZXR1cm4geihlKT09PVwiTnVsbFwifWZ1bmN0aW9uIF9lKGUsdCxyLG4scyl7cmV0dXJuIG89PmUobyl8fHQobyl8fCEhciYmcihvKXx8ISFuJiZuKG8pfHwhIXMmJnMobyl9ZnVuY3Rpb24gcWUoZSl7cmV0dXJuIHooZSk9PT1cIlVuZGVmaW5lZFwifXZhciBkdD1fZShqZSxxZSk7ZnVuY3Rpb24gS2UoZSx0LHIsbixzKXtsZXQgbz17fS5wcm9wZXJ0eUlzRW51bWVyYWJsZS5jYWxsKG4sdCk/XCJlbnVtZXJhYmxlXCI6XCJub25lbnVtZXJhYmxlXCI7bz09PVwiZW51bWVyYWJsZVwiJiYoZVt0XT1yKSxzJiZvPT09XCJub25lbnVtZXJhYmxlXCImJk9iamVjdC5kZWZpbmVQcm9wZXJ0eShlLHQse3ZhbHVlOnIsZW51bWVyYWJsZTohMSx3cml0YWJsZTohMCxjb25maWd1cmFibGU6ITB9KX1mdW5jdGlvbiBCKGUsdD17fSl7aWYoUShlKSlyZXR1cm4gZS5tYXAocz0+QihzLHQpKTtpZighYmUoZSkpcmV0dXJuIGU7bGV0IHI9T2JqZWN0LmdldE93blByb3BlcnR5TmFtZXMoZSksbj1PYmplY3QuZ2V0T3duUHJvcGVydHlTeW1ib2xzKGUpO3JldHVyblsuLi5yLC4uLm5dLnJlZHVjZSgocyxvKT0+e2lmKFEodC5wcm9wcykmJiF0LnByb3BzLmluY2x1ZGVzKG8pKXJldHVybiBzO2xldCBhPWVbb10sdT1CKGEsdCk7cmV0dXJuIEtlKHMsbyx1LGUsdC5ub25lbnVtZXJhYmxlKSxzfSx7fSl9dmFyIGk9Y2xhc3N7Y29uc3RydWN0b3Ioe2RlZHVwZTp0PSExfT17fSl7dGhpcy5jbGFzc1JlZ2lzdHJ5PW5ldyBJLHRoaXMuc3ltYm9sUmVnaXN0cnk9bmV3IGIocj0+ci5kZXNjcmlwdGlvbj8/XCJcIiksdGhpcy5jdXN0b21UcmFuc2Zvcm1lclJlZ2lzdHJ5PW5ldyBULHRoaXMuYWxsb3dlZEVycm9yUHJvcHM9W10sdGhpcy5kZWR1cGU9dH1zZXJpYWxpemUodCl7bGV0IHI9bmV3IE1hcCxuPUgodCxyLHRoaXMsdGhpcy5kZWR1cGUpLHM9e2pzb246bi50cmFuc2Zvcm1lZFZhbHVlfTtuLmFubm90YXRpb25zJiYocy5tZXRhPXsuLi5zLm1ldGEsdmFsdWVzOm4uYW5ub3RhdGlvbnN9KTtsZXQgbz13ZShyLHRoaXMuZGVkdXBlKTtyZXR1cm4gbyYmKHMubWV0YT17Li4ucy5tZXRhLHJlZmVyZW50aWFsRXF1YWxpdGllczpvfSksc31kZXNlcmlhbGl6ZSh0KXtsZXR7anNvbjpyLG1ldGE6bn09dCxzPUIocik7cmV0dXJuIG4/LnZhbHVlcyYmKHM9Z2UocyxuLnZhbHVlcyx0aGlzKSksbj8ucmVmZXJlbnRpYWxFcXVhbGl0aWVzJiYocz1oZShzLG4ucmVmZXJlbnRpYWxFcXVhbGl0aWVzKSksc31zdHJpbmdpZnkodCl7cmV0dXJuIEpTT04uc3RyaW5naWZ5KHRoaXMuc2VyaWFsaXplKHQpKX1wYXJzZSh0KXtyZXR1cm4gdGhpcy5kZXNlcmlhbGl6ZShKU09OLnBhcnNlKHQpKX1yZWdpc3RlckNsYXNzKHQscil7dGhpcy5jbGFzc1JlZ2lzdHJ5LnJlZ2lzdGVyKHQscil9cmVnaXN0ZXJTeW1ib2wodCxyKXt0aGlzLnN5bWJvbFJlZ2lzdHJ5LnJlZ2lzdGVyKHQscil9cmVnaXN0ZXJDdXN0b20odCxyKXt0aGlzLmN1c3RvbVRyYW5zZm9ybWVyUmVnaXN0cnkucmVnaXN0ZXIoe25hbWU6ciwuLi50fSl9YWxsb3dFcnJvclByb3BzKC4uLnQpe3RoaXMuYWxsb3dlZEVycm9yUHJvcHMucHVzaCguLi50KX19O2kuZGVmYXVsdEluc3RhbmNlPW5ldyBpO2kuc2VyaWFsaXplPWkuZGVmYXVsdEluc3RhbmNlLnNlcmlhbGl6ZS5iaW5kKGkuZGVmYXVsdEluc3RhbmNlKTtpLmRlc2VyaWFsaXplPWkuZGVmYXVsdEluc3RhbmNlLmRlc2VyaWFsaXplLmJpbmQoaS5kZWZhdWx0SW5zdGFuY2UpO2kuc3RyaW5naWZ5PWkuZGVmYXVsdEluc3RhbmNlLnN0cmluZ2lmeS5iaW5kKGkuZGVmYXVsdEluc3RhbmNlKTtpLnBhcnNlPWkuZGVmYXVsdEluc3RhbmNlLnBhcnNlLmJpbmQoaS5kZWZhdWx0SW5zdGFuY2UpO2kucmVnaXN0ZXJDbGFzcz1pLmRlZmF1bHRJbnN0YW5jZS5yZWdpc3RlckNsYXNzLmJpbmQoaS5kZWZhdWx0SW5zdGFuY2UpO2kucmVnaXN0ZXJTeW1ib2w9aS5kZWZhdWx0SW5zdGFuY2UucmVnaXN0ZXJTeW1ib2wuYmluZChpLmRlZmF1bHRJbnN0YW5jZSk7aS5yZWdpc3RlckN1c3RvbT1pLmRlZmF1bHRJbnN0YW5jZS5yZWdpc3RlckN1c3RvbS5iaW5kKGkuZGVmYXVsdEluc3RhbmNlKTtpLmFsbG93RXJyb3JQcm9wcz1pLmRlZmF1bHRJbnN0YW5jZS5hbGxvd0Vycm9yUHJvcHMuYmluZChpLmRlZmF1bHRJbnN0YW5jZSk7dmFyIFJ0PWkuc2VyaWFsaXplLFN0PWkuZGVzZXJpYWxpemUsQXQ9aS5zdHJpbmdpZnksTnQ9aS5wYXJzZSxrdD1pLnJlZ2lzdGVyQ2xhc3MsSXQ9aS5yZWdpc3RlckN1c3RvbSxUdD1pLnJlZ2lzdGVyU3ltYm9sLHZ0PWkuYWxsb3dFcnJvclByb3BzO3ZhciBQPXJlcXVpcmUoXCJAdGVtcG9yYWxpby9jb21tb24vbGliL2VuY29kaW5nXCIpLEQ9Y2xhc3N7ZW5jb2RpbmdUeXBlPVwianNvbi9wbGFpblwiO3RvUGF5bG9hZCh0KXtpZih0PT09dm9pZCAwKXJldHVybjtsZXQgcj1cIlwiO3RyeXtyPWkuc3RyaW5naWZ5KHQpfWNhdGNoKG4pe3Rocm93IG5ldyBBKGBDYW4ndCBydW4gU1VQRVJKU09OLnN0cmluZ2lmeSBvbiB0aGlzIHZhbHVlOiAke3R9LiBFaXRoZXIgY29udmVydCBpdCAob3IgaXRzIHByb3BlcnRpZXMpIHRvIFNVUEVSSlNPTi1zZXJpYWxpemFibGUgdmFsdWVzIChzZWUgaHR0cHM6Ly9naXRodWIuY29tL2ZsaWdodGNvbnRyb2xocS9zdXBlcmpzb24jcmVhZG1lICksIG9yIGNyZWF0ZSBhIGN1c3RvbSBkYXRhIGNvbnZlcnRlci4gU0pTT04uc3RyaW5naWZ5IGVycm9yIG1lc3NhZ2U6ICR7RWUobil9YCxuKX1yZXR1cm57bWV0YWRhdGE6e1tNLk1FVEFEQVRBX0VOQ09ESU5HX0tFWV06KDAsUC5lbmNvZGUpKFwianNvbi9wbGFpblwiKSxmb3JtYXQ6KDAsUC5lbmNvZGUpKFwiZXh0ZW5kZWRcIil9LGRhdGE6KDAsUC5lbmNvZGUpKHIpfX1mcm9tUGF5bG9hZCh0KXt0cnl7aWYoIXQuZGF0YSl0aHJvdyBuZXcgQShgQ2FuJ3QgcnVuIFNVUEVSSlNPTi5wYXJzZSBvbiB0aGlzIHZhbHVlOiAke3QuZGF0YX0uIEVpdGhlciBjb252ZXJ0IGl0IChvciBpdHMgcHJvcGVydGllcykgdG8gU1VQRVJKU09OLXNlcmlhbGl6YWJsZSB2YWx1ZXMgKHNlZSBodHRwczovL2dpdGh1Yi5jb20vZmxpZ2h0Y29udHJvbGhxL3N1cGVyanNvbiNyZWFkbWUgKSwgb3IgY3JlYXRlIGEgY3VzdG9tIGRhdGEgY29udmVydGVyLiBObyBkYXRhIGZvdW5kIGluIHBheWxvYWQuYCk7cmV0dXJuIGkucGFyc2UoKDAsUC5kZWNvZGUpKHQuZGF0YSkpfWNhdGNoKHIpe3Rocm93IG5ldyBBKGBDYW4ndCBydW4gU1VQRVJKU09OLnBhcnNlIG9uIHRoaXMgdmFsdWU6ICR7dC5kYXRhfS4gRWl0aGVyIGNvbnZlcnQgaXQgKG9yIGl0cyBwcm9wZXJ0aWVzKSB0byBTVVBFUkpTT04tc2VyaWFsaXphYmxlIHZhbHVlcyAoc2VlIGh0dHBzOi8vZ2l0aHViLmNvbS9mbGlnaHRjb250cm9saHEvc3VwZXJqc29uI3JlYWRtZSApLCBvciBjcmVhdGUgYSBjdXN0b20gZGF0YSBjb252ZXJ0ZXIuIFNKU09OLnBhcnNlIGVycm9yIG1lc3NhZ2U6ICR7RWUocil9YCxyKX19fSxBPWNsYXNzIGV4dGVuZHMgTS5QYXlsb2FkQ29udmVydGVyRXJyb3J7Y29uc3RydWN0b3IocixuKXtzdXBlcihyPz92b2lkIDApO3RoaXMuY2F1c2U9bn1uYW1lPVwiVW5zdXBwb3J0ZWRKc29uVHlwZUVycm9yXCJ9O2Z1bmN0aW9uIEVlKGUpe2lmKHR5cGVvZiBlPT1cInN0cmluZ1wiKXJldHVybiBlO2lmKGUgaW5zdGFuY2VvZiBFcnJvcilyZXR1cm4gZS5tZXNzYWdlfXZhciBGZT1uZXcgai5Db21wb3NpdGVQYXlsb2FkQ29udmVydGVyKG5ldyBqLlVuZGVmaW5lZFBheWxvYWRDb252ZXJ0ZXIsbmV3IEQpOzAmJihtb2R1bGUuZXhwb3J0cz17cGF5bG9hZENvbnZlcnRlcn0pO1xuIiwiaW1wb3J0IHsgaXNBcnJheSwgaXNQbGFpbk9iamVjdCB9IGZyb20gJ2lzLXdoYXQnO1xuXG5mdW5jdGlvbiBhc3NpZ25Qcm9wKGNhcnJ5LCBrZXksIG5ld1ZhbCwgb3JpZ2luYWxPYmplY3QsIGluY2x1ZGVOb25lbnVtZXJhYmxlKSB7XG4gIGNvbnN0IHByb3BUeXBlID0ge30ucHJvcGVydHlJc0VudW1lcmFibGUuY2FsbChvcmlnaW5hbE9iamVjdCwga2V5KSA/IFwiZW51bWVyYWJsZVwiIDogXCJub25lbnVtZXJhYmxlXCI7XG4gIGlmIChwcm9wVHlwZSA9PT0gXCJlbnVtZXJhYmxlXCIpXG4gICAgY2Fycnlba2V5XSA9IG5ld1ZhbDtcbiAgaWYgKGluY2x1ZGVOb25lbnVtZXJhYmxlICYmIHByb3BUeXBlID09PSBcIm5vbmVudW1lcmFibGVcIikge1xuICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eShjYXJyeSwga2V5LCB7XG4gICAgICB2YWx1ZTogbmV3VmFsLFxuICAgICAgZW51bWVyYWJsZTogZmFsc2UsXG4gICAgICB3cml0YWJsZTogdHJ1ZSxcbiAgICAgIGNvbmZpZ3VyYWJsZTogdHJ1ZVxuICAgIH0pO1xuICB9XG59XG5mdW5jdGlvbiBjb3B5KHRhcmdldCwgb3B0aW9ucyA9IHt9KSB7XG4gIGlmIChpc0FycmF5KHRhcmdldCkpIHtcbiAgICByZXR1cm4gdGFyZ2V0Lm1hcCgoaXRlbSkgPT4gY29weShpdGVtLCBvcHRpb25zKSk7XG4gIH1cbiAgaWYgKCFpc1BsYWluT2JqZWN0KHRhcmdldCkpIHtcbiAgICByZXR1cm4gdGFyZ2V0O1xuICB9XG4gIGNvbnN0IHByb3BzID0gT2JqZWN0LmdldE93blByb3BlcnR5TmFtZXModGFyZ2V0KTtcbiAgY29uc3Qgc3ltYm9scyA9IE9iamVjdC5nZXRPd25Qcm9wZXJ0eVN5bWJvbHModGFyZ2V0KTtcbiAgcmV0dXJuIFsuLi5wcm9wcywgLi4uc3ltYm9sc10ucmVkdWNlKChjYXJyeSwga2V5KSA9PiB7XG4gICAgaWYgKGlzQXJyYXkob3B0aW9ucy5wcm9wcykgJiYgIW9wdGlvbnMucHJvcHMuaW5jbHVkZXMoa2V5KSkge1xuICAgICAgcmV0dXJuIGNhcnJ5O1xuICAgIH1cbiAgICBjb25zdCB2YWwgPSB0YXJnZXRba2V5XTtcbiAgICBjb25zdCBuZXdWYWwgPSBjb3B5KHZhbCwgb3B0aW9ucyk7XG4gICAgYXNzaWduUHJvcChjYXJyeSwga2V5LCBuZXdWYWwsIHRhcmdldCwgb3B0aW9ucy5ub25lbnVtZXJhYmxlKTtcbiAgICByZXR1cm4gY2Fycnk7XG4gIH0sIHt9KTtcbn1cblxuZXhwb3J0IHsgY29weSB9O1xuIiwiZnVuY3Rpb24gZ2V0VHlwZShwYXlsb2FkKSB7XG4gIHJldHVybiBPYmplY3QucHJvdG90eXBlLnRvU3RyaW5nLmNhbGwocGF5bG9hZCkuc2xpY2UoOCwgLTEpO1xufVxuXG5mdW5jdGlvbiBpc0FueU9iamVjdChwYXlsb2FkKSB7XG4gIHJldHVybiBnZXRUeXBlKHBheWxvYWQpID09PSBcIk9iamVjdFwiO1xufVxuXG5mdW5jdGlvbiBpc0FycmF5KHBheWxvYWQpIHtcbiAgcmV0dXJuIGdldFR5cGUocGF5bG9hZCkgPT09IFwiQXJyYXlcIjtcbn1cblxuZnVuY3Rpb24gaXNCbG9iKHBheWxvYWQpIHtcbiAgcmV0dXJuIGdldFR5cGUocGF5bG9hZCkgPT09IFwiQmxvYlwiO1xufVxuXG5mdW5jdGlvbiBpc0Jvb2xlYW4ocGF5bG9hZCkge1xuICByZXR1cm4gZ2V0VHlwZShwYXlsb2FkKSA9PT0gXCJCb29sZWFuXCI7XG59XG5cbmZ1bmN0aW9uIGlzRGF0ZShwYXlsb2FkKSB7XG4gIHJldHVybiBnZXRUeXBlKHBheWxvYWQpID09PSBcIkRhdGVcIiAmJiAhaXNOYU4ocGF5bG9hZCk7XG59XG5cbmZ1bmN0aW9uIGlzRW1wdHlBcnJheShwYXlsb2FkKSB7XG4gIHJldHVybiBpc0FycmF5KHBheWxvYWQpICYmIHBheWxvYWQubGVuZ3RoID09PSAwO1xufVxuXG5mdW5jdGlvbiBpc1BsYWluT2JqZWN0KHBheWxvYWQpIHtcbiAgaWYgKGdldFR5cGUocGF5bG9hZCkgIT09IFwiT2JqZWN0XCIpXG4gICAgcmV0dXJuIGZhbHNlO1xuICBjb25zdCBwcm90b3R5cGUgPSBPYmplY3QuZ2V0UHJvdG90eXBlT2YocGF5bG9hZCk7XG4gIHJldHVybiAhIXByb3RvdHlwZSAmJiBwcm90b3R5cGUuY29uc3RydWN0b3IgPT09IE9iamVjdCAmJiBwcm90b3R5cGUgPT09IE9iamVjdC5wcm90b3R5cGU7XG59XG5cbmZ1bmN0aW9uIGlzRW1wdHlPYmplY3QocGF5bG9hZCkge1xuICByZXR1cm4gaXNQbGFpbk9iamVjdChwYXlsb2FkKSAmJiBPYmplY3Qua2V5cyhwYXlsb2FkKS5sZW5ndGggPT09IDA7XG59XG5cbmZ1bmN0aW9uIGlzRW1wdHlTdHJpbmcocGF5bG9hZCkge1xuICByZXR1cm4gcGF5bG9hZCA9PT0gXCJcIjtcbn1cblxuZnVuY3Rpb24gaXNFcnJvcihwYXlsb2FkKSB7XG4gIHJldHVybiBnZXRUeXBlKHBheWxvYWQpID09PSBcIkVycm9yXCIgfHwgcGF5bG9hZCBpbnN0YW5jZW9mIEVycm9yO1xufVxuXG5mdW5jdGlvbiBpc0ZpbGUocGF5bG9hZCkge1xuICByZXR1cm4gZ2V0VHlwZShwYXlsb2FkKSA9PT0gXCJGaWxlXCI7XG59XG5cbmZ1bmN0aW9uIGlzRnVsbEFycmF5KHBheWxvYWQpIHtcbiAgcmV0dXJuIGlzQXJyYXkocGF5bG9hZCkgJiYgcGF5bG9hZC5sZW5ndGggPiAwO1xufVxuXG5mdW5jdGlvbiBpc0Z1bGxPYmplY3QocGF5bG9hZCkge1xuICByZXR1cm4gaXNQbGFpbk9iamVjdChwYXlsb2FkKSAmJiBPYmplY3Qua2V5cyhwYXlsb2FkKS5sZW5ndGggPiAwO1xufVxuXG5mdW5jdGlvbiBpc1N0cmluZyhwYXlsb2FkKSB7XG4gIHJldHVybiBnZXRUeXBlKHBheWxvYWQpID09PSBcIlN0cmluZ1wiO1xufVxuXG5mdW5jdGlvbiBpc0Z1bGxTdHJpbmcocGF5bG9hZCkge1xuICByZXR1cm4gaXNTdHJpbmcocGF5bG9hZCkgJiYgcGF5bG9hZCAhPT0gXCJcIjtcbn1cblxuZnVuY3Rpb24gaXNGdW5jdGlvbihwYXlsb2FkKSB7XG4gIHJldHVybiB0eXBlb2YgcGF5bG9hZCA9PT0gXCJmdW5jdGlvblwiO1xufVxuXG5mdW5jdGlvbiBpc1R5cGUocGF5bG9hZCwgdHlwZSkge1xuICBpZiAoISh0eXBlIGluc3RhbmNlb2YgRnVuY3Rpb24pKSB7XG4gICAgdGhyb3cgbmV3IFR5cGVFcnJvcihcIlR5cGUgbXVzdCBiZSBhIGZ1bmN0aW9uXCIpO1xuICB9XG4gIGlmICghT2JqZWN0LnByb3RvdHlwZS5oYXNPd25Qcm9wZXJ0eS5jYWxsKHR5cGUsIFwicHJvdG90eXBlXCIpKSB7XG4gICAgdGhyb3cgbmV3IFR5cGVFcnJvcihcIlR5cGUgaXMgbm90IGEgY2xhc3NcIik7XG4gIH1cbiAgY29uc3QgbmFtZSA9IHR5cGUubmFtZTtcbiAgcmV0dXJuIGdldFR5cGUocGF5bG9hZCkgPT09IG5hbWUgfHwgQm9vbGVhbihwYXlsb2FkICYmIHBheWxvYWQuY29uc3RydWN0b3IgPT09IHR5cGUpO1xufVxuXG5mdW5jdGlvbiBpc0luc3RhbmNlT2YodmFsdWUsIGNsYXNzT3JDbGFzc05hbWUpIHtcbiAgaWYgKHR5cGVvZiBjbGFzc09yQ2xhc3NOYW1lID09PSBcImZ1bmN0aW9uXCIpIHtcbiAgICBmb3IgKGxldCBwID0gdmFsdWU7IHA7IHAgPSBPYmplY3QuZ2V0UHJvdG90eXBlT2YocCkpIHtcbiAgICAgIGlmIChpc1R5cGUocCwgY2xhc3NPckNsYXNzTmFtZSkpIHtcbiAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgICB9XG4gICAgfVxuICAgIHJldHVybiBmYWxzZTtcbiAgfSBlbHNlIHtcbiAgICBmb3IgKGxldCBwID0gdmFsdWU7IHA7IHAgPSBPYmplY3QuZ2V0UHJvdG90eXBlT2YocCkpIHtcbiAgICAgIGlmIChnZXRUeXBlKHApID09PSBjbGFzc09yQ2xhc3NOYW1lKSB7XG4gICAgICAgIHJldHVybiB0cnVlO1xuICAgICAgfVxuICAgIH1cbiAgICByZXR1cm4gZmFsc2U7XG4gIH1cbn1cblxuZnVuY3Rpb24gaXNNYXAocGF5bG9hZCkge1xuICByZXR1cm4gZ2V0VHlwZShwYXlsb2FkKSA9PT0gXCJNYXBcIjtcbn1cblxuZnVuY3Rpb24gaXNOYU5WYWx1ZShwYXlsb2FkKSB7XG4gIHJldHVybiBnZXRUeXBlKHBheWxvYWQpID09PSBcIk51bWJlclwiICYmIGlzTmFOKHBheWxvYWQpO1xufVxuXG5mdW5jdGlvbiBpc051bWJlcihwYXlsb2FkKSB7XG4gIHJldHVybiBnZXRUeXBlKHBheWxvYWQpID09PSBcIk51bWJlclwiICYmICFpc05hTihwYXlsb2FkKTtcbn1cblxuZnVuY3Rpb24gaXNOZWdhdGl2ZU51bWJlcihwYXlsb2FkKSB7XG4gIHJldHVybiBpc051bWJlcihwYXlsb2FkKSAmJiBwYXlsb2FkIDwgMDtcbn1cblxuZnVuY3Rpb24gaXNOdWxsKHBheWxvYWQpIHtcbiAgcmV0dXJuIGdldFR5cGUocGF5bG9hZCkgPT09IFwiTnVsbFwiO1xufVxuXG5mdW5jdGlvbiBpc09uZU9mKGEsIGIsIGMsIGQsIGUpIHtcbiAgcmV0dXJuICh2YWx1ZSkgPT4gYSh2YWx1ZSkgfHwgYih2YWx1ZSkgfHwgISFjICYmIGModmFsdWUpIHx8ICEhZCAmJiBkKHZhbHVlKSB8fCAhIWUgJiYgZSh2YWx1ZSk7XG59XG5cbmZ1bmN0aW9uIGlzVW5kZWZpbmVkKHBheWxvYWQpIHtcbiAgcmV0dXJuIGdldFR5cGUocGF5bG9hZCkgPT09IFwiVW5kZWZpbmVkXCI7XG59XG5cbmNvbnN0IGlzTnVsbE9yVW5kZWZpbmVkID0gaXNPbmVPZihpc051bGwsIGlzVW5kZWZpbmVkKTtcblxuZnVuY3Rpb24gaXNPYmplY3QocGF5bG9hZCkge1xuICByZXR1cm4gaXNQbGFpbk9iamVjdChwYXlsb2FkKTtcbn1cblxuZnVuY3Rpb24gaXNPYmplY3RMaWtlKHBheWxvYWQpIHtcbiAgcmV0dXJuIGlzQW55T2JqZWN0KHBheWxvYWQpO1xufVxuXG5mdW5jdGlvbiBpc1Bvc2l0aXZlTnVtYmVyKHBheWxvYWQpIHtcbiAgcmV0dXJuIGlzTnVtYmVyKHBheWxvYWQpICYmIHBheWxvYWQgPiAwO1xufVxuXG5mdW5jdGlvbiBpc1N5bWJvbChwYXlsb2FkKSB7XG4gIHJldHVybiBnZXRUeXBlKHBheWxvYWQpID09PSBcIlN5bWJvbFwiO1xufVxuXG5mdW5jdGlvbiBpc1ByaW1pdGl2ZShwYXlsb2FkKSB7XG4gIHJldHVybiBpc0Jvb2xlYW4ocGF5bG9hZCkgfHwgaXNOdWxsKHBheWxvYWQpIHx8IGlzVW5kZWZpbmVkKHBheWxvYWQpIHx8IGlzTnVtYmVyKHBheWxvYWQpIHx8IGlzU3RyaW5nKHBheWxvYWQpIHx8IGlzU3ltYm9sKHBheWxvYWQpO1xufVxuXG5mdW5jdGlvbiBpc1Byb21pc2UocGF5bG9hZCkge1xuICByZXR1cm4gZ2V0VHlwZShwYXlsb2FkKSA9PT0gXCJQcm9taXNlXCI7XG59XG5cbmZ1bmN0aW9uIGlzUmVnRXhwKHBheWxvYWQpIHtcbiAgcmV0dXJuIGdldFR5cGUocGF5bG9hZCkgPT09IFwiUmVnRXhwXCI7XG59XG5cbmZ1bmN0aW9uIGlzU2V0KHBheWxvYWQpIHtcbiAgcmV0dXJuIGdldFR5cGUocGF5bG9hZCkgPT09IFwiU2V0XCI7XG59XG5cbmZ1bmN0aW9uIGlzV2Vha01hcChwYXlsb2FkKSB7XG4gIHJldHVybiBnZXRUeXBlKHBheWxvYWQpID09PSBcIldlYWtNYXBcIjtcbn1cblxuZnVuY3Rpb24gaXNXZWFrU2V0KHBheWxvYWQpIHtcbiAgcmV0dXJuIGdldFR5cGUocGF5bG9hZCkgPT09IFwiV2Vha1NldFwiO1xufVxuXG5leHBvcnQgeyBnZXRUeXBlLCBpc0FueU9iamVjdCwgaXNBcnJheSwgaXNCbG9iLCBpc0Jvb2xlYW4sIGlzRGF0ZSwgaXNFbXB0eUFycmF5LCBpc0VtcHR5T2JqZWN0LCBpc0VtcHR5U3RyaW5nLCBpc0Vycm9yLCBpc0ZpbGUsIGlzRnVsbEFycmF5LCBpc0Z1bGxPYmplY3QsIGlzRnVsbFN0cmluZywgaXNGdW5jdGlvbiwgaXNJbnN0YW5jZU9mLCBpc01hcCwgaXNOYU5WYWx1ZSwgaXNOZWdhdGl2ZU51bWJlciwgaXNOdWxsLCBpc051bGxPclVuZGVmaW5lZCwgaXNOdW1iZXIsIGlzT2JqZWN0LCBpc09iamVjdExpa2UsIGlzT25lT2YsIGlzUGxhaW5PYmplY3QsIGlzUG9zaXRpdmVOdW1iZXIsIGlzUHJpbWl0aXZlLCBpc1Byb21pc2UsIGlzUmVnRXhwLCBpc1NldCwgaXNTdHJpbmcsIGlzU3ltYm9sLCBpc1R5cGUsIGlzVW5kZWZpbmVkLCBpc1dlYWtNYXAsIGlzV2Vha1NldCB9O1xuIixudWxsLG51bGwsbnVsbCxudWxsLG51bGwsbnVsbCxudWxsLG51bGwsbnVsbCxudWxsLG51bGwsImltcG9ydCB0eXBlIHsgRXJyb3JUeXBlIH0gZnJvbSAnLi4vLi4vZXJyb3JzL3V0aWxzLmpzJ1xuaW1wb3J0IHR5cGUgeyBIZXggfSBmcm9tICcuLi8uLi90eXBlcy9taXNjLmpzJ1xuXG5leHBvcnQgdHlwZSBJc0hleEVycm9yVHlwZSA9IEVycm9yVHlwZVxuXG5leHBvcnQgZnVuY3Rpb24gaXNIZXgoXG4gIHZhbHVlOiB1bmtub3duLFxuICB7IHN0cmljdCA9IHRydWUgfTogeyBzdHJpY3Q/OiBib29sZWFuIHwgdW5kZWZpbmVkIH0gPSB7fSxcbik6IHZhbHVlIGlzIEhleCB7XG4gIGlmICghdmFsdWUpIHJldHVybiBmYWxzZVxuICBpZiAodHlwZW9mIHZhbHVlICE9PSAnc3RyaW5nJykgcmV0dXJuIGZhbHNlXG4gIHJldHVybiBzdHJpY3QgPyAvXjB4WzAtOWEtZkEtRl0qJC8udGVzdCh2YWx1ZSkgOiB2YWx1ZS5zdGFydHNXaXRoKCcweCcpXG59XG4iLCIvLyBUaGUgbW9kdWxlIGNhY2hlXG52YXIgX193ZWJwYWNrX21vZHVsZV9jYWNoZV9fID0ge307XG5cbi8vIFRoZSByZXF1aXJlIGZ1bmN0aW9uXG5mdW5jdGlvbiBfX3dlYnBhY2tfcmVxdWlyZV9fKG1vZHVsZUlkKSB7XG5cdC8vIENoZWNrIGlmIG1vZHVsZSBpcyBpbiBjYWNoZVxuXHR2YXIgY2FjaGVkTW9kdWxlID0gX193ZWJwYWNrX21vZHVsZV9jYWNoZV9fW21vZHVsZUlkXTtcblx0aWYgKGNhY2hlZE1vZHVsZSAhPT0gdW5kZWZpbmVkKSB7XG5cdFx0cmV0dXJuIGNhY2hlZE1vZHVsZS5leHBvcnRzO1xuXHR9XG5cdC8vIENyZWF0ZSBhIG5ldyBtb2R1bGUgKGFuZCBwdXQgaXQgaW50byB0aGUgY2FjaGUpXG5cdHZhciBtb2R1bGUgPSBfX3dlYnBhY2tfbW9kdWxlX2NhY2hlX19bbW9kdWxlSWRdID0ge1xuXHRcdC8vIG5vIG1vZHVsZS5pZCBuZWVkZWRcblx0XHQvLyBubyBtb2R1bGUubG9hZGVkIG5lZWRlZFxuXHRcdGV4cG9ydHM6IHt9XG5cdH07XG5cblx0Ly8gRXhlY3V0ZSB0aGUgbW9kdWxlIGZ1bmN0aW9uXG5cdF9fd2VicGFja19tb2R1bGVzX19bbW9kdWxlSWRdLmNhbGwobW9kdWxlLmV4cG9ydHMsIG1vZHVsZSwgbW9kdWxlLmV4cG9ydHMsIF9fd2VicGFja19yZXF1aXJlX18pO1xuXG5cdC8vIFJldHVybiB0aGUgZXhwb3J0cyBvZiB0aGUgbW9kdWxlXG5cdHJldHVybiBtb2R1bGUuZXhwb3J0cztcbn1cblxuIiwiLy8gZ2V0RGVmYXVsdEV4cG9ydCBmdW5jdGlvbiBmb3IgY29tcGF0aWJpbGl0eSB3aXRoIG5vbi1oYXJtb255IG1vZHVsZXNcbl9fd2VicGFja19yZXF1aXJlX18ubiA9IChtb2R1bGUpID0+IHtcblx0dmFyIGdldHRlciA9IG1vZHVsZSAmJiBtb2R1bGUuX19lc01vZHVsZSA/XG5cdFx0KCkgPT4gKG1vZHVsZVsnZGVmYXVsdCddKSA6XG5cdFx0KCkgPT4gKG1vZHVsZSk7XG5cdF9fd2VicGFja19yZXF1aXJlX18uZChnZXR0ZXIsIHsgYTogZ2V0dGVyIH0pO1xuXHRyZXR1cm4gZ2V0dGVyO1xufTsiLCIvLyBkZWZpbmUgZ2V0dGVyIGZ1bmN0aW9ucyBmb3IgaGFybW9ueSBleHBvcnRzXG5fX3dlYnBhY2tfcmVxdWlyZV9fLmQgPSAoZXhwb3J0cywgZGVmaW5pdGlvbikgPT4ge1xuXHRmb3IodmFyIGtleSBpbiBkZWZpbml0aW9uKSB7XG5cdFx0aWYoX193ZWJwYWNrX3JlcXVpcmVfXy5vKGRlZmluaXRpb24sIGtleSkgJiYgIV9fd2VicGFja19yZXF1aXJlX18ubyhleHBvcnRzLCBrZXkpKSB7XG5cdFx0XHRPYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywga2V5LCB7IGVudW1lcmFibGU6IHRydWUsIGdldDogZGVmaW5pdGlvbltrZXldIH0pO1xuXHRcdH1cblx0fVxufTsiLCJfX3dlYnBhY2tfcmVxdWlyZV9fLm8gPSAob2JqLCBwcm9wKSA9PiAoT2JqZWN0LnByb3RvdHlwZS5oYXNPd25Qcm9wZXJ0eS5jYWxsKG9iaiwgcHJvcCkpIiwiLy8gZGVmaW5lIF9fZXNNb2R1bGUgb24gZXhwb3J0c1xuX193ZWJwYWNrX3JlcXVpcmVfXy5yID0gKGV4cG9ydHMpID0+IHtcblx0aWYodHlwZW9mIFN5bWJvbCAhPT0gJ3VuZGVmaW5lZCcgJiYgU3ltYm9sLnRvU3RyaW5nVGFnKSB7XG5cdFx0T2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFN5bWJvbC50b1N0cmluZ1RhZywgeyB2YWx1ZTogJ01vZHVsZScgfSk7XG5cdH1cblx0T2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsICdfX2VzTW9kdWxlJywgeyB2YWx1ZTogdHJ1ZSB9KTtcbn07IiwiXG5jb25zdCBhcGkgPSByZXF1aXJlKCdAdGVtcG9yYWxpby93b3JrZmxvdy9saWIvd29ya2VyLWludGVyZmFjZS5qcycpO1xuXG5hcGkub3ZlcnJpZGVHbG9iYWxzKCk7XG5cbmV4cG9ydHMuYXBpID0gYXBpO1xuXG5leHBvcnRzLmltcG9ydFdvcmtmbG93cyA9IGZ1bmN0aW9uIGltcG9ydFdvcmtmbG93cygpIHtcbiAgcmV0dXJuIHJlcXVpcmUoLyogd2VicGFja01vZGU6IFwiZWFnZXJcIiAqLyBcIi9Vc2Vycy92aWN0MHhyL0RvY3VtZW50cy9TZW5kL3NlbmRhcHAvcGFja2FnZXMvd29ya2Zsb3dzL3NyYy9hbGwtd29ya2Zsb3dzLnRzXCIpO1xufVxuXG5leHBvcnRzLmltcG9ydEludGVyY2VwdG9ycyA9IGZ1bmN0aW9uIGltcG9ydEludGVyY2VwdG9ycygpIHtcbiAgcmV0dXJuIFtcbiAgICBcbiAgXTtcbn1cbiJdLCJuYW1lcyI6WyJhc3NlcnQiLCJjb25kaXRpb24iLCJtc2ciLCJFcnJvciIsImlzSGV4IiwiaGV4VG9CeXRlYSIsInN0ciIsInNsaWNlIiwidG9Mb3dlckNhc2UiLCJwcm94eUFjdGl2aXRpZXMiLCJBcHBsaWNhdGlvbkZhaWx1cmUiLCJjYWxjdWxhdGVEaXN0cmlidXRpb25TaGFyZXNBY3Rpdml0eSIsImZldGNoRGlzdHJpYnV0aW9uQWN0aXZpdHkiLCJmZXRjaEFsbE9wZW5EaXN0cmlidXRpb25zQWN0aXZpdHkiLCJzdGFydFRvQ2xvc2VUaW1lb3V0IiwiRGlzdHJpYnV0aW9uV29ya2Zsb3ciLCJkaXN0cmlidXRpb25JZCIsImRpc3RyaWJ1dGlvbiIsInRvU3RyaW5nIiwiRGlzdHJpYnV0aW9uc1dvcmtmbG93IiwiZGlzdHJpYnV0aW9ucyIsImlkIiwid29ya2Zsb3dJbmZvIiwic3VwZXJqc29uIiwiZGVidWciLCJsb2ciLCJ1cHNlcnRUZW1wb3JhbFNlbmRBY2NvdW50VHJhbnNmZXJBY3Rpdml0eSIsInNpbXVsYXRlVHJhbnNmZXJBY3Rpdml0eSIsImdldEJhc2VCbG9ja051bWJlckFjdGl2aXR5IiwiZGVjb2RlVHJhbnNmZXJVc2VyT3BBY3Rpdml0eSIsInVwZGF0ZVRlbXBvcmFsU2VuZEFjY291bnRUcmFuc2ZlckFjdGl2aXR5Iiwic2VuZFVzZXJPcEFjdGl2aXR5Iiwid2FpdEZvclRyYW5zYWN0aW9uUmVjZWlwdEFjdGl2aXR5IiwiVHJhbnNmZXJXb3JrZmxvdyIsInVzZXJPcCIsIndvcmtmbG93SWQiLCJkYXRhIiwic2VuZGVyIiwiXyIsImNyZWF0ZWRBdEJsb2NrTnVtIiwidG9rZW4iLCJmcm9tIiwidG8iLCJhbW91bnQiLCJzdWJtaXR0ZWRUcmFuc2ZlciIsInN0YXR1cyIsImYiLCJ0IiwidiIsImxvZ19hZGRyIiwidmFsdWUiLCJzdHJpbmdpZnkiLCJoYXNoIiwic2VudFRyYW5zZmVyIiwidXNlcl9vcF9oYXNoIiwicmVjZWlwdCIsInR4X2hhc2giLCJ0cmFuc2FjdGlvbkhhc2giLCJibG9ja19udW0iLCJibG9ja051bWJlciJdLCJzb3VyY2VSb290IjoiIn0=