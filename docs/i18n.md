# Internationalization (i18n) Specification

## Objectives
- Deliver first-class multilingual support across Expo (native) and Next.js (web) surfaces without duplicating UI logic shared via `packages/app`.
- Provide predictable language detection, switching, and persistence that respects OS/browser settings while giving users explicit control.
- Establish tooling and guardrails so developers can add, translate, and validate copy safely without hand-editing multiple files.
- Preserve existing stability (navigation, auth, theming, feature flags) by introducing i18n through additive, well-isolated providers and utilities.

## Non-Goals
- Automatic locale negotiation for backend services (handled separately by Supabase/backends).
- Translating raw CMS/database content (out of scope until content sources are internationalized).
- Shipping full RTL layout support in phase one (foundation includes direction signals; layout adjustments can land later).

## Current State
- User-facing strings live inline in React components spread throughout `packages/app/features`, `packages/app/components`, and `apps/next/pages`.
- `packages/app/provider/Provider` composes shared state (auth, theming, query clients) used by both Expo and Next entry points.
- No localization utilities, lint rules, or translation file structure currently exist.

## Technical Stack
- **Core library:** `i18next`
- **React bindings:** `react-i18next`
- **Expo locale signals:** `expo-localization` (and `react-native-localize` fallback for non-Expo runtimes/tests).
- **Persistence:** `@react-native-async-storage/async-storage` on native, `window.localStorage` on web, wrapped in a shared storage abstraction.
- **Formatting helpers:** Built-in `Intl` APIs with light wrappers for currency, dates, and relative time. Future-friendly towards `@formatjs` if advanced rules are needed.
- **Type safety:** `i18next` resources typings via generated `resources.d.ts`, enforced in CI.

## Target Architecture

### Resource Organization
- Add `packages/app/i18n/` containing:
  - `config.ts` – shared initialization helpers.
  - `resources/<namespace>/<locale>.json` – e.g. `resources/onboarding/en.json`.
  - `index.ts` – export typed helpers, resource loaders, and runtime accessors.
- Namespaces mirror feature folders (onboarding, auth, wallet, settings, shared) to keep bundle size manageable and PR reviews scoped.
- English (`en`) remains the canonical source. Additional locales (e.g. `es`, `pt-BR`) sit beside it. Missing keys fall back to English at runtime.

### Initialization & Provider Integration
- Create `createI18nClient(config?: InitOptions)` that instantiates i18next with:
  - React bindings (`initReactI18next`).
  - Resource preloading for default namespace(s).
  - Language detector plugin reading the storage abstraction first, then platform locale.
- Extend `packages/app/provider/index.tsx` to wrap the provider tree with `<I18nextProvider i18n={i18nClient}>` and expose a hook `useAppI18n()` if needed.
- For Expo entry (`apps/expo/app/_layout.tsx`): initialize the client once on app boot, resolve initial language asynchronously before revealing main UI (similar to font/theme preload sequence). Use a suspense-style fallback or gated render to avoid flicker.
- For Next.js (`apps/next/pages/_app.tsx`):
  - Instantiate a new i18n client per request on the server to avoid cross-request leakage.
  - Hydrate on the client by reusing serialized initial language + namespaces (injected via `pageProps.__i18n` or script tag).
  - Provide helper to load namespaces during `getStaticProps`/`getServerSideProps` for pages still using the Pages router.

### Language Detection & Persistence
- Detection order: explicit user setting (storage) → OS/browser locale → fallback `en`.
- Store selected locale at `i18n.locale` key via storage abstraction:
  ```ts
  interface LocaleStorage {
    get(): Promise<string | undefined>
    set(locale: string): Promise<void>
    clear(): Promise<void>
  }
  ```
- Expose `changeLanguage(locale: string)` utility that updates i18next, writes storage, and broadcasts via an event emitter so non-React code (e.g. background tasks) can listen.
- Surface `direction: 'ltr' | 'rtl'` and derived booleans through a lightweight context or exported selector to coordinate Tamagui/theme adjustments.

### Formatting Utilities
- Add `packages/app/utils/i18n/format.ts` providing wrappers for:
  - `formatCurrency(amount, currency, options?)`
  - `formatDate(date, { style })`
  - `formatRelativeDate(date)`
- Internally use memoized `Intl.DateTimeFormat` / `Intl.NumberFormat` keyed by locale to avoid repeated constructor cost.
- Ensure utilities read the active locale from i18next to keep React and non-React code in sync.

### Translation Workflow
1. Developers add keys to English JSON and reference them in code via `t('namespace.key')` or `Trans` components for rich text.
2. Generate or refresh locale files via `yarn i18n:translate --locale <target> [--namespace <name>]` (requires `OPENROUTER_API_KEY`). The command only fills missing keys by default; pass `--force` to retranslate existing strings or `--dry-run` to audit changes.
3. A CLI script `yarn i18n:sync` validates JSON structure (no duplicate/missing keys across locales) and keeps files sorted.
4. CI step runs `yarn i18n:check` to ensure:
   - All locales contain the same key set as English.
   - No unused keys exist (using `i18next-scanner` or a custom AST check against TSX).
   - JSON files stay sorted for diff readability.
5. Provide documentation in `docs/i18n.md` (this file) describing the flow for on-call and new contributors.

### Guardrails & Developer Ergonomics
- ESLint rule: disallow hard-coded string literals in JSX/text nodes outside of whitelisted utility files (`eslint-plugin-i18next` or custom rule).
- Jest helpers:
  - Add `renderWithI18n` test util that includes the provider and defaults to English.
  - Provide snapshot serializer to handle translated output (ensures deterministic snapshots by pinning locale).
- Storybook/Playwright (if used) should be updated to accept a `locale` knob and run smoke checks for at least one non-English locale.

### Compatibility & Reliability Checklist
- **Provider composition:** insert the i18n provider in `packages/app/provider/Providers` without reordering critical context (e.g. Auth, Theme). Confirm no circular imports.
- **Async boot sequencing:** ensure i18n init hooks into existing splash-screen gating (fonts, theme, session) to prevent blank UI states or double renders.
- **React Query / API usage:** verify queries that embed strings (toasts, errors) transition to use translation keys; keep underlying data contracts untouched.
- **Linking / Deep links:** preserve existing behavior by keeping route segment names constant; only UI labels change.
- **Error handling:** standardize through translation keys but keep error codes/data surfaces (e.g. `PasskeyDiagnosticError`) unaffected.

## Incremental Rollout Plan

### Phase 0 – Prep (1–2 days)
- Add dependencies and base folder structure with empty resources.
- Ship ESLint rule in warn mode, documentation, and developer announcement.
- Configure `yarn i18n:sync` and CI checks (failing only if command errors).

### Phase 1 – Infrastructure (2–3 days)
- Implement shared i18n initialization, storage abstraction, and provider wiring for Expo + Next.
- Add formatting utilities and testing helpers.
- Deliver QA checklist and manual test cases (language switch, fallback, RTL smoke).

### Phase 2 – Pilot Namespace (3–4 days)
- Migrate a self-contained flow (e.g. onboarding welcome + passkey screens) to validate patterns.
- Exercise language switching on device and browser, confirm SSR hydration.
- Collect feedback from QA/product, adjust utilities.

### Phase 3 – Broad Adoption (ongoing)
- Convert remaining high-traffic surfaces (navigation labels, home, wallet, send/receive flows).
- Enable ESLint hard-error mode once coverage passes agreed threshold.
- Integrate automated LLM translation step once manual QA process is defined.

### Phase 4 – Enhancements (as needed)
- Introduce RTL layout adaptations (Tamagui + native layout direction).
- Localize notifications, backend-rendered emails, or Supabase edge functions if required.

## Testing & Verification Strategy
- Unit tests for detection logic and storage fallbacks (mocking Expo vs web environments).
- Integration tests ensuring `changeLanguage` triggers rerenders and storage persistence.
- Visual regression / Playwright flows executed in at least two locales to catch layout overflow.
- Manual QA checklist for product: language switch persistence, mixed-namespace screens, fallback to English when translations absent.

## Risks & Mitigations
- **Bundle size growth:** Tree-shake by namespace; lazy-load seldom-used namespaces via `i18next-http-backend`-like custom loader tied to dynamic import.
- **Async init race conditions:** reuse existing splash-screen gating and add explicit `await initI18n()` before rendering provider.
- **Missing translations in production:** CI sync + runtime fallback to English ensures user experience degrades gracefully.
- **LLM translation quality:** enforce human review toggle per namespace; keep CLI capable of bypassing automated translations when needed.
- **SSR mismatch warnings:** ensure server and client share identical `initialLanguage` and namespace list during hydration.

## Open Questions
- Preferred locales for initial rollout (product input required).
- Which LLM vendor/API to use for automated translation (needs infra approval/security review).
- Whether to expose language choice in settings immediately or after initial locales ship.

## Next Steps Checklist
1. Stakeholder review of this spec (product, design, infra).
2. Approve dependency additions (`i18next`, `react-i18next`, `expo-localization`).
3. Create tracking ticket for Phase 0 tasks and assign owners.
4. Schedule QA/resources for pilot namespace migration once infrastructure lands.
