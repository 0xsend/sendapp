#!/usr/bin/env bun run
import 'zx/globals'
import { createServer, type AddressInfo } from 'node:net'
import { existsSync, readFileSync, writeFileSync, unlinkSync } from 'node:fs'
import { join } from 'node:path'

/**
 * gen-env: Generate a .localnet.env file with dynamically allocated free ports.
 *
 * This enables multiple developers to run independent local development environments
 * simultaneously without port conflicts.
 *
 * Usage:
 *   bun run bin/gen-env.ts local              # Generate .localnet.env with free ports
 *   bun run bin/gen-env.ts local --force      # Force regenerate even if lockfile exists
 *   bun run bin/gen-env.ts local --clean      # Remove .localnet.env and lockfile
 */

// Port configuration structure
interface PortConfig {
  // Next.js
  NEXTJS_PORT: number

  // Supabase
  SUPABASE_API_PORT: number
  SUPABASE_DB_PORT: number
  SUPABASE_STUDIO_PORT: number
  SUPABASE_INBUCKET_PORT: number
  SUPABASE_INBUCKET_SMTP_PORT: number
  SUPABASE_INBUCKET_POP3_PORT: number

  // Anvil (Ethereum nodes)
  ANVIL_MAINNET_PORT: number
  ANVIL_BASE_PORT: number

  // AA Bundler
  BUNDLER_PORT: number

  // Shovel (indexer)
  SHOVEL_PORT: number

  // Otterscan (block explorer)
  OTTERSCAN_MAINNET_PORT: number
  OTTERSCAN_BASE_PORT: number

  // Temporal (workflow engine)
  TEMPORAL_PORT: number
  TEMPORAL_UI_PORT: number
}

// Ordered list of port keys for allocation
const PORT_KEYS: (keyof PortConfig)[] = [
  'NEXTJS_PORT',
  'SUPABASE_API_PORT',
  'SUPABASE_DB_PORT',
  'SUPABASE_STUDIO_PORT',
  'SUPABASE_INBUCKET_PORT',
  'SUPABASE_INBUCKET_SMTP_PORT',
  'SUPABASE_INBUCKET_POP3_PORT',
  'ANVIL_MAINNET_PORT',
  'ANVIL_BASE_PORT',
  'BUNDLER_PORT',
  'SHOVEL_PORT',
  'OTTERSCAN_MAINNET_PORT',
  'OTTERSCAN_BASE_PORT',
  'TEMPORAL_PORT',
  'TEMPORAL_UI_PORT',
]

const PROJECT_ROOT = join(import.meta.dir, '..')
const LOCKFILE_PATH = join(PROJECT_ROOT, '.localnet.lock')
const ENV_FILE_PATH = join(PROJECT_ROOT, '.localnet.env')

/**
 * Find a free port by binding to port 0 and getting the OS-assigned port.
 */
async function findFreePort(): Promise<number> {
  return new Promise((resolve, reject) => {
    const server = createServer()
    server.listen(0, '127.0.0.1', () => {
      const address = server.address() as AddressInfo
      const port = address.port
      server.close((err) => {
        if (err) reject(err)
        else resolve(port)
      })
    })
    server.on('error', reject)
  })
}

/**
 * Check if a port is currently in use.
 */
async function isPortInUse(port: number): Promise<boolean> {
  return new Promise((resolve) => {
    const server = createServer()
    server.listen(port, '127.0.0.1', () => {
      server.close(() => resolve(false))
    })
    server.on('error', () => resolve(true))
  })
}

/**
 * Allocate all required ports dynamically.
 */
async function allocatePorts(): Promise<PortConfig> {
  const ports: Partial<PortConfig> = {}
  const usedPorts = new Set<number>()

  for (const key of PORT_KEYS) {
    let port: number
    let attempts = 0
    const maxAttempts = 100

    do {
      port = await findFreePort()
      attempts++
      if (attempts > maxAttempts) {
        throw new Error(`Failed to find free port for ${key} after ${maxAttempts} attempts`)
      }
    } while (usedPorts.has(port))

    usedPorts.add(port)
    ports[key] = port
  }

  return ports as PortConfig
}

/**
 * Validate that all ports in a config are still available.
 */
async function validatePorts(config: PortConfig): Promise<boolean> {
  for (const key of PORT_KEYS) {
    const port = config[key]
    if (await isPortInUse(port)) {
      console.log(chalk.yellow(`Port ${port} (${key}) is in use`))
      return false
    }
  }
  return true
}

/**
 * Load port config from lockfile if it exists.
 */
function loadLockfile(): PortConfig | null {
  if (!existsSync(LOCKFILE_PATH)) {
    return null
  }

  try {
    const content = readFileSync(LOCKFILE_PATH, 'utf-8')
    const config = JSON.parse(content) as PortConfig

    // Validate all required keys exist
    for (const key of PORT_KEYS) {
      if (typeof config[key] !== 'number') {
        console.log(chalk.yellow(`Lockfile missing or invalid ${key}, regenerating...`))
        return null
      }
    }

    return config
  } catch {
    console.log(chalk.yellow('Failed to parse lockfile, regenerating...'))
    return null
  }
}

/**
 * Save port config to lockfile.
 */
function saveLockfile(config: PortConfig): void {
  writeFileSync(LOCKFILE_PATH, JSON.stringify(config, null, 2))
}

/**
 * Generate the .localnet.env file content.
 */
function generateEnvContent(ports: PortConfig): string {
  const lines = [
    '# Auto-generated by gen-env. Do not edit manually.',
    `# Generated at: ${new Date().toISOString()}`,
    '#',
    '# These environment variables configure the local development environment',
    '# with dynamically allocated ports to avoid conflicts.',
    '',
    '# Next.js',
    `NEXTJS_PORT=${ports.NEXTJS_PORT}`,
    `NEXT_PUBLIC_URL=http://localhost:${ports.NEXTJS_PORT}`,
    '',
    '# Supabase',
    `NEXT_PUBLIC_SUPABASE_URL=http://localhost:${ports.SUPABASE_API_PORT}`,
    `NEXT_PUBLIC_SUPABASE_GRAPHQL_URL=http://localhost:${ports.SUPABASE_API_PORT}/graphql/v1`,
    `SUPABASE_DB_URL=postgresql://postgres:postgres@localhost:${ports.SUPABASE_DB_PORT}/postgres`,
    `SUPABASE_AUTH_SITE_URL=http://localhost:${ports.NEXTJS_PORT}`,
    '',
    '# Supabase ports (for Tilt/config.toml)',
    `SUPABASE_API_PORT=${ports.SUPABASE_API_PORT}`,
    `SUPABASE_DB_PORT=${ports.SUPABASE_DB_PORT}`,
    `SUPABASE_STUDIO_PORT=${ports.SUPABASE_STUDIO_PORT}`,
    `SUPABASE_INBUCKET_PORT=${ports.SUPABASE_INBUCKET_PORT}`,
    `SUPABASE_INBUCKET_SMTP_PORT=${ports.SUPABASE_INBUCKET_SMTP_PORT}`,
    `SUPABASE_INBUCKET_POP3_PORT=${ports.SUPABASE_INBUCKET_POP3_PORT}`,
    '',
    '# Anvil (Ethereum nodes)',
    `NEXT_PUBLIC_MAINNET_RPC_URL=http://localhost:${ports.ANVIL_MAINNET_PORT}`,
    `NEXT_PUBLIC_BASE_RPC_URL=http://localhost:${ports.ANVIL_BASE_PORT}`,
    `ANVIL_MAINNET_PORT=${ports.ANVIL_MAINNET_PORT}`,
    `ANVIL_BASE_PORT=${ports.ANVIL_BASE_PORT}`,
    '',
    '# AA Bundler',
    `NEXT_PUBLIC_BUNDLER_RPC_URL=http://localhost:${ports.BUNDLER_PORT}/rpc`,
    `BUNDLER_PORT=${ports.BUNDLER_PORT}`,
    '',
    '# Shovel (indexer)',
    `SHOVEL_PORT=${ports.SHOVEL_PORT}`,
    '',
    '# Otterscan (block explorer)',
    `OTTERSCAN_MAINNET_PORT=${ports.OTTERSCAN_MAINNET_PORT}`,
    `OTTERSCAN_BASE_PORT=${ports.OTTERSCAN_BASE_PORT}`,
    '',
    '# Temporal (workflow engine)',
    `TEMPORAL_ADDR=localhost:${ports.TEMPORAL_PORT}`,
    `TEMPORAL_PORT=${ports.TEMPORAL_PORT}`,
    `TEMPORAL_UI_PORT=${ports.TEMPORAL_UI_PORT}`,
    '',
  ]

  return lines.join('\n')
}

/**
 * Print port summary.
 */
function printSummary(ports: PortConfig): void {
  console.log('')
  console.log(chalk.cyan('=== Localnet Port Configuration ==='))
  console.log('')
  console.log(chalk.green('Next.js:'))
  console.log(`  Web App:          http://localhost:${ports.NEXTJS_PORT}`)
  console.log('')
  console.log(chalk.green('Supabase:'))
  console.log(`  API:              http://localhost:${ports.SUPABASE_API_PORT}`)
  console.log(`  Studio:           http://localhost:${ports.SUPABASE_STUDIO_PORT}`)
  console.log(`  Database:         postgresql://localhost:${ports.SUPABASE_DB_PORT}`)
  console.log(`  Inbucket:         http://localhost:${ports.SUPABASE_INBUCKET_PORT}`)
  console.log('')
  console.log(chalk.green('Blockchain:'))
  console.log(`  Anvil Mainnet:    http://localhost:${ports.ANVIL_MAINNET_PORT}`)
  console.log(`  Anvil Base:       http://localhost:${ports.ANVIL_BASE_PORT}`)
  console.log(`  Bundler:          http://localhost:${ports.BUNDLER_PORT}`)
  console.log(`  Otterscan (main): http://localhost:${ports.OTTERSCAN_MAINNET_PORT}`)
  console.log(`  Otterscan (base): http://localhost:${ports.OTTERSCAN_BASE_PORT}`)
  console.log('')
  console.log(chalk.green('Infrastructure:'))
  console.log(`  Shovel:           http://localhost:${ports.SHOVEL_PORT}`)
  console.log(`  Temporal:         localhost:${ports.TEMPORAL_PORT}`)
  console.log(`  Temporal UI:      http://localhost:${ports.TEMPORAL_UI_PORT}`)
  console.log('')
}

async function main() {
  const args = process.argv.slice(2)
  const command = args[0]

  if (command !== 'local') {
    console.log(chalk.yellow('Usage: gen-env local [--force] [--clean]'))
    console.log('')
    console.log('Commands:')
    console.log('  local          Generate .localnet.env with free ports')
    console.log('')
    console.log('Options:')
    console.log('  --force        Force regenerate even if lockfile exists')
    console.log('  --clean        Remove .localnet.env and lockfile')
    process.exit(1)
  }

  const forceRegenerate = args.includes('--force')
  const clean = args.includes('--clean')

  if (clean) {
    console.log(chalk.yellow('Cleaning up...'))
    if (existsSync(LOCKFILE_PATH)) {
      unlinkSync(LOCKFILE_PATH)
      console.log(`  Removed ${LOCKFILE_PATH}`)
    }
    if (existsSync(ENV_FILE_PATH)) {
      unlinkSync(ENV_FILE_PATH)
      console.log(`  Removed ${ENV_FILE_PATH}`)
    }
    console.log(chalk.green('Done!'))
    return
  }

  let ports: PortConfig

  // Try to load existing lockfile
  if (!forceRegenerate) {
    const existingPorts = loadLockfile()
    if (existingPorts) {
      console.log(chalk.blue('Found existing port configuration, validating...'))
      const valid = await validatePorts(existingPorts)
      if (valid) {
        console.log(chalk.green('Existing ports are available, reusing configuration.'))
        ports = existingPorts
      } else {
        console.log(chalk.yellow('Some ports are in use, allocating new ports...'))
        ports = await allocatePorts()
        saveLockfile(ports)
      }
    } else {
      console.log(chalk.blue('Allocating new ports...'))
      ports = await allocatePorts()
      saveLockfile(ports)
    }
  } else {
    console.log(chalk.blue('Force regenerating ports...'))
    ports = await allocatePorts()
    saveLockfile(ports)
  }

  // Generate .localnet.env
  const envContent = generateEnvContent(ports)
  writeFileSync(ENV_FILE_PATH, envContent)
  console.log(chalk.green(`Generated ${ENV_FILE_PATH}`))

  printSummary(ports)

  console.log(chalk.cyan('Next steps:'))
  console.log('  1. Reload direnv: direnv allow')
  console.log('  2. Start services: tilt up')
  console.log('')
  console.log(chalk.gray('Note: .localnet.env is loaded automatically via .envrc'))
}

main().catch((err) => {
  console.error(chalk.red('Error:'), err)
  process.exit(1)
})
