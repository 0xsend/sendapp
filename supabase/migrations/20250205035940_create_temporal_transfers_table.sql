CREATE TYPE temporal_transfer_status AS ENUM(
  'simulating',
  'sending',
  'waiting',
  'indexing',
  'success',
  'fail'
);

CREATE TABLE temporal_transfers(
  id bigint GENERATED BY DEFAULT AS IDENTITY PRIMARY KEY,
  workflow_id text NOT NULL,
  user_op_hash text NOT NULL,
  user_id uuid NOT NULL,
  f bytea NOT NULL,
  t bytea NOT NULL,
  v numeric NOT NULL, -- Adding value field to match transfer pattern
  status temporal_transfer_status NOT NULL,
  data jsonb NOT NULL,
  created_at timestamp with time zone DEFAULT NOW(),
  updated_at timestamp with time zone DEFAULT NOW()
);

-- Indexes for common queries
CREATE INDEX temporal_transfers_user_id_idx ON temporal_transfers(user_id);

CREATE INDEX temporal_transfers_user_op_hash_idx ON temporal_transfers(user_op_hash);

CREATE INDEX temporal_transfers_status_idx ON temporal_transfers(status);

CREATE UNIQUE INDEX temporal_transfers_workflow_id_idx ON temporal_transfers(workflow_id);

-- Function to insert initial temporal transfer record
CREATE OR REPLACE FUNCTION insert_temporal_transfer(_user_id uuid, _user_op_hash text, _f bytea, _t bytea, _v numeric, _data jsonb)
  RETURNS text
  LANGUAGE plpgsql
  SECURITY DEFINER
  AS $$
DECLARE
  _workflow_id text;
BEGIN
  _workflow_id := _user_id || '_' || _user_op_hash;
  INSERT INTO temporal_transfers(
    workflow_id,
    user_op_hash,
    user_id,
    f,
    t,
    v,
    status,
    data)
  VALUES (
    _workflow_id,
    _user_op_hash,
    _user_id,
    _f,
    _t,
    _v,
    'simulating',
    _data);
  RETURN _workflow_id;
END;
$$;

-- Function to create activity for new temporal transfers
CREATE OR REPLACE FUNCTION temporal_transfers_trigger_insert_activity()
  RETURNS TRIGGER
  LANGUAGE plpgsql
  SECURITY DEFINER
  AS $$
DECLARE
  _f_user_id uuid;
  _t_user_id uuid;
BEGIN
  -- select send app info for from address
  SELECT
    user_id INTO _f_user_id
  FROM
    send_accounts
  WHERE
    address = concat('0x', encode(NEW.f, 'hex'))::citext;
  SELECT
    user_id INTO _t_user_id
  FROM
    send_accounts
  WHERE
    address = concat('0x', encode(NEW.t, 'hex'))::citext;
  INSERT INTO activity(
    event_name,
    event_id,
    from_user_id,
    to_user_id,
    data,
    created_at)
  VALUES (
    'temporal_transfer_workflow',
    NEW.workflow_id,
    _f_user_id,
    _t_user_id,
    json_build_object(
      'from', NEW.f, 'to', NEW.t, 'value', NEW.v, 'status', NEW.status, 'user_op_hash', NEW.user_op_hash, 'data', NEW.data),
    NEW.created_at);
  RETURN NEW;
END;
$$;

-- Trigger for new temporal transfers
CREATE TRIGGER temporal_transfers_trigger_insert_activity
  AFTER INSERT ON temporal_transfers
  FOR EACH ROW
  EXECUTE FUNCTION temporal_transfers_trigger_insert_activity();

-- Function to handle status updates
CREATE OR REPLACE FUNCTION temporal_transfers_trigger_status_update()
  RETURNS TRIGGER
  LANGUAGE plpgsql
  SECURITY DEFINER
  AS $$
BEGIN
  IF NEW.status = 'success' THEN
    -- On success, activity will be replaced by send_account_transfer activity
    DELETE FROM activity
    WHERE event_name = 'temporal_transfer_workflow'
      AND event_id = NEW.workflow_id;
  ELSIF NEW.status = 'fail' THEN
    -- On fail, update activity with error info and mark as failed
    UPDATE
      activity
    SET
      data = jsonb_set(jsonb_set(data, '{status}', '"fail"'), '{error}', NEW.data -> 'error')
    WHERE
      event_name = 'temporal_transfer_workflow'
      AND event_id = NEW.workflow_id;
  ELSE
    -- Update status in activity data for other status changes
    UPDATE
      activity
    SET
      data = jsonb_set(data, '{status}', to_jsonb(NEW.status::text))
    WHERE
      event_name = 'temporal_transfer_workflow'
      AND event_id = NEW.workflow_id;
  END IF;
  RETURN NEW;
END;
$$;

-- Trigger for temporal transfer status updates
CREATE TRIGGER temporal_transfers_trigger_status_update
  AFTER UPDATE ON temporal_transfers
  FOR EACH ROW
  WHEN(OLD.status IS DISTINCT FROM NEW.status)
  EXECUTE FUNCTION temporal_transfers_trigger_status_update();

